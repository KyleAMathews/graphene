{"version":3,"sources":["webpack:///1.1.js","webpack:///../playground/page.js","webpack:///../~/codemirror/lib/codemirror.js","webpack:///../~/graphql/index.js","webpack:///../~/graphql/graphql.js","webpack:///../~/graphql/language/source.js","webpack:///../~/graphql/language/parser.js","webpack:///../~/graphql/error/index.js","webpack:///../~/graphql/error/GraphQLError.js","webpack:///../~/graphql/language/index.js","webpack:///../~/graphql/language/kinds.js","webpack:///../~/graphql/language/location.js","webpack:///../~/graphql/language/lexer.js","webpack:///../~/graphql/language/printer.js","webpack:///../~/graphql/language/visitor.js","webpack:///../~/graphql/error/syntaxError.js","webpack:///../~/graphql/error/locatedError.js","webpack:///../~/graphql/error/formatError.js","webpack:///../~/graphql/jsutils/invariant.js","webpack:///../~/graphql/validation/validate.js","webpack:///../~/graphql/type/schema.js","webpack:///../~/graphql/type/definition.js","webpack:///../~/graphql/jsutils/isNullish.js","webpack:///../~/graphql/jsutils/keyMap.js","webpack:///../~/graphql/type/directives.js","webpack:///../~/graphql/type/scalars.js","webpack:///../~/graphql/type/introspection.js","webpack:///../~/graphql/utilities/astFromValue.js","webpack:///../~/graphql/jsutils/find.js","webpack:///../~/graphql/utilities/typeComparators.js","webpack:///../~/graphql/utilities/TypeInfo.js","webpack:///../~/graphql/utilities/typeFromAST.js","webpack:///../~/graphql/validation/specifiedRules.js","webpack:///../~/graphql/validation/rules/UniqueOperationNames.js","webpack:///../~/graphql/validation/rules/LoneAnonymousOperation.js","webpack:///../~/graphql/validation/rules/KnownTypeNames.js","webpack:///../~/graphql/validation/rules/FragmentsOnCompositeTypes.js","webpack:///../~/graphql/validation/rules/VariablesAreInputTypes.js","webpack:///../~/graphql/validation/rules/ScalarLeafs.js","webpack:///../~/graphql/validation/rules/FieldsOnCorrectType.js","webpack:///../~/graphql/validation/rules/UniqueFragmentNames.js","webpack:///../~/graphql/validation/rules/KnownFragmentNames.js","webpack:///../~/graphql/validation/rules/NoUnusedFragments.js","webpack:///../~/graphql/validation/rules/PossibleFragmentSpreads.js","webpack:///../~/graphql/validation/rules/NoFragmentCycles.js","webpack:///../~/graphql/validation/rules/NoUndefinedVariables.js","webpack:///../~/graphql/validation/rules/NoUnusedVariables.js","webpack:///../~/graphql/validation/rules/KnownDirectives.js","webpack:///../~/graphql/validation/rules/KnownArgumentNames.js","webpack:///../~/graphql/validation/rules/UniqueArgumentNames.js","webpack:///../~/graphql/validation/rules/ArgumentsOfCorrectType.js","webpack:///../~/graphql/utilities/isValidLiteralValue.js","webpack:///../~/graphql/validation/rules/ProvidedNonNullArguments.js","webpack:///../~/graphql/validation/rules/DefaultValuesOfCorrectType.js","webpack:///../~/graphql/validation/rules/VariablesInAllowedPosition.js","webpack:///../~/graphql/validation/rules/OverlappingFieldsCanBeMerged.js","webpack:///../~/graphql/validation/rules/UniqueInputFieldNames.js","webpack:///../~/graphql/execution/execute.js","webpack:///../~/graphql/execution/values.js","webpack:///../~/graphql/utilities/valueFromAST.js","webpack:///../~/graphql/utilities/isValidJSValue.js","webpack:///../~/graphiql/dist/index.js","webpack:///../~/graphiql/dist/components/GraphiQL.js","webpack:///../~/graphql/type/index.js","webpack:///../~/graphql/utilities/index.js","webpack:///../~/graphql/utilities/introspectionQuery.js","webpack:///../~/graphql/utilities/getOperationAST.js","webpack:///../~/graphql/utilities/buildClientSchema.js","webpack:///../~/graphql/jsutils/keyValMap.js","webpack:///../~/graphql/utilities/buildASTSchema.js","webpack:///../~/graphql/utilities/extendSchema.js","webpack:///../~/graphql/utilities/schemaPrinter.js","webpack:///../~/graphql/utilities/concatAST.js","webpack:///../~/graphiql/dist/components/ExecuteButton.js","webpack:///../~/graphiql/dist/components/QueryEditor.js","webpack:///../~/graphiql/~/marked/lib/marked.js","webpack:///../~/codemirror/addon/hint/show-hint.js","webpack:///../~/codemirror/addon/comment/comment.js","webpack:///../~/codemirror/addon/edit/matchbrackets.js","webpack:///../~/codemirror/addon/edit/closebrackets.js","webpack:///../~/codemirror/addon/fold/foldgutter.js","webpack:///../~/codemirror/addon/fold/foldcode.js","webpack:///../~/codemirror/addon/fold/brace-fold.js","webpack:///../~/codemirror/addon/lint/lint.js","webpack:///../~/codemirror/keymap/sublime.js","webpack:///../~/codemirror/addon/search/searchcursor.js","webpack:///../~/graphiql/~/codemirror-graphql/hint.js","webpack:///../~/graphiql/~/codemirror-graphql/lint.js","webpack:///../~/graphql/validation/index.js","webpack:///../~/graphiql/~/codemirror-graphql/mode.js","webpack:///../~/graphiql/dist/components/VariableEditor.js","webpack:///../~/codemirror/mode/javascript/javascript.js","webpack:///../~/graphiql/dist/codemirror/lint/json-lint.js","webpack:///../~/graphiql/dist/codemirror/lint/jsonLint.js","webpack:///../~/graphiql/dist/components/ResultViewer.js","webpack:///../~/graphiql/dist/components/DocExplorer.js","webpack:///../~/graphiql/dist/utility/fillLeafs.js","webpack:///../~/graphiql/dist/utility/elementPosition.js","webpack:///../~/graphiql/dist/utility/introspectionQueries.js","webpack:///../playground/schema.js","webpack:///../playground/graphene-js/pypyjs.js","webpack:///../~/webpack/~/node-libs-browser/~/process/browser.js","webpack:///../~/es6-promise/dist/es6-promise.js","webpack:///../~/webpack/buildin/amd-define.js","webpack:///../playground/graphene-js/FunctionPromise.js","webpack:///../~/webpack/~/node-libs-browser/~/path-browserify/index.js","webpack:///../~/codemirror/mode/python/python.js","webpack:///../css/playground.styl?f70d","webpack:///../css/playground.styl","webpack:///../css/graphiql.css"],"names":["webpackJsonp","Array","concat","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","graphQLFetcher","graphQLParams","_graphql","graphql","_schema2","query","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","_get","_x","_x2","_x3","_again","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","getter","get","call","parent","getPrototypeOf","_react","_react2","_reactDom","_reactDom2","_codemirror","_codemirror2","_graphiql","_graphiql2","_schema","_pypyjs","_pypyjs2","PUBLIC_PATH","rootURL","cacheKey","baseCode","registerHelper","text","options","editor","errors","map","error","tokens","getLineTokens","line","filter","token","pos","type","string","trim","message","name","severity","from","Pos","start","to","end","default_interpreter","Playground","_React$Component","this","state","pypyjs","stdout","response","console","log","arguments","_this","pypy_interpreter","bind","stdin","stderr","ready","then","exec","createSchema","setState","window","markLine","lineNo","findDOMNode","refs","schemaCode","mode","theme","lineNumbers","tabSize","indentUnit","gutters","lint","on","onEditorChange","_this2","changeTimeout","clearTimeout","setTimeout","updateSchema","getValue","code","_this3","previousCode","validSchema","removeErrors","err","logError","updateGraphiQL","graphiql","schema","componentDidMount","forceUpdate","docExplorer","lines","trace","split","file_errors","errorLine","match","x","parseInt","push","signal","execute","_this4","data","json_data","JSON","parse","_this5","addLineClass","removeLineClass","createElement","className","ref","fetcher","Component","mod","CodeMirror","place","copyObj","defaults","setGuttersForLineNumbers","doc","Doc","lineSeparator","input","inputStyles","inputStyle","display","Display","wrapper","updateGutters","themeChanged","lineWrapping","autofocus","mobile","focus","initScrollbars","keyMaps","overlays","modeGen","overwrite","delayingBlurEvent","focused","suppressEdits","pasteIncoming","cutIncoming","selectingText","draggingText","highlight","Delayed","keySeq","specialChars","cm","ie","ie_version","reset","registerEventHandlers","ensureGlobalHandlers","startOperation","curOp","attachDoc","hasFocus","onFocus","onBlur","opt","optionHandlers","hasOwnProperty","Init","maybeUpdateLineNumberWidth","finishInit","initHooks","endOperation","webkit","getComputedStyle","lineDiv","textRendering","style","d","scrollbarFiller","elt","setAttribute","gutterFiller","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","mover","sizer","sizerWidth","heightForcer","scrollerGap","lineGutter","scroller","zIndex","paddingRight","gecko","draggable","appendChild","viewFrom","viewTo","first","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","activeTouch","init","loadMode","getMode","modeOption","resetModeState","iter","stateAfter","styles","frontier","startWorker","regChange","wrappingChanged","addClass","minWidth","rmClass","findMaxLine","estimateLineHeights","clearCaches","updateScrollbars","estimateHeight","th","textHeight","wrapping","perLine","Math","max","clientWidth","charWidth","lineIsHidden","widgetsHeight","widgets","height","ceil","est","estHeight","updateLineHeight","replace","guttersChanged","alignHorizontally","specs","removeChildren","gutterClass","gElt","width","updateGutterSpace","offsetWidth","marginLeft","lineLength","merged","len","cur","collapsedSpanAtStart","found","find","ch","collapsedSpanAtEnd","getLine","indexOf","slice","splice","measureForScrollbars","gutterW","docH","round","paddingVert","clientHeight","viewHeight","scrollWidth","viewWidth","barLeft","fixedGutter","docHeight","scrollHeight","scrollGap","gutterWidth","NativeScrollbars","scroll","vert","horiz","scrollTop","scrollLeft","checkedZeroWidth","minHeight","NullScrollbars","scrollbars","clear","scrollbarModel","scrollbarStyle","node","insertBefore","axis","setScrollLeft","setScrollTop","startWidth","startHeight","updateScrollbarsInner","updateHeightsInViewport","sizes","update","right","paddingBottom","bottom","coverGutterNextToScrollbar","visibleLines","viewport","top","floor","paddingTop","lineAtHeight","ensure","ensureFrom","ensureTo","heightAtLine","min","lastLine","firstChild","comp","compensateForHScroll","left","hidden","gutter","align","alignable","j","last","lineNumberFor","size","test","innerW","padding","String","lineNumberFormatter","firstLineNumber","getBoundingClientRect","DisplayUpdate","force","visible","editorIsHidden","wrapperHeight","wrapperWidth","oldDisplayWidth","displayWidth","dims","getDimensions","events","maybeClipScrollbars","marginBottom","borderRightWidth","updateDisplayIfNeeded","resetView","countDirtyView","viewportMargin","sawCollapsedSpans","visualLineNo","visualLineEndNo","different","adjustView","toUpdate","activeElt","patchDisplay","offsetHeight","postUpdateDisplay","displayHeight","barMeasure","updateSelection","setDocumentHeight","updateDisplaySimple","finish","total","prevBottom","offsetTop","bot","box","diff","updateWidgetHeight","rest","gutterLeft","clientLeft","n","nextSibling","offsetLeft","fixedPos","gutterTotalWidth","updateNumbersFrom","rm","next","mac","currentWheelTarget","parentNode","removeChild","container","lineN","lineView","updateNumber","lineNumber","changes","updateLineForChanges","document","createTextNode","buildLineElement","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","cls","bgClass","background","wrap","getLineContent","ext","built","buildLineContent","pre","textClass","wrapClass","gutterBackground","markers","gutterMarkers","gutterWrap","setUneditable","k","id","insertLineWidgets","insertLineWidgetsFor","allowAbove","ws","widget","handleMouseEvents","positionLineWidget","above","signalLater","noHScroll","coverGutter","paddingLeft","position","copyPos","maxPos","a","b","cmp","minPos","ensureFocus","isReadOnly","readOnly","cantEdit","applyTextInput","inserted","deleted","sel","origin","paste","textLines","splitLines","multiPaste","ranges","lastCopied","join","l","range","empty","lst","updateInput","changeEvent","makeChange","triggerElectric","ensureCursorVisible","typing","handlePaste","e","pasted","clipboardData","getData","preventDefault","disableInput","runInOp","electricChars","smartIndent","head","getModeAt","indented","charAt","indentLine","electricInput","copyableRanges","lineRange","anchor","getRange","disableBrowserMagic","field","TextareaInput","prevInput","pollingFast","polling","inaccurateSelection","hasSelection","composing","hiddenTextarea","te","div","ios","border","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","gracePeriod","posToDOM","findViewForLine","info","mapFromLineView","order","getOrder","side","partPos","getBidiPartAt","result","nodeAndOffsetInLineMap","offset","collapse","badPos","bad","domToPos","lineNode","childNodes","clipPos","locateNodeInLineView","textNode","topNode","maps","curNode","contains","nodeType","nodeValue","after","dist","textContent","before","previousSibling","domTextBetween","fromLine","toLine","recognizeMarker","marker","walk","cmText","getAttribute","markerID","findMarks","getBetween","lineSep","nodeName","closing","val","Selection","primIndex","Range","normalizeSelection","prim","sort","prev","inv","simpleSelection","clipLine","clipToLen","linelen","isLine","clipPosArray","array","out","extendRange","other","extend","posBefore","extendSelection","setSelection","primary","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","setSelectionReplaceHistory","done","history","setSelectionNoUndo","addSelectionToHistory","NaN","hasHandler","bias","setSelectionInner","skipAtomicInSelection","equals","selectionChanged","signalCursorActivity","reCheckSelection","sel_dontScroll","mayClear","newAnchor","skipAtomic","newHead","flipped","curPos","dir","search","markedSpans","sp","m","inclusiveLeft","inclusiveRight","explicitlyCleared","atomic","newPos","showSelection","prepareSelection","curFragment","cursors","createDocumentFragment","selFragment","selection","collapsed","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","output","cursorCoords","singleCursorHeightPerLine","cursor","cursorHeight","otherCursor","add","fragment","rightSide","drawForLine","fromArg","toArg","coords","charCoords","lineObj","lineLen","iterateBidiSections","rightPos","leftPos","tmp","leftSide","paddingH","sFrom","sTo","singleVLine","visualLine","leftEnd","rightStart","restartBlink","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","time","startState","set","highlightWorker","Date","workTime","copyState","getStateBefore","changedLines","oldStyles","tooLong","maxHighlightLength","highlighted","highlightLine","oldCls","styleClasses","newCls","classes","ischange","processLine","workDelay","regLineChange","findStartLine","precise","minindent","minline","lim","innerMode","countColumn","save","removeChildrenAndAdd","currentStyle","isNaN","ensureLineHeights","rect","curWidth","heights","rects","getClientRects","abs","cache","caches","updateExternalMeasurement","LineView","measureChar","measureCharPrepared","prepareMeasureForLine","findViewIndex","hasHeights","prepared","varHeight","measureCharInner","bogus","rtop","rbottom","mStart","mEnd","insertLeft","coverStart","coverEnd","isExtendingChar","nullRect","maybeUpdateRectForZooming","rSpan","rbot","mid","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","pageScrollX","pageXOffset","documentElement","body","pageScrollY","pageYOffset","intoCoordSystem","context","widgetHeight","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","preparedMeasure","getBidi","part","level","bidiLeft","bidiRight","bidiOther","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","mergedPos","getX","wrongLine","innerOff","adjust","bidi","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","step","middle","middleX","measureText","viewChanged","changeObjs","cursorActivityHandlers","cursorActivityCalled","updateMaxLine","scrollToPos","nextOpId","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","callbacks","op","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","mustUpdate","updatedDisplay","adjustWidthTo","maxScrollLeft","preparedSelection","forceScroll","scrollPosIntoView","margin","isCursor","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","f","operation","apply","methodOp","docMethodOp","visualLineContinued","buildViewArray","nextPos","lendiff","cut","viewCuttingPoint","index","cutTop","cutBot","arr","oldN","newN","dirty","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touches","touch","radiusX","radiusY","farAway","dx","dy","onMouseDown","signalDOMEvent","posFromMouse","clickInGutter","eventInWidget","e_preventDefault","word","findWordAt","captureRightClick","onContextMenu","now","moved","pageX","pageY","onScrollWheel","dragFunctions","enter","e_stop","over","onDragOver","onDragStart","drop","onDrop","leave","clearDragCursor","inp","getField","onKeyUp","onKeyDown","onKeyPress","dragDropChanged","old","wasOn","funcs","toggle","off","onResize","setSize","e_target","liberal","forRect","space","clientX","clientY","colDiff","supportsTouch","shiftKey","e_button","leftButtonDown","lastMiddleDown","delayBlurEvent","lastDoubleClick","lastClick","contained","modifier","metaKey","ctrlKey","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","startTime","dragEnd","e2","addNew","extendTo","lastPos","startCol","posCol","findColumn","startSel","ourIndex","scrollIntoView","oldRange","ourRange","sel_mouse","curCount","counter","editorSize","Infinity","move","up","lastSelOrigin","altKey","gutterEvent","prevent","mX","mY","lineBox","e_defaultPrevented","g","lastDrop","files","dataTransfer","FileReader","File","read","loadFile","file","allowDropFileTypes","reader","onload","content","change","changeEnd","readAsText","selected","listSelections","replaceRange","replaceSelection","setData","getSelection","setDragImage","safari","img","src","presto","_top","frag","dragCursor","isScroller","delta","wheelEventDelta","canScrollX","canScrollY","outer","wheelPixelsPerUnit","pixels","wheelSamples","movedX","movedY","sample","doHandleBinding","bound","dropShift","commands","ensurePolled","prevShift","Pass","lookupKeyForEditor","handle","lookupKey","extraKeys","keyMap","dispatchKey","seq","isModifierKey","stopSeq","handleKeyBinding","keyName","motion","handleCharBinding","keyCode","returnValue","handled","lastStoppedKey","hasCopyEvent","showCrossHair","charCode","which","fromCharCode","receivedFocus","contextMenuInGutter","adjustForChange","computeSelAfterChange","offsetPos","nw","computeReplacedSel","hint","oldPrev","newPrev","filterChange","canceled","cancel","ignoreReadOnly","sawReadOnlySpans","removeReadOnlyRanges","makeChangeInner","selAfter","addChangeToHistory","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","rebaseHist","makeChangeFromHistory","allowSelectionOnly","event","hist","source","undone","dest","lastOrigin","pop","pushSelectionToHistory","clearRedo","antiChanges","generation","maxGeneration","historyChangeFromChange","mergeOldSpans","shiftDoc","distance","spans","removed","makeChangeSingleDocInEditor","updateDoc","recomputeMaxLength","checkWidthStart","full","isWholeLineUpdate","changesHandler","changeHandler","doScroll","innerHeight","phantom","scrollNode","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","x1","y1","x2","y2","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollPos","resolveScrollToPos","getCursor","cursorScrollMargin","sPos","scrollTo","how","aggressive","indent","curSpace","indentation","curSpaceString","indentString","indentWithTabs","spaceStr","changeLine","changeType","no","deleteNearSelection","compute","kill","toKill","replaced","findPosH","unit","visually","findNextLine","possible","moveOnce","boundToLine","moveLogically","origDir","sawType","helper","getHelper","isWordChar","hitSide","findPosV","pageSize","option","deflt","notOnInit","normalizeKeyName","alt","ctrl","cmd","parts","Error","getKeyMap","markText","shared","markTextShared","TextMarker","clearWhenEmpty","replacedWith","widgetNode","conflictingCollapsedRange","addToHistory","curLine","addMarkedSpan","MarkedSpan","clearOnEnter","clearHistory","nextMarkerId","title","startStyle","endStyle","css","cloneNode","linked","isParent","SharedTextMarker","findSharedMarkers","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","getMarkedSpanFor","span","removeMarkedSpan","r","attachLine","markedSpansBefore","startCh","isInsert","startsBefore","endsAfter","markedSpansAfter","endCh","oldFirst","oldLast","sameLine","clearEmptySpans","newMarkers","gapMarkers","gap","getOldSpans","stretched","oldCur","stretchCur","mark","mk","p","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","vis","lineIsHiddenInner","adjustScrollWhenAboveVisible","parentStyle","addLineWidget","LineWidget","insertAt","aboveVisible","updateLine","cleanUpLine","extractLineClasses","lineClass","prop","RegExp","callBlankLine","blankLine","inner","readToken","stream","takeToken","asArray","getObj","copy","current","StringStream","eol","runMode","lineClasses","forceToEnd","flattenSpans","curStart","curStyle","addModeClass","mName","st","o","overlay","at","i_end","opaque","getLineStyles","updateFrontier","startAt","interpretTokenStyle","styleToClassCacheWithMode","styleToClassCache","builder","col","splitSpaces","getOption","addToken","buildToken","hasBadBidiRects","buildTokenBadBidi","allowFrontierUpdate","insertLineContent","joinClasses","zeroWidthElement","lastChild","defaultSpecialCharPlaceholder","charCodeAt","toString","displayText","special","mustWrap","lastIndex","skipped","txt","tabWidth","specialCharPlaceholder","fullStyle","buildCollapsedSpan","ignoreWidget","needsContentAttribute","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","foundBookmarks","upto","tokenText","wholeLineUpdateBefore","spansFor","linesFor","Line","firstLine","lastText","lastSpans","nlines","insert","remove","added","LeafChunk","BranchChunk","children","chunkSize","sharedHistOnly","propagate","skip","rel","chunk","child","sz","getLines","h","lh","bidiOrdering","History","startGen","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","opId","historyEventDelay","selectionEventCanBeMerged","somethingSelected","existing","removeClearedSpans","copyHistoryArray","newGroup","instantiateSel","deepCopy","newChanges","Number","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","defaultPrevented","srcElement","button","getHandlers","emitter","_handlers","noHandlers","bnd","args","list","orphanDelayedCallbacks","fireOrphanDelayed","delayed","override","codemirrorIgnore","cursorActivity","eventMixin","ctor","spaceStrs","nothing","createObj","base","inst","isWordCharBasic","isEmpty","extendingChars","tag","cssText","count","activeElement","root","classTest","as","forEachCodeMirror","getElementsByClassName","byClass","globalsRegistered","registerGlobalHandlers","resizeTimer","zwspSupported","badBidiRects","r0","r1","badZoomedRects","normal","fromRange","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","compareBidiLevel","linedir","moveInLine","byUnit","userAgent","navigator","platform","ie_upto10","ie_11up","documentMode","qtwebkit","chrome","vendor","mac_geMountainLion","windows","presto_version","flipCtrlCmd","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","w","pointerEvents","bar","delay","maybeDisable","elementFromPoint","native","null","cmpPos","prepareCopyCut","getSelections","selectInput","lineWiseCopyCut","setSelections","textarea","poll","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","minimal","blur","resetPosition","slowPoll","pollInterval","missed","execCommand","same","self","prepareSelectAllHack","selectionStart","extval","selectionEnd","rehide","oldCSS","selectAll","detectingSelectAll","resetSelectionOnContextMenu","oldScrollY","scrollY","mouseup","readOnlyChanged","onCopyCut","clearData","kludge","hadFocus","startData","ours","applyComposition","forceCompositionEnd","pollContent","showPrimarySelection","showMultipleSelections","curAnchor","anchorNode","anchorOffset","curFocus","focusNode","focusOffset","rangeCount","getRangeAt","rng","removeAllRanges","addRange","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","pollSelection","fromIndex","fromNode","toIndex","toNode","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","contenteditable","here","there","wheelDeltaX","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","spec","modeSpec","removeOverlay","indentSelection","newRanges","getTokenAt","getTokenTypeAt","getHelpers","helpers","help","helperType","_global","pred","getStateAfter","defaultTextHeight","defaultCharWidth","setGutterMarker","gutterID","clearGutter","lineInfo","getViewport","addWidget","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","amount","moveH","extendSelectionsBy","rtlMoveVisually","sel_move","deleteH","goalColumn","moveV","goals","startChar","check","toggleOverwrite","getScrollInfo","interpret","refresh","oldHeight","swapDoc","getInputField","getWrapperElement","getScrollerElement","getGutterElement","setValue","newBreaks","detach","attach","integer","disabled","tabIndex","modes","mimeModes","defineMode","dependencies","defineMIME","mime","resolveMode","mfactory","modeObj","modeExtensions","exts","modeProps","skipToEnd","extendMode","properties","defineExtension","func","defineDocExtension","defineOption","defineInitHook","registerGlobalHelper","predicate","nstate","a1","a2","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","undo","redo","undoSelection","redoSelection","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","goLineDown","goPageUp","goPageDown","goCharLeft","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertTab","insertSoftTab","spaces","replaceSelections","defaultTab","transposeChars","newlineAndIndent","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","fallthrough","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","normalizeKeyMap","keymap","keyname","keys","keyNames","noShift","altGraphKey","fromTextArea","tabindex","placeholder","form","leaveSubmitMethodAlone","realSubmit","submit","wrappedSubmit","getTextArea","toTextArea","lastColumnPos","lastColumnValue","sol","peek","eat","eatWhile","eatSpace","skipTo","backUp","column","pattern","consume","caseInsensitive","cased","str","toLowerCase","substr","hideFirstChars","withOp","dHeight","oldH","removeInner","insertInner","iterN","spilled","newleaf","maybeSpill","me","sibling","myIndex","used","nextDocId","cleanGeneration","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","addSelection","dup","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","where","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","splitLinesAuto","eachLine","dontDelegate","method","e_stopPropagation","stopPropagation","cancelBubble","addEventListener","attachEvent","removeEventListener","detachEvent","handlers","ms","startIndex","startValue","nextTab","goal","select","_e","nonASCIISingleCaseWordChar","toUpperCase","createRange","endNode","setEnd","setStart","createTextRange","moveToElementText","moveEnd","moveStart","host","nl","rt","ownerDocument","parentElement","compareEndPoints","oncopy",3,8,9,13,16,17,18,19,20,27,32,33,34,35,36,37,38,39,40,44,45,46,59,61,91,92,93,106,107,109,110,111,127,173,186,187,188,189,190,191,192,219,220,221,222,63232,63233,63234,63235,63272,63273,63275,63276,63277,63302,"charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","types","nstart","unshift","version","_typeSchema","GraphQLSchema","_typeDefinition","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","_typeScalars","GraphQLInt","GraphQLFloat","GraphQLString","GraphQLBoolean","GraphQLID","_errorFormatError","formatError","requestString","rootValue","variableValues","operationName","Promise","resolve","_languageSource","Source","documentAST","_languageParser","validationErrors","_validationValidate","validate","_executionExecute","sourceObj","_source","parser","makeParser","parseDocument","parseValue","parseValueLiteral","parseName","expect","_lexer","TokenKind","NAME","kind","_kinds","loc","definitions","parseDefinition","EOF","DOCUMENT","BRACE_L","parseOperationDefinition","parseFragmentDefinition","parseTypeDefinition","unexpected","OPERATION_DEFINITION","variableDefinitions","directives","selectionSet","parseSelectionSet","operationToken","parseVariableDefinitions","parseDirectives","PAREN_L","many","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","parseType","defaultValue","EQUALS","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","alias","nameOrAlias","FIELD","parseArguments","parseArgument","ARGUMENT","FRAGMENT_SPREAD","parseFragmentName","typeCondition","advance","parseNamedType","INLINE_FRAGMENT","expectKeyword","FRAGMENT_DEFINITION","isConst","BRACKET_L","parseList","parseObject","INT","FLOAT","STRING","BOOLEAN","ENUM","parseConstValue","parseValueValue","item","LIST","values","any","BRACKET_R","fields","parseObjectField","OBJECT","OBJECT_FIELD","AT","parseDirective","DIRECTIVE","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseScalarTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseTypeExtensionDefinition","interfaces","parseImplementsInterfaces","parseFieldDefinition","OBJECT_TYPE_DEFINITION","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","parseUnionMembers","UNION_TYPE_DEFINITION","members","PIPE","SCALAR_TYPE_DEFINITION","parseEnumValueDefinition","ENUM_TYPE_DEFINITION","ENUM_VALUE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","definition","TYPE_EXTENSION_DEFINITION","_lexToken","lex","prevEnd","noLocation","noSource","_error","syntaxError","getTokenKindDesc","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes","_GraphQLError","GraphQLError","_syntaxError","_locatedError","locatedError","_formatError","_language","_Error","stack","positions","nodePositions","some","getLocation","_interopRequireWildcard","newObj","Kind","_location","_parser","_printer","print","_visitor","visit","BREAK","lineRegexp","prevPosition","tokenDescription","makeToken","printCharCode","stringify","fromPosition","bodyLength","positionAfterWhitespace","readName","readNumber","readString","startPosition","firstCode","isFloat","readDigits","chunkStart","uniCharCode","c","char2hex","ast","printDocASTReducer","maybeArray","separator","block","maybeString","Name","Variable","Document","OperationDefinition","defs","VariableDefinition","_ref","SelectionSet","_ref2","Field","_ref3","Argument","_ref4","FragmentSpread","_ref5","InlineFragment","_ref6","FragmentDefinition","_ref7","IntValue","_ref8","FloatValue","_ref9","StringValue","_ref10","BooleanValue","_ref11","EnumValue","_ref12","ListValue","_ref13","ObjectValue","_ref14","ObjectField","_ref15","Directive","_ref16","NamedType","_ref17","ListType","_ref18","NonNullType","_ref19","ObjectTypeDefinition","_ref20","FieldDefinition","_ref21","InputValueDefinition","_ref22","InterfaceTypeDefinition","_ref23","UnionTypeDefinition","_ref24","ScalarTypeDefinition","_ref25","EnumTypeDefinition","_ref26","EnumValueDefinition","_ref27","InputObjectTypeDefinition","_ref28","TypeExtensionDefinition","_ref29","visitor","visitorKeys","QueryDocumentKeys","inArray","isArray","edits","path","ancestors","newRoot","isLeaving","isEdited","clone","editOffset","ii","_edits$ii","_slicedToArray","editKey","editValue","isNode","visitFn","getVisitFn","maybeNode","visitInParallel","visitors","skipping","fn","visitWithTypeInfo","typeInfo","kindVisitor","kindSpecificVisitor","specificVisitor","specificKindVisitor","sliceIterator","_arr","_n","_d","_s","_i","Symbol","iterator","description","location","_languageLocation","highlightSourceAtLocation","prevLineNum","lineNum","nextLineNum","padLen","lpad","_jsutilsInvariant2","locations","_jsutilsInvariant","invariant","condition","rules","_utilitiesTypeInfo","TypeInfo","visitUsingRules","_specifiedRules","specifiedRules","ValidationContext","rule","_languageVisitor","getErrors","_languageKinds","_ast","_typeInfo","_errors","_fragmentSpreads","Map","_recursivelyReferencedFragments","_variableUsages","_recursiveVariableUsages","fragments","_fragments","getDocument","reduce","frags","statement","spreads","setsToVisit","collectedNames","nodesToVisit","_node","getFragmentSpreads","fragName","getFragment","usages","getInputType","getVariableUsages","getRecursivelyReferencedFragments","getType","getParentType","getFieldDef","getDirective","getArgument","typeMapReducer","reducedMap","fieldMap","_definition","getPossibleTypes","getInterfaces","getFields","forEach","fieldName","fieldArgTypes","arg","ofType","assertObjectImplementsInterface","iface","objectFieldMap","ifaceFieldMap","objectField","ifaceField","_utilitiesTypeComparators","isTypeSubTypeOf","ifaceArg","argName","objectArg","_jsutilsFind2","isEqualType","_directives","_introspection","_jsutilsFind","config","_queryType","mutation","_mutationType","subscription","_subscriptionType","every","directive","GraphQLDirective","GraphQLIncludeDirective","GraphQLSkipDirective","_typeMap","getQueryType","getMutationType","getSubscriptionType","__Schema","typeName","getTypeMap","getDirectives","isType","isInputType","namedType","getNamedType","isOutputType","isLeafType","isCompositeType","isAbstractType","getNullableType","unmodifiedType","resolveMaybeThunk","thingOrThunk","defineInterfaces","interfacesOrThunk","resolveType","isTypeOf","defineFieldMap","isPlainObj","fieldNames","resultFieldMap","assertValidName","_extends","addImplementationToInterfaces","impl","_implementations","getTypeOf","abstractType","possibleTypes","defineEnumValues","valueMap","valueNames","valueName","deprecationReason","_jsutilsIsNullish2","NAME_RX","assign","_jsutilsIsNullish","_jsutilsKeyMap","_jsutilsKeyMap2","serialize","parseLiteral","_scalarConfig","serializer","valueAST","_typeConfig","_fields","_interfaces","_possibleTypes","possibleType","Boolean","resolver","_types","possibleTypeNames","_possibleTypeNames","_values","_enumConfig","enumValue","_getValueLookup","_getNameLookup","_valueLookup","lookup","getValues","_nameLookup","_defineFieldMap","isNullish","keyFn","_scalars","onOperation","onFragment","onField","coerceInt","num","MAX_INT","MIN_INT","coerceFloat","parseFloat","_utilitiesAstFromValue","_languagePrinter","__Type","typeMap","queryType","mutationType","subscriptionType","__Directive","__InputValue","__TypeKind","TypeKind","SCALAR","INTERFACE","UNION","INPUT_OBJECT","NON_NULL","__Field","includeDeprecated","enumValues","__EnumValue","inputFields","isDeprecated","inputVal","astFromValue","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","parentType","itemType","stringNum","isIntValue","fieldType","fieldDef","fieldValue","typeA","typeB","_x4","_again2","_function2","maybeSubType","superType","isPossibleType","fieldAST","_typeIntrospection","_typeFromAST","getFieldDefFn","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_directive","_argument","_getFieldDef","compositeType","typeConditionAST","outputType","typeFromAST","inputType","argDef","argType","fieldOrDirective","listType","objectType","inputField","inputTypeAST","innerType","_rulesUniqueOperationNames","_rulesLoneAnonymousOperation","_rulesKnownTypeNames","_rulesFragmentsOnCompositeTypes","_rulesVariablesAreInputTypes","_rulesScalarLeafs","_rulesFieldsOnCorrectType","_rulesUniqueFragmentNames","_rulesKnownFragmentNames","_rulesNoUnusedFragments","_rulesPossibleFragmentSpreads","_rulesNoFragmentCycles","_rulesNoUndefinedVariables","_rulesNoUnusedVariables","_rulesKnownDirectives","_rulesKnownArgumentNames","_rulesUniqueArgumentNames","_rulesArgumentsOfCorrectType","_rulesProvidedNonNullArguments","_rulesDefaultValuesOfCorrectType","_rulesVariablesInAllowedPosition","_rulesOverlappingFieldsCanBeMerged","_rulesUniqueInputFieldNames","UniqueOperationNames","LoneAnonymousOperation","KnownTypeNames","FragmentsOnCompositeTypes","VariablesAreInputTypes","ScalarLeafs","FieldsOnCorrectType","UniqueFragmentNames","KnownFragmentNames","NoUnusedFragments","PossibleFragmentSpreads","NoFragmentCycles","NoUndefinedVariables","NoUnusedVariables","KnownDirectives","KnownArgumentNames","UniqueArgumentNames","ArgumentsOfCorrectType","ProvidedNonNullArguments","DefaultValuesOfCorrectType","VariablesInAllowedPosition","OverlappingFieldsCanBeMerged","UniqueInputFieldNames","duplicateOperationNameMessage","knownOperationNames","reportError","anonOperationNotAloneMessage","operationCount","unknownTypeMessage","getSchema","inlineFragmentOnNonCompositeErrorMessage","fragmentOnNonCompositeErrorMessage","nonInputTypeOnVarMessage","variableName","_utilitiesTypeFromAST","noSubselectionAllowedMessage","requiredSubselectionMessage","undefinedFieldMessage","duplicateFragmentNameMessage","knownFragmentNames","fragmentName","unknownFragmentMessage","unusedFragMessage","operationDefs","fragmentDefs","fragmentNameUsed","fragmentDef","typeIncompatibleSpreadMessage","fragType","typeIncompatibleAnonSpreadMessage","doTypesOverlap","getFragmentType","t1","t2","t1TypeNames","cycleErrorMessage","spreadNames","via","detectCycleRecursive","visitedFrags","spreadNodes","spreadPathIndexByName","spreadPath","spreadNode","spreadName","cycleIndex","spreadFragment","cyclePath","s","undefinedVarMessage","varName","opName","variableNameDefined","getRecursiveVariableUsages","varDefAST","unusedVariableMessage","variableDefs","variableNameUsed","variableDef","def","unknownDirectiveMessage","directiveName","misplacedDirectiveMessage","placement","directiveDef","appliedTo","unknownArgMessage","unknownDirectiveArgMessage","argumentOf","fieldArgDef","directiveArgDef","duplicateArgMessage","knownArgNames","badValueMessage","verboseErrors","argAST","_utilitiesIsValidLiteralValue","isValidLiteralValue","_toConsumableArray","arr2","fieldASTs","_iteratorNormalCompletion","_didIteratorError","_iteratorError","fieldASTMap","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","parseResult","_step","_iterator","providedFieldAST","_step2","_iterator2","acc","itemAST","missingFieldArgMessage","missingDirectiveArgMessage","argASTs","argASTMap","directiveAST","defaultForNonNullArgMessage","guessType","badValueForDefaultArgMessage","badVarPosMessage","varType","expectedType","varDefMap","varDef","effectiveType","fieldsConflictMessage","responseName","reason","reasonMessage","subreason","findConflicts","conflicts","conflict","findConflict","field1","field2","_field1","parentType1","ast1","def1","_field2","parentType2","ast2","def2","comparedSet","has","name1","name2","type1","type2","sameArguments","selectionSet1","selectionSet2","visitedFragmentNames","subfieldMap","collectFieldASTsAndDefs","_ref32","allFields","_ref42","fields1","_ref52","fields2","PairSet","_ref62","_ref62$0","arguments1","arguments2","argument1","argument2","argument","sameValue","value1","value2","astAndDefs","_visitedFragmentNames","_astAndDefs","inlineFragmentType","fragmentType","_pairSetAdd","Set","_data","duplicateInputFieldMessage","knownNameStack","knownNames","buildExecutionContext","executeOperation","rawVariableValues","getVariableValues","exeContext","getOperationRootType","collectFields","executeFieldsSerially","executeFields","sourceValue","prevPromise","results","resolveField","isThenable","resolvedResult","containsPromise","finalResults","promiseForObject","runtimeType","shouldIncludeNode","getFieldEntryKey","doesFragmentConditionMatch","skipAST","_typeDirectives","_getArgumentValues","getArgumentValues","skipIf","includeAST","_getArgumentValues2","includeIf","conditionalType","valuesAndPromises","all","resolvedObject","returnType","resolveFn","defaultResolveFn","resolveOrError","completeValueCatchingError","completeValue","completed","resolved","reject","completedResults","completedItem","serializedResult","getObjectType","subFieldASTs","definitionASTs","inputs","defAST","getVariableValue","argDefs","_utilitiesValueFromAST","valueFromAST","definitionAST","_utilitiesIsValidJSValue","isValidJSValue","coerceValue","nullableType","parsed","variables","providedField","newErrors","GraphiQL","_graphqlType","_graphqlUtilities","_graphqlJsutilsFind","_graphqlJsutilsFind2","_ExecuteButton","_QueryEditor","_VariableEditor","_ResultViewer","_DocExplorer","_utilityFillLeafs","_utilityElementPosition","_utilityIntrospectionQueries","_runEditorQuery","_editorQueryID","queryID","editedQuery","autoCompleteLeafs","_fetchQuery","_onEditQuery","_storageSet","onEditQuery","_onEditVariables","onEditVariables","_onHintInformationRender","elem","_onClickHintInformation","onRemoveFn","innerHTML","docsOpen","showDoc","_onToggleDocs","_onResizeStart","downEvent","_didClickDragBar","getLeft","onMouseMove","moveEvent","buttons","onMouseUp","editorBar","leftSize","rightSize","editorFlex","_onMouseUp","_onDocsResizeStart","hadWidth","docsWidth","app","cursorPos","docsSize","_onMouseUp2","_onVariableResizeStart","didMove","wasOpen","variableEditorOpen","hadHeight","variableEditorHeight","getTop","topSize","bottomSize","_onMouseUp3","_storage","storage","localStorage","_storageGet","defaultQuery","_fillLeafs","fillLeafs","getDefaultFieldNames","insertions","queryEditor","getCodeMirror","cursorIndex","newCursorIndex","newCursor","PropTypes","isRequired","instanceOf","shape","getItem","setItem","componentWillReceiveProps","nextProps","nextQuery","nextVariables","nextResponse","introspectionQuery","introspectionQuerySansSubscriptions","buildClientSchema","componentDidUpdate","prevProps","prevState","dispatchEvent","Event","render","Children","logo","Logo","toolbar","Toolbar","footer","Footer","queryWrapStyle","WebkitFlex","flex","docWrapStyle","variableOpen","variableStyle","ExecuteButton","onClick","QueryEditor","onEdit","onHintInformationRender","VariableEditor","ResultViewer","DocExplorer","cb","resultWindow","_React$Component2","GraphiQLLogo","_React$Component3","GraphiQLToolbar","_React$Component4","GraphiQLFooter","_introspectionQuery","_getOperationAST","getOperationAST","_buildClientSchema","_buildASTSchema","buildASTSchema","_extendSchema","extendSchema","_schemaPrinter","printSchema","printIntrospectionSchema","_valueFromAST","_astFromValue","_TypeInfo","_isValidJSValue","_isValidLiteralValue","_concatAST","concatAST","introspection","typeRef","itemRef","nullableRef","typeDefCache","typeIntrospection","typeIntrospectionMap","typeDef","buildType","getOutputType","getInterfaceType","buildScalarDef","buildObjectDef","buildInterfaceDef","buildUnionDef","buildEnumDef","buildInputObjectDef","scalarIntrospection","objectIntrospection","buildFieldDefMap","interfaceIntrospection","unionIntrospection","enumIntrospection","_jsutilsKeyValMap2","valueIntrospection","inputObjectIntrospection","buildInputValueDefMap","fieldIntrospection","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","buildDirective","directiveIntrospection","schemaIntrospection","__schema","Int","Float","ID","_jsutilsKeyValMap","keyValMap","valFn","buildWrappedType","_type","getInnerTypeName","typeAST","queryTypeName","mutationTypeName","subscriptionTypeName","getTypeDefProducer","innerTypeMap","astMap","innerTypeDef","makeSchemaDef","makeTypeDef","makeInterfaceDef","makeEnumDef","makeUnionDef","makeScalarDef","makeInputObjectDef","makeFieldDefMap","makeImplementedInterfaces","produceTypeDef","makeInputValues","inter","enumType","v","t","typeDefs","schemaBody","getTypeFromDef","_getNamedType","getTypeFromAST","astNode","_errorGraphQLError","cachedTypeDef","existingType","extendType","typeDefinitionMap","extendObjectType","extendInterfaceType","extendUnionType","extendImplementedInterfaces","extendFieldMap","throwClientSchemaExecutionError","extensions","typeExtensionsMap","extension","interfaceName","newFieldMap","oldFieldMap","extendFieldType","buildFieldType","buildInputValues","buildObjectType","buildInterfaceType","buildUnionType","buildScalarType","buildEnumType","buildInputObjectType","buildImplementedInterfaces","buildFieldMap","extendedTypeName","existingMutationType","existingSubscriptionType","printFilteredSchema","isDefinedType","isIntrospectionType","typename","isBuiltInScalar","typeFilter","localeCompare","printType","printScalar","printObject","printInterface","printUnion","printEnum","printInputObject","implementedInterfaces","printFields","printInputValue","printArgs","argDecl","asts","batchDefinitions","keyHandler","componentWillUnmount","renderType","_marked","_marked2","_onKeyUp","_onEdit","ignoreChangeEvent","cachedValue","_onHasCompletion","information","ctx","el","hintsUl","cursorTop","smartypants","autoCloseBrackets","matchBrackets","foldGutter","minFoldSize","hintOptions","closeOnUnfocus","completeSingle","Cmd-Space","showHint","Ctrl-Space","global","Lexer","links","marked","gfm","tables","InlineLexer","inline","renderer","Renderer","breaks","pedantic","Parser","escape","html","encode","unescape","_","substring","regex","noop","merge","callback","pending","lang","escaped","silent","newline","fences","hr","heading","nptable","lheading","blockquote","table","paragraph","bullet","_tag","lexer","bq","loose","cap","bull","depth","header","cells","ordered","smartLists","sanitize","sanitizer","href","autolink","url","reflink","nolink","strong","em","br","del","_inside","_href","mangle","inLink","outputLink","codespan","image","random","langPrefix","quote","raw","headerPrefix","xhtml","listitem","tablerow","tablecell","flags","prot","decodeURIComponent","reverse","tok","parseText","row","cell","setOptions","inlineLexer","Completion","debounce","tick","startPos","startLen","activityFunc","parseOptions","defaultOptions","getText","completion","buildKeyMap","addBinding","baseMap","ourMap","moveFocus","menuSize","setFocus","pick","close","custom","customKeys","extra","getHintElement","hintsElement","Widget","picked","hints","selectedHint","completions","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","hintId","alignWithWord","below","winW","innerWidth","winH","overlapY","curTop","overlapX","avoidWrap","changeActive","screenAmount","closingOnBlur","startScroll","onScroll","curScroll","point","completeOnSingleClick","applicableHelpers","supportsSelection","resolveAutoHints","words","async","run","fromList","anyword","getHints","newOpts","completionActive","requestAnimationFrame","cancelAnimationFrame","active","closeCharacters","disable","myTick","finishUpdate","term","autocomplete","auto","nonWS","noOptions","toggleComment","minLine","uncomment","lineComment","commentString","blockCommentStart","fullLines","blockComment","pad","blankLines","commentBlankLines","baseString","whitespace","startString","endString","blockCommentEnd","lastLineHasText","lead","blockCommentLead","didSomething","lineString","endPos","startLine","endLine","open","lastIndexOf","lastStart","firstEnd","almostLastStart","openEnd","foundEnd","findMatchingBracket","strict","matching","scanForBracket","forward","maxScanLen","maxScanLineLength","maxScanLines","re","bracketRegex","autoclear","maxHighlightLen","maxHighlightLineLength","marks","ie_lt8","doMatchBrackets","currentlyHighlighted","(",")","[","]","{","}","conf","handler","handleChar","getConfig","closeBrackets","handleBackspace","pairs","around","charsAround","handleEnter","explode","contractSelection","inverted","triples","identical","opening","curType","enteringString","isClosingBracket","sels","State","opts","indicatorOpen","indicatorFolded","isFolded","__isFold","updateFoldInfo","minSize","foldOption","updateInViewport","vp","onGutterClick","folded","foldCode","rangeFinder","onChange","changeUpdate","foldOnChangeTimeSpan","onViewportChange","updateViewportTimeSpan","onFold","doFold","allowFolded","finder","cleared","myWidget","makeWidget","myRange","editorOptions","foldOptions","newFoldFunction","toggleFold","fold","unfold","foldAll","unfoldAll","scanUp","findOpening","openCh","pass","lineText","tokenType","startToken","endToken","nextOpen","nextClose","hasImport","semi","hasInclude","showTooltip","tt","opacity","hideTooltip","showTooltipFor","hide","tooltip","LintState","hasGutter","timeout","onMouseOver","waitingFor","_cm","getAnnotations","clearMarks","GUTTER_ID","makeMarker","labels","multiple","tooltips","getMaxSeverity","groupByLine","annotations","ann","annotationTooltip","tip","lintAsync","passOptions","abort","arg2","updateLinting","startLinting","annotationsNotSorted","anns","maxSeverity","tipLabel","formatAnnotation","__annotation","onUpdateLinting","popupSpanTooltip","lintOnChange","hasLintGutter","findPosSubword","cat","moveSubword","insertLine","newSelection","wordAt","selectBetweenBrackets","mirror","sortLines","caseSensitive","toSort","au","bu","modifyWordOrSelection","indices","replacements","getTarget","findAndGoTo","getSearchCursor","findNext","findPrevious","sublime","cmds","scrollLineCombo","visibleBottomLine","visibleTopLine","lineRanges","extended","fullWord","sublimeFindFullWord","swapLineCombo","linesToMove","newSels","joined","actual","sublimeBookmarks","sublimeBookmark","cK","toStartOfLine","prevIndent","sublimeMark","sublimeKilled","matches","primaryIndex","SearchCursor","caseFold","atOccurrence","ignoreCase","cutOff","newMatch","matchLen","origQuery","orig","adjustPos","origTarget","ln","pos1","len1","savePosAndFail","getTypeInfo","tokenState","objectFieldDefs","forEachState","reverseStateStack","_graphqlTypeIntrospection","hintList","filterAndSortList","normalizeText","tokenStart","sorted","entry","proximity","getProximity","pair","suggestion","lexicalDistance","aLength","bLength","cost","fieldObj","objectFields","namedInputType","inputTypeMap","inputTypes","errorAnnotations","highlightNode","mapCat","mapper","_graphqlLanguage","_graphqlValidation","_validate","getToken","needsAdvance","advanceRule","indentLevel","saveState","levels","expected","ofRule","pushRule","unsuccessful","restoreState","textAfter","stateCache","ruleKind","ParseRules","popRule","isList","kinds","LexRules","initialState","Punctuation","Definition","Query","ShortQuery","Mutation","Subscription","VariableDefinitions","DefaultValue","AliasedField","Arguments","TypeCondition","Value","NumberValue","Type","json","parserConfig","readRegexp","inSet","ret","tp","cont","tokenBase","tokenize","tokenString","tokenComment","lastType","isOperatorChar","tokenQuasi","wordRE","known","keywords","propertyIsEnumerable","jsonldMode","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","sawSomething","bracket","brackets","JSLexical","inScope","varname","localVars","cx","vars","parseJS","cc","lexical","combinator","jsonMode","expression","register","inList","globalVars","pushcontext","defaultVars","popcontext","pushlex","poplex","wanted","exp","vardef","maybeelse","functiondef","forspec","maybelabel","funarg","afterExport","afterImport","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","maybeexpressionNoComma","maybeexpression","comprehension","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","expr","continueQuasi","targetNoComma","getterSetter","afterprop","what","proceed","maybetype","isTS","typedef","maybedefault","maybeAssign","vardefCont","proppattern","forspec1","forspec2","formaybeinof","forspec3","classNameAfter","classBody","classGetterSetter","maybeFrom","importSpec","maybeAs","maybeArrayComprehension","isContinuedStatement","statementIndent","jsonld","typescript","wordCharacters","kw","A","B","C","operator","atom","jsKeywords","if","while","with","else","do","try","finally","return","break","continue","new","delete","throw","debugger","var","const","let","function","catch","for","switch","case","in","typeof","instanceof","true","false","class","super","yield","export","import","extends","tsKeywords","interface","public","private","protected","static","number","boolean","attr","regexp","jsonld-keyword","basecolumn","firstChar","doubleIndentSwitch","_jsonLint","jsonLint","looseMode","strLen","readVal","readObj","readArr","readHex","viewer","shouldComponentUpdate","_onToggleBtnClick","expanded","_onNavBackClick","navStack","_onClickTypeOrField","typeOrField","isCurrentlyShown","nextState","TypeDoc","onClickType","onClickField","FieldDoc","SchemaDoc","prevName","Description","markdown","TypeLink","typesTitle","typesDef","subtype","fieldsDef","argsDef","valuesDef","_React$Component5","_React$Component6","dangerouslySetInnerHTML","__html","docString","fieldNameFn","defaultGetDefaultFieldNames","buildSelectionSet","getIndentation","withInsertions","leafFieldNames","initial","edited","prevIndex","indentStart","indentEnd","initialElem","pt","offsetParent","__emptyField","process","totalMemory","autoLoadModules","_pendingModules","_loadedModules","_allModules","stdio","__dirname","_vmBuilderPromise","fetch","xhr","funcBody","responseText","FunctionPromise","_ready","Module","_module","TOTAL_MEMORY","noFSInit","thisProgram","filePackagePrefixURL","memoryInitializerPrefixURL","locateFile","noInitialRun","noExitRuntime","initializedResolve","initializedReject","FS","stdout_buffer","initializedP","dependenciesFulfilled","fs","FS_createPath","moduleDataP","vmBuilder","modIndex","modules","preload","_writeModuleFile","_rpython_startup_code","pypy_home","intArrayFromString","allocate","ALLOC_NORMAL","_pypy_setup_home","_free","initCode","codeStr","res","_pypy_execute_source","_escape","debug","errlines","devNull","write","_print","_printErr","printErr","buffer","relpath","responseType","use_cache","XMLHttpRequest","status","send","readFile","snarf","readbuffer","_execute_source","code_chars","code_ptr","_lastErrorName","_lastErrorMessage","_lastErrorTrace","findImportedNames","imports","loadModuleData","eval","warn","execfile","filename","_resultsID","_resultsMap","_fromGlobals","resid","namespace","_emjs_make_handle","repl","prmpt","ps1","idx","slurp","once","_repl_loop","importStatementRE","relmod","submods","submod","toLoad","NEXTNAME","_findModuleDeps","_makeLoadModuleData","seen","deps","modfile","contents","fullpath","FS_createDataFile","_defaultVM","PUBLIC_NAMES","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","Item","fun","nextTick","browser","env","argv","versions","addListener","removeListener","removeAllListeners","emit","binding","cwd","chdir","umask","__WEBPACK_AMD_DEFINE_RESULT__","lib$es6$promise$utils$$objectOrFunction","lib$es6$promise$utils$$isFunction","lib$es6$promise$utils$$isMaybeThenable","lib$es6$promise$asap$$setScheduler","scheduleFn","lib$es6$promise$asap$$customSchedulerFn","lib$es6$promise$asap$$setAsap","asapFn","lib$es6$promise$asap$$asap","lib$es6$promise$asap$$useNextTick","lib$es6$promise$asap$$flush","lib$es6$promise$asap$$useVertxTimer","lib$es6$promise$asap$$vertxNext","lib$es6$promise$asap$$useMutationObserver","iterations","observer","lib$es6$promise$asap$$BrowserMutationObserver","observe","characterData","lib$es6$promise$asap$$useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","lib$es6$promise$asap$$useSetTimeout","lib$es6$promise$asap$$len","lib$es6$promise$asap$$queue","lib$es6$promise$asap$$attemptVertx","vertx","runOnLoop","runOnContext","lib$es6$promise$$internal$$noop","lib$es6$promise$$internal$$selfFulfillment","lib$es6$promise$$internal$$cannotReturnOwn","lib$es6$promise$$internal$$getThen","promise","lib$es6$promise$$internal$$GET_THEN_ERROR","lib$es6$promise$$internal$$tryThen","fulfillmentHandler","rejectionHandler","lib$es6$promise$$internal$$handleForeignThenable","thenable","sealed","lib$es6$promise$$internal$$resolve","lib$es6$promise$$internal$$fulfill","lib$es6$promise$$internal$$reject","_label","lib$es6$promise$$internal$$handleOwnThenable","_state","lib$es6$promise$$internal$$FULFILLED","_result","lib$es6$promise$$internal$$REJECTED","lib$es6$promise$$internal$$subscribe","lib$es6$promise$$internal$$handleMaybeThenable","maybeThenable","lib$es6$promise$$internal$$publishRejection","_onerror","lib$es6$promise$$internal$$publish","lib$es6$promise$$internal$$PENDING","_subscribers","onFulfillment","onRejection","subscribers","settled","lib$es6$promise$$internal$$invokeCallback","lib$es6$promise$$internal$$ErrorObject","lib$es6$promise$$internal$$tryCatch","lib$es6$promise$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","lib$es6$promise$$internal$$initializePromise","lib$es6$promise$enumerator$$Enumerator","enumerator","_instanceConstructor","_validateInput","_input","_remaining","_init","_enumerate","_validationError","lib$es6$promise$promise$all$$all","entries","lib$es6$promise$enumerator$$default","lib$es6$promise$promise$race$$race","lib$es6$promise$utils$$isArray","lib$es6$promise$promise$resolve$$resolve","lib$es6$promise$promise$reject$$reject","lib$es6$promise$promise$$needsResolver","lib$es6$promise$promise$$needsNew","lib$es6$promise$promise$$Promise","_id","lib$es6$promise$promise$$counter","lib$es6$promise$polyfill$$polyfill","local","P","cast","lib$es6$promise$promise$$default","lib$es6$promise$utils$$_isArray","lib$es6$promise$asap$$scheduleFlush","lib$es6$promise$asap$$browserWindow","lib$es6$promise$asap$$browserGlobal","MutationObserver","WebKitMutationObserver","lib$es6$promise$asap$$isNode","lib$es6$promise$asap$$isWorker","Uint8ClampedArray","importScripts","_eachEntry","_settledAt","_willSettleAt","lib$es6$promise$promise$all$$default","lib$es6$promise$promise$race$$default","lib$es6$promise$promise$resolve$$default","lib$es6$promise$promise$reject$$default","race","_setScheduler","_setAsap","_asap","lib$es6$promise$polyfill$$default","lib$es6$promise$umd$$ES6Promise","polyfill","useFallback","Blob","URL","createObjectURL","funcid","_nextid","funcSrc","dataUrl","scriptTag","cleanup","revokeObjectURL","_results","onerror","normalizeArray","allowAboveRoot","xs","splitPathRe","splitPath","resolvedPath","resolvedAbsolute","normalize","isAbsolute","trailingSlash","paths","relative","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dirname","basename","extname","wordRegexp","scopes","wordOperators","commonKeywords","commonBuiltins","py2","builtins","py3","parserConf","scopeOffset","lineOffset","pushScope","dedent","errorToken","tokenBaseInner","ERRORCLASS","floatLiteral","intLiteral","stringPrefixes","tokenStringFactory","tripleDelimiters","doubleDelimiters","doubleOperators","singleOperators","singleDelimiters","lastToken","identifiers","singleline","OUTCLASS","singleLineStringErrors","isString","hangingIndent","tokenLexer","lambda","delimiter_index","myKeywords","myBuiltins","extra_keywords","extra_builtins","external","addErr","scope","locals"],"mappings":"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","file":"1.1.js","sourcesContent":["webpackJsonp([1],Array(350).concat([\n/* 350 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _reactDom = __webpack_require__(155);\n\t\n\tvar _reactDom2 = _interopRequireDefault(_reactDom);\n\t\n\tvar _reactRouter = __webpack_require__(156);\n\t\n\tvar _codemirror = __webpack_require__(351);\n\t\n\tvar _codemirror2 = _interopRequireDefault(_codemirror);\n\t\n\tvar _graphql = __webpack_require__(352);\n\t\n\tvar _graphiql = __webpack_require__(410);\n\t\n\tvar _graphiql2 = _interopRequireDefault(_graphiql);\n\t\n\tvar _schema = __webpack_require__(448);\n\t\n\tvar _schema2 = _interopRequireDefault(_schema);\n\t\n\tvar _pypyjs = __webpack_require__(449);\n\t\n\tvar _pypyjs2 = _interopRequireDefault(_pypyjs);\n\t\n\t__webpack_require__(456);\n\t\n\t__webpack_require__(432);\n\t\n\t__webpack_require__(457);\n\t\n\tif (typeof PUBLIC_PATH === \"undefined\") {\n\t  var PUBLIC_PATH = '';\n\t}\n\t\n\t_pypyjs2['default'].rootURL = PUBLIC_PATH + '/playground/lib/';\n\t_pypyjs2['default'].cacheKey = 'graphene';\n\t\n\tvar baseCode = 'import graphene\\n\\nclass Query(graphene.ObjectType):\\n    hello = graphene.String()\\n    ping = graphene.String(to=graphene.String())\\n\\n    def resolve_hello(self, args, info):\\n        return \\'World\\'\\n\\n    def resolve_ping(self, args, info):\\n        return \\'Pinging {}\\'.format(args.get(\\'to\\'))\\n\\nschema = graphene.Schema(query=Query)\\n';\n\t\n\t_codemirror2['default'].registerHelper('lint', 'python', function (text, options, editor) {\n\t  return (options.errors || []).map(function (error) {\n\t    var tokens = editor.getLineTokens(error.line - 1);\n\t    tokens = tokens.filter(function (token, pos) {\n\t      return !!token.type || token.string.trim().length > 0;\n\t    });\n\t    if (!tokens) return [];\n\t    return {\n\t      message: error.name + ': ' + error.message,\n\t      severity: 'error',\n\t      type: 'syntax',\n\t      from: _codemirror2['default'].Pos(error.line - 1, tokens[0].start),\n\t      to: _codemirror2['default'].Pos(error.line - 1, tokens[tokens.length - 1].end)\n\t    };\n\t  });\n\t});\n\t\n\t// function graphQLFetcher(graphQLParams) {\n\t//   return fetch('http://swapi.graphene-python.org/graphql', {\n\t//     method: 'post',\n\t//     headers: { 'Content-Type': 'application/json' },\n\t//     body: JSON.stringify(graphQLParams),\n\t//   }).then(response => response.json());\n\t// }\n\tfunction graphQLFetcher(graphQLParams) {\n\t  return (0, _graphql.graphql)(_schema2['default'], graphQLParams.query);\n\t}\n\t// var schema = null;\n\t\n\tfunction syntaxError() {\n\t  var marker = document.createElement(\"div\");\n\t  marker.style.color = \"#822\";\n\t  marker.innerHTML = \"●\";\n\t  return marker;\n\t}\n\t\n\tvar default_interpreter;\n\t\n\tvar Playground = (function (_React$Component) {\n\t  _inherits(Playground, _React$Component);\n\t\n\t  function Playground() {\n\t    _classCallCheck(this, Playground);\n\t\n\t    _get(Object.getPrototypeOf(Playground.prototype), 'constructor', this).call(this);\n\t    this.state = { pypyjs: false, stdout: '', response: '' };\n\t  }\n\t\n\t  _createClass(Playground, [{\n\t    key: 'stdout',\n\t    value: function stdout() {\n\t      console.log('stdout', arguments);\n\t    }\n\t  }, {\n\t    key: 'componentDidMount',\n\t    value: function componentDidMount() {\n\t      var _this = this;\n\t\n\t      if (default_interpreter) {\n\t        this.pypy_interpreter = default_interpreter;\n\t        this.pypy_interpreter.stdout = this.stdout.bind(this);\n\t      } else {\n\t        this.pypy_interpreter = new _pypyjs2['default']({\n\t          stdin: function stdin() {},\n\t          stdout: this.stdout.bind(this),\n\t          stderr: function stderr() {},\n\t          rootURL: PUBLIC_PATH + '/playground/lib/'\n\t        });\n\t        default_interpreter = this.pypy_interpreter;\n\t      }\n\t\n\t      this.pypyjs = this.pypy_interpreter.ready().then(function () {\n\t        return _this.pypy_interpreter.exec('\\nimport graphene\\nimport js\\nfrom collections import OrderedDict\\nfrom graphql.core.execution.executor import Executor\\nfrom graphql.core.execution.middlewares.sync import SynchronousExecutionMiddleware\\nfrom graphql.core.error import GraphQLError, format_error\\n\\ndef get_wrapped(f):\\n    if hasattr(f, \\'func_closure\\') and f.func_closure:\\n        return get_wrapped(f.func_closure[0].cell_contents)\\n    return f\\n\\nclass TrackResolver(SynchronousExecutionMiddleware):\\n    @staticmethod\\n    def run_resolve_fn(resolver, original_resolver):\\n        if resolver.func.__module__ == \\'__main__\\':\\n            line = get_wrapped(resolver.func).resolver.func_code.co_firstlineno\\n            js.globals.markLine(line-3)\\n        return SynchronousExecutionMiddleware.run_resolve_fn(resolver, original_resolver)\\n\\n__graphene_executor = Executor([TrackResolver()], map_type=OrderedDict)\\n');\n\t      }).then(function () {\n\t        _this.createSchema(baseCode);\n\t      }).then(function () {\n\t        _this.setState({ pypyjs: true, response: '\"Execute the query for see the results\"' });\n\t      });\n\t\n\t      window.markLine = function (lineNo) {\n\t        _this.markLine(lineNo);\n\t      };\n\t\n\t      this.editor = (0, _codemirror2['default'])(_reactDom2['default'].findDOMNode(this.refs.schemaCode), {\n\t        value: baseCode,\n\t        mode: \"python\",\n\t        theme: \"graphene\",\n\t        lineNumbers: true,\n\t        tabSize: 4,\n\t        indentUnit: 4,\n\t        gutters: [\"CodeMirror-linenumbers\", \"breakpoints\"],\n\t        lint: {\n\t          errors: []\n\t        }\n\t      });\n\t      this.editor.on(\"change\", this.onEditorChange.bind(this));\n\t    }\n\t  }, {\n\t    key: 'onEditorChange',\n\t    value: function onEditorChange() {\n\t      var _this2 = this;\n\t\n\t      if (this.changeTimeout) {\n\t        clearTimeout(this.changeTimeout);\n\t      }\n\t      this.changeTimeout = setTimeout(function () {\n\t        return _this2.updateSchema();\n\t      }, 300);\n\t    }\n\t  }, {\n\t    key: 'updateSchema',\n\t    value: function updateSchema() {\n\t      this.createSchema(this.editor.getValue());\n\t    }\n\t  }, {\n\t    key: 'createSchema',\n\t    value: function createSchema(code) {\n\t      var _this3 = this;\n\t\n\t      if (this.previousCode == code) return;\n\t      console.log('createSchema');\n\t      this.validSchema = null;\n\t      this.pypyjs.then(function () {\n\t        return _this3.pypy_interpreter.exec('\\nschema = None\\n' + code + '\\nassert schema, \\'You have to define a schema\\'\\n');\n\t      }).then(function () {\n\t        console.log('NO ERRORS');\n\t        _this3.removeErrors();\n\t        _this3.validSchema = true;\n\t      }, function (err) {\n\t        _this3.editor.options.lint.errors = [];\n\t        console.log('ERRORS', err);\n\t        _this3.logError(err);\n\t        _this3.validSchema = false;\n\t        // this.editor.setGutterMarker(5, \"breakpoints\", syntaxError());\n\t      }).then(this.updateGraphiQL.bind(this));\n\t      this.previousCode = code;\n\t    }\n\t  }, {\n\t    key: 'updateGraphiQL',\n\t    value: function updateGraphiQL() {\n\t      if (this.validSchema) {\n\t        this.refs.graphiql.state.schema = null;\n\t        this.refs.graphiql.componentDidMount();\n\t        this.refs.graphiql.forceUpdate();\n\t        this.refs.graphiql.refs.docExplorer.forceUpdate();\n\t      }\n\t    }\n\t  }, {\n\t    key: 'logError',\n\t    value: function logError(error) {\n\t      var lines = error.trace.split('\\n');\n\t      var file_errors = lines.map(function (errorLine) {\n\t        return errorLine.match(/File \"<string>\", line (\\d+)/);\n\t      }).filter(function (x) {\n\t        return !!x;\n\t      });\n\t      if (!file_errors.length) return;\n\t      var line = parseInt(file_errors[file_errors.length - 1][1]);\n\t      error.line = line - 2;\n\t      if (error.name == \"ImportError\" && error.message == \"No module named django\") {\n\t        error.message = \"Django is not supported yet in Playground editor\";\n\t      }\n\t      this.editor.options.lint.errors.push(error);\n\t      _codemirror2['default'].signal(this.editor, 'change', this.editor);\n\t    }\n\t  }, {\n\t    key: 'removeErrors',\n\t    value: function removeErrors() {\n\t      this.editor.options.lint.errors = [];\n\t      _codemirror2['default'].signal(this.editor, 'change', this.editor);\n\t    }\n\t  }, {\n\t    key: 'fetcher',\n\t    value: function fetcher(graphQLParams) {\n\t      if (!this.validSchema) {\n\t        return graphQLFetcher(arguments);\n\t      }\n\t      return this.execute(graphQLParams.query);\n\t    }\n\t  }, {\n\t    key: 'execute',\n\t    value: function execute(query) {\n\t      var _this4 = this;\n\t\n\t      // console.log('execute', query);\n\t      return this.pypyjs.then(function () {\n\t        var x = '\\nimport json\\nresult = __graphene_executor.execute(schema.schema, \\'\\'\\'' + query + '\\'\\'\\')\\nresult_dict = {};\\nif result.errors:\\n  result_dict[\\'errors\\'] = [format_error(e) for e in result.errors]\\nif result.data:\\n  result_dict[\\'data\\'] = result.data\\nresult_json = json.dumps(result_dict)\\n';\n\t        return _this4.pypy_interpreter.exec(x);\n\t      }).then(function () {\n\t        return _this4.pypy_interpreter.get('result_json');\n\t      }).then(function (data) {\n\t        var json_data = JSON.parse(data);\n\t        return json_data;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'markLine',\n\t    value: function markLine(lineNo) {\n\t      var _this5 = this;\n\t\n\t      console.log(lineNo);\n\t      var hlLine = this.editor.addLineClass(lineNo, \"text\", \"activeline\");\n\t      // var mark = this.editor.markText({line: lineNo, ch: 0}, {line: lineNo, ch: 10}, {className: \"called-function\"});\n\t      setTimeout(function () {\n\t        _this5.editor.removeLineClass(lineNo, \"text\", \"activeline\");\n\t      }, 1200);\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render() {\n\t      return _react2['default'].createElement(\n\t        'div',\n\t        { className: 'playground' },\n\t        !this.state.pypyjs ? _react2['default'].createElement('div', { className: 'loading' }) : null,\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'playground-schema' },\n\t          _react2['default'].createElement(\n\t            'header',\n\t            { className: 'playground-schema-header' },\n\t            'Schema'\n\t          ),\n\t          _react2['default'].createElement('div', { className: 'playground-schema-editor', ref: 'schemaCode' })\n\t        ),\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'playground-graphiql' },\n\t          _react2['default'].createElement(_graphiql2['default'], { ref: 'graphiql', fetcher: this.fetcher.bind(this), response: this.state.response })\n\t        )\n\t      );\n\t    }\n\t  }]);\n\t\n\t  return Playground;\n\t})(_react2['default'].Component);\n\t\n\tmodule.exports = Playground;\n\n/***/ },\n/* 351 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// This is CodeMirror (http://codemirror.net), a code editor\n\t// implemented in JavaScript on top of the browser's DOM.\n\t//\n\t// You can find some technical background for some of the code below\n\t// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    module.exports = mod();\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    return define([], mod);\n\t  else // Plain browser env\n\t    this.CodeMirror = mod();\n\t})(function() {\n\t  \"use strict\";\n\t\n\t  // BROWSER SNIFFING\n\t\n\t  // Kludges for bugs and behavior differences that can't be feature\n\t  // detected are enabled based on userAgent etc sniffing.\n\t  var userAgent = navigator.userAgent;\n\t  var platform = navigator.platform;\n\t\n\t  var gecko = /gecko\\/\\d/i.test(userAgent);\n\t  var ie_upto10 = /MSIE \\d/.test(userAgent);\n\t  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n\t  var ie = ie_upto10 || ie_11up;\n\t  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n\t  var webkit = /WebKit\\//.test(userAgent);\n\t  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n\t  var chrome = /Chrome\\//.test(userAgent);\n\t  var presto = /Opera\\//.test(userAgent);\n\t  var safari = /Apple Computer/.test(navigator.vendor);\n\t  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n\t  var phantom = /PhantomJS/.test(userAgent);\n\t\n\t  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n\t  // This is woefully incomplete. Suggestions for alternative methods welcome.\n\t  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n\t  var mac = ios || /Mac/.test(platform);\n\t  var windows = /win/i.test(platform);\n\t\n\t  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\t  if (presto_version) presto_version = Number(presto_version[1]);\n\t  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n\t  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\t  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n\t  var captureRightClick = gecko || (ie && ie_version >= 9);\n\t\n\t  // Optimize some code when these features are not used.\n\t  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\t\n\t  // EDITOR CONSTRUCTOR\n\t\n\t  // A CodeMirror instance represents an editor. This is the object\n\t  // that user code is usually dealing with.\n\t\n\t  function CodeMirror(place, options) {\n\t    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\t\n\t    this.options = options = options ? copyObj(options) : {};\n\t    // Determine effective options based on given values and defaults.\n\t    copyObj(defaults, options, false);\n\t    setGuttersForLineNumbers(options);\n\t\n\t    var doc = options.value;\n\t    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n\t    this.doc = doc;\n\t\n\t    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n\t    var display = this.display = new Display(place, doc, input);\n\t    display.wrapper.CodeMirror = this;\n\t    updateGutters(this);\n\t    themeChanged(this);\n\t    if (options.lineWrapping)\n\t      this.display.wrapper.className += \" CodeMirror-wrap\";\n\t    if (options.autofocus && !mobile) display.input.focus();\n\t    initScrollbars(this);\n\t\n\t    this.state = {\n\t      keyMaps: [],  // stores maps added by addKeyMap\n\t      overlays: [], // highlighting overlays, as added by addOverlay\n\t      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n\t      overwrite: false,\n\t      delayingBlurEvent: false,\n\t      focused: false,\n\t      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n\t      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n\t      selectingText: false,\n\t      draggingText: false,\n\t      highlight: new Delayed(), // stores highlight worker timeout\n\t      keySeq: null,  // Unfinished key sequence\n\t      specialChars: null\n\t    };\n\t\n\t    var cm = this;\n\t\n\t    // Override magic textarea content restore that IE sometimes does\n\t    // on our hidden textarea on reload\n\t    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\t\n\t    registerEventHandlers(this);\n\t    ensureGlobalHandlers();\n\t\n\t    startOperation(this);\n\t    this.curOp.forceUpdate = true;\n\t    attachDoc(this, doc);\n\t\n\t    if ((options.autofocus && !mobile) || cm.hasFocus())\n\t      setTimeout(bind(onFocus, this), 20);\n\t    else\n\t      onBlur(this);\n\t\n\t    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n\t      optionHandlers[opt](this, options[opt], Init);\n\t    maybeUpdateLineNumberWidth(this);\n\t    if (options.finishInit) options.finishInit(this);\n\t    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n\t    endOperation(this);\n\t    // Suppress optimizelegibility in Webkit, since it breaks text\n\t    // measuring on line wrapping boundaries.\n\t    if (webkit && options.lineWrapping &&\n\t        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n\t      display.lineDiv.style.textRendering = \"auto\";\n\t  }\n\t\n\t  // DISPLAY CONSTRUCTOR\n\t\n\t  // The display handles the DOM integration, both for input reading\n\t  // and content drawing. It holds references to DOM nodes and\n\t  // display-related state.\n\t\n\t  function Display(place, doc, input) {\n\t    var d = this;\n\t    this.input = input;\n\t\n\t    // Covers bottom-right square when both scrollbars are present.\n\t    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n\t    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n\t    // and h scrollbar is present.\n\t    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n\t    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Will contain the actual code, positioned to cover the viewport.\n\t    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n\t    // Elements are added to these to represent selection and cursors.\n\t    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n\t    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n\t    // A visibility: hidden element used to find the size of things.\n\t    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // When lines outside of the viewport are measured, they are drawn in this.\n\t    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\t    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n\t                      null, \"position: relative; outline: none\");\n\t    // Moved around its parent to cover visible view.\n\t    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n\t    // Set to the height of the document, allowing scrolling.\n\t    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n\t    d.sizerWidth = null;\n\t    // Behavior of elts with overflow: auto and padding is\n\t    // inconsistent across browsers. This is used to ensure the\n\t    // scrollable area is big enough.\n\t    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n\t    // Will contain the gutters, if any.\n\t    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n\t    d.lineGutter = null;\n\t    // Actual scrollable element.\n\t    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n\t    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n\t    // The element in which the editor lives.\n\t    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\t\n\t    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n\t    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n\t    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\t\n\t    if (place) {\n\t      if (place.appendChild) place.appendChild(d.wrapper);\n\t      else place(d.wrapper);\n\t    }\n\t\n\t    // Current rendered range (may be bigger than the view window).\n\t    d.viewFrom = d.viewTo = doc.first;\n\t    d.reportedViewFrom = d.reportedViewTo = doc.first;\n\t    // Information about the rendered lines.\n\t    d.view = [];\n\t    d.renderedView = null;\n\t    // Holds info about a single rendered line when it was rendered\n\t    // for measurement, while not in view.\n\t    d.externalMeasured = null;\n\t    // Empty space (in pixels) above the view\n\t    d.viewOffset = 0;\n\t    d.lastWrapHeight = d.lastWrapWidth = 0;\n\t    d.updateLineNumbers = null;\n\t\n\t    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n\t    d.scrollbarsClipped = false;\n\t\n\t    // Used to only resize the line number gutter when necessary (when\n\t    // the amount of lines crosses a boundary that makes its width change)\n\t    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n\t    // Set to true when a non-horizontal-scrolling line widget is\n\t    // added. As an optimization, line widget aligning is skipped when\n\t    // this is false.\n\t    d.alignWidgets = false;\n\t\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t\n\t    // Tracks the maximum line length so that the horizontal scrollbar\n\t    // can be kept static when scrolling.\n\t    d.maxLine = null;\n\t    d.maxLineLength = 0;\n\t    d.maxLineChanged = false;\n\t\n\t    // Used for measuring wheel scrolling granularity\n\t    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\t\n\t    // True when shift is held down.\n\t    d.shift = false;\n\t\n\t    // Used to track whether anything happened since the context menu\n\t    // was opened.\n\t    d.selForContextMenu = null;\n\t\n\t    d.activeTouch = null;\n\t\n\t    input.init(d);\n\t  }\n\t\n\t  // STATE UPDATES\n\t\n\t  // Used to get the editor into a consistent state again when options change.\n\t\n\t  function loadMode(cm) {\n\t    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n\t    resetModeState(cm);\n\t  }\n\t\n\t  function resetModeState(cm) {\n\t    cm.doc.iter(function(line) {\n\t      if (line.stateAfter) line.stateAfter = null;\n\t      if (line.styles) line.styles = null;\n\t    });\n\t    cm.doc.frontier = cm.doc.first;\n\t    startWorker(cm, 100);\n\t    cm.state.modeGen++;\n\t    if (cm.curOp) regChange(cm);\n\t  }\n\t\n\t  function wrappingChanged(cm) {\n\t    if (cm.options.lineWrapping) {\n\t      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      cm.display.sizer.style.minWidth = \"\";\n\t      cm.display.sizerWidth = null;\n\t    } else {\n\t      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      findMaxLine(cm);\n\t    }\n\t    estimateLineHeights(cm);\n\t    regChange(cm);\n\t    clearCaches(cm);\n\t    setTimeout(function(){updateScrollbars(cm);}, 100);\n\t  }\n\t\n\t  // Returns a function that estimates the height of a line, to use as\n\t  // first approximation until the line becomes visible (and is thus\n\t  // properly measurable).\n\t  function estimateHeight(cm) {\n\t    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n\t    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n\t    return function(line) {\n\t      if (lineIsHidden(cm.doc, line)) return 0;\n\t\n\t      var widgetsHeight = 0;\n\t      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n\t        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n\t      }\n\t\n\t      if (wrapping)\n\t        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n\t      else\n\t        return widgetsHeight + th;\n\t    };\n\t  }\n\t\n\t  function estimateLineHeights(cm) {\n\t    var doc = cm.doc, est = estimateHeight(cm);\n\t    doc.iter(function(line) {\n\t      var estHeight = est(line);\n\t      if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t    });\n\t  }\n\t\n\t  function themeChanged(cm) {\n\t    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n\t      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n\t    clearCaches(cm);\n\t  }\n\t\n\t  function guttersChanged(cm) {\n\t    updateGutters(cm);\n\t    regChange(cm);\n\t    setTimeout(function(){alignHorizontally(cm);}, 20);\n\t  }\n\t\n\t  // Rebuild the gutter elements, ensure the margin to the left of the\n\t  // code matches their width.\n\t  function updateGutters(cm) {\n\t    var gutters = cm.display.gutters, specs = cm.options.gutters;\n\t    removeChildren(gutters);\n\t    for (var i = 0; i < specs.length; ++i) {\n\t      var gutterClass = specs[i];\n\t      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n\t      if (gutterClass == \"CodeMirror-linenumbers\") {\n\t        cm.display.lineGutter = gElt;\n\t        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n\t      }\n\t    }\n\t    gutters.style.display = i ? \"\" : \"none\";\n\t    updateGutterSpace(cm);\n\t  }\n\t\n\t  function updateGutterSpace(cm) {\n\t    var width = cm.display.gutters.offsetWidth;\n\t    cm.display.sizer.style.marginLeft = width + \"px\";\n\t  }\n\t\n\t  // Compute the character length of a line, taking into account\n\t  // collapsed ranges (see markText) that might hide parts, and join\n\t  // other lines onto it.\n\t  function lineLength(line) {\n\t    if (line.height == 0) return 0;\n\t    var len = line.text.length, merged, cur = line;\n\t    while (merged = collapsedSpanAtStart(cur)) {\n\t      var found = merged.find(0, true);\n\t      cur = found.from.line;\n\t      len += found.from.ch - found.to.ch;\n\t    }\n\t    cur = line;\n\t    while (merged = collapsedSpanAtEnd(cur)) {\n\t      var found = merged.find(0, true);\n\t      len -= cur.text.length - found.from.ch;\n\t      cur = found.to.line;\n\t      len += cur.text.length - found.to.ch;\n\t    }\n\t    return len;\n\t  }\n\t\n\t  // Find the longest line in the document.\n\t  function findMaxLine(cm) {\n\t    var d = cm.display, doc = cm.doc;\n\t    d.maxLine = getLine(doc, doc.first);\n\t    d.maxLineLength = lineLength(d.maxLine);\n\t    d.maxLineChanged = true;\n\t    doc.iter(function(line) {\n\t      var len = lineLength(line);\n\t      if (len > d.maxLineLength) {\n\t        d.maxLineLength = len;\n\t        d.maxLine = line;\n\t      }\n\t    });\n\t  }\n\t\n\t  // Make sure the gutters options contains the element\n\t  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n\t  function setGuttersForLineNumbers(options) {\n\t    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n\t    if (found == -1 && options.lineNumbers) {\n\t      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n\t    } else if (found > -1 && !options.lineNumbers) {\n\t      options.gutters = options.gutters.slice(0);\n\t      options.gutters.splice(found, 1);\n\t    }\n\t  }\n\t\n\t  // SCROLLBARS\n\t\n\t  // Prepare DOM reads needed to update the scrollbars. Done in one\n\t  // shot to minimize update/measure roundtrips.\n\t  function measureForScrollbars(cm) {\n\t    var d = cm.display, gutterW = d.gutters.offsetWidth;\n\t    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n\t    return {\n\t      clientHeight: d.scroller.clientHeight,\n\t      viewHeight: d.wrapper.clientHeight,\n\t      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n\t      viewWidth: d.wrapper.clientWidth,\n\t      barLeft: cm.options.fixedGutter ? gutterW : 0,\n\t      docHeight: docH,\n\t      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n\t      nativeBarWidth: d.nativeBarWidth,\n\t      gutterWidth: gutterW\n\t    };\n\t  }\n\t\n\t  function NativeScrollbars(place, scroll, cm) {\n\t    this.cm = cm;\n\t    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n\t    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n\t    place(vert); place(horiz);\n\t\n\t    on(vert, \"scroll\", function() {\n\t      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n\t    });\n\t    on(horiz, \"scroll\", function() {\n\t      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n\t    });\n\t\n\t    this.checkedZeroWidth = false;\n\t    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\t    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n\t  }\n\t\n\t  NativeScrollbars.prototype = copyObj({\n\t    update: function(measure) {\n\t      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n\t      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n\t      var sWidth = measure.nativeBarWidth;\n\t\n\t      if (needsV) {\n\t        this.vert.style.display = \"block\";\n\t        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n\t        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n\t        // A bug in IE8 can cause this value to be negative, so guard it.\n\t        this.vert.firstChild.style.height =\n\t          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n\t      } else {\n\t        this.vert.style.display = \"\";\n\t        this.vert.firstChild.style.height = \"0\";\n\t      }\n\t\n\t      if (needsH) {\n\t        this.horiz.style.display = \"block\";\n\t        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n\t        this.horiz.style.left = measure.barLeft + \"px\";\n\t        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n\t        this.horiz.firstChild.style.width =\n\t          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n\t      } else {\n\t        this.horiz.style.display = \"\";\n\t        this.horiz.firstChild.style.width = \"0\";\n\t      }\n\t\n\t      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n\t        if (sWidth == 0) this.zeroWidthHack();\n\t        this.checkedZeroWidth = true;\n\t      }\n\t\n\t      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n\t    },\n\t    setScrollLeft: function(pos) {\n\t      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n\t      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n\t    },\n\t    setScrollTop: function(pos) {\n\t      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n\t      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n\t    },\n\t    zeroWidthHack: function() {\n\t      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n\t      this.horiz.style.height = this.vert.style.width = w;\n\t      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n\t      this.disableHoriz = new Delayed;\n\t      this.disableVert = new Delayed;\n\t    },\n\t    enableZeroWidthBar: function(bar, delay) {\n\t      bar.style.pointerEvents = \"auto\";\n\t      function maybeDisable() {\n\t        // To find out whether the scrollbar is still visible, we\n\t        // check whether the element under the pixel in the bottom\n\t        // left corner of the scrollbar box is the scrollbar box\n\t        // itself (when the bar is still visible) or its filler child\n\t        // (when the bar is hidden). If it is still visible, we keep\n\t        // it enabled, if it's hidden, we disable pointer events.\n\t        var box = bar.getBoundingClientRect();\n\t        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n\t        if (elt != bar) bar.style.pointerEvents = \"none\";\n\t        else delay.set(1000, maybeDisable);\n\t      }\n\t      delay.set(1000, maybeDisable);\n\t    },\n\t    clear: function() {\n\t      var parent = this.horiz.parentNode;\n\t      parent.removeChild(this.horiz);\n\t      parent.removeChild(this.vert);\n\t    }\n\t  }, NativeScrollbars.prototype);\n\t\n\t  function NullScrollbars() {}\n\t\n\t  NullScrollbars.prototype = copyObj({\n\t    update: function() { return {bottom: 0, right: 0}; },\n\t    setScrollLeft: function() {},\n\t    setScrollTop: function() {},\n\t    clear: function() {}\n\t  }, NullScrollbars.prototype);\n\t\n\t  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\t\n\t  function initScrollbars(cm) {\n\t    if (cm.display.scrollbars) {\n\t      cm.display.scrollbars.clear();\n\t      if (cm.display.scrollbars.addClass)\n\t        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t    }\n\t\n\t    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n\t      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n\t      // Prevent clicks in the scrollbars from killing focus\n\t      on(node, \"mousedown\", function() {\n\t        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n\t      });\n\t      node.setAttribute(\"cm-not-content\", \"true\");\n\t    }, function(pos, axis) {\n\t      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n\t      else setScrollTop(cm, pos);\n\t    }, cm);\n\t    if (cm.display.scrollbars.addClass)\n\t      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t  }\n\t\n\t  function updateScrollbars(cm, measure) {\n\t    if (!measure) measure = measureForScrollbars(cm);\n\t    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n\t    updateScrollbarsInner(cm, measure);\n\t    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n\t      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n\t        updateHeightsInViewport(cm);\n\t      updateScrollbarsInner(cm, measureForScrollbars(cm));\n\t      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n\t    }\n\t  }\n\t\n\t  // Re-synchronize the fake scrollbars with the actual size of the\n\t  // content.\n\t  function updateScrollbarsInner(cm, measure) {\n\t    var d = cm.display;\n\t    var sizes = d.scrollbars.update(measure);\n\t\n\t    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n\t    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\t\n\t    if (sizes.right && sizes.bottom) {\n\t      d.scrollbarFiller.style.display = \"block\";\n\t      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n\t      d.scrollbarFiller.style.width = sizes.right + \"px\";\n\t    } else d.scrollbarFiller.style.display = \"\";\n\t    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n\t      d.gutterFiller.style.display = \"block\";\n\t      d.gutterFiller.style.height = sizes.bottom + \"px\";\n\t      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n\t    } else d.gutterFiller.style.display = \"\";\n\t  }\n\t\n\t  // Compute the lines that are visible in a given viewport (defaults\n\t  // the the current scroll position). viewport may contain top,\n\t  // height, and ensure (see op.scrollToPos) properties.\n\t  function visibleLines(display, doc, viewport) {\n\t    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n\t    top = Math.floor(top - paddingTop(display));\n\t    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\t\n\t    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n\t    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n\t    // forces those lines into the viewport (if possible).\n\t    if (viewport && viewport.ensure) {\n\t      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n\t      if (ensureFrom < from) {\n\t        from = ensureFrom;\n\t        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n\t      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n\t        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n\t        to = ensureTo;\n\t      }\n\t    }\n\t    return {from: from, to: Math.max(to, from + 1)};\n\t  }\n\t\n\t  // LINE NUMBERS\n\t\n\t  // Re-align line numbers and gutter marks to compensate for\n\t  // horizontal scrolling.\n\t  function alignHorizontally(cm) {\n\t    var display = cm.display, view = display.view;\n\t    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n\t    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n\t    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n\t    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n\t      if (cm.options.fixedGutter && view[i].gutter)\n\t        view[i].gutter.style.left = left;\n\t      var align = view[i].alignable;\n\t      if (align) for (var j = 0; j < align.length; j++)\n\t        align[j].style.left = left;\n\t    }\n\t    if (cm.options.fixedGutter)\n\t      display.gutters.style.left = (comp + gutterW) + \"px\";\n\t  }\n\t\n\t  // Used to ensure that the line number gutter is still the right\n\t  // size for the current document size. Returns true when an update\n\t  // is needed.\n\t  function maybeUpdateLineNumberWidth(cm) {\n\t    if (!cm.options.lineNumbers) return false;\n\t    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n\t    if (last.length != display.lineNumChars) {\n\t      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n\t                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n\t      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n\t      display.lineGutter.style.width = \"\";\n\t      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n\t      display.lineNumWidth = display.lineNumInnerWidth + padding;\n\t      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n\t      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n\t      updateGutterSpace(cm);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function lineNumberFor(options, i) {\n\t    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n\t  }\n\t\n\t  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n\t  // but using getBoundingClientRect to get a sub-pixel-accurate\n\t  // result.\n\t  function compensateForHScroll(display) {\n\t    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n\t  }\n\t\n\t  // DISPLAY DRAWING\n\t\n\t  function DisplayUpdate(cm, viewport, force) {\n\t    var display = cm.display;\n\t\n\t    this.viewport = viewport;\n\t    // Store some values that we'll need later (but don't want to force a relayout for)\n\t    this.visible = visibleLines(display, cm.doc, viewport);\n\t    this.editorIsHidden = !display.wrapper.offsetWidth;\n\t    this.wrapperHeight = display.wrapper.clientHeight;\n\t    this.wrapperWidth = display.wrapper.clientWidth;\n\t    this.oldDisplayWidth = displayWidth(cm);\n\t    this.force = force;\n\t    this.dims = getDimensions(cm);\n\t    this.events = [];\n\t  }\n\t\n\t  DisplayUpdate.prototype.signal = function(emitter, type) {\n\t    if (hasHandler(emitter, type))\n\t      this.events.push(arguments);\n\t  };\n\t  DisplayUpdate.prototype.finish = function() {\n\t    for (var i = 0; i < this.events.length; i++)\n\t      signal.apply(null, this.events[i]);\n\t  };\n\t\n\t  function maybeClipScrollbars(cm) {\n\t    var display = cm.display;\n\t    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n\t      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n\t      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n\t      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n\t      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n\t      display.scrollbarsClipped = true;\n\t    }\n\t  }\n\t\n\t  // Does the actual updating of the line display. Bails out\n\t  // (returning false) when there is nothing to be done and forced is\n\t  // false.\n\t  function updateDisplayIfNeeded(cm, update) {\n\t    var display = cm.display, doc = cm.doc;\n\t\n\t    if (update.editorIsHidden) {\n\t      resetView(cm);\n\t      return false;\n\t    }\n\t\n\t    // Bail out if the visible area is already rendered and nothing changed.\n\t    if (!update.force &&\n\t        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n\t        display.renderedView == display.view && countDirtyView(cm) == 0)\n\t      return false;\n\t\n\t    if (maybeUpdateLineNumberWidth(cm)) {\n\t      resetView(cm);\n\t      update.dims = getDimensions(cm);\n\t    }\n\t\n\t    // Compute a suitable new viewport (from & to)\n\t    var end = doc.first + doc.size;\n\t    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n\t    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n\t    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n\t    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n\t    if (sawCollapsedSpans) {\n\t      from = visualLineNo(cm.doc, from);\n\t      to = visualLineEndNo(cm.doc, to);\n\t    }\n\t\n\t    var different = from != display.viewFrom || to != display.viewTo ||\n\t      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n\t    adjustView(cm, from, to);\n\t\n\t    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n\t    // Position the mover div to align with the current scroll position\n\t    cm.display.mover.style.top = display.viewOffset + \"px\";\n\t\n\t    var toUpdate = countDirtyView(cm);\n\t    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n\t      return false;\n\t\n\t    // For big changes, we hide the enclosing element during the\n\t    // update, since that speeds up the operations on most browsers.\n\t    var focused = activeElt();\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n\t    patchDisplay(cm, display.updateLineNumbers, update.dims);\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n\t    display.renderedView = display.view;\n\t    // There might have been a widget with a focused element that got\n\t    // hidden or updated, if so re-focus it.\n\t    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\t\n\t    // Prevent selection and cursors from interfering with the scroll\n\t    // width and height.\n\t    removeChildren(display.cursorDiv);\n\t    removeChildren(display.selectionDiv);\n\t    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\t\n\t    if (different) {\n\t      display.lastWrapHeight = update.wrapperHeight;\n\t      display.lastWrapWidth = update.wrapperWidth;\n\t      startWorker(cm, 400);\n\t    }\n\t\n\t    display.updateLineNumbers = null;\n\t\n\t    return true;\n\t  }\n\t\n\t  function postUpdateDisplay(cm, update) {\n\t    var viewport = update.viewport;\n\t    for (var first = true;; first = false) {\n\t      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n\t        // Clip forced viewport to actual scrollable area.\n\t        if (viewport && viewport.top != null)\n\t          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n\t        // Updated line heights might result in the drawn area not\n\t        // actually covering the viewport. Keep looping until it does.\n\t        update.visible = visibleLines(cm.display, cm.doc, viewport);\n\t        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n\t          break;\n\t      }\n\t      if (!updateDisplayIfNeeded(cm, update)) break;\n\t      updateHeightsInViewport(cm);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      setDocumentHeight(cm, barMeasure);\n\t      updateScrollbars(cm, barMeasure);\n\t    }\n\t\n\t    update.signal(cm, \"update\", cm);\n\t    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n\t      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n\t      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n\t    }\n\t  }\n\t\n\t  function updateDisplaySimple(cm, viewport) {\n\t    var update = new DisplayUpdate(cm, viewport);\n\t    if (updateDisplayIfNeeded(cm, update)) {\n\t      updateHeightsInViewport(cm);\n\t      postUpdateDisplay(cm, update);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      setDocumentHeight(cm, barMeasure);\n\t      updateScrollbars(cm, barMeasure);\n\t      update.finish();\n\t    }\n\t  }\n\t\n\t  function setDocumentHeight(cm, measure) {\n\t    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n\t    var total = measure.docHeight + cm.display.barHeight;\n\t    cm.display.heightForcer.style.top = total + \"px\";\n\t    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + \"px\";\n\t  }\n\t\n\t  // Read the actual heights of the rendered lines, and update their\n\t  // stored heights to match.\n\t  function updateHeightsInViewport(cm) {\n\t    var display = cm.display;\n\t    var prevBottom = display.lineDiv.offsetTop;\n\t    for (var i = 0; i < display.view.length; i++) {\n\t      var cur = display.view[i], height;\n\t      if (cur.hidden) continue;\n\t      if (ie && ie_version < 8) {\n\t        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n\t        height = bot - prevBottom;\n\t        prevBottom = bot;\n\t      } else {\n\t        var box = cur.node.getBoundingClientRect();\n\t        height = box.bottom - box.top;\n\t      }\n\t      var diff = cur.line.height - height;\n\t      if (height < 2) height = textHeight(display);\n\t      if (diff > .001 || diff < -.001) {\n\t        updateLineHeight(cur.line, height);\n\t        updateWidgetHeight(cur.line);\n\t        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n\t          updateWidgetHeight(cur.rest[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Read and store the height of line widgets associated with the\n\t  // given line.\n\t  function updateWidgetHeight(line) {\n\t    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n\t      line.widgets[i].height = line.widgets[i].node.offsetHeight;\n\t  }\n\t\n\t  // Do a bulk-read of the DOM positions and sizes needed to draw the\n\t  // view, so that we don't interleave reading and writing to the DOM.\n\t  function getDimensions(cm) {\n\t    var d = cm.display, left = {}, width = {};\n\t    var gutterLeft = d.gutters.clientLeft;\n\t    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n\t      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n\t      width[cm.options.gutters[i]] = n.clientWidth;\n\t    }\n\t    return {fixedPos: compensateForHScroll(d),\n\t            gutterTotalWidth: d.gutters.offsetWidth,\n\t            gutterLeft: left,\n\t            gutterWidth: width,\n\t            wrapperWidth: d.wrapper.clientWidth};\n\t  }\n\t\n\t  // Sync the actual display DOM structure with display.view, removing\n\t  // nodes for lines that are no longer in view, and creating the ones\n\t  // that are not there yet, and updating the ones that are out of\n\t  // date.\n\t  function patchDisplay(cm, updateNumbersFrom, dims) {\n\t    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n\t    var container = display.lineDiv, cur = container.firstChild;\n\t\n\t    function rm(node) {\n\t      var next = node.nextSibling;\n\t      // Works around a throw-scroll bug in OS X Webkit\n\t      if (webkit && mac && cm.display.currentWheelTarget == node)\n\t        node.style.display = \"none\";\n\t      else\n\t        node.parentNode.removeChild(node);\n\t      return next;\n\t    }\n\t\n\t    var view = display.view, lineN = display.viewFrom;\n\t    // Loop over the elements in the view, syncing cur (the DOM nodes\n\t    // in display.lineDiv) with the view as we go.\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (lineView.hidden) {\n\t      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n\t        var node = buildLineElement(cm, lineView, lineN, dims);\n\t        container.insertBefore(node, cur);\n\t      } else { // Already drawn\n\t        while (cur != lineView.node) cur = rm(cur);\n\t        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n\t          updateNumbersFrom <= lineN && lineView.lineNumber;\n\t        if (lineView.changes) {\n\t          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n\t          updateLineForChanges(cm, lineView, lineN, dims);\n\t        }\n\t        if (updateNumber) {\n\t          removeChildren(lineView.lineNumber);\n\t          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n\t        }\n\t        cur = lineView.node.nextSibling;\n\t      }\n\t      lineN += lineView.size;\n\t    }\n\t    while (cur) cur = rm(cur);\n\t  }\n\t\n\t  // When an aspect of a line changes, a string is added to\n\t  // lineView.changes. This updates the relevant part of the line's\n\t  // DOM structure.\n\t  function updateLineForChanges(cm, lineView, lineN, dims) {\n\t    for (var j = 0; j < lineView.changes.length; j++) {\n\t      var type = lineView.changes[j];\n\t      if (type == \"text\") updateLineText(cm, lineView);\n\t      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n\t      else if (type == \"class\") updateLineClasses(lineView);\n\t      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n\t    }\n\t    lineView.changes = null;\n\t  }\n\t\n\t  // Lines with gutter elements, widgets or a background class need to\n\t  // be wrapped, and have the extra elements added to the wrapper div\n\t  function ensureLineWrapped(lineView) {\n\t    if (lineView.node == lineView.text) {\n\t      lineView.node = elt(\"div\", null, null, \"position: relative\");\n\t      if (lineView.text.parentNode)\n\t        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n\t      lineView.node.appendChild(lineView.text);\n\t      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n\t    }\n\t    return lineView.node;\n\t  }\n\t\n\t  function updateLineBackground(lineView) {\n\t    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n\t    if (cls) cls += \" CodeMirror-linebackground\";\n\t    if (lineView.background) {\n\t      if (cls) lineView.background.className = cls;\n\t      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n\t    } else if (cls) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n\t    }\n\t  }\n\t\n\t  // Wrapper around buildLineContent which will reuse the structure\n\t  // in display.externalMeasured when possible.\n\t  function getLineContent(cm, lineView) {\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && ext.line == lineView.line) {\n\t      cm.display.externalMeasured = null;\n\t      lineView.measure = ext.measure;\n\t      return ext.built;\n\t    }\n\t    return buildLineContent(cm, lineView);\n\t  }\n\t\n\t  // Redraw the line's text. Interacts with the background and text\n\t  // classes because the mode may output tokens that influence these\n\t  // classes.\n\t  function updateLineText(cm, lineView) {\n\t    var cls = lineView.text.className;\n\t    var built = getLineContent(cm, lineView);\n\t    if (lineView.text == lineView.node) lineView.node = built.pre;\n\t    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n\t    lineView.text = built.pre;\n\t    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n\t      lineView.bgClass = built.bgClass;\n\t      lineView.textClass = built.textClass;\n\t      updateLineClasses(lineView);\n\t    } else if (cls) {\n\t      lineView.text.className = cls;\n\t    }\n\t  }\n\t\n\t  function updateLineClasses(lineView) {\n\t    updateLineBackground(lineView);\n\t    if (lineView.line.wrapClass)\n\t      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n\t    else if (lineView.node != lineView.text)\n\t      lineView.node.className = \"\";\n\t    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n\t    lineView.text.className = textClass || \"\";\n\t  }\n\t\n\t  function updateLineGutter(cm, lineView, lineN, dims) {\n\t    if (lineView.gutter) {\n\t      lineView.node.removeChild(lineView.gutter);\n\t      lineView.gutter = null;\n\t    }\n\t    if (lineView.gutterBackground) {\n\t      lineView.node.removeChild(lineView.gutterBackground);\n\t      lineView.gutterBackground = null;\n\t    }\n\t    if (lineView.line.gutterClass) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n\t                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n\t                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n\t      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n\t    }\n\t    var markers = lineView.line.gutterMarkers;\n\t    if (cm.options.lineNumbers || markers) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n\t                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n\t      cm.display.input.setUneditable(gutterWrap);\n\t      wrap.insertBefore(gutterWrap, lineView.text);\n\t      if (lineView.line.gutterClass)\n\t        gutterWrap.className += \" \" + lineView.line.gutterClass;\n\t      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n\t        lineView.lineNumber = gutterWrap.appendChild(\n\t          elt(\"div\", lineNumberFor(cm.options, lineN),\n\t              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n\t              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n\t              + cm.display.lineNumInnerWidth + \"px\"));\n\t      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n\t        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n\t        if (found)\n\t          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n\t                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n\t      }\n\t    }\n\t  }\n\t\n\t  function updateLineWidgets(cm, lineView, dims) {\n\t    if (lineView.alignable) lineView.alignable = null;\n\t    for (var node = lineView.node.firstChild, next; node; node = next) {\n\t      var next = node.nextSibling;\n\t      if (node.className == \"CodeMirror-linewidget\")\n\t        lineView.node.removeChild(node);\n\t    }\n\t    insertLineWidgets(cm, lineView, dims);\n\t  }\n\t\n\t  // Build a line's DOM representation from scratch\n\t  function buildLineElement(cm, lineView, lineN, dims) {\n\t    var built = getLineContent(cm, lineView);\n\t    lineView.text = lineView.node = built.pre;\n\t    if (built.bgClass) lineView.bgClass = built.bgClass;\n\t    if (built.textClass) lineView.textClass = built.textClass;\n\t\n\t    updateLineClasses(lineView);\n\t    updateLineGutter(cm, lineView, lineN, dims);\n\t    insertLineWidgets(cm, lineView, dims);\n\t    return lineView.node;\n\t  }\n\t\n\t  // A lineView may contain multiple logical lines (when merged by\n\t  // collapsed spans). The widgets for all of them need to be drawn.\n\t  function insertLineWidgets(cm, lineView, dims) {\n\t    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n\t    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n\t  }\n\t\n\t  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n\t    if (!line.widgets) return;\n\t    var wrap = ensureLineWrapped(lineView);\n\t    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n\t      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n\t      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      positionLineWidget(widget, node, lineView, dims);\n\t      cm.display.input.setUneditable(node);\n\t      if (allowAbove && widget.above)\n\t        wrap.insertBefore(node, lineView.gutter || lineView.text);\n\t      else\n\t        wrap.appendChild(node);\n\t      signalLater(widget, \"redraw\");\n\t    }\n\t  }\n\t\n\t  function positionLineWidget(widget, node, lineView, dims) {\n\t    if (widget.noHScroll) {\n\t      (lineView.alignable || (lineView.alignable = [])).push(node);\n\t      var width = dims.wrapperWidth;\n\t      node.style.left = dims.fixedPos + \"px\";\n\t      if (!widget.coverGutter) {\n\t        width -= dims.gutterTotalWidth;\n\t        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n\t      }\n\t      node.style.width = width + \"px\";\n\t    }\n\t    if (widget.coverGutter) {\n\t      node.style.zIndex = 5;\n\t      node.style.position = \"relative\";\n\t      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n\t    }\n\t  }\n\t\n\t  // POSITION OBJECT\n\t\n\t  // A Pos instance represents a position within the text.\n\t  var Pos = CodeMirror.Pos = function(line, ch) {\n\t    if (!(this instanceof Pos)) return new Pos(line, ch);\n\t    this.line = line; this.ch = ch;\n\t  };\n\t\n\t  // Compare two positions, return 0 if they are the same, a negative\n\t  // number when a is less, and a positive number otherwise.\n\t  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\t\n\t  function copyPos(x) {return Pos(x.line, x.ch);}\n\t  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n\t  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\t\n\t  // INPUT HANDLING\n\t\n\t  function ensureFocus(cm) {\n\t    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n\t  }\n\t\n\t  function isReadOnly(cm) {\n\t    return cm.options.readOnly || cm.doc.cantEdit;\n\t  }\n\t\n\t  // This will be set to an array of strings when copying, so that,\n\t  // when pasting, we know what kind of selections the copied text\n\t  // was made out of.\n\t  var lastCopied = null;\n\t\n\t  function applyTextInput(cm, inserted, deleted, sel, origin) {\n\t    var doc = cm.doc;\n\t    cm.display.shift = false;\n\t    if (!sel) sel = doc.sel;\n\t\n\t    var paste = cm.state.pasteIncoming || origin == \"paste\";\n\t    var textLines = doc.splitLines(inserted), multiPaste = null;\n\t    // When pasing N lines into N selections, insert one line per selection\n\t    if (paste && sel.ranges.length > 1) {\n\t      if (lastCopied && lastCopied.join(\"\\n\") == inserted) {\n\t        if (sel.ranges.length % lastCopied.length == 0) {\n\t          multiPaste = [];\n\t          for (var i = 0; i < lastCopied.length; i++)\n\t            multiPaste.push(doc.splitLines(lastCopied[i]));\n\t        }\n\t      } else if (textLines.length == sel.ranges.length) {\n\t        multiPaste = map(textLines, function(l) { return [l]; });\n\t      }\n\t    }\n\t\n\t    // Normal behavior is to insert the new text into every selection\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      var from = range.from(), to = range.to();\n\t      if (range.empty()) {\n\t        if (deleted && deleted > 0) // Handle deletion\n\t          from = Pos(from.line, from.ch - deleted);\n\t        else if (cm.state.overwrite && !paste) // Handle overwrite\n\t          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n\t      }\n\t      var updateInput = cm.curOp.updateInput;\n\t      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n\t                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n\t      makeChange(cm.doc, changeEvent);\n\t      signalLater(cm, \"inputRead\", cm, changeEvent);\n\t    }\n\t    if (inserted && !paste)\n\t      triggerElectric(cm, inserted);\n\t\n\t    ensureCursorVisible(cm);\n\t    cm.curOp.updateInput = updateInput;\n\t    cm.curOp.typing = true;\n\t    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n\t  }\n\t\n\t  function handlePaste(e, cm) {\n\t    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n\t    if (pasted) {\n\t      e.preventDefault();\n\t      if (!isReadOnly(cm) && !cm.options.disableInput)\n\t        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n\t      return true;\n\t    }\n\t  }\n\t\n\t  function triggerElectric(cm, inserted) {\n\t    // When an 'electric' character is inserted, immediately trigger a reindent\n\t    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n\t    var sel = cm.doc.sel;\n\t\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n\t      var mode = cm.getModeAt(range.head);\n\t      var indented = false;\n\t      if (mode.electricChars) {\n\t        for (var j = 0; j < mode.electricChars.length; j++)\n\t          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n\t            indented = indentLine(cm, range.head.line, \"smart\");\n\t            break;\n\t          }\n\t      } else if (mode.electricInput) {\n\t        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n\t          indented = indentLine(cm, range.head.line, \"smart\");\n\t      }\n\t      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n\t    }\n\t  }\n\t\n\t  function copyableRanges(cm) {\n\t    var text = [], ranges = [];\n\t    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n\t      var line = cm.doc.sel.ranges[i].head.line;\n\t      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n\t      ranges.push(lineRange);\n\t      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n\t    }\n\t    return {text: text, ranges: ranges};\n\t  }\n\t\n\t  function disableBrowserMagic(field) {\n\t    field.setAttribute(\"autocorrect\", \"off\");\n\t    field.setAttribute(\"autocapitalize\", \"off\");\n\t    field.setAttribute(\"spellcheck\", \"false\");\n\t  }\n\t\n\t  // TEXTAREA INPUT STYLE\n\t\n\t  function TextareaInput(cm) {\n\t    this.cm = cm;\n\t    // See input.poll and input.reset\n\t    this.prevInput = \"\";\n\t\n\t    // Flag that indicates whether we expect input to appear real soon\n\t    // now (after some event like 'keypress' or 'input') and are\n\t    // polling intensively.\n\t    this.pollingFast = false;\n\t    // Self-resetting timeout for the poller\n\t    this.polling = new Delayed();\n\t    // Tracks when input.reset has punted to just putting a short\n\t    // string into the textarea instead of the full selection.\n\t    this.inaccurateSelection = false;\n\t    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n\t    this.hasSelection = false;\n\t    this.composing = null;\n\t  };\n\t\n\t  function hiddenTextarea() {\n\t    var te = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n\t    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n\t    // The textarea is kept positioned near the cursor to prevent the\n\t    // fact that it'll be scrolled into view on input from scrolling\n\t    // our fake cursor out of view. On webkit, when wrap=off, paste is\n\t    // very slow. So make the area wide instead.\n\t    if (webkit) te.style.width = \"1000px\";\n\t    else te.setAttribute(\"wrap\", \"off\");\n\t    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n\t    if (ios) te.style.border = \"1px solid black\";\n\t    disableBrowserMagic(te);\n\t    return div;\n\t  }\n\t\n\t  TextareaInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = this.cm;\n\t\n\t      // Wraps and hides input textarea\n\t      var div = this.wrapper = hiddenTextarea();\n\t      // The semihidden textarea that is focused when the editor is\n\t      // focused, and receives input.\n\t      var te = this.textarea = div.firstChild;\n\t      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\t\n\t      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n\t      if (ios) te.style.width = \"0px\";\n\t\n\t      on(te, \"input\", function() {\n\t        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n\t        input.poll();\n\t      });\n\t\n\t      on(te, \"paste\", function(e) {\n\t        if (handlePaste(e, cm)) return true;\n\t\n\t        cm.state.pasteIncoming = true;\n\t        input.fastPoll();\n\t      });\n\t\n\t      function prepareCopyCut(e) {\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = cm.getSelections();\n\t          if (input.inaccurateSelection) {\n\t            input.prevInput = \"\";\n\t            input.inaccurateSelection = false;\n\t            te.value = lastCopied.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = ranges.text;\n\t          if (e.type == \"cut\") {\n\t            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n\t          } else {\n\t            input.prevInput = \"\";\n\t            te.value = ranges.text.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        }\n\t        if (e.type == \"cut\") cm.state.cutIncoming = true;\n\t      }\n\t      on(te, \"cut\", prepareCopyCut);\n\t      on(te, \"copy\", prepareCopyCut);\n\t\n\t      on(display.scroller, \"paste\", function(e) {\n\t        if (eventInWidget(display, e)) return;\n\t        cm.state.pasteIncoming = true;\n\t        input.focus();\n\t      });\n\t\n\t      // Prevent normal selection in the editor (we handle our own)\n\t      on(display.lineSpace, \"selectstart\", function(e) {\n\t        if (!eventInWidget(display, e)) e_preventDefault(e);\n\t      });\n\t\n\t      on(te, \"compositionstart\", function() {\n\t        var start = cm.getCursor(\"from\");\n\t        if (input.composing) input.composing.range.clear()\n\t        input.composing = {\n\t          start: start,\n\t          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n\t        };\n\t      });\n\t      on(te, \"compositionend\", function() {\n\t        if (input.composing) {\n\t          input.poll();\n\t          input.composing.range.clear();\n\t          input.composing = null;\n\t        }\n\t      });\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      // Redraw the selection and/or cursor\n\t      var cm = this.cm, display = cm.display, doc = cm.doc;\n\t      var result = prepareSelection(cm);\n\t\n\t      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\t      if (cm.options.moveInputWithCursor) {\n\t        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n\t        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n\t        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n\t                                            headPos.top + lineOff.top - wrapOff.top));\n\t        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n\t                                             headPos.left + lineOff.left - wrapOff.left));\n\t      }\n\t\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(drawn) {\n\t      var cm = this.cm, display = cm.display;\n\t      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n\t      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n\t      if (drawn.teTop != null) {\n\t        this.wrapper.style.top = drawn.teTop + \"px\";\n\t        this.wrapper.style.left = drawn.teLeft + \"px\";\n\t      }\n\t    },\n\t\n\t    // Reset the input to correspond to the selection (or to be empty,\n\t    // when not typing and nothing is selected)\n\t    reset: function(typing) {\n\t      if (this.contextMenuPending) return;\n\t      var minimal, selected, cm = this.cm, doc = cm.doc;\n\t      if (cm.somethingSelected()) {\n\t        this.prevInput = \"\";\n\t        var range = doc.sel.primary();\n\t        minimal = hasCopyEvent &&\n\t          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n\t        var content = minimal ? \"-\" : selected || cm.getSelection();\n\t        this.textarea.value = content;\n\t        if (cm.state.focused) selectInput(this.textarea);\n\t        if (ie && ie_version >= 9) this.hasSelection = content;\n\t      } else if (!typing) {\n\t        this.prevInput = this.textarea.value = \"\";\n\t        if (ie && ie_version >= 9) this.hasSelection = null;\n\t      }\n\t      this.inaccurateSelection = minimal;\n\t    },\n\t\n\t    getField: function() { return this.textarea; },\n\t\n\t    supportsTouch: function() { return false; },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n\t        try { this.textarea.focus(); }\n\t        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n\t      }\n\t    },\n\t\n\t    blur: function() { this.textarea.blur(); },\n\t\n\t    resetPosition: function() {\n\t      this.wrapper.style.top = this.wrapper.style.left = 0;\n\t    },\n\t\n\t    receivedFocus: function() { this.slowPoll(); },\n\t\n\t    // Poll for input changes, using the normal rate of polling. This\n\t    // runs as long as the editor is focused.\n\t    slowPoll: function() {\n\t      var input = this;\n\t      if (input.pollingFast) return;\n\t      input.polling.set(this.cm.options.pollInterval, function() {\n\t        input.poll();\n\t        if (input.cm.state.focused) input.slowPoll();\n\t      });\n\t    },\n\t\n\t    // When an event has just come in that is likely to add or change\n\t    // something in the input textarea, we poll faster, to ensure that\n\t    // the change appears on the screen quickly.\n\t    fastPoll: function() {\n\t      var missed = false, input = this;\n\t      input.pollingFast = true;\n\t      function p() {\n\t        var changed = input.poll();\n\t        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n\t        else {input.pollingFast = false; input.slowPoll();}\n\t      }\n\t      input.polling.set(20, p);\n\t    },\n\t\n\t    // Read input from the textarea, and update the document to match.\n\t    // When something is selected, it is present in the textarea, and\n\t    // selected (unless it is huge, in which case a placeholder is\n\t    // used). When nothing is selected, the cursor sits after previously\n\t    // seen text (can be empty), which is stored in prevInput (we must\n\t    // not reset the textarea when typing, because that breaks IME).\n\t    poll: function() {\n\t      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n\t      // Since this is called a *lot*, try to bail out as cheaply as\n\t      // possible when it is clear that nothing happened. hasSelection\n\t      // will be the case when there is a lot of text in the textarea,\n\t      // in which case reading its value would be expensive.\n\t      if (this.contextMenuPending || !cm.state.focused ||\n\t          (hasSelection(input) && !prevInput && !this.composing) ||\n\t          isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)\n\t        return false;\n\t\n\t      var text = input.value;\n\t      // If nothing changed, bail.\n\t      if (text == prevInput && !cm.somethingSelected()) return false;\n\t      // Work around nonsensical selection resetting in IE9/10, and\n\t      // inexplicable appearance of private area unicode characters on\n\t      // some key combos in Mac (#2689).\n\t      if (ie && ie_version >= 9 && this.hasSelection === text ||\n\t          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n\t        cm.display.input.reset();\n\t        return false;\n\t      }\n\t\n\t      if (cm.doc.sel == cm.display.selForContextMenu) {\n\t        var first = text.charCodeAt(0);\n\t        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n\t        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n\t      }\n\t      // Find the part of the input that is actually new\n\t      var same = 0, l = Math.min(prevInput.length, text.length);\n\t      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\t\n\t      var self = this;\n\t      runInOp(cm, function() {\n\t        applyTextInput(cm, text.slice(same), prevInput.length - same,\n\t                       null, self.composing ? \"*compose\" : null);\n\t\n\t        // Don't leave long text in the textarea, since it makes further polling slow\n\t        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n\t        else self.prevInput = text;\n\t\n\t        if (self.composing) {\n\t          self.composing.range.clear();\n\t          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n\t                                             {className: \"CodeMirror-composing\"});\n\t        }\n\t      });\n\t      return true;\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      if (this.pollingFast && this.poll()) this.pollingFast = false;\n\t    },\n\t\n\t    onKeyPress: function() {\n\t      if (ie && ie_version >= 9) this.hasSelection = null;\n\t      this.fastPoll();\n\t    },\n\t\n\t    onContextMenu: function(e) {\n\t      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n\t      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n\t      if (!pos || presto) return; // Opera is difficult.\n\t\n\t      // Reset the current text selection only if the click is done outside of the selection\n\t      // and 'resetSelectionOnContextMenu' option is true.\n\t      var reset = cm.options.resetSelectionOnContextMenu;\n\t      if (reset && cm.doc.sel.contains(pos) == -1)\n\t        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\t\n\t      var oldCSS = te.style.cssText;\n\t      input.wrapper.style.position = \"absolute\";\n\t      te.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n\t        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n\t        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n\t        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n\t      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n\t      display.input.focus();\n\t      if (webkit) window.scrollTo(null, oldScrollY);\n\t      display.input.reset();\n\t      // Adds \"Select all\" to context menu in FF\n\t      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n\t      input.contextMenuPending = true;\n\t      display.selForContextMenu = cm.doc.sel;\n\t      clearTimeout(display.detectingSelectAll);\n\t\n\t      // Select-all will be greyed out if there's nothing to select, so\n\t      // this adds a zero-width space so that we can later check whether\n\t      // it got selected.\n\t      function prepareSelectAllHack() {\n\t        if (te.selectionStart != null) {\n\t          var selected = cm.somethingSelected();\n\t          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n\t          te.value = \"\\u21da\"; // Used to catch context-menu undo\n\t          te.value = extval;\n\t          input.prevInput = selected ? \"\" : \"\\u200b\";\n\t          te.selectionStart = 1; te.selectionEnd = extval.length;\n\t          // Re-set this, in case some other handler touched the\n\t          // selection in the meantime.\n\t          display.selForContextMenu = cm.doc.sel;\n\t        }\n\t      }\n\t      function rehide() {\n\t        input.contextMenuPending = false;\n\t        input.wrapper.style.position = \"relative\";\n\t        te.style.cssText = oldCSS;\n\t        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\t\n\t        // Try to detect the user choosing select-all\n\t        if (te.selectionStart != null) {\n\t          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n\t          var i = 0, poll = function() {\n\t            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n\t                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n\t              operation(cm, commands.selectAll)(cm);\n\t            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n\t            else display.input.reset();\n\t          };\n\t          display.detectingSelectAll = setTimeout(poll, 200);\n\t        }\n\t      }\n\t\n\t      if (ie && ie_version >= 9) prepareSelectAllHack();\n\t      if (captureRightClick) {\n\t        e_stop(e);\n\t        var mouseup = function() {\n\t          off(window, \"mouseup\", mouseup);\n\t          setTimeout(rehide, 20);\n\t        };\n\t        on(window, \"mouseup\", mouseup);\n\t      } else {\n\t        setTimeout(rehide, 50);\n\t      }\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      if (!val) this.reset();\n\t    },\n\t\n\t    setUneditable: nothing,\n\t\n\t    needsContentAttribute: false\n\t  }, TextareaInput.prototype);\n\t\n\t  // CONTENTEDITABLE INPUT STYLE\n\t\n\t  function ContentEditableInput(cm) {\n\t    this.cm = cm;\n\t    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n\t    this.polling = new Delayed();\n\t    this.gracePeriod = false;\n\t  }\n\t\n\t  ContentEditableInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = input.cm;\n\t      var div = input.div = display.lineDiv;\n\t      disableBrowserMagic(div);\n\t\n\t      on(div, \"paste\", function(e) { handlePaste(e, cm); })\n\t\n\t      on(div, \"compositionstart\", function(e) {\n\t        var data = e.data;\n\t        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n\t        if (!data) return;\n\t        var prim = cm.doc.sel.primary();\n\t        var line = cm.getLine(prim.head.line);\n\t        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n\t        if (found > -1 && found <= prim.head.ch)\n\t          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n\t                                                Pos(prim.head.line, found + data.length));\n\t      });\n\t      on(div, \"compositionupdate\", function(e) {\n\t        input.composing.data = e.data;\n\t      });\n\t      on(div, \"compositionend\", function(e) {\n\t        var ours = input.composing;\n\t        if (!ours) return;\n\t        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n\t          ours.data = e.data;\n\t        // Need a small delay to prevent other code (input event,\n\t        // selection polling) from doing damage when fired right after\n\t        // compositionend.\n\t        setTimeout(function() {\n\t          if (!ours.handled)\n\t            input.applyComposition(ours);\n\t          if (input.composing == ours)\n\t            input.composing = null;\n\t        }, 50);\n\t      });\n\t\n\t      on(div, \"touchstart\", function() {\n\t        input.forceCompositionEnd();\n\t      });\n\t\n\t      on(div, \"input\", function() {\n\t        if (input.composing) return;\n\t        if (isReadOnly(cm) || !input.pollContent())\n\t          runInOp(input.cm, function() {regChange(cm);});\n\t      });\n\t\n\t      function onCopyCut(e) {\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = cm.getSelections();\n\t          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = ranges.text;\n\t          if (e.type == \"cut\") {\n\t            cm.operation(function() {\n\t              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n\t              cm.replaceSelection(\"\", null, \"cut\");\n\t            });\n\t          }\n\t        }\n\t        // iOS exposes the clipboard API, but seems to discard content inserted into it\n\t        if (e.clipboardData && !ios) {\n\t          e.preventDefault();\n\t          e.clipboardData.clearData();\n\t          e.clipboardData.setData(\"text/plain\", lastCopied.join(\"\\n\"));\n\t        } else {\n\t          // Old-fashioned briefly-focus-a-textarea hack\n\t          var kludge = hiddenTextarea(), te = kludge.firstChild;\n\t          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n\t          te.value = lastCopied.join(\"\\n\");\n\t          var hadFocus = document.activeElement;\n\t          selectInput(te);\n\t          setTimeout(function() {\n\t            cm.display.lineSpace.removeChild(kludge);\n\t            hadFocus.focus();\n\t          }, 50);\n\t        }\n\t      }\n\t      on(div, \"copy\", onCopyCut);\n\t      on(div, \"cut\", onCopyCut);\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      var result = prepareSelection(this.cm, false);\n\t      result.focus = this.cm.state.focused;\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(info) {\n\t      if (!info || !this.cm.display.view.length) return;\n\t      if (info.focus) this.showPrimarySelection();\n\t      this.showMultipleSelections(info);\n\t    },\n\t\n\t    showPrimarySelection: function() {\n\t      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n\t      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n\t      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n\t      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n\t          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n\t          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n\t        return;\n\t\n\t      var start = posToDOM(this.cm, prim.from());\n\t      var end = posToDOM(this.cm, prim.to());\n\t      if (!start && !end) return;\n\t\n\t      var view = this.cm.display.view;\n\t      var old = sel.rangeCount && sel.getRangeAt(0);\n\t      if (!start) {\n\t        start = {node: view[0].measure.map[2], offset: 0};\n\t      } else if (!end) { // FIXME dangerously hacky\n\t        var measure = view[view.length - 1].measure;\n\t        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n\t        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n\t      }\n\t\n\t      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n\t      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n\t      if (rng) {\n\t        sel.removeAllRanges();\n\t        sel.addRange(rng);\n\t        if (old && sel.anchorNode == null) sel.addRange(old);\n\t        else if (gecko) this.startGracePeriod();\n\t      }\n\t      this.rememberSelection();\n\t    },\n\t\n\t    startGracePeriod: function() {\n\t      var input = this;\n\t      clearTimeout(this.gracePeriod);\n\t      this.gracePeriod = setTimeout(function() {\n\t        input.gracePeriod = false;\n\t        if (input.selectionChanged())\n\t          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n\t      }, 20);\n\t    },\n\t\n\t    showMultipleSelections: function(info) {\n\t      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n\t      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n\t    },\n\t\n\t    rememberSelection: function() {\n\t      var sel = window.getSelection();\n\t      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n\t      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n\t    },\n\t\n\t    selectionInEditor: function() {\n\t      var sel = window.getSelection();\n\t      if (!sel.rangeCount) return false;\n\t      var node = sel.getRangeAt(0).commonAncestorContainer;\n\t      return contains(this.div, node);\n\t    },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n\t    },\n\t    blur: function() { this.div.blur(); },\n\t    getField: function() { return this.div; },\n\t\n\t    supportsTouch: function() { return true; },\n\t\n\t    receivedFocus: function() {\n\t      var input = this;\n\t      if (this.selectionInEditor())\n\t        this.pollSelection();\n\t      else\n\t        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\t\n\t      function poll() {\n\t        if (input.cm.state.focused) {\n\t          input.pollSelection();\n\t          input.polling.set(input.cm.options.pollInterval, poll);\n\t        }\n\t      }\n\t      this.polling.set(this.cm.options.pollInterval, poll);\n\t    },\n\t\n\t    selectionChanged: function() {\n\t      var sel = window.getSelection();\n\t      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n\t        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n\t    },\n\t\n\t    pollSelection: function() {\n\t      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n\t        var sel = window.getSelection(), cm = this.cm;\n\t        this.rememberSelection();\n\t        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n\t        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n\t        if (anchor && head) runInOp(cm, function() {\n\t          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n\t          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n\t        });\n\t      }\n\t    },\n\t\n\t    pollContent: function() {\n\t      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n\t      var from = sel.from(), to = sel.to();\n\t      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\t\n\t      var fromIndex;\n\t      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n\t        var fromLine = lineNo(display.view[0].line);\n\t        var fromNode = display.view[0].node;\n\t      } else {\n\t        var fromLine = lineNo(display.view[fromIndex].line);\n\t        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n\t      }\n\t      var toIndex = findViewIndex(cm, to.line);\n\t      if (toIndex == display.view.length - 1) {\n\t        var toLine = display.viewTo - 1;\n\t        var toNode = display.lineDiv.lastChild;\n\t      } else {\n\t        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n\t        var toNode = display.view[toIndex + 1].node.previousSibling;\n\t      }\n\t\n\t      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n\t      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n\t      while (newText.length > 1 && oldText.length > 1) {\n\t        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n\t        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n\t        else break;\n\t      }\n\t\n\t      var cutFront = 0, cutEnd = 0;\n\t      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n\t      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n\t        ++cutFront;\n\t      var newBot = lst(newText), oldBot = lst(oldText);\n\t      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n\t                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n\t      while (cutEnd < maxCutEnd &&\n\t             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n\t        ++cutEnd;\n\t\n\t      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n\t      newText[0] = newText[0].slice(cutFront);\n\t\n\t      var chFrom = Pos(fromLine, cutFront);\n\t      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n\t      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n\t        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n\t        return true;\n\t      }\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    reset: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    forceCompositionEnd: function() {\n\t      if (!this.composing || this.composing.handled) return;\n\t      this.applyComposition(this.composing);\n\t      this.composing.handled = true;\n\t      this.div.blur();\n\t      this.div.focus();\n\t    },\n\t    applyComposition: function(composing) {\n\t      if (isReadOnly(this.cm))\n\t        operation(this.cm, regChange)(this.cm)\n\t      else if (composing.data && composing.data != composing.startData)\n\t        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n\t    },\n\t\n\t    setUneditable: function(node) {\n\t      node.contentEditable = \"false\"\n\t    },\n\t\n\t    onKeyPress: function(e) {\n\t      e.preventDefault();\n\t      if (!isReadOnly(this.cm))\n\t        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      this.div.contentEditable = String(val != \"nocursor\")\n\t    },\n\t\n\t    onContextMenu: nothing,\n\t    resetPosition: nothing,\n\t\n\t    needsContentAttribute: true\n\t  }, ContentEditableInput.prototype);\n\t\n\t  function posToDOM(cm, pos) {\n\t    var view = findViewForLine(cm, pos.line);\n\t    if (!view || view.hidden) return null;\n\t    var line = getLine(cm.doc, pos.line);\n\t    var info = mapFromLineView(view, line, pos.line);\n\t\n\t    var order = getOrder(line), side = \"left\";\n\t    if (order) {\n\t      var partPos = getBidiPartAt(order, pos.ch);\n\t      side = partPos % 2 ? \"right\" : \"left\";\n\t    }\n\t    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n\t    result.offset = result.collapse == \"right\" ? result.end : result.start;\n\t    return result;\n\t  }\n\t\n\t  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\t\n\t  function domToPos(cm, node, offset) {\n\t    var lineNode;\n\t    if (node == cm.display.lineDiv) {\n\t      lineNode = cm.display.lineDiv.childNodes[offset];\n\t      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n\t      node = null; offset = 0;\n\t    } else {\n\t      for (lineNode = node;; lineNode = lineNode.parentNode) {\n\t        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n\t        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n\t      }\n\t    }\n\t    for (var i = 0; i < cm.display.view.length; i++) {\n\t      var lineView = cm.display.view[i];\n\t      if (lineView.node == lineNode)\n\t        return locateNodeInLineView(lineView, node, offset);\n\t    }\n\t  }\n\t\n\t  function locateNodeInLineView(lineView, node, offset) {\n\t    var wrapper = lineView.text.firstChild, bad = false;\n\t    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n\t    if (node == wrapper) {\n\t      bad = true;\n\t      node = wrapper.childNodes[offset];\n\t      offset = 0;\n\t      if (!node) {\n\t        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n\t        return badPos(Pos(lineNo(line), line.text.length), bad);\n\t      }\n\t    }\n\t\n\t    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n\t    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n\t      textNode = node.firstChild;\n\t      if (offset) offset = textNode.nodeValue.length;\n\t    }\n\t    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n\t    var measure = lineView.measure, maps = measure.maps;\n\t\n\t    function find(textNode, topNode, offset) {\n\t      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n\t        var map = i < 0 ? measure.map : maps[i];\n\t        for (var j = 0; j < map.length; j += 3) {\n\t          var curNode = map[j + 2];\n\t          if (curNode == textNode || curNode == topNode) {\n\t            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n\t            var ch = map[j] + offset;\n\t            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n\t            return Pos(line, ch);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    var found = find(textNode, topNode, offset);\n\t    if (found) return badPos(found, bad);\n\t\n\t    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n\t    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n\t      found = find(after, after.firstChild, 0);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch - dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n\t      found = find(before, before.firstChild, -1);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch + dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t  }\n\t\n\t  function domTextBetween(cm, from, to, fromLine, toLine) {\n\t    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n\t    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n\t    function walk(node) {\n\t      if (node.nodeType == 1) {\n\t        var cmText = node.getAttribute(\"cm-text\");\n\t        if (cmText != null) {\n\t          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n\t          text += cmText;\n\t          return;\n\t        }\n\t        var markerID = node.getAttribute(\"cm-marker\"), range;\n\t        if (markerID) {\n\t          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n\t          if (found.length && (range = found[0].find()))\n\t            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n\t          return;\n\t        }\n\t        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n\t        for (var i = 0; i < node.childNodes.length; i++)\n\t          walk(node.childNodes[i]);\n\t        if (/^(pre|div|p)$/i.test(node.nodeName))\n\t          closing = true;\n\t      } else if (node.nodeType == 3) {\n\t        var val = node.nodeValue;\n\t        if (!val) return;\n\t        if (closing) {\n\t          text += lineSep;\n\t          closing = false;\n\t        }\n\t        text += val;\n\t      }\n\t    }\n\t    for (;;) {\n\t      walk(from);\n\t      if (from == to) break;\n\t      from = from.nextSibling;\n\t    }\n\t    return text;\n\t  }\n\t\n\t  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\t\n\t  // SELECTION / CURSOR\n\t\n\t  // Selection objects are immutable. A new one is created every time\n\t  // the selection changes. A selection is one or more non-overlapping\n\t  // (and non-touching) ranges, sorted, and an integer that indicates\n\t  // which one is the primary selection (the one that's scrolled into\n\t  // view, that getCursor returns, etc).\n\t  function Selection(ranges, primIndex) {\n\t    this.ranges = ranges;\n\t    this.primIndex = primIndex;\n\t  }\n\t\n\t  Selection.prototype = {\n\t    primary: function() { return this.ranges[this.primIndex]; },\n\t    equals: function(other) {\n\t      if (other == this) return true;\n\t      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var here = this.ranges[i], there = other.ranges[i];\n\t        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n\t      }\n\t      return true;\n\t    },\n\t    deepCopy: function() {\n\t      for (var out = [], i = 0; i < this.ranges.length; i++)\n\t        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n\t      return new Selection(out, this.primIndex);\n\t    },\n\t    somethingSelected: function() {\n\t      for (var i = 0; i < this.ranges.length; i++)\n\t        if (!this.ranges[i].empty()) return true;\n\t      return false;\n\t    },\n\t    contains: function(pos, end) {\n\t      if (!end) end = pos;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var range = this.ranges[i];\n\t        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n\t          return i;\n\t      }\n\t      return -1;\n\t    }\n\t  };\n\t\n\t  function Range(anchor, head) {\n\t    this.anchor = anchor; this.head = head;\n\t  }\n\t\n\t  Range.prototype = {\n\t    from: function() { return minPos(this.anchor, this.head); },\n\t    to: function() { return maxPos(this.anchor, this.head); },\n\t    empty: function() {\n\t      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n\t    }\n\t  };\n\t\n\t  // Take an unsorted, potentially overlapping set of ranges, and\n\t  // build a selection out of it. 'Consumes' ranges array (modifying\n\t  // it).\n\t  function normalizeSelection(ranges, primIndex) {\n\t    var prim = ranges[primIndex];\n\t    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n\t    primIndex = indexOf(ranges, prim);\n\t    for (var i = 1; i < ranges.length; i++) {\n\t      var cur = ranges[i], prev = ranges[i - 1];\n\t      if (cmp(prev.to(), cur.from()) >= 0) {\n\t        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n\t        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n\t        if (i <= primIndex) --primIndex;\n\t        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n\t      }\n\t    }\n\t    return new Selection(ranges, primIndex);\n\t  }\n\t\n\t  function simpleSelection(anchor, head) {\n\t    return new Selection([new Range(anchor, head || anchor)], 0);\n\t  }\n\t\n\t  // Most of the external API clips given positions to make sure they\n\t  // actually exist within the document.\n\t  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n\t  function clipPos(doc, pos) {\n\t    if (pos.line < doc.first) return Pos(doc.first, 0);\n\t    var last = doc.first + doc.size - 1;\n\t    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n\t    return clipToLen(pos, getLine(doc, pos.line).text.length);\n\t  }\n\t  function clipToLen(pos, linelen) {\n\t    var ch = pos.ch;\n\t    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n\t    else if (ch < 0) return Pos(pos.line, 0);\n\t    else return pos;\n\t  }\n\t  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\t  function clipPosArray(doc, array) {\n\t    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n\t    return out;\n\t  }\n\t\n\t  // SELECTION UPDATES\n\t\n\t  // The 'scroll' parameter given to many of these indicated whether\n\t  // the new cursor position should be scrolled into view after\n\t  // modifying the selection.\n\t\n\t  // If shift is held or the extend flag is set, extends a range to\n\t  // include a given position (and optionally a second position).\n\t  // Otherwise, simply returns the range between the given positions.\n\t  // Used for cursor motion and such.\n\t  function extendRange(doc, range, head, other) {\n\t    if (doc.cm && doc.cm.display.shift || doc.extend) {\n\t      var anchor = range.anchor;\n\t      if (other) {\n\t        var posBefore = cmp(head, anchor) < 0;\n\t        if (posBefore != (cmp(other, anchor) < 0)) {\n\t          anchor = head;\n\t          head = other;\n\t        } else if (posBefore != (cmp(head, other) < 0)) {\n\t          head = other;\n\t        }\n\t      }\n\t      return new Range(anchor, head);\n\t    } else {\n\t      return new Range(other || head, head);\n\t    }\n\t  }\n\t\n\t  // Extend the primary selection range, discard the rest.\n\t  function extendSelection(doc, head, other, options) {\n\t    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n\t  }\n\t\n\t  // Extend all selections (pos is an array of selections with length\n\t  // equal the number of selections)\n\t  function extendSelections(doc, heads, options) {\n\t    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n\t      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n\t    var newSel = normalizeSelection(out, doc.sel.primIndex);\n\t    setSelection(doc, newSel, options);\n\t  }\n\t\n\t  // Updates a single range in the selection.\n\t  function replaceOneSelection(doc, i, range, options) {\n\t    var ranges = doc.sel.ranges.slice(0);\n\t    ranges[i] = range;\n\t    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n\t  }\n\t\n\t  // Reset the selection to a single range.\n\t  function setSimpleSelection(doc, anchor, head, options) {\n\t    setSelection(doc, simpleSelection(anchor, head), options);\n\t  }\n\t\n\t  // Give beforeSelectionChange handlers a change to influence a\n\t  // selection update.\n\t  function filterSelectionChange(doc, sel) {\n\t    var obj = {\n\t      ranges: sel.ranges,\n\t      update: function(ranges) {\n\t        this.ranges = [];\n\t        for (var i = 0; i < ranges.length; i++)\n\t          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n\t                                     clipPos(doc, ranges[i].head));\n\t      }\n\t    };\n\t    signal(doc, \"beforeSelectionChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n\t    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n\t    else return sel;\n\t  }\n\t\n\t  function setSelectionReplaceHistory(doc, sel, options) {\n\t    var done = doc.history.done, last = lst(done);\n\t    if (last && last.ranges) {\n\t      done[done.length - 1] = sel;\n\t      setSelectionNoUndo(doc, sel, options);\n\t    } else {\n\t      setSelection(doc, sel, options);\n\t    }\n\t  }\n\t\n\t  // Set a new selection.\n\t  function setSelection(doc, sel, options) {\n\t    setSelectionNoUndo(doc, sel, options);\n\t    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n\t  }\n\t\n\t  function setSelectionNoUndo(doc, sel, options) {\n\t    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n\t      sel = filterSelectionChange(doc, sel);\n\t\n\t    var bias = options && options.bias ||\n\t      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\t\n\t    if (!(options && options.scroll === false) && doc.cm)\n\t      ensureCursorVisible(doc.cm);\n\t  }\n\t\n\t  function setSelectionInner(doc, sel) {\n\t    if (sel.equals(doc.sel)) return;\n\t\n\t    doc.sel = sel;\n\t\n\t    if (doc.cm) {\n\t      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n\t      signalCursorActivity(doc.cm);\n\t    }\n\t    signalLater(doc, \"cursorActivity\", doc);\n\t  }\n\t\n\t  // Verify that the selection does not partially select any atomic\n\t  // marked ranges.\n\t  function reCheckSelection(doc) {\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n\t  }\n\t\n\t  // Return a selection that does not partially select any atomic\n\t  // ranges.\n\t  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n\t    var out;\n\t    for (var i = 0; i < sel.ranges.length; i++) {\n\t      var range = sel.ranges[i];\n\t      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);\n\t      var newHead = skipAtomic(doc, range.head, bias, mayClear);\n\t      if (out || newAnchor != range.anchor || newHead != range.head) {\n\t        if (!out) out = sel.ranges.slice(0, i);\n\t        out[i] = new Range(newAnchor, newHead);\n\t      }\n\t    }\n\t    return out ? normalizeSelection(out, sel.primIndex) : sel;\n\t  }\n\t\n\t  // Ensure a given position is not inside an atomic range.\n\t  function skipAtomic(doc, pos, bias, mayClear) {\n\t    var flipped = false, curPos = pos;\n\t    var dir = bias || 1;\n\t    doc.cantEdit = false;\n\t    search: for (;;) {\n\t      var line = getLine(doc, curPos.line);\n\t      if (line.markedSpans) {\n\t        for (var i = 0; i < line.markedSpans.length; ++i) {\n\t          var sp = line.markedSpans[i], m = sp.marker;\n\t          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n\t              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n\t            if (mayClear) {\n\t              signal(m, \"beforeCursorEnter\");\n\t              if (m.explicitlyCleared) {\n\t                if (!line.markedSpans) break;\n\t                else {--i; continue;}\n\t              }\n\t            }\n\t            if (!m.atomic) continue;\n\t            var newPos = m.find(dir < 0 ? -1 : 1);\n\t            if (cmp(newPos, curPos) == 0) {\n\t              newPos.ch += dir;\n\t              if (newPos.ch < 0) {\n\t                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n\t                else newPos = null;\n\t              } else if (newPos.ch > line.text.length) {\n\t                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n\t                else newPos = null;\n\t              }\n\t              if (!newPos) {\n\t                if (flipped) {\n\t                  // Driven in a corner -- no valid cursor position found at all\n\t                  // -- try again *with* clearing, if we didn't already\n\t                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n\t                  // Otherwise, turn off editing until further notice, and return the start of the doc\n\t                  doc.cantEdit = true;\n\t                  return Pos(doc.first, 0);\n\t                }\n\t                flipped = true; newPos = pos; dir = -dir;\n\t              }\n\t            }\n\t            curPos = newPos;\n\t            continue search;\n\t          }\n\t        }\n\t      }\n\t      return curPos;\n\t    }\n\t  }\n\t\n\t  // SELECTION DRAWING\n\t\n\t  function updateSelection(cm) {\n\t    cm.display.input.showSelection(cm.display.input.prepareSelection());\n\t  }\n\t\n\t  function prepareSelection(cm, primary) {\n\t    var doc = cm.doc, result = {};\n\t    var curFragment = result.cursors = document.createDocumentFragment();\n\t    var selFragment = result.selection = document.createDocumentFragment();\n\t\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      if (primary === false && i == doc.sel.primIndex) continue;\n\t      var range = doc.sel.ranges[i];\n\t      var collapsed = range.empty();\n\t      if (collapsed || cm.options.showCursorWhenSelecting)\n\t        drawSelectionCursor(cm, range.head, curFragment);\n\t      if (!collapsed)\n\t        drawSelectionRange(cm, range, selFragment);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  // Draws a cursor for the given range\n\t  function drawSelectionCursor(cm, head, output) {\n\t    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\t\n\t    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n\t    cursor.style.left = pos.left + \"px\";\n\t    cursor.style.top = pos.top + \"px\";\n\t    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\t\n\t    if (pos.other) {\n\t      // Secondary cursor, shown when on a 'jump' in bi-directional text\n\t      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n\t      otherCursor.style.display = \"\";\n\t      otherCursor.style.left = pos.other.left + \"px\";\n\t      otherCursor.style.top = pos.other.top + \"px\";\n\t      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n\t    }\n\t  }\n\t\n\t  // Draws the given range as a highlighted selection\n\t  function drawSelectionRange(cm, range, output) {\n\t    var display = cm.display, doc = cm.doc;\n\t    var fragment = document.createDocumentFragment();\n\t    var padding = paddingH(cm.display), leftSide = padding.left;\n\t    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\t\n\t    function add(left, top, width, bottom) {\n\t      if (top < 0) top = 0;\n\t      top = Math.round(top);\n\t      bottom = Math.round(bottom);\n\t      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n\t                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n\t                               \"px; height: \" + (bottom - top) + \"px\"));\n\t    }\n\t\n\t    function drawForLine(line, fromArg, toArg) {\n\t      var lineObj = getLine(doc, line);\n\t      var lineLen = lineObj.text.length;\n\t      var start, end;\n\t      function coords(ch, bias) {\n\t        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n\t      }\n\t\n\t      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n\t        var leftPos = coords(from, \"left\"), rightPos, left, right;\n\t        if (from == to) {\n\t          rightPos = leftPos;\n\t          left = right = leftPos.left;\n\t        } else {\n\t          rightPos = coords(to - 1, \"right\");\n\t          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n\t          left = leftPos.left;\n\t          right = rightPos.right;\n\t        }\n\t        if (fromArg == null && from == 0) left = leftSide;\n\t        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n\t          add(left, leftPos.top, null, leftPos.bottom);\n\t          left = leftSide;\n\t          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n\t        }\n\t        if (toArg == null && to == lineLen) right = rightSide;\n\t        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n\t          start = leftPos;\n\t        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n\t          end = rightPos;\n\t        if (left < leftSide + 1) left = leftSide;\n\t        add(left, rightPos.top, right - left, rightPos.bottom);\n\t      });\n\t      return {start: start, end: end};\n\t    }\n\t\n\t    var sFrom = range.from(), sTo = range.to();\n\t    if (sFrom.line == sTo.line) {\n\t      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n\t    } else {\n\t      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n\t      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n\t      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n\t      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n\t      if (singleVLine) {\n\t        if (leftEnd.top < rightStart.top - 2) {\n\t          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n\t          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n\t        } else {\n\t          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n\t        }\n\t      }\n\t      if (leftEnd.bottom < rightStart.top)\n\t        add(leftSide, leftEnd.bottom, null, rightStart.top);\n\t    }\n\t\n\t    output.appendChild(fragment);\n\t  }\n\t\n\t  // Cursor-blinking\n\t  function restartBlink(cm) {\n\t    if (!cm.state.focused) return;\n\t    var display = cm.display;\n\t    clearInterval(display.blinker);\n\t    var on = true;\n\t    display.cursorDiv.style.visibility = \"\";\n\t    if (cm.options.cursorBlinkRate > 0)\n\t      display.blinker = setInterval(function() {\n\t        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n\t      }, cm.options.cursorBlinkRate);\n\t    else if (cm.options.cursorBlinkRate < 0)\n\t      display.cursorDiv.style.visibility = \"hidden\";\n\t  }\n\t\n\t  // HIGHLIGHT WORKER\n\t\n\t  function startWorker(cm, time) {\n\t    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n\t      cm.state.highlight.set(time, bind(highlightWorker, cm));\n\t  }\n\t\n\t  function highlightWorker(cm) {\n\t    var doc = cm.doc;\n\t    if (doc.frontier < doc.first) doc.frontier = doc.first;\n\t    if (doc.frontier >= cm.display.viewTo) return;\n\t    var end = +new Date + cm.options.workTime;\n\t    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n\t    var changedLines = [];\n\t\n\t    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n\t      if (doc.frontier >= cm.display.viewFrom) { // Visible\n\t        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n\t        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n\t        line.styles = highlighted.styles;\n\t        var oldCls = line.styleClasses, newCls = highlighted.classes;\n\t        if (newCls) line.styleClasses = newCls;\n\t        else if (oldCls) line.styleClasses = null;\n\t        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n\t          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n\t        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n\t        if (ischange) changedLines.push(doc.frontier);\n\t        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n\t      } else {\n\t        if (line.text.length <= cm.options.maxHighlightLength)\n\t          processLine(cm, line.text, state);\n\t        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n\t      }\n\t      ++doc.frontier;\n\t      if (+new Date > end) {\n\t        startWorker(cm, cm.options.workDelay);\n\t        return true;\n\t      }\n\t    });\n\t    if (changedLines.length) runInOp(cm, function() {\n\t      for (var i = 0; i < changedLines.length; i++)\n\t        regLineChange(cm, changedLines[i], \"text\");\n\t    });\n\t  }\n\t\n\t  // Finds the line to start with when starting a parse. Tries to\n\t  // find a line with a stateAfter, so that it can start with a\n\t  // valid state. If that fails, it returns the line with the\n\t  // smallest indentation, which tends to need the least context to\n\t  // parse correctly.\n\t  function findStartLine(cm, n, precise) {\n\t    var minindent, minline, doc = cm.doc;\n\t    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\t    for (var search = n; search > lim; --search) {\n\t      if (search <= doc.first) return doc.first;\n\t      var line = getLine(doc, search - 1);\n\t      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n\t      var indented = countColumn(line.text, null, cm.options.tabSize);\n\t      if (minline == null || minindent > indented) {\n\t        minline = search - 1;\n\t        minindent = indented;\n\t      }\n\t    }\n\t    return minline;\n\t  }\n\t\n\t  function getStateBefore(cm, n, precise) {\n\t    var doc = cm.doc, display = cm.display;\n\t    if (!doc.mode.startState) return true;\n\t    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n\t    if (!state) state = startState(doc.mode);\n\t    else state = copyState(doc.mode, state);\n\t    doc.iter(pos, n, function(line) {\n\t      processLine(cm, line.text, state);\n\t      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n\t      line.stateAfter = save ? copyState(doc.mode, state) : null;\n\t      ++pos;\n\t    });\n\t    if (precise) doc.frontier = pos;\n\t    return state;\n\t  }\n\t\n\t  // POSITION MEASUREMENT\n\t\n\t  function paddingTop(display) {return display.lineSpace.offsetTop;}\n\t  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n\t  function paddingH(display) {\n\t    if (display.cachedPaddingH) return display.cachedPaddingH;\n\t    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n\t    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n\t    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n\t    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n\t    return data;\n\t  }\n\t\n\t  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n\t  function displayWidth(cm) {\n\t    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n\t  }\n\t  function displayHeight(cm) {\n\t    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n\t  }\n\t\n\t  // Ensure the lineView.wrapping.heights array is populated. This is\n\t  // an array of bottom offsets for the lines that make up a drawn\n\t  // line. When lineWrapping is on, there might be more than one\n\t  // height.\n\t  function ensureLineHeights(cm, lineView, rect) {\n\t    var wrapping = cm.options.lineWrapping;\n\t    var curWidth = wrapping && displayWidth(cm);\n\t    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n\t      var heights = lineView.measure.heights = [];\n\t      if (wrapping) {\n\t        lineView.measure.width = curWidth;\n\t        var rects = lineView.text.firstChild.getClientRects();\n\t        for (var i = 0; i < rects.length - 1; i++) {\n\t          var cur = rects[i], next = rects[i + 1];\n\t          if (Math.abs(cur.bottom - next.bottom) > 2)\n\t            heights.push((cur.bottom + next.top) / 2 - rect.top);\n\t        }\n\t      }\n\t      heights.push(rect.bottom - rect.top);\n\t    }\n\t  }\n\t\n\t  // Find a line map (mapping character offsets to text nodes) and a\n\t  // measurement cache for the given line number. (A line view might\n\t  // contain multiple lines when collapsed ranges are present.)\n\t  function mapFromLineView(lineView, line, lineN) {\n\t    if (lineView.line == line)\n\t      return {map: lineView.measure.map, cache: lineView.measure.cache};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineView.rest[i] == line)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineNo(lineView.rest[i]) > lineN)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n\t  }\n\t\n\t  // Render a line into the hidden node display.externalMeasured. Used\n\t  // when measurement is needed for a line that's not in the viewport.\n\t  function updateExternalMeasurement(cm, line) {\n\t    line = visualLine(line);\n\t    var lineN = lineNo(line);\n\t    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n\t    view.lineN = lineN;\n\t    var built = view.built = buildLineContent(cm, view);\n\t    view.text = built.pre;\n\t    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n\t    return view;\n\t  }\n\t\n\t  // Get a {top, bottom, left, right} box (in line-local coordinates)\n\t  // for a given character.\n\t  function measureChar(cm, line, ch, bias) {\n\t    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n\t  }\n\t\n\t  // Find a line view that corresponds to the given line number.\n\t  function findViewForLine(cm, lineN) {\n\t    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n\t      return cm.display.view[findViewIndex(cm, lineN)];\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n\t      return ext;\n\t  }\n\t\n\t  // Measurement can be split in two steps, the set-up work that\n\t  // applies to the whole line, and the measurement of the actual\n\t  // character. Functions like coordsChar, that need to do a lot of\n\t  // measurements in a row, can thus ensure that the set-up work is\n\t  // only done once.\n\t  function prepareMeasureForLine(cm, line) {\n\t    var lineN = lineNo(line);\n\t    var view = findViewForLine(cm, lineN);\n\t    if (view && !view.text) {\n\t      view = null;\n\t    } else if (view && view.changes) {\n\t      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n\t      cm.curOp.forceUpdate = true;\n\t    }\n\t    if (!view)\n\t      view = updateExternalMeasurement(cm, line);\n\t\n\t    var info = mapFromLineView(view, line, lineN);\n\t    return {\n\t      line: line, view: view, rect: null,\n\t      map: info.map, cache: info.cache, before: info.before,\n\t      hasHeights: false\n\t    };\n\t  }\n\t\n\t  // Given a prepared measurement object, measures the position of an\n\t  // actual character (or fetches it from the cache).\n\t  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n\t    if (prepared.before) ch = -1;\n\t    var key = ch + (bias || \"\"), found;\n\t    if (prepared.cache.hasOwnProperty(key)) {\n\t      found = prepared.cache[key];\n\t    } else {\n\t      if (!prepared.rect)\n\t        prepared.rect = prepared.view.text.getBoundingClientRect();\n\t      if (!prepared.hasHeights) {\n\t        ensureLineHeights(cm, prepared.view, prepared.rect);\n\t        prepared.hasHeights = true;\n\t      }\n\t      found = measureCharInner(cm, prepared, ch, bias);\n\t      if (!found.bogus) prepared.cache[key] = found;\n\t    }\n\t    return {left: found.left, right: found.right,\n\t            top: varHeight ? found.rtop : found.top,\n\t            bottom: varHeight ? found.rbottom : found.bottom};\n\t  }\n\t\n\t  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\t\n\t  function nodeAndOffsetInLineMap(map, ch, bias) {\n\t    var node, start, end, collapse;\n\t    // First, search the line map for the text node corresponding to,\n\t    // or closest to, the target character.\n\t    for (var i = 0; i < map.length; i += 3) {\n\t      var mStart = map[i], mEnd = map[i + 1];\n\t      if (ch < mStart) {\n\t        start = 0; end = 1;\n\t        collapse = \"left\";\n\t      } else if (ch < mEnd) {\n\t        start = ch - mStart;\n\t        end = start + 1;\n\t      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n\t        end = mEnd - mStart;\n\t        start = end - 1;\n\t        if (ch >= mEnd) collapse = \"right\";\n\t      }\n\t      if (start != null) {\n\t        node = map[i + 2];\n\t        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n\t          collapse = bias;\n\t        if (bias == \"left\" && start == 0)\n\t          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n\t            node = map[(i -= 3) + 2];\n\t            collapse = \"left\";\n\t          }\n\t        if (bias == \"right\" && start == mEnd - mStart)\n\t          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n\t            node = map[(i += 3) + 2];\n\t            collapse = \"right\";\n\t          }\n\t        break;\n\t      }\n\t    }\n\t    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n\t  }\n\t\n\t  function measureCharInner(cm, prepared, ch, bias) {\n\t    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n\t    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\t\n\t    var rect;\n\t    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n\t      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n\t        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n\t        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n\t        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n\t          rect = node.parentNode.getBoundingClientRect();\n\t        } else if (ie && cm.options.lineWrapping) {\n\t          var rects = range(node, start, end).getClientRects();\n\t          if (rects.length)\n\t            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t          else\n\t            rect = nullRect;\n\t        } else {\n\t          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n\t        }\n\t        if (rect.left || rect.right || start == 0) break;\n\t        end = start;\n\t        start = start - 1;\n\t        collapse = \"right\";\n\t      }\n\t      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n\t    } else { // If it is a widget, simply get the box for the whole widget.\n\t      if (start > 0) collapse = bias = \"right\";\n\t      var rects;\n\t      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n\t        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t      else\n\t        rect = node.getBoundingClientRect();\n\t    }\n\t    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n\t      var rSpan = node.parentNode.getClientRects()[0];\n\t      if (rSpan)\n\t        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n\t      else\n\t        rect = nullRect;\n\t    }\n\t\n\t    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n\t    var mid = (rtop + rbot) / 2;\n\t    var heights = prepared.view.measure.heights;\n\t    for (var i = 0; i < heights.length - 1; i++)\n\t      if (mid < heights[i]) break;\n\t    var top = i ? heights[i - 1] : 0, bot = heights[i];\n\t    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n\t                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n\t                  top: top, bottom: bot};\n\t    if (!rect.left && !rect.right) result.bogus = true;\n\t    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\t\n\t    return result;\n\t  }\n\t\n\t  // Work around problem with bounding client rects on ranges being\n\t  // returned incorrectly when zoomed on IE10 and below.\n\t  function maybeUpdateRectForZooming(measure, rect) {\n\t    if (!window.screen || screen.logicalXDPI == null ||\n\t        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n\t      return rect;\n\t    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n\t    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n\t    return {left: rect.left * scaleX, right: rect.right * scaleX,\n\t            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n\t  }\n\t\n\t  function clearLineMeasurementCacheFor(lineView) {\n\t    if (lineView.measure) {\n\t      lineView.measure.cache = {};\n\t      lineView.measure.heights = null;\n\t      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t        lineView.measure.caches[i] = {};\n\t    }\n\t  }\n\t\n\t  function clearLineMeasurementCache(cm) {\n\t    cm.display.externalMeasure = null;\n\t    removeChildren(cm.display.lineMeasure);\n\t    for (var i = 0; i < cm.display.view.length; i++)\n\t      clearLineMeasurementCacheFor(cm.display.view[i]);\n\t  }\n\t\n\t  function clearCaches(cm) {\n\t    clearLineMeasurementCache(cm);\n\t    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\t    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n\t    cm.display.lineNumChars = null;\n\t  }\n\t\n\t  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n\t  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\t\n\t  // Converts a {top, bottom, left, right} box from line-local\n\t  // coordinates into another coordinate system. Context may be one of\n\t  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n\t  // or \"page\".\n\t  function intoCoordSystem(cm, lineObj, rect, context) {\n\t    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n\t      var size = widgetHeight(lineObj.widgets[i]);\n\t      rect.top += size; rect.bottom += size;\n\t    }\n\t    if (context == \"line\") return rect;\n\t    if (!context) context = \"local\";\n\t    var yOff = heightAtLine(lineObj);\n\t    if (context == \"local\") yOff += paddingTop(cm.display);\n\t    else yOff -= cm.display.viewOffset;\n\t    if (context == \"page\" || context == \"window\") {\n\t      var lOff = cm.display.lineSpace.getBoundingClientRect();\n\t      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n\t      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n\t      rect.left += xOff; rect.right += xOff;\n\t    }\n\t    rect.top += yOff; rect.bottom += yOff;\n\t    return rect;\n\t  }\n\t\n\t  // Coverts a box from \"div\" coords to another coordinate system.\n\t  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n\t  function fromCoordSystem(cm, coords, context) {\n\t    if (context == \"div\") return coords;\n\t    var left = coords.left, top = coords.top;\n\t    // First move into \"page\" coordinate system\n\t    if (context == \"page\") {\n\t      left -= pageScrollX();\n\t      top -= pageScrollY();\n\t    } else if (context == \"local\" || !context) {\n\t      var localBox = cm.display.sizer.getBoundingClientRect();\n\t      left += localBox.left;\n\t      top += localBox.top;\n\t    }\n\t\n\t    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n\t    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n\t  }\n\t\n\t  function charCoords(cm, pos, context, lineObj, bias) {\n\t    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n\t    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n\t  }\n\t\n\t  // Returns a box for a given cursor position, which may have an\n\t  // 'other' property containing the position of the secondary cursor\n\t  // on a bidi boundary.\n\t  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n\t    lineObj = lineObj || getLine(cm.doc, pos.line);\n\t    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t    function get(ch, right) {\n\t      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n\t      if (right) m.left = m.right; else m.right = m.left;\n\t      return intoCoordSystem(cm, lineObj, m, context);\n\t    }\n\t    function getBidi(ch, partPos) {\n\t      var part = order[partPos], right = part.level % 2;\n\t      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n\t        part = order[--partPos];\n\t        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n\t        right = true;\n\t      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n\t        part = order[++partPos];\n\t        ch = bidiLeft(part) - part.level % 2;\n\t        right = false;\n\t      }\n\t      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n\t      return get(ch, right);\n\t    }\n\t    var order = getOrder(lineObj), ch = pos.ch;\n\t    if (!order) return get(ch);\n\t    var partPos = getBidiPartAt(order, ch);\n\t    var val = getBidi(ch, partPos);\n\t    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n\t    return val;\n\t  }\n\t\n\t  // Used to cheaply estimate the coordinates for a position. Used for\n\t  // intermediate scroll updates.\n\t  function estimateCoords(cm, pos) {\n\t    var left = 0, pos = clipPos(cm.doc, pos);\n\t    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n\t    var lineObj = getLine(cm.doc, pos.line);\n\t    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n\t    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n\t  }\n\t\n\t  // Positions returned by coordsChar contain some extra information.\n\t  // xRel is the relative x position of the input coordinates compared\n\t  // to the found position (so xRel > 0 means the coordinates are to\n\t  // the right of the character position, for example). When outside\n\t  // is true, that means the coordinates lie outside the line's\n\t  // vertical range.\n\t  function PosWithInfo(line, ch, outside, xRel) {\n\t    var pos = Pos(line, ch);\n\t    pos.xRel = xRel;\n\t    if (outside) pos.outside = true;\n\t    return pos;\n\t  }\n\t\n\t  // Compute the character position closest to the given coordinates.\n\t  // Input must be lineSpace-local (\"div\" coordinate system).\n\t  function coordsChar(cm, x, y) {\n\t    var doc = cm.doc;\n\t    y += cm.display.viewOffset;\n\t    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n\t    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n\t    if (lineN > last)\n\t      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n\t    if (x < 0) x = 0;\n\t\n\t    var lineObj = getLine(doc, lineN);\n\t    for (;;) {\n\t      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n\t      var merged = collapsedSpanAtEnd(lineObj);\n\t      var mergedPos = merged && merged.find(0, true);\n\t      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n\t        lineN = lineNo(lineObj = mergedPos.to.line);\n\t      else\n\t        return found;\n\t    }\n\t  }\n\t\n\t  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n\t    var innerOff = y - heightAtLine(lineObj);\n\t    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n\t    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t\n\t    function getX(ch) {\n\t      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n\t      wrongLine = true;\n\t      if (innerOff > sp.bottom) return sp.left - adjust;\n\t      else if (innerOff < sp.top) return sp.left + adjust;\n\t      else wrongLine = false;\n\t      return sp.left;\n\t    }\n\t\n\t    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n\t    var from = lineLeft(lineObj), to = lineRight(lineObj);\n\t    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\t\n\t    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n\t    // Do a binary search between these bounds.\n\t    for (;;) {\n\t      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n\t        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n\t        var xDiff = x - (ch == from ? fromX : toX);\n\t        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n\t        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n\t                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n\t        return pos;\n\t      }\n\t      var step = Math.ceil(dist / 2), middle = from + step;\n\t      if (bidi) {\n\t        middle = from;\n\t        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n\t      }\n\t      var middleX = getX(middle);\n\t      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n\t      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n\t    }\n\t  }\n\t\n\t  var measureText;\n\t  // Compute the default text height.\n\t  function textHeight(display) {\n\t    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n\t    if (measureText == null) {\n\t      measureText = elt(\"pre\");\n\t      // Measure a bunch of lines, for browsers that compute\n\t      // fractional heights.\n\t      for (var i = 0; i < 49; ++i) {\n\t        measureText.appendChild(document.createTextNode(\"x\"));\n\t        measureText.appendChild(elt(\"br\"));\n\t      }\n\t      measureText.appendChild(document.createTextNode(\"x\"));\n\t    }\n\t    removeChildrenAndAdd(display.measure, measureText);\n\t    var height = measureText.offsetHeight / 50;\n\t    if (height > 3) display.cachedTextHeight = height;\n\t    removeChildren(display.measure);\n\t    return height || 1;\n\t  }\n\t\n\t  // Compute the default character width.\n\t  function charWidth(display) {\n\t    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n\t    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n\t    var pre = elt(\"pre\", [anchor]);\n\t    removeChildrenAndAdd(display.measure, pre);\n\t    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n\t    if (width > 2) display.cachedCharWidth = width;\n\t    return width || 10;\n\t  }\n\t\n\t  // OPERATIONS\n\t\n\t  // Operations are used to wrap a series of changes to the editor\n\t  // state in such a way that each change won't have to update the\n\t  // cursor and display (which would be awkward, slow, and\n\t  // error-prone). Instead, display updates are batched and then all\n\t  // combined and executed at once.\n\t\n\t  var operationGroup = null;\n\t\n\t  var nextOpId = 0;\n\t  // Start a new operation.\n\t  function startOperation(cm) {\n\t    cm.curOp = {\n\t      cm: cm,\n\t      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n\t      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n\t      forceUpdate: false,      // Used to force a redraw\n\t      updateInput: null,       // Whether to reset the input textarea\n\t      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n\t      changeObjs: null,        // Accumulated changes, for firing change events\n\t      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n\t      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n\t      selectionChanged: false, // Whether the selection needs to be redrawn\n\t      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n\t      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n\t      scrollToPos: null,       // Used to scroll to a specific position\n\t      focus: false,\n\t      id: ++nextOpId           // Unique ID\n\t    };\n\t    if (operationGroup) {\n\t      operationGroup.ops.push(cm.curOp);\n\t    } else {\n\t      cm.curOp.ownsGroup = operationGroup = {\n\t        ops: [cm.curOp],\n\t        delayedCallbacks: []\n\t      };\n\t    }\n\t  }\n\t\n\t  function fireCallbacksForOps(group) {\n\t    // Calls delayed callbacks and cursorActivity handlers until no\n\t    // new ones appear\n\t    var callbacks = group.delayedCallbacks, i = 0;\n\t    do {\n\t      for (; i < callbacks.length; i++)\n\t        callbacks[i].call(null);\n\t      for (var j = 0; j < group.ops.length; j++) {\n\t        var op = group.ops[j];\n\t        if (op.cursorActivityHandlers)\n\t          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n\t            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n\t      }\n\t    } while (i < callbacks.length);\n\t  }\n\t\n\t  // Finish an operation, updating the display and signalling delayed events\n\t  function endOperation(cm) {\n\t    var op = cm.curOp, group = op.ownsGroup;\n\t    if (!group) return;\n\t\n\t    try { fireCallbacksForOps(group); }\n\t    finally {\n\t      operationGroup = null;\n\t      for (var i = 0; i < group.ops.length; i++)\n\t        group.ops[i].cm.curOp = null;\n\t      endOperations(group);\n\t    }\n\t  }\n\t\n\t  // The DOM updates done when an operation finishes are batched so\n\t  // that the minimum number of relayouts are required.\n\t  function endOperations(group) {\n\t    var ops = group.ops;\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_finish(ops[i]);\n\t  }\n\t\n\t  function endOperation_R1(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    maybeClipScrollbars(cm);\n\t    if (op.updateMaxLine) findMaxLine(cm);\n\t\n\t    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n\t      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n\t                         op.scrollToPos.to.line >= display.viewTo) ||\n\t      display.maxLineChanged && cm.options.lineWrapping;\n\t    op.update = op.mustUpdate &&\n\t      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n\t  }\n\t\n\t  function endOperation_W1(op) {\n\t    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n\t  }\n\t\n\t  function endOperation_R2(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\t\n\t    op.barMeasure = measureForScrollbars(cm);\n\t\n\t    // If the max line changed since it was last measured, measure it,\n\t    // and ensure the document's width matches it.\n\t    // updateDisplay_W2 will use these properties to do the actual resizing\n\t    if (display.maxLineChanged && !cm.options.lineWrapping) {\n\t      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n\t      cm.display.sizerWidth = op.adjustWidthTo;\n\t      op.barMeasure.scrollWidth =\n\t        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n\t      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n\t    }\n\t\n\t    if (op.updatedDisplay || op.selectionChanged)\n\t      op.preparedSelection = display.input.prepareSelection();\n\t  }\n\t\n\t  function endOperation_W2(op) {\n\t    var cm = op.cm;\n\t\n\t    if (op.adjustWidthTo != null) {\n\t      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n\t      if (op.maxScrollLeft < cm.doc.scrollLeft)\n\t        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n\t      cm.display.maxLineChanged = false;\n\t    }\n\t\n\t    if (op.preparedSelection)\n\t      cm.display.input.showSelection(op.preparedSelection);\n\t    if (op.updatedDisplay)\n\t      setDocumentHeight(cm, op.barMeasure);\n\t    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n\t      updateScrollbars(cm, op.barMeasure);\n\t\n\t    if (op.selectionChanged) restartBlink(cm);\n\t\n\t    if (cm.state.focused && op.updateInput)\n\t      cm.display.input.reset(op.typing);\n\t    if (op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus()))\n\t      ensureFocus(op.cm);\n\t  }\n\t\n\t  function endOperation_finish(op) {\n\t    var cm = op.cm, display = cm.display, doc = cm.doc;\n\t\n\t    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\t\n\t    // Abort mouse wheel delta measurement, when scrolling explicitly\n\t    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n\t      display.wheelStartX = display.wheelStartY = null;\n\t\n\t    // Propagate the scroll position to the actual DOM scroller\n\t    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n\t      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n\t      display.scrollbars.setScrollTop(doc.scrollTop);\n\t      display.scroller.scrollTop = doc.scrollTop;\n\t    }\n\t    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n\t      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));\n\t      display.scrollbars.setScrollLeft(doc.scrollLeft);\n\t      display.scroller.scrollLeft = doc.scrollLeft;\n\t      alignHorizontally(cm);\n\t    }\n\t    // If we need to scroll a specific position into view, do so.\n\t    if (op.scrollToPos) {\n\t      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n\t                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n\t      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n\t    }\n\t\n\t    // Fire events for markers that are hidden/unidden by editing or\n\t    // undoing\n\t    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n\t    if (hidden) for (var i = 0; i < hidden.length; ++i)\n\t      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n\t    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n\t      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\t\n\t    if (display.wrapper.offsetHeight)\n\t      doc.scrollTop = cm.display.scroller.scrollTop;\n\t\n\t    // Fire change events, and delayed event handlers\n\t    if (op.changeObjs)\n\t      signal(cm, \"changes\", cm, op.changeObjs);\n\t    if (op.update)\n\t      op.update.finish();\n\t  }\n\t\n\t  // Run the given function in an operation\n\t  function runInOp(cm, f) {\n\t    if (cm.curOp) return f();\n\t    startOperation(cm);\n\t    try { return f(); }\n\t    finally { endOperation(cm); }\n\t  }\n\t  // Wraps a function in an operation. Returns the wrapped function.\n\t  function operation(cm, f) {\n\t    return function() {\n\t      if (cm.curOp) return f.apply(cm, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(cm, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t  // Used to add methods to editor and doc instances, wrapping them in\n\t  // operations.\n\t  function methodOp(f) {\n\t    return function() {\n\t      if (this.curOp) return f.apply(this, arguments);\n\t      startOperation(this);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(this); }\n\t    };\n\t  }\n\t  function docMethodOp(f) {\n\t    return function() {\n\t      var cm = this.cm;\n\t      if (!cm || cm.curOp) return f.apply(this, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t\n\t  // VIEW TRACKING\n\t\n\t  // These objects are used to represent the visible (currently drawn)\n\t  // part of the document. A LineView may correspond to multiple\n\t  // logical lines, if those are connected by collapsed ranges.\n\t  function LineView(doc, line, lineN) {\n\t    // The starting line\n\t    this.line = line;\n\t    // Continuing lines, if any\n\t    this.rest = visualLineContinued(line);\n\t    // Number of logical lines in this visual line\n\t    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n\t    this.node = this.text = null;\n\t    this.hidden = lineIsHidden(doc, line);\n\t  }\n\t\n\t  // Create a range of LineView objects for the given lines.\n\t  function buildViewArray(cm, from, to) {\n\t    var array = [], nextPos;\n\t    for (var pos = from; pos < to; pos = nextPos) {\n\t      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n\t      nextPos = pos + view.size;\n\t      array.push(view);\n\t    }\n\t    return array;\n\t  }\n\t\n\t  // Updates the display.view data structure for a given change to the\n\t  // document. From and to are in pre-change coordinates. Lendiff is\n\t  // the amount of lines added or subtracted by the change. This is\n\t  // used for changes that span multiple lines, or change the way\n\t  // lines are divided into visual lines. regLineChange (below)\n\t  // registers single-line changes.\n\t  function regChange(cm, from, to, lendiff) {\n\t    if (from == null) from = cm.doc.first;\n\t    if (to == null) to = cm.doc.first + cm.doc.size;\n\t    if (!lendiff) lendiff = 0;\n\t\n\t    var display = cm.display;\n\t    if (lendiff && to < display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n\t      display.updateLineNumbers = from;\n\t\n\t    cm.curOp.viewChanged = true;\n\t\n\t    if (from >= display.viewTo) { // Change after\n\t      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n\t        resetView(cm);\n\t    } else if (to <= display.viewFrom) { // Change before\n\t      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n\t        resetView(cm);\n\t      } else {\n\t        display.viewFrom += lendiff;\n\t        display.viewTo += lendiff;\n\t      }\n\t    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n\t      resetView(cm);\n\t    } else if (from <= display.viewFrom) { // Top overlap\n\t      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cut) {\n\t        display.view = display.view.slice(cut.index);\n\t        display.viewFrom = cut.lineN;\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else if (to >= display.viewTo) { // Bottom overlap\n\t      var cut = viewCuttingPoint(cm, from, from, -1);\n\t      if (cut) {\n\t        display.view = display.view.slice(0, cut.index);\n\t        display.viewTo = cut.lineN;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else { // Gap in the middle\n\t      var cutTop = viewCuttingPoint(cm, from, from, -1);\n\t      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cutTop && cutBot) {\n\t        display.view = display.view.slice(0, cutTop.index)\n\t          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n\t          .concat(display.view.slice(cutBot.index));\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    }\n\t\n\t    var ext = display.externalMeasured;\n\t    if (ext) {\n\t      if (to < ext.lineN)\n\t        ext.lineN += lendiff;\n\t      else if (from < ext.lineN + ext.size)\n\t        display.externalMeasured = null;\n\t    }\n\t  }\n\t\n\t  // Register a change to a single line. Type must be one of \"text\",\n\t  // \"gutter\", \"class\", \"widget\"\n\t  function regLineChange(cm, line, type) {\n\t    cm.curOp.viewChanged = true;\n\t    var display = cm.display, ext = cm.display.externalMeasured;\n\t    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n\t      display.externalMeasured = null;\n\t\n\t    if (line < display.viewFrom || line >= display.viewTo) return;\n\t    var lineView = display.view[findViewIndex(cm, line)];\n\t    if (lineView.node == null) return;\n\t    var arr = lineView.changes || (lineView.changes = []);\n\t    if (indexOf(arr, type) == -1) arr.push(type);\n\t  }\n\t\n\t  // Clear the view.\n\t  function resetView(cm) {\n\t    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n\t    cm.display.view = [];\n\t    cm.display.viewOffset = 0;\n\t  }\n\t\n\t  // Find the view element corresponding to a given line. Return null\n\t  // when the line isn't visible.\n\t  function findViewIndex(cm, n) {\n\t    if (n >= cm.display.viewTo) return null;\n\t    n -= cm.display.viewFrom;\n\t    if (n < 0) return null;\n\t    var view = cm.display.view;\n\t    for (var i = 0; i < view.length; i++) {\n\t      n -= view[i].size;\n\t      if (n < 0) return i;\n\t    }\n\t  }\n\t\n\t  function viewCuttingPoint(cm, oldN, newN, dir) {\n\t    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n\t    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n\t      return {index: index, lineN: newN};\n\t    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n\t      n += view[i].size;\n\t    if (n != oldN) {\n\t      if (dir > 0) {\n\t        if (index == view.length - 1) return null;\n\t        diff = (n + view[index].size) - oldN;\n\t        index++;\n\t      } else {\n\t        diff = n - oldN;\n\t      }\n\t      oldN += diff; newN += diff;\n\t    }\n\t    while (visualLineNo(cm.doc, newN) != newN) {\n\t      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n\t      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n\t      index += dir;\n\t    }\n\t    return {index: index, lineN: newN};\n\t  }\n\t\n\t  // Force the view to cover a given range, adding empty view element\n\t  // or clipping off existing ones as needed.\n\t  function adjustView(cm, from, to) {\n\t    var display = cm.display, view = display.view;\n\t    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n\t      display.view = buildViewArray(cm, from, to);\n\t      display.viewFrom = from;\n\t    } else {\n\t      if (display.viewFrom > from)\n\t        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n\t      else if (display.viewFrom < from)\n\t        display.view = display.view.slice(findViewIndex(cm, from));\n\t      display.viewFrom = from;\n\t      if (display.viewTo < to)\n\t        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n\t      else if (display.viewTo > to)\n\t        display.view = display.view.slice(0, findViewIndex(cm, to));\n\t    }\n\t    display.viewTo = to;\n\t  }\n\t\n\t  // Count the number of lines in the view whose DOM representation is\n\t  // out of date (or nonexistent).\n\t  function countDirtyView(cm) {\n\t    var view = cm.display.view, dirty = 0;\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n\t    }\n\t    return dirty;\n\t  }\n\t\n\t  // EVENT HANDLERS\n\t\n\t  // Attach the necessary event handlers when initializing the editor\n\t  function registerEventHandlers(cm) {\n\t    var d = cm.display;\n\t    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n\t    // Older IE's will not fire a second mousedown for a double click\n\t    if (ie && ie_version < 11)\n\t      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n\t        if (signalDOMEvent(cm, e)) return;\n\t        var pos = posFromMouse(cm, e);\n\t        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n\t        e_preventDefault(e);\n\t        var word = cm.findWordAt(pos);\n\t        extendSelection(cm.doc, word.anchor, word.head);\n\t      }));\n\t    else\n\t      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n\t    // Some browsers fire contextmenu *after* opening the menu, at\n\t    // which point we can't mess with it anymore. Context menu is\n\t    // handled in onMouseDown for these browsers.\n\t    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\t\n\t    // Used to suppress mouse event handling when a touch happens\n\t    var touchFinished, prevTouch = {end: 0};\n\t    function finishTouch() {\n\t      if (d.activeTouch) {\n\t        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n\t        prevTouch = d.activeTouch;\n\t        prevTouch.end = +new Date;\n\t      }\n\t    };\n\t    function isMouseLikeTouchEvent(e) {\n\t      if (e.touches.length != 1) return false;\n\t      var touch = e.touches[0];\n\t      return touch.radiusX <= 1 && touch.radiusY <= 1;\n\t    }\n\t    function farAway(touch, other) {\n\t      if (other.left == null) return true;\n\t      var dx = other.left - touch.left, dy = other.top - touch.top;\n\t      return dx * dx + dy * dy > 20 * 20;\n\t    }\n\t    on(d.scroller, \"touchstart\", function(e) {\n\t      if (!isMouseLikeTouchEvent(e)) {\n\t        clearTimeout(touchFinished);\n\t        var now = +new Date;\n\t        d.activeTouch = {start: now, moved: false,\n\t                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n\t        if (e.touches.length == 1) {\n\t          d.activeTouch.left = e.touches[0].pageX;\n\t          d.activeTouch.top = e.touches[0].pageY;\n\t        }\n\t      }\n\t    });\n\t    on(d.scroller, \"touchmove\", function() {\n\t      if (d.activeTouch) d.activeTouch.moved = true;\n\t    });\n\t    on(d.scroller, \"touchend\", function(e) {\n\t      var touch = d.activeTouch;\n\t      if (touch && !eventInWidget(d, e) && touch.left != null &&\n\t          !touch.moved && new Date - touch.start < 300) {\n\t        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n\t        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n\t          range = new Range(pos, pos);\n\t        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n\t          range = cm.findWordAt(pos);\n\t        else // Triple tap\n\t          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n\t        cm.setSelection(range.anchor, range.head);\n\t        cm.focus();\n\t        e_preventDefault(e);\n\t      }\n\t      finishTouch();\n\t    });\n\t    on(d.scroller, \"touchcancel\", finishTouch);\n\t\n\t    // Sync scrolling between fake scrollbars and real scrollable\n\t    // area, ensure viewport is updated when scrolling.\n\t    on(d.scroller, \"scroll\", function() {\n\t      if (d.scroller.clientHeight) {\n\t        setScrollTop(cm, d.scroller.scrollTop);\n\t        setScrollLeft(cm, d.scroller.scrollLeft, true);\n\t        signal(cm, \"scroll\", cm);\n\t      }\n\t    });\n\t\n\t    // Listen to wheel events in order to try and update the viewport on time.\n\t    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n\t    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\t\n\t    // Prevent wrapper from ever scrolling\n\t    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\t\n\t    d.dragFunctions = {\n\t      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n\t      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n\t      start: function(e){onDragStart(cm, e);},\n\t      drop: operation(cm, onDrop),\n\t      leave: function() {clearDragCursor(cm);}\n\t    };\n\t\n\t    var inp = d.input.getField();\n\t    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n\t    on(inp, \"keydown\", operation(cm, onKeyDown));\n\t    on(inp, \"keypress\", operation(cm, onKeyPress));\n\t    on(inp, \"focus\", bind(onFocus, cm));\n\t    on(inp, \"blur\", bind(onBlur, cm));\n\t  }\n\t\n\t  function dragDropChanged(cm, value, old) {\n\t    var wasOn = old && old != CodeMirror.Init;\n\t    if (!value != !wasOn) {\n\t      var funcs = cm.display.dragFunctions;\n\t      var toggle = value ? on : off;\n\t      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n\t      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n\t      toggle(cm.display.scroller, \"dragover\", funcs.over);\n\t      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n\t      toggle(cm.display.scroller, \"drop\", funcs.drop);\n\t    }\n\t  }\n\t\n\t  // Called when the window resizes\n\t  function onResize(cm) {\n\t    var d = cm.display;\n\t    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n\t      return;\n\t    // Might be a text scaling operation, clear size caches.\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t    d.scrollbarsClipped = false;\n\t    cm.setSize();\n\t  }\n\t\n\t  // MOUSE EVENTS\n\t\n\t  // Return true when the given mouse event happened in a widget\n\t  function eventInWidget(display, e) {\n\t    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n\t      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n\t          (n.parentNode == display.sizer && n != display.mover))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // Given a mouse event, find the corresponding position. If liberal\n\t  // is false, it checks whether a gutter or scrollbar was clicked,\n\t  // and returns null if it was. forRect is used by rectangular\n\t  // selections, and tries to estimate a character position even for\n\t  // coordinates beyond the right of the text.\n\t  function posFromMouse(cm, e, liberal, forRect) {\n\t    var display = cm.display;\n\t    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\t\n\t    var x, y, space = display.lineSpace.getBoundingClientRect();\n\t    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\t    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n\t    catch (e) { return null; }\n\t    var coords = coordsChar(cm, x, y), line;\n\t    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n\t      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n\t      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // A mouse down can be a single click, double click, triple click,\n\t  // start of selection drag, start of text drag, new cursor\n\t  // (ctrl-click), rectangle drag (alt-drag), or xwin\n\t  // middle-click-paste. Or it might be a click on something we should\n\t  // not interfere with, such as a scrollbar or widget.\n\t  function onMouseDown(e) {\n\t    var cm = this, display = cm.display;\n\t    if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e)) return;\n\t    display.shift = e.shiftKey;\n\t\n\t    if (eventInWidget(display, e)) {\n\t      if (!webkit) {\n\t        // Briefly turn off draggability, to allow widgets to do\n\t        // normal dragging things.\n\t        display.scroller.draggable = false;\n\t        setTimeout(function(){display.scroller.draggable = true;}, 100);\n\t      }\n\t      return;\n\t    }\n\t    if (clickInGutter(cm, e)) return;\n\t    var start = posFromMouse(cm, e);\n\t    window.focus();\n\t\n\t    switch (e_button(e)) {\n\t    case 1:\n\t      // #3261: make sure, that we're not starting a second selection\n\t      if (cm.state.selectingText)\n\t        cm.state.selectingText(e);\n\t      else if (start)\n\t        leftButtonDown(cm, e, start);\n\t      else if (e_target(e) == display.scroller)\n\t        e_preventDefault(e);\n\t      break;\n\t    case 2:\n\t      if (webkit) cm.state.lastMiddleDown = +new Date;\n\t      if (start) extendSelection(cm.doc, start);\n\t      setTimeout(function() {display.input.focus();}, 20);\n\t      e_preventDefault(e);\n\t      break;\n\t    case 3:\n\t      if (captureRightClick) onContextMenu(cm, e);\n\t      else delayBlurEvent(cm);\n\t      break;\n\t    }\n\t  }\n\t\n\t  var lastClick, lastDoubleClick;\n\t  function leftButtonDown(cm, e, start) {\n\t    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n\t    else cm.curOp.focus = activeElt();\n\t\n\t    var now = +new Date, type;\n\t    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n\t      type = \"triple\";\n\t    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n\t      type = \"double\";\n\t      lastDoubleClick = {time: now, pos: start};\n\t    } else {\n\t      type = \"single\";\n\t      lastClick = {time: now, pos: start};\n\t    }\n\t\n\t    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n\t    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&\n\t        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n\t        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n\t        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n\t      leftButtonStartDrag(cm, e, start, modifier);\n\t    else\n\t      leftButtonSelect(cm, e, start, type, modifier);\n\t  }\n\t\n\t  // Start a text drag. When it ends, see if any dragging actually\n\t  // happen, and treat as a click if it didn't.\n\t  function leftButtonStartDrag(cm, e, start, modifier) {\n\t    var display = cm.display, startTime = +new Date;\n\t    var dragEnd = operation(cm, function(e2) {\n\t      if (webkit) display.scroller.draggable = false;\n\t      cm.state.draggingText = false;\n\t      off(document, \"mouseup\", dragEnd);\n\t      off(display.scroller, \"drop\", dragEnd);\n\t      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n\t        e_preventDefault(e2);\n\t        if (!modifier && +new Date - 200 < startTime)\n\t          extendSelection(cm.doc, start);\n\t        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n\t        if (webkit || ie && ie_version == 9)\n\t          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n\t        else\n\t          display.input.focus();\n\t      }\n\t    });\n\t    // Let the drag handler handle this.\n\t    if (webkit) display.scroller.draggable = true;\n\t    cm.state.draggingText = dragEnd;\n\t    // IE's approach to draggable\n\t    if (display.scroller.dragDrop) display.scroller.dragDrop();\n\t    on(document, \"mouseup\", dragEnd);\n\t    on(display.scroller, \"drop\", dragEnd);\n\t  }\n\t\n\t  // Normal selection, as opposed to text dragging.\n\t  function leftButtonSelect(cm, e, start, type, addNew) {\n\t    var display = cm.display, doc = cm.doc;\n\t    e_preventDefault(e);\n\t\n\t    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n\t    if (addNew && !e.shiftKey) {\n\t      ourIndex = doc.sel.contains(start);\n\t      if (ourIndex > -1)\n\t        ourRange = ranges[ourIndex];\n\t      else\n\t        ourRange = new Range(start, start);\n\t    } else {\n\t      ourRange = doc.sel.primary();\n\t      ourIndex = doc.sel.primIndex;\n\t    }\n\t\n\t    if (e.altKey) {\n\t      type = \"rect\";\n\t      if (!addNew) ourRange = new Range(start, start);\n\t      start = posFromMouse(cm, e, true, true);\n\t      ourIndex = -1;\n\t    } else if (type == \"double\") {\n\t      var word = cm.findWordAt(start);\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n\t      else\n\t        ourRange = word;\n\t    } else if (type == \"triple\") {\n\t      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n\t      else\n\t        ourRange = line;\n\t    } else {\n\t      ourRange = extendRange(doc, ourRange, start);\n\t    }\n\t\n\t    if (!addNew) {\n\t      ourIndex = 0;\n\t      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n\t      startSel = doc.sel;\n\t    } else if (ourIndex == -1) {\n\t      ourIndex = ranges.length;\n\t      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n\t      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t      startSel = doc.sel;\n\t    } else {\n\t      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n\t    }\n\t\n\t    var lastPos = start;\n\t    function extendTo(pos) {\n\t      if (cmp(lastPos, pos) == 0) return;\n\t      lastPos = pos;\n\t\n\t      if (type == \"rect\") {\n\t        var ranges = [], tabSize = cm.options.tabSize;\n\t        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n\t        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n\t        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n\t        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n\t             line <= end; line++) {\n\t          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n\t          if (left == right)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n\t          else if (text.length > leftPos)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n\t        }\n\t        if (!ranges.length) ranges.push(new Range(start, start));\n\t        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n\t                     {origin: \"*mouse\", scroll: false});\n\t        cm.scrollIntoView(pos);\n\t      } else {\n\t        var oldRange = ourRange;\n\t        var anchor = oldRange.anchor, head = pos;\n\t        if (type != \"single\") {\n\t          if (type == \"double\")\n\t            var range = cm.findWordAt(pos);\n\t          else\n\t            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n\t          if (cmp(range.anchor, anchor) > 0) {\n\t            head = range.head;\n\t            anchor = minPos(oldRange.from(), range.anchor);\n\t          } else {\n\t            head = range.anchor;\n\t            anchor = maxPos(oldRange.to(), range.head);\n\t          }\n\t        }\n\t        var ranges = startSel.ranges.slice(0);\n\t        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n\t        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n\t      }\n\t    }\n\t\n\t    var editorSize = display.wrapper.getBoundingClientRect();\n\t    // Used to ensure timeout re-tries don't fire when another extend\n\t    // happened in the meantime (clearTimeout isn't reliable -- at\n\t    // least on Chrome, the timeouts still happen even when cleared,\n\t    // if the clear happens after their scheduled firing time).\n\t    var counter = 0;\n\t\n\t    function extend(e) {\n\t      var curCount = ++counter;\n\t      var cur = posFromMouse(cm, e, true, type == \"rect\");\n\t      if (!cur) return;\n\t      if (cmp(cur, lastPos) != 0) {\n\t        cm.curOp.focus = activeElt();\n\t        extendTo(cur);\n\t        var visible = visibleLines(display, doc);\n\t        if (cur.line >= visible.to || cur.line < visible.from)\n\t          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n\t      } else {\n\t        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\t        if (outside) setTimeout(operation(cm, function() {\n\t          if (counter != curCount) return;\n\t          display.scroller.scrollTop += outside;\n\t          extend(e);\n\t        }), 50);\n\t      }\n\t    }\n\t\n\t    function done(e) {\n\t      cm.state.selectingText = false;\n\t      counter = Infinity;\n\t      e_preventDefault(e);\n\t      display.input.focus();\n\t      off(document, \"mousemove\", move);\n\t      off(document, \"mouseup\", up);\n\t      doc.history.lastSelOrigin = null;\n\t    }\n\t\n\t    var move = operation(cm, function(e) {\n\t      if (!e_button(e)) done(e);\n\t      else extend(e);\n\t    });\n\t    var up = operation(cm, done);\n\t    cm.state.selectingText = up;\n\t    on(document, \"mousemove\", move);\n\t    on(document, \"mouseup\", up);\n\t  }\n\t\n\t  // Determines whether an event happened in the gutter, and fires the\n\t  // handlers for the corresponding event.\n\t  function gutterEvent(cm, e, type, prevent) {\n\t    try { var mX = e.clientX, mY = e.clientY; }\n\t    catch(e) { return false; }\n\t    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n\t    if (prevent) e_preventDefault(e);\n\t\n\t    var display = cm.display;\n\t    var lineBox = display.lineDiv.getBoundingClientRect();\n\t\n\t    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n\t    mY -= lineBox.top - display.viewOffset;\n\t\n\t    for (var i = 0; i < cm.options.gutters.length; ++i) {\n\t      var g = display.gutters.childNodes[i];\n\t      if (g && g.getBoundingClientRect().right >= mX) {\n\t        var line = lineAtHeight(cm.doc, mY);\n\t        var gutter = cm.options.gutters[i];\n\t        signal(cm, type, cm, line, gutter, e);\n\t        return e_defaultPrevented(e);\n\t      }\n\t    }\n\t  }\n\t\n\t  function clickInGutter(cm, e) {\n\t    return gutterEvent(cm, e, \"gutterClick\", true);\n\t  }\n\t\n\t  // Kludge to work around strange IE behavior where it'll sometimes\n\t  // re-fire a series of drag-related events right after the drop (#1551)\n\t  var lastDrop = 0;\n\t\n\t  function onDrop(e) {\n\t    var cm = this;\n\t    clearDragCursor(cm);\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n\t      return;\n\t    e_preventDefault(e);\n\t    if (ie) lastDrop = +new Date;\n\t    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n\t    if (!pos || isReadOnly(cm)) return;\n\t    // Might be a file drop, in which case we simply extract the text\n\t    // and insert it.\n\t    if (files && files.length && window.FileReader && window.File) {\n\t      var n = files.length, text = Array(n), read = 0;\n\t      var loadFile = function(file, i) {\n\t        if (cm.options.allowDropFileTypes &&\n\t            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n\t          return;\n\t\n\t        var reader = new FileReader;\n\t        reader.onload = operation(cm, function() {\n\t          var content = reader.result;\n\t          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n\t          text[i] = content;\n\t          if (++read == n) {\n\t            pos = clipPos(cm.doc, pos);\n\t            var change = {from: pos, to: pos,\n\t                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n\t                          origin: \"paste\"};\n\t            makeChange(cm.doc, change);\n\t            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n\t          }\n\t        });\n\t        reader.readAsText(file);\n\t      };\n\t      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n\t    } else { // Normal drop\n\t      // Don't do a replace if the drop happened inside of the selected text.\n\t      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n\t        cm.state.draggingText(e);\n\t        // Ensure the editor is re-focused\n\t        setTimeout(function() {cm.display.input.focus();}, 20);\n\t        return;\n\t      }\n\t      try {\n\t        var text = e.dataTransfer.getData(\"Text\");\n\t        if (text) {\n\t          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))\n\t            var selected = cm.listSelections();\n\t          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n\t          if (selected) for (var i = 0; i < selected.length; ++i)\n\t            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n\t          cm.replaceSelection(text, \"around\", \"paste\");\n\t          cm.display.input.focus();\n\t        }\n\t      }\n\t      catch(e){}\n\t    }\n\t  }\n\t\n\t  function onDragStart(cm, e) {\n\t    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\t\n\t    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\t\n\t    // Use dummy image instead of default browsers image.\n\t    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\t    if (e.dataTransfer.setDragImage && !safari) {\n\t      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n\t      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\t      if (presto) {\n\t        img.width = img.height = 1;\n\t        cm.display.wrapper.appendChild(img);\n\t        // Force a relayout, or Opera won't use our image for some obscure reason\n\t        img._top = img.offsetTop;\n\t      }\n\t      e.dataTransfer.setDragImage(img, 0, 0);\n\t      if (presto) img.parentNode.removeChild(img);\n\t    }\n\t  }\n\t\n\t  function onDragOver(cm, e) {\n\t    var pos = posFromMouse(cm, e);\n\t    if (!pos) return;\n\t    var frag = document.createDocumentFragment();\n\t    drawSelectionCursor(cm, pos, frag);\n\t    if (!cm.display.dragCursor) {\n\t      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n\t      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n\t    }\n\t    removeChildrenAndAdd(cm.display.dragCursor, frag);\n\t  }\n\t\n\t  function clearDragCursor(cm) {\n\t    if (cm.display.dragCursor) {\n\t      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n\t      cm.display.dragCursor = null;\n\t    }\n\t  }\n\t\n\t  // SCROLL EVENTS\n\t\n\t  // Sync the scrollable area and scrollbars, ensure the viewport\n\t  // covers the visible area.\n\t  function setScrollTop(cm, val) {\n\t    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n\t    cm.doc.scrollTop = val;\n\t    if (!gecko) updateDisplaySimple(cm, {top: val});\n\t    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n\t    cm.display.scrollbars.setScrollTop(val);\n\t    if (gecko) updateDisplaySimple(cm);\n\t    startWorker(cm, 100);\n\t  }\n\t  // Sync scroller and scrollbar, ensure the gutter elements are\n\t  // aligned.\n\t  function setScrollLeft(cm, val, isScroller) {\n\t    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n\t    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n\t    cm.doc.scrollLeft = val;\n\t    alignHorizontally(cm);\n\t    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n\t    cm.display.scrollbars.setScrollLeft(val);\n\t  }\n\t\n\t  // Since the delta values reported on mouse wheel events are\n\t  // unstandardized between browsers and even browser versions, and\n\t  // generally horribly unpredictable, this code starts by measuring\n\t  // the scroll effect that the first few mouse wheel events have,\n\t  // and, from that, detects the way it can convert deltas to pixel\n\t  // offsets afterwards.\n\t  //\n\t  // The reason we want to know the amount a wheel event will scroll\n\t  // is that it gives us a chance to update the display before the\n\t  // actual scrolling happens, reducing flickering.\n\t\n\t  var wheelSamples = 0, wheelPixelsPerUnit = null;\n\t  // Fill in a browser-detected starting value on browsers where we\n\t  // know one. These don't have to be accurate -- the result of them\n\t  // being wrong would just be a slight flicker on the first wheel\n\t  // scroll (if it is large enough).\n\t  if (ie) wheelPixelsPerUnit = -.53;\n\t  else if (gecko) wheelPixelsPerUnit = 15;\n\t  else if (chrome) wheelPixelsPerUnit = -.7;\n\t  else if (safari) wheelPixelsPerUnit = -1/3;\n\t\n\t  var wheelEventDelta = function(e) {\n\t    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n\t    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n\t    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n\t    else if (dy == null) dy = e.wheelDelta;\n\t    return {x: dx, y: dy};\n\t  };\n\t  CodeMirror.wheelEventPixels = function(e) {\n\t    var delta = wheelEventDelta(e);\n\t    delta.x *= wheelPixelsPerUnit;\n\t    delta.y *= wheelPixelsPerUnit;\n\t    return delta;\n\t  };\n\t\n\t  function onScrollWheel(cm, e) {\n\t    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\t\n\t    var display = cm.display, scroll = display.scroller;\n\t    // Quit if there's nothing to scroll here\n\t    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n\t    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n\t    if (!(dx && canScrollX || dy && canScrollY)) return;\n\t\n\t    // Webkit browsers on OS X abort momentum scrolls when the target\n\t    // of the scroll event is removed from the scrollable element.\n\t    // This hack (see related code in patchDisplay) makes sure the\n\t    // element is kept around.\n\t    if (dy && mac && webkit) {\n\t      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n\t        for (var i = 0; i < view.length; i++) {\n\t          if (view[i].node == cur) {\n\t            cm.display.currentWheelTarget = cur;\n\t            break outer;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // On some browsers, horizontal scrolling will cause redraws to\n\t    // happen before the gutter has been realigned, causing it to\n\t    // wriggle around in a most unseemly way. When we have an\n\t    // estimated pixels/delta value, we just handle horizontal\n\t    // scrolling entirely here. It'll be slightly off from native, but\n\t    // better than glitching out.\n\t    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n\t      if (dy && canScrollY)\n\t        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n\t      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n\t      // Only prevent default scrolling if vertical scrolling is\n\t      // actually possible. Otherwise, it causes vertical scroll\n\t      // jitter on OSX trackpads when deltaX is small and deltaY\n\t      // is large (issue #3579)\n\t      if (!dy || (dy && canScrollY))\n\t        e_preventDefault(e);\n\t      display.wheelStartX = null; // Abort measurement, if in progress\n\t      return;\n\t    }\n\t\n\t    // 'Project' the visible viewport to cover the area that is being\n\t    // scrolled into view (if we know enough to estimate it).\n\t    if (dy && wheelPixelsPerUnit != null) {\n\t      var pixels = dy * wheelPixelsPerUnit;\n\t      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n\t      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n\t      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n\t      updateDisplaySimple(cm, {top: top, bottom: bot});\n\t    }\n\t\n\t    if (wheelSamples < 20) {\n\t      if (display.wheelStartX == null) {\n\t        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n\t        display.wheelDX = dx; display.wheelDY = dy;\n\t        setTimeout(function() {\n\t          if (display.wheelStartX == null) return;\n\t          var movedX = scroll.scrollLeft - display.wheelStartX;\n\t          var movedY = scroll.scrollTop - display.wheelStartY;\n\t          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n\t            (movedX && display.wheelDX && movedX / display.wheelDX);\n\t          display.wheelStartX = display.wheelStartY = null;\n\t          if (!sample) return;\n\t          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n\t          ++wheelSamples;\n\t        }, 200);\n\t      } else {\n\t        display.wheelDX += dx; display.wheelDY += dy;\n\t      }\n\t    }\n\t  }\n\t\n\t  // KEY EVENTS\n\t\n\t  // Run a handler that was bound to a key.\n\t  function doHandleBinding(cm, bound, dropShift) {\n\t    if (typeof bound == \"string\") {\n\t      bound = commands[bound];\n\t      if (!bound) return false;\n\t    }\n\t    // Ensure previous input has been read, so that the handler sees a\n\t    // consistent view of the document\n\t    cm.display.input.ensurePolled();\n\t    var prevShift = cm.display.shift, done = false;\n\t    try {\n\t      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n\t      if (dropShift) cm.display.shift = false;\n\t      done = bound(cm) != Pass;\n\t    } finally {\n\t      cm.display.shift = prevShift;\n\t      cm.state.suppressEdits = false;\n\t    }\n\t    return done;\n\t  }\n\t\n\t  function lookupKeyForEditor(cm, name, handle) {\n\t    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n\t      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n\t      if (result) return result;\n\t    }\n\t    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n\t      || lookupKey(name, cm.options.keyMap, handle, cm);\n\t  }\n\t\n\t  var stopSeq = new Delayed;\n\t  function dispatchKey(cm, name, e, handle) {\n\t    var seq = cm.state.keySeq;\n\t    if (seq) {\n\t      if (isModifierKey(name)) return \"handled\";\n\t      stopSeq.set(50, function() {\n\t        if (cm.state.keySeq == seq) {\n\t          cm.state.keySeq = null;\n\t          cm.display.input.reset();\n\t        }\n\t      });\n\t      name = seq + \" \" + name;\n\t    }\n\t    var result = lookupKeyForEditor(cm, name, handle);\n\t\n\t    if (result == \"multi\")\n\t      cm.state.keySeq = name;\n\t    if (result == \"handled\")\n\t      signalLater(cm, \"keyHandled\", cm, name, e);\n\t\n\t    if (result == \"handled\" || result == \"multi\") {\n\t      e_preventDefault(e);\n\t      restartBlink(cm);\n\t    }\n\t\n\t    if (seq && !result && /\\'$/.test(name)) {\n\t      e_preventDefault(e);\n\t      return true;\n\t    }\n\t    return !!result;\n\t  }\n\t\n\t  // Handle a key from the keydown event.\n\t  function handleKeyBinding(cm, e) {\n\t    var name = keyName(e, true);\n\t    if (!name) return false;\n\t\n\t    if (e.shiftKey && !cm.state.keySeq) {\n\t      // First try to resolve full name (including 'Shift-'). Failing\n\t      // that, see if there is a cursor-motion command (starting with\n\t      // 'go') bound to the keyname without 'Shift-'.\n\t      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n\t          || dispatchKey(cm, name, e, function(b) {\n\t               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n\t                 return doHandleBinding(cm, b);\n\t             });\n\t    } else {\n\t      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n\t    }\n\t  }\n\t\n\t  // Handle a key from the keypress event\n\t  function handleCharBinding(cm, e, ch) {\n\t    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n\t                       function(b) { return doHandleBinding(cm, b, true); });\n\t  }\n\t\n\t  var lastStoppedKey = null;\n\t  function onKeyDown(e) {\n\t    var cm = this;\n\t    cm.curOp.focus = activeElt();\n\t    if (signalDOMEvent(cm, e)) return;\n\t    // IE does strange things with escape.\n\t    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n\t    var code = e.keyCode;\n\t    cm.display.shift = code == 16 || e.shiftKey;\n\t    var handled = handleKeyBinding(cm, e);\n\t    if (presto) {\n\t      lastStoppedKey = handled ? code : null;\n\t      // Opera has no cut event... we try to at least catch the key combo\n\t      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n\t        cm.replaceSelection(\"\", null, \"cut\");\n\t    }\n\t\n\t    // Turn mouse into crosshair when Alt is held on Mac.\n\t    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n\t      showCrossHair(cm);\n\t  }\n\t\n\t  function showCrossHair(cm) {\n\t    var lineDiv = cm.display.lineDiv;\n\t    addClass(lineDiv, \"CodeMirror-crosshair\");\n\t\n\t    function up(e) {\n\t      if (e.keyCode == 18 || !e.altKey) {\n\t        rmClass(lineDiv, \"CodeMirror-crosshair\");\n\t        off(document, \"keyup\", up);\n\t        off(document, \"mouseover\", up);\n\t      }\n\t    }\n\t    on(document, \"keyup\", up);\n\t    on(document, \"mouseover\", up);\n\t  }\n\t\n\t  function onKeyUp(e) {\n\t    if (e.keyCode == 16) this.doc.sel.shift = false;\n\t    signalDOMEvent(this, e);\n\t  }\n\t\n\t  function onKeyPress(e) {\n\t    var cm = this;\n\t    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n\t    var keyCode = e.keyCode, charCode = e.charCode;\n\t    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n\t    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n\t    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n\t    if (handleCharBinding(cm, e, ch)) return;\n\t    cm.display.input.onKeyPress(e);\n\t  }\n\t\n\t  // FOCUS/BLUR EVENTS\n\t\n\t  function delayBlurEvent(cm) {\n\t    cm.state.delayingBlurEvent = true;\n\t    setTimeout(function() {\n\t      if (cm.state.delayingBlurEvent) {\n\t        cm.state.delayingBlurEvent = false;\n\t        onBlur(cm);\n\t      }\n\t    }, 100);\n\t  }\n\t\n\t  function onFocus(cm) {\n\t    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\t\n\t    if (cm.options.readOnly == \"nocursor\") return;\n\t    if (!cm.state.focused) {\n\t      signal(cm, \"focus\", cm);\n\t      cm.state.focused = true;\n\t      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t      // This test prevents this from firing when a context\n\t      // menu is closed (since the input reset would kill the\n\t      // select-all detection hack)\n\t      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n\t        cm.display.input.reset();\n\t        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n\t      }\n\t      cm.display.input.receivedFocus();\n\t    }\n\t    restartBlink(cm);\n\t  }\n\t  function onBlur(cm) {\n\t    if (cm.state.delayingBlurEvent) return;\n\t\n\t    if (cm.state.focused) {\n\t      signal(cm, \"blur\", cm);\n\t      cm.state.focused = false;\n\t      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t    }\n\t    clearInterval(cm.display.blinker);\n\t    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n\t  }\n\t\n\t  // CONTEXT MENU HANDLING\n\t\n\t  // To make the context menu work, we need to briefly unhide the\n\t  // textarea (making it as unobtrusive as possible) to let the\n\t  // right-click take effect on it.\n\t  function onContextMenu(cm, e) {\n\t    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n\t    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n\t    cm.display.input.onContextMenu(e);\n\t  }\n\t\n\t  function contextMenuInGutter(cm, e) {\n\t    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n\t    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n\t  }\n\t\n\t  // UPDATING\n\t\n\t  // Compute the position of the end of a change (its 'to' property\n\t  // refers to the pre-change end).\n\t  var changeEnd = CodeMirror.changeEnd = function(change) {\n\t    if (!change.text) return change.to;\n\t    return Pos(change.from.line + change.text.length - 1,\n\t               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n\t  };\n\t\n\t  // Adjust a position to refer to the post-change position of the\n\t  // same text, or the end of the change if the change covers it.\n\t  function adjustForChange(pos, change) {\n\t    if (cmp(pos, change.from) < 0) return pos;\n\t    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\t\n\t    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n\t    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n\t    return Pos(line, ch);\n\t  }\n\t\n\t  function computeSelAfterChange(doc, change) {\n\t    var out = [];\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      var range = doc.sel.ranges[i];\n\t      out.push(new Range(adjustForChange(range.anchor, change),\n\t                         adjustForChange(range.head, change)));\n\t    }\n\t    return normalizeSelection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  function offsetPos(pos, old, nw) {\n\t    if (pos.line == old.line)\n\t      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n\t    else\n\t      return Pos(nw.line + (pos.line - old.line), pos.ch);\n\t  }\n\t\n\t  // Used by replaceSelections to allow moving the selection to the\n\t  // start or around the replaced test. Hint may be \"start\" or \"around\".\n\t  function computeReplacedSel(doc, changes, hint) {\n\t    var out = [];\n\t    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n\t    for (var i = 0; i < changes.length; i++) {\n\t      var change = changes[i];\n\t      var from = offsetPos(change.from, oldPrev, newPrev);\n\t      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n\t      oldPrev = change.to;\n\t      newPrev = to;\n\t      if (hint == \"around\") {\n\t        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n\t        out[i] = new Range(inv ? to : from, inv ? from : to);\n\t      } else {\n\t        out[i] = new Range(from, from);\n\t      }\n\t    }\n\t    return new Selection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  // Allow \"beforeChange\" event handlers to influence a change\n\t  function filterChange(doc, change, update) {\n\t    var obj = {\n\t      canceled: false,\n\t      from: change.from,\n\t      to: change.to,\n\t      text: change.text,\n\t      origin: change.origin,\n\t      cancel: function() { this.canceled = true; }\n\t    };\n\t    if (update) obj.update = function(from, to, text, origin) {\n\t      if (from) this.from = clipPos(doc, from);\n\t      if (to) this.to = clipPos(doc, to);\n\t      if (text) this.text = text;\n\t      if (origin !== undefined) this.origin = origin;\n\t    };\n\t    signal(doc, \"beforeChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\t\n\t    if (obj.canceled) return null;\n\t    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n\t  }\n\t\n\t  // Apply a change to a document, and add it to the document's\n\t  // history, and propagating it to all linked documents.\n\t  function makeChange(doc, change, ignoreReadOnly) {\n\t    if (doc.cm) {\n\t      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n\t      if (doc.cm.state.suppressEdits) return;\n\t    }\n\t\n\t    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n\t      change = filterChange(doc, change, true);\n\t      if (!change) return;\n\t    }\n\t\n\t    // Possibly split or suppress the update based on the presence\n\t    // of read-only spans in its range.\n\t    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\t    if (split) {\n\t      for (var i = split.length - 1; i >= 0; --i)\n\t        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n\t    } else {\n\t      makeChangeInner(doc, change);\n\t    }\n\t  }\n\t\n\t  function makeChangeInner(doc, change) {\n\t    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n\t    var selAfter = computeSelAfterChange(doc, change);\n\t    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\t\n\t    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n\t    var rebased = [];\n\t\n\t    linkedDocs(doc, function(doc, sharedHist) {\n\t      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t        rebaseHist(doc.history, change);\n\t        rebased.push(doc.history);\n\t      }\n\t      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n\t    });\n\t  }\n\t\n\t  // Revert a change stored in a document's history.\n\t  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n\t    if (doc.cm && doc.cm.state.suppressEdits) return;\n\t\n\t    var hist = doc.history, event, selAfter = doc.sel;\n\t    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\t\n\t    // Verify that there is a useable event (so that ctrl-z won't\n\t    // needlessly clear selection events)\n\t    for (var i = 0; i < source.length; i++) {\n\t      event = source[i];\n\t      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n\t        break;\n\t    }\n\t    if (i == source.length) return;\n\t    hist.lastOrigin = hist.lastSelOrigin = null;\n\t\n\t    for (;;) {\n\t      event = source.pop();\n\t      if (event.ranges) {\n\t        pushSelectionToHistory(event, dest);\n\t        if (allowSelectionOnly && !event.equals(doc.sel)) {\n\t          setSelection(doc, event, {clearRedo: false});\n\t          return;\n\t        }\n\t        selAfter = event;\n\t      }\n\t      else break;\n\t    }\n\t\n\t    // Build up a reverse change object to add to the opposite history\n\t    // stack (redo when undoing, and vice versa).\n\t    var antiChanges = [];\n\t    pushSelectionToHistory(selAfter, dest);\n\t    dest.push({changes: antiChanges, generation: hist.generation});\n\t    hist.generation = event.generation || ++hist.maxGeneration;\n\t\n\t    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\t\n\t    for (var i = event.changes.length - 1; i >= 0; --i) {\n\t      var change = event.changes[i];\n\t      change.origin = type;\n\t      if (filter && !filterChange(doc, change, false)) {\n\t        source.length = 0;\n\t        return;\n\t      }\n\t\n\t      antiChanges.push(historyChangeFromChange(doc, change));\n\t\n\t      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n\t      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\t      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n\t      var rebased = [];\n\t\n\t      // Propagate to the linked documents\n\t      linkedDocs(doc, function(doc, sharedHist) {\n\t        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t          rebaseHist(doc.history, change);\n\t          rebased.push(doc.history);\n\t        }\n\t        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n\t      });\n\t    }\n\t  }\n\t\n\t  // Sub-views need their line numbers shifted when text is added\n\t  // above or below them in the parent document.\n\t  function shiftDoc(doc, distance) {\n\t    if (distance == 0) return;\n\t    doc.first += distance;\n\t    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n\t      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n\t                       Pos(range.head.line + distance, range.head.ch));\n\t    }), doc.sel.primIndex);\n\t    if (doc.cm) {\n\t      regChange(doc.cm, doc.first, doc.first - distance, distance);\n\t      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n\t        regLineChange(doc.cm, l, \"gutter\");\n\t    }\n\t  }\n\t\n\t  // More lower-level change function, handling only a single document\n\t  // (not linked ones).\n\t  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n\t    if (doc.cm && !doc.cm.curOp)\n\t      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\t\n\t    if (change.to.line < doc.first) {\n\t      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n\t      return;\n\t    }\n\t    if (change.from.line > doc.lastLine()) return;\n\t\n\t    // Clip the change to the size of this doc\n\t    if (change.from.line < doc.first) {\n\t      var shift = change.text.length - 1 - (doc.first - change.from.line);\n\t      shiftDoc(doc, shift);\n\t      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n\t                text: [lst(change.text)], origin: change.origin};\n\t    }\n\t    var last = doc.lastLine();\n\t    if (change.to.line > last) {\n\t      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n\t                text: [change.text[0]], origin: change.origin};\n\t    }\n\t\n\t    change.removed = getBetween(doc, change.from, change.to);\n\t\n\t    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n\t    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n\t    else updateDoc(doc, change, spans);\n\t    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\t  }\n\t\n\t  // Handle the interaction of a change to a document with the editor\n\t  // that this document is part of.\n\t  function makeChangeSingleDocInEditor(cm, change, spans) {\n\t    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\t\n\t    var recomputeMaxLength = false, checkWidthStart = from.line;\n\t    if (!cm.options.lineWrapping) {\n\t      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n\t      doc.iter(checkWidthStart, to.line + 1, function(line) {\n\t        if (line == display.maxLine) {\n\t          recomputeMaxLength = true;\n\t          return true;\n\t        }\n\t      });\n\t    }\n\t\n\t    if (doc.sel.contains(change.from, change.to) > -1)\n\t      signalCursorActivity(cm);\n\t\n\t    updateDoc(doc, change, spans, estimateHeight(cm));\n\t\n\t    if (!cm.options.lineWrapping) {\n\t      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n\t        var len = lineLength(line);\n\t        if (len > display.maxLineLength) {\n\t          display.maxLine = line;\n\t          display.maxLineLength = len;\n\t          display.maxLineChanged = true;\n\t          recomputeMaxLength = false;\n\t        }\n\t      });\n\t      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n\t    }\n\t\n\t    // Adjust frontier, schedule worker\n\t    doc.frontier = Math.min(doc.frontier, from.line);\n\t    startWorker(cm, 400);\n\t\n\t    var lendiff = change.text.length - (to.line - from.line) - 1;\n\t    // Remember that these lines changed, for updating the display\n\t    if (change.full)\n\t      regChange(cm);\n\t    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n\t      regLineChange(cm, from.line, \"text\");\n\t    else\n\t      regChange(cm, from.line, to.line + 1, lendiff);\n\t\n\t    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n\t    if (changeHandler || changesHandler) {\n\t      var obj = {\n\t        from: from, to: to,\n\t        text: change.text,\n\t        removed: change.removed,\n\t        origin: change.origin\n\t      };\n\t      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n\t      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n\t    }\n\t    cm.display.selForContextMenu = null;\n\t  }\n\t\n\t  function replaceRange(doc, code, from, to, origin) {\n\t    if (!to) to = from;\n\t    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n\t    if (typeof code == \"string\") code = doc.splitLines(code);\n\t    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n\t  }\n\t\n\t  // SCROLLING THINGS INTO VIEW\n\t\n\t  // If an editor sits on the top or bottom of the window, partially\n\t  // scrolled out of view, this ensures that the cursor is visible.\n\t  function maybeScrollWindow(cm, coords) {\n\t    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\t\n\t    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n\t    if (coords.top + box.top < 0) doScroll = true;\n\t    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n\t    if (doScroll != null && !phantom) {\n\t      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n\t                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n\t                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n\t                           coords.left + \"px; width: 2px;\");\n\t      cm.display.lineSpace.appendChild(scrollNode);\n\t      scrollNode.scrollIntoView(doScroll);\n\t      cm.display.lineSpace.removeChild(scrollNode);\n\t    }\n\t  }\n\t\n\t  // Scroll a given position into view (immediately), verifying that\n\t  // it actually became visible (as line heights are accurately\n\t  // measured, the position of something may 'drift' during drawing).\n\t  function scrollPosIntoView(cm, pos, end, margin) {\n\t    if (margin == null) margin = 0;\n\t    for (var limit = 0; limit < 5; limit++) {\n\t      var changed = false, coords = cursorCoords(cm, pos);\n\t      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n\t      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n\t                                         Math.min(coords.top, endCoords.top) - margin,\n\t                                         Math.max(coords.left, endCoords.left),\n\t                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n\t      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n\t      if (scrollPos.scrollTop != null) {\n\t        setScrollTop(cm, scrollPos.scrollTop);\n\t        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n\t      }\n\t      if (scrollPos.scrollLeft != null) {\n\t        setScrollLeft(cm, scrollPos.scrollLeft);\n\t        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n\t      }\n\t      if (!changed) break;\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // Scroll a given set of coordinates into view (immediately).\n\t  function scrollIntoView(cm, x1, y1, x2, y2) {\n\t    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n\t    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n\t    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n\t  }\n\t\n\t  // Calculate a new scroll position needed to scroll the given\n\t  // rectangle into view. Returns an object with scrollTop and\n\t  // scrollLeft properties. When these are undefined, the\n\t  // vertical/horizontal position does not need to be adjusted.\n\t  function calculateScrollPos(cm, x1, y1, x2, y2) {\n\t    var display = cm.display, snapMargin = textHeight(cm.display);\n\t    if (y1 < 0) y1 = 0;\n\t    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n\t    var screen = displayHeight(cm), result = {};\n\t    if (y2 - y1 > screen) y2 = y1 + screen;\n\t    var docBottom = cm.doc.height + paddingVert(display);\n\t    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n\t    if (y1 < screentop) {\n\t      result.scrollTop = atTop ? 0 : y1;\n\t    } else if (y2 > screentop + screen) {\n\t      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n\t      if (newTop != screentop) result.scrollTop = newTop;\n\t    }\n\t\n\t    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n\t    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n\t    var tooWide = x2 - x1 > screenw;\n\t    if (tooWide) x2 = x1 + screenw;\n\t    if (x1 < 10)\n\t      result.scrollLeft = 0;\n\t    else if (x1 < screenleft)\n\t      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n\t    else if (x2 > screenw + screenleft - 3)\n\t      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n\t    return result;\n\t  }\n\t\n\t  // Store a relative adjustment to the scroll position in the current\n\t  // operation (to be applied when the operation finishes).\n\t  function addToScrollPos(cm, left, top) {\n\t    if (left != null || top != null) resolveScrollToPos(cm);\n\t    if (left != null)\n\t      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n\t    if (top != null)\n\t      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n\t  }\n\t\n\t  // Make sure that at the end of the operation the current cursor is\n\t  // shown.\n\t  function ensureCursorVisible(cm) {\n\t    resolveScrollToPos(cm);\n\t    var cur = cm.getCursor(), from = cur, to = cur;\n\t    if (!cm.options.lineWrapping) {\n\t      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n\t      to = Pos(cur.line, cur.ch + 1);\n\t    }\n\t    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n\t  }\n\t\n\t  // When an operation has its scrollToPos property set, and another\n\t  // scroll action is applied before the end of the operation, this\n\t  // 'simulates' scrolling that position into view in a cheap way, so\n\t  // that the effect of intermediate scroll commands is not ignored.\n\t  function resolveScrollToPos(cm) {\n\t    var range = cm.curOp.scrollToPos;\n\t    if (range) {\n\t      cm.curOp.scrollToPos = null;\n\t      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n\t      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n\t                                    Math.min(from.top, to.top) - range.margin,\n\t                                    Math.max(from.right, to.right),\n\t                                    Math.max(from.bottom, to.bottom) + range.margin);\n\t      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t    }\n\t  }\n\t\n\t  // API UTILITIES\n\t\n\t  // Indent the given line. The how parameter can be \"smart\",\n\t  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n\t  // (typically set to true for forced single-line indents), empty\n\t  // lines are not indented, and places where the mode returns Pass\n\t  // are left alone.\n\t  function indentLine(cm, n, how, aggressive) {\n\t    var doc = cm.doc, state;\n\t    if (how == null) how = \"add\";\n\t    if (how == \"smart\") {\n\t      // Fall back to \"prev\" when the mode doesn't have an indentation\n\t      // method.\n\t      if (!doc.mode.indent) how = \"prev\";\n\t      else state = getStateBefore(cm, n);\n\t    }\n\t\n\t    var tabSize = cm.options.tabSize;\n\t    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n\t    if (!aggressive && !/\\S/.test(line.text)) {\n\t      indentation = 0;\n\t      how = \"not\";\n\t    } else if (how == \"smart\") {\n\t      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\t      if (indentation == Pass || indentation > 150) {\n\t        if (!aggressive) return;\n\t        how = \"prev\";\n\t      }\n\t    }\n\t    if (how == \"prev\") {\n\t      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n\t      else indentation = 0;\n\t    } else if (how == \"add\") {\n\t      indentation = curSpace + cm.options.indentUnit;\n\t    } else if (how == \"subtract\") {\n\t      indentation = curSpace - cm.options.indentUnit;\n\t    } else if (typeof how == \"number\") {\n\t      indentation = curSpace + how;\n\t    }\n\t    indentation = Math.max(0, indentation);\n\t\n\t    var indentString = \"\", pos = 0;\n\t    if (cm.options.indentWithTabs)\n\t      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n\t    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\t\n\t    if (indentString != curSpaceString) {\n\t      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\t      line.stateAfter = null;\n\t      return true;\n\t    } else {\n\t      // Ensure that, if the cursor was in the whitespace at the start\n\t      // of the line, it is moved to the end of that space.\n\t      for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t        var range = doc.sel.ranges[i];\n\t        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n\t          var pos = Pos(n, curSpaceString.length);\n\t          replaceOneSelection(doc, i, new Range(pos, pos));\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // Utility for applying a change to a line by handle or number,\n\t  // returning the number and optionally registering the line as\n\t  // changed.\n\t  function changeLine(doc, handle, changeType, op) {\n\t    var no = handle, line = handle;\n\t    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n\t    else no = lineNo(handle);\n\t    if (no == null) return null;\n\t    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n\t    return line;\n\t  }\n\t\n\t  // Helper for deleting text near the selection(s), used to implement\n\t  // backspace, delete, and similar functionality.\n\t  function deleteNearSelection(cm, compute) {\n\t    var ranges = cm.doc.sel.ranges, kill = [];\n\t    // Build up a set of ranges to kill first, merging overlapping\n\t    // ranges.\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var toKill = compute(ranges[i]);\n\t      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n\t        var replaced = kill.pop();\n\t        if (cmp(replaced.from, toKill.from) < 0) {\n\t          toKill.from = replaced.from;\n\t          break;\n\t        }\n\t      }\n\t      kill.push(toKill);\n\t    }\n\t    // Next, remove those actual ranges.\n\t    runInOp(cm, function() {\n\t      for (var i = kill.length - 1; i >= 0; i--)\n\t        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n\t      ensureCursorVisible(cm);\n\t    });\n\t  }\n\t\n\t  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n\t  // right), unit can be \"char\", \"column\" (like char, but doesn't\n\t  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n\t  // the start of next group of word or non-word-non-whitespace\n\t  // chars). The visually param controls whether, in right-to-left\n\t  // text, direction 1 means to move towards the next index in the\n\t  // string, or towards the character to the right of the current\n\t  // position. The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosH(doc, pos, dir, unit, visually) {\n\t    var line = pos.line, ch = pos.ch, origDir = dir;\n\t    var lineObj = getLine(doc, line);\n\t    var possible = true;\n\t    function findNextLine() {\n\t      var l = line + dir;\n\t      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n\t      line = l;\n\t      return lineObj = getLine(doc, l);\n\t    }\n\t    function moveOnce(boundToLine) {\n\t      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n\t      if (next == null) {\n\t        if (!boundToLine && findNextLine()) {\n\t          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n\t          else ch = dir < 0 ? lineObj.text.length : 0;\n\t        } else return (possible = false);\n\t      } else ch = next;\n\t      return true;\n\t    }\n\t\n\t    if (unit == \"char\") moveOnce();\n\t    else if (unit == \"column\") moveOnce(true);\n\t    else if (unit == \"word\" || unit == \"group\") {\n\t      var sawType = null, group = unit == \"group\";\n\t      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n\t      for (var first = true;; first = false) {\n\t        if (dir < 0 && !moveOnce(!first)) break;\n\t        var cur = lineObj.text.charAt(ch) || \"\\n\";\n\t        var type = isWordChar(cur, helper) ? \"w\"\n\t          : group && cur == \"\\n\" ? \"n\"\n\t          : !group || /\\s/.test(cur) ? null\n\t          : \"p\";\n\t        if (group && !first && !type) type = \"s\";\n\t        if (sawType && sawType != type) {\n\t          if (dir < 0) {dir = 1; moveOnce();}\n\t          break;\n\t        }\n\t\n\t        if (type) sawType = type;\n\t        if (dir > 0 && !moveOnce(!first)) break;\n\t      }\n\t    }\n\t    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n\t    if (!possible) result.hitSide = true;\n\t    return result;\n\t  }\n\t\n\t  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n\t  // \"page\" or \"line\". The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosV(cm, pos, dir, unit) {\n\t    var doc = cm.doc, x = pos.left, y;\n\t    if (unit == \"page\") {\n\t      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n\t      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n\t    } else if (unit == \"line\") {\n\t      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n\t    }\n\t    for (;;) {\n\t      var target = coordsChar(cm, x, y);\n\t      if (!target.outside) break;\n\t      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n\t      y += dir * 5;\n\t    }\n\t    return target;\n\t  }\n\t\n\t  // EDITOR METHODS\n\t\n\t  // The publicly visible API. Note that methodOp(f) means\n\t  // 'wrap f in an operation, performed on its `this` parameter'.\n\t\n\t  // This is not the complete set of editor methods. Most of the\n\t  // methods defined on the Doc type are also injected into\n\t  // CodeMirror.prototype, for backwards compatibility and\n\t  // convenience.\n\t\n\t  CodeMirror.prototype = {\n\t    constructor: CodeMirror,\n\t    focus: function(){window.focus(); this.display.input.focus();},\n\t\n\t    setOption: function(option, value) {\n\t      var options = this.options, old = options[option];\n\t      if (options[option] == value && option != \"mode\") return;\n\t      options[option] = value;\n\t      if (optionHandlers.hasOwnProperty(option))\n\t        operation(this, optionHandlers[option])(this, value, old);\n\t    },\n\t\n\t    getOption: function(option) {return this.options[option];},\n\t    getDoc: function() {return this.doc;},\n\t\n\t    addKeyMap: function(map, bottom) {\n\t      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n\t    },\n\t    removeKeyMap: function(map) {\n\t      var maps = this.state.keyMaps;\n\t      for (var i = 0; i < maps.length; ++i)\n\t        if (maps[i] == map || maps[i].name == map) {\n\t          maps.splice(i, 1);\n\t          return true;\n\t        }\n\t    },\n\t\n\t    addOverlay: methodOp(function(spec, options) {\n\t      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\t      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n\t      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n\t      this.state.modeGen++;\n\t      regChange(this);\n\t    }),\n\t    removeOverlay: methodOp(function(spec) {\n\t      var overlays = this.state.overlays;\n\t      for (var i = 0; i < overlays.length; ++i) {\n\t        var cur = overlays[i].modeSpec;\n\t        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n\t          overlays.splice(i, 1);\n\t          this.state.modeGen++;\n\t          regChange(this);\n\t          return;\n\t        }\n\t      }\n\t    }),\n\t\n\t    indentLine: methodOp(function(n, dir, aggressive) {\n\t      if (typeof dir != \"string\" && typeof dir != \"number\") {\n\t        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n\t        else dir = dir ? \"add\" : \"subtract\";\n\t      }\n\t      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n\t    }),\n\t    indentSelection: methodOp(function(how) {\n\t      var ranges = this.doc.sel.ranges, end = -1;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (!range.empty()) {\n\t          var from = range.from(), to = range.to();\n\t          var start = Math.max(end, from.line);\n\t          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n\t          for (var j = start; j < end; ++j)\n\t            indentLine(this, j, how);\n\t          var newRanges = this.doc.sel.ranges;\n\t          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n\t            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n\t        } else if (range.head.line > end) {\n\t          indentLine(this, range.head.line, how, true);\n\t          end = range.head.line;\n\t          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n\t        }\n\t      }\n\t    }),\n\t\n\t    // Fetch the parser token for a given character. Useful for hacks\n\t    // that want to inspect the mode state (say, for completion).\n\t    getTokenAt: function(pos, precise) {\n\t      return takeToken(this, pos, precise);\n\t    },\n\t\n\t    getLineTokens: function(line, precise) {\n\t      return takeToken(this, Pos(line), precise, true);\n\t    },\n\t\n\t    getTokenTypeAt: function(pos) {\n\t      pos = clipPos(this.doc, pos);\n\t      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n\t      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n\t      var type;\n\t      if (ch == 0) type = styles[2];\n\t      else for (;;) {\n\t        var mid = (before + after) >> 1;\n\t        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n\t        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n\t        else { type = styles[mid * 2 + 2]; break; }\n\t      }\n\t      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n\t      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n\t    },\n\t\n\t    getModeAt: function(pos) {\n\t      var mode = this.doc.mode;\n\t      if (!mode.innerMode) return mode;\n\t      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n\t    },\n\t\n\t    getHelper: function(pos, type) {\n\t      return this.getHelpers(pos, type)[0];\n\t    },\n\t\n\t    getHelpers: function(pos, type) {\n\t      var found = [];\n\t      if (!helpers.hasOwnProperty(type)) return found;\n\t      var help = helpers[type], mode = this.getModeAt(pos);\n\t      if (typeof mode[type] == \"string\") {\n\t        if (help[mode[type]]) found.push(help[mode[type]]);\n\t      } else if (mode[type]) {\n\t        for (var i = 0; i < mode[type].length; i++) {\n\t          var val = help[mode[type][i]];\n\t          if (val) found.push(val);\n\t        }\n\t      } else if (mode.helperType && help[mode.helperType]) {\n\t        found.push(help[mode.helperType]);\n\t      } else if (help[mode.name]) {\n\t        found.push(help[mode.name]);\n\t      }\n\t      for (var i = 0; i < help._global.length; i++) {\n\t        var cur = help._global[i];\n\t        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n\t          found.push(cur.val);\n\t      }\n\t      return found;\n\t    },\n\t\n\t    getStateAfter: function(line, precise) {\n\t      var doc = this.doc;\n\t      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n\t      return getStateBefore(this, line + 1, precise);\n\t    },\n\t\n\t    cursorCoords: function(start, mode) {\n\t      var pos, range = this.doc.sel.primary();\n\t      if (start == null) pos = range.head;\n\t      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n\t      else pos = start ? range.from() : range.to();\n\t      return cursorCoords(this, pos, mode || \"page\");\n\t    },\n\t\n\t    charCoords: function(pos, mode) {\n\t      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n\t    },\n\t\n\t    coordsChar: function(coords, mode) {\n\t      coords = fromCoordSystem(this, coords, mode || \"page\");\n\t      return coordsChar(this, coords.left, coords.top);\n\t    },\n\t\n\t    lineAtHeight: function(height, mode) {\n\t      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n\t      return lineAtHeight(this.doc, height + this.display.viewOffset);\n\t    },\n\t    heightAtLine: function(line, mode) {\n\t      var end = false, lineObj;\n\t      if (typeof line == \"number\") {\n\t        var last = this.doc.first + this.doc.size - 1;\n\t        if (line < this.doc.first) line = this.doc.first;\n\t        else if (line > last) { line = last; end = true; }\n\t        lineObj = getLine(this.doc, line);\n\t      } else {\n\t        lineObj = line;\n\t      }\n\t      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n\t        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n\t    },\n\t\n\t    defaultTextHeight: function() { return textHeight(this.display); },\n\t    defaultCharWidth: function() { return charWidth(this.display); },\n\t\n\t    setGutterMarker: methodOp(function(line, gutterID, value) {\n\t      return changeLine(this.doc, line, \"gutter\", function(line) {\n\t        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n\t        markers[gutterID] = value;\n\t        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    clearGutter: methodOp(function(gutterID) {\n\t      var cm = this, doc = cm.doc, i = doc.first;\n\t      doc.iter(function(line) {\n\t        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n\t          line.gutterMarkers[gutterID] = null;\n\t          regLineChange(cm, i, \"gutter\");\n\t          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n\t        }\n\t        ++i;\n\t      });\n\t    }),\n\t\n\t    lineInfo: function(line) {\n\t      if (typeof line == \"number\") {\n\t        if (!isLine(this.doc, line)) return null;\n\t        var n = line;\n\t        line = getLine(this.doc, line);\n\t        if (!line) return null;\n\t      } else {\n\t        var n = lineNo(line);\n\t        if (n == null) return null;\n\t      }\n\t      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n\t              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n\t              widgets: line.widgets};\n\t    },\n\t\n\t    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\t\n\t    addWidget: function(pos, node, scroll, vert, horiz) {\n\t      var display = this.display;\n\t      pos = cursorCoords(this, clipPos(this.doc, pos));\n\t      var top = pos.bottom, left = pos.left;\n\t      node.style.position = \"absolute\";\n\t      node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      this.display.input.setUneditable(node);\n\t      display.sizer.appendChild(node);\n\t      if (vert == \"over\") {\n\t        top = pos.top;\n\t      } else if (vert == \"above\" || vert == \"near\") {\n\t        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n\t        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n\t        // Default to positioning above (if specified and possible); otherwise default to positioning below\n\t        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n\t          top = pos.top - node.offsetHeight;\n\t        else if (pos.bottom + node.offsetHeight <= vspace)\n\t          top = pos.bottom;\n\t        if (left + node.offsetWidth > hspace)\n\t          left = hspace - node.offsetWidth;\n\t      }\n\t      node.style.top = top + \"px\";\n\t      node.style.left = node.style.right = \"\";\n\t      if (horiz == \"right\") {\n\t        left = display.sizer.clientWidth - node.offsetWidth;\n\t        node.style.right = \"0px\";\n\t      } else {\n\t        if (horiz == \"left\") left = 0;\n\t        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n\t        node.style.left = left + \"px\";\n\t      }\n\t      if (scroll)\n\t        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n\t    },\n\t\n\t    triggerOnKeyDown: methodOp(onKeyDown),\n\t    triggerOnKeyPress: methodOp(onKeyPress),\n\t    triggerOnKeyUp: onKeyUp,\n\t\n\t    execCommand: function(cmd) {\n\t      if (commands.hasOwnProperty(cmd))\n\t        return commands[cmd].call(null, this);\n\t    },\n\t\n\t    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\t\n\t    findPosH: function(from, amount, unit, visually) {\n\t      var dir = 1;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        cur = findPosH(this.doc, cur, dir, unit, visually);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveH: methodOp(function(dir, unit) {\n\t      var cm = this;\n\t      cm.extendSelectionsBy(function(range) {\n\t        if (cm.display.shift || cm.doc.extend || range.empty())\n\t          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n\t        else\n\t          return dir < 0 ? range.from() : range.to();\n\t      }, sel_move);\n\t    }),\n\t\n\t    deleteH: methodOp(function(dir, unit) {\n\t      var sel = this.doc.sel, doc = this.doc;\n\t      if (sel.somethingSelected())\n\t        doc.replaceSelection(\"\", null, \"+delete\");\n\t      else\n\t        deleteNearSelection(this, function(range) {\n\t          var other = findPosH(doc, range.head, dir, unit, false);\n\t          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n\t        });\n\t    }),\n\t\n\t    findPosV: function(from, amount, unit, goalColumn) {\n\t      var dir = 1, x = goalColumn;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        var coords = cursorCoords(this, cur, \"div\");\n\t        if (x == null) x = coords.left;\n\t        else coords.left = x;\n\t        cur = findPosV(this, coords, dir, unit);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveV: methodOp(function(dir, unit) {\n\t      var cm = this, doc = this.doc, goals = [];\n\t      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n\t      doc.extendSelectionsBy(function(range) {\n\t        if (collapse)\n\t          return dir < 0 ? range.from() : range.to();\n\t        var headPos = cursorCoords(cm, range.head, \"div\");\n\t        if (range.goalColumn != null) headPos.left = range.goalColumn;\n\t        goals.push(headPos.left);\n\t        var pos = findPosV(cm, headPos, dir, unit);\n\t        if (unit == \"page\" && range == doc.sel.primary())\n\t          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n\t        return pos;\n\t      }, sel_move);\n\t      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n\t        doc.sel.ranges[i].goalColumn = goals[i];\n\t    }),\n\t\n\t    // Find the word at the given position (as returned by coordsChar).\n\t    findWordAt: function(pos) {\n\t      var doc = this.doc, line = getLine(doc, pos.line).text;\n\t      var start = pos.ch, end = pos.ch;\n\t      if (line) {\n\t        var helper = this.getHelper(pos, \"wordChars\");\n\t        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n\t        var startChar = line.charAt(start);\n\t        var check = isWordChar(startChar, helper)\n\t          ? function(ch) { return isWordChar(ch, helper); }\n\t          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n\t          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n\t        while (start > 0 && check(line.charAt(start - 1))) --start;\n\t        while (end < line.length && check(line.charAt(end))) ++end;\n\t      }\n\t      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n\t    },\n\t\n\t    toggleOverwrite: function(value) {\n\t      if (value != null && value == this.state.overwrite) return;\n\t      if (this.state.overwrite = !this.state.overwrite)\n\t        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t      else\n\t        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t\n\t      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n\t    },\n\t    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n\t\n\t    scrollTo: methodOp(function(x, y) {\n\t      if (x != null || y != null) resolveScrollToPos(this);\n\t      if (x != null) this.curOp.scrollLeft = x;\n\t      if (y != null) this.curOp.scrollTop = y;\n\t    }),\n\t    getScrollInfo: function() {\n\t      var scroller = this.display.scroller;\n\t      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n\t              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n\t              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n\t              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n\t    },\n\t\n\t    scrollIntoView: methodOp(function(range, margin) {\n\t      if (range == null) {\n\t        range = {from: this.doc.sel.primary().head, to: null};\n\t        if (margin == null) margin = this.options.cursorScrollMargin;\n\t      } else if (typeof range == \"number\") {\n\t        range = {from: Pos(range, 0), to: null};\n\t      } else if (range.from == null) {\n\t        range = {from: range, to: null};\n\t      }\n\t      if (!range.to) range.to = range.from;\n\t      range.margin = margin || 0;\n\t\n\t      if (range.from.line != null) {\n\t        resolveScrollToPos(this);\n\t        this.curOp.scrollToPos = range;\n\t      } else {\n\t        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n\t                                      Math.min(range.from.top, range.to.top) - range.margin,\n\t                                      Math.max(range.from.right, range.to.right),\n\t                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n\t        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t      }\n\t    }),\n\t\n\t    setSize: methodOp(function(width, height) {\n\t      var cm = this;\n\t      function interpret(val) {\n\t        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n\t      }\n\t      if (width != null) cm.display.wrapper.style.width = interpret(width);\n\t      if (height != null) cm.display.wrapper.style.height = interpret(height);\n\t      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n\t      var lineNo = cm.display.viewFrom;\n\t      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n\t        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n\t          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n\t        ++lineNo;\n\t      });\n\t      cm.curOp.forceUpdate = true;\n\t      signal(cm, \"refresh\", this);\n\t    }),\n\t\n\t    operation: function(f){return runInOp(this, f);},\n\t\n\t    refresh: methodOp(function() {\n\t      var oldHeight = this.display.cachedTextHeight;\n\t      regChange(this);\n\t      this.curOp.forceUpdate = true;\n\t      clearCaches(this);\n\t      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n\t      updateGutterSpace(this);\n\t      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n\t        estimateLineHeights(this);\n\t      signal(this, \"refresh\", this);\n\t    }),\n\t\n\t    swapDoc: methodOp(function(doc) {\n\t      var old = this.doc;\n\t      old.cm = null;\n\t      attachDoc(this, doc);\n\t      clearCaches(this);\n\t      this.display.input.reset();\n\t      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n\t      this.curOp.forceScroll = true;\n\t      signalLater(this, \"swapDoc\", this, old);\n\t      return old;\n\t    }),\n\t\n\t    getInputField: function(){return this.display.input.getField();},\n\t    getWrapperElement: function(){return this.display.wrapper;},\n\t    getScrollerElement: function(){return this.display.scroller;},\n\t    getGutterElement: function(){return this.display.gutters;}\n\t  };\n\t  eventMixin(CodeMirror);\n\t\n\t  // OPTION DEFAULTS\n\t\n\t  // The default configuration options.\n\t  var defaults = CodeMirror.defaults = {};\n\t  // Functions to run when options are changed.\n\t  var optionHandlers = CodeMirror.optionHandlers = {};\n\t\n\t  function option(name, deflt, handle, notOnInit) {\n\t    CodeMirror.defaults[name] = deflt;\n\t    if (handle) optionHandlers[name] =\n\t      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n\t  }\n\t\n\t  // Passed to option handlers when there is no old value.\n\t  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\t\n\t  // These two are, on init, called from the constructor because they\n\t  // have to be initialized before the editor can start at all.\n\t  option(\"value\", \"\", function(cm, val) {\n\t    cm.setValue(val);\n\t  }, true);\n\t  option(\"mode\", null, function(cm, val) {\n\t    cm.doc.modeOption = val;\n\t    loadMode(cm);\n\t  }, true);\n\t\n\t  option(\"indentUnit\", 2, loadMode, true);\n\t  option(\"indentWithTabs\", false);\n\t  option(\"smartIndent\", true);\n\t  option(\"tabSize\", 4, function(cm) {\n\t    resetModeState(cm);\n\t    clearCaches(cm);\n\t    regChange(cm);\n\t  }, true);\n\t  option(\"lineSeparator\", null, function(cm, val) {\n\t    cm.doc.lineSep = val;\n\t    if (!val) return;\n\t    var newBreaks = [], lineNo = cm.doc.first;\n\t    cm.doc.iter(function(line) {\n\t      for (var pos = 0;;) {\n\t        var found = line.text.indexOf(val, pos);\n\t        if (found == -1) break;\n\t        pos = found + val.length;\n\t        newBreaks.push(Pos(lineNo, found));\n\t      }\n\t      lineNo++;\n\t    });\n\t    for (var i = newBreaks.length - 1; i >= 0; i--)\n\t      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n\t  });\n\t  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n\t    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\t    if (old != CodeMirror.Init) cm.refresh();\n\t  });\n\t  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n\t  option(\"electricChars\", true);\n\t  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n\t    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n\t  }, true);\n\t  option(\"rtlMoveVisually\", !windows);\n\t  option(\"wholeLineUpdateBefore\", true);\n\t\n\t  option(\"theme\", \"default\", function(cm) {\n\t    themeChanged(cm);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"keyMap\", \"default\", function(cm, val, old) {\n\t    var next = getKeyMap(val);\n\t    var prev = old != CodeMirror.Init && getKeyMap(old);\n\t    if (prev && prev.detach) prev.detach(cm, next);\n\t    if (next.attach) next.attach(cm, prev || null);\n\t  });\n\t  option(\"extraKeys\", null);\n\t\n\t  option(\"lineWrapping\", false, wrappingChanged, true);\n\t  option(\"gutters\", [], function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"fixedGutter\", true, function(cm, val) {\n\t    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n\t    cm.refresh();\n\t  }, true);\n\t  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n\t  option(\"scrollbarStyle\", \"native\", function(cm) {\n\t    initScrollbars(cm);\n\t    updateScrollbars(cm);\n\t    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n\t    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n\t  }, true);\n\t  option(\"lineNumbers\", false, function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"firstLineNumber\", 1, guttersChanged, true);\n\t  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n\t  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\t\n\t  option(\"resetSelectionOnContextMenu\", true);\n\t  option(\"lineWiseCopyCut\", true);\n\t\n\t  option(\"readOnly\", false, function(cm, val) {\n\t    if (val == \"nocursor\") {\n\t      onBlur(cm);\n\t      cm.display.input.blur();\n\t      cm.display.disabled = true;\n\t    } else {\n\t      cm.display.disabled = false;\n\t    }\n\t    cm.display.input.readOnlyChanged(val)\n\t  });\n\t  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n\t  option(\"dragDrop\", true, dragDropChanged);\n\t  option(\"allowDropFileTypes\", null);\n\t\n\t  option(\"cursorBlinkRate\", 530);\n\t  option(\"cursorScrollMargin\", 0);\n\t  option(\"cursorHeight\", 1, updateSelection, true);\n\t  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n\t  option(\"workTime\", 100);\n\t  option(\"workDelay\", 100);\n\t  option(\"flattenSpans\", true, resetModeState, true);\n\t  option(\"addModeClass\", false, resetModeState, true);\n\t  option(\"pollInterval\", 100);\n\t  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n\t  option(\"historyEventDelay\", 1250);\n\t  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n\t  option(\"maxHighlightLength\", 10000, resetModeState, true);\n\t  option(\"moveInputWithCursor\", true, function(cm, val) {\n\t    if (!val) cm.display.input.resetPosition();\n\t  });\n\t\n\t  option(\"tabindex\", null, function(cm, val) {\n\t    cm.display.input.getField().tabIndex = val || \"\";\n\t  });\n\t  option(\"autofocus\", null);\n\t\n\t  // MODE DEFINITION AND QUERYING\n\t\n\t  // Known modes, by name and by MIME\n\t  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\t\n\t  // Extra arguments are stored as the mode's dependencies, which is\n\t  // used by (legacy) mechanisms like loadmode.js to automatically\n\t  // load a mode. (Preferred mechanism is the require/define calls.)\n\t  CodeMirror.defineMode = function(name, mode) {\n\t    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n\t    if (arguments.length > 2)\n\t      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n\t    modes[name] = mode;\n\t  };\n\t\n\t  CodeMirror.defineMIME = function(mime, spec) {\n\t    mimeModes[mime] = spec;\n\t  };\n\t\n\t  // Given a MIME type, a {name, ...options} config object, or a name\n\t  // string, return a mode config object.\n\t  CodeMirror.resolveMode = function(spec) {\n\t    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n\t      spec = mimeModes[spec];\n\t    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n\t      var found = mimeModes[spec.name];\n\t      if (typeof found == \"string\") found = {name: found};\n\t      spec = createObj(found, spec);\n\t      spec.name = found.name;\n\t    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n\t      return CodeMirror.resolveMode(\"application/xml\");\n\t    }\n\t    if (typeof spec == \"string\") return {name: spec};\n\t    else return spec || {name: \"null\"};\n\t  };\n\t\n\t  // Given a mode spec (anything that resolveMode accepts), find and\n\t  // initialize an actual mode object.\n\t  CodeMirror.getMode = function(options, spec) {\n\t    var spec = CodeMirror.resolveMode(spec);\n\t    var mfactory = modes[spec.name];\n\t    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n\t    var modeObj = mfactory(options, spec);\n\t    if (modeExtensions.hasOwnProperty(spec.name)) {\n\t      var exts = modeExtensions[spec.name];\n\t      for (var prop in exts) {\n\t        if (!exts.hasOwnProperty(prop)) continue;\n\t        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n\t        modeObj[prop] = exts[prop];\n\t      }\n\t    }\n\t    modeObj.name = spec.name;\n\t    if (spec.helperType) modeObj.helperType = spec.helperType;\n\t    if (spec.modeProps) for (var prop in spec.modeProps)\n\t      modeObj[prop] = spec.modeProps[prop];\n\t\n\t    return modeObj;\n\t  };\n\t\n\t  // Minimal default mode.\n\t  CodeMirror.defineMode(\"null\", function() {\n\t    return {token: function(stream) {stream.skipToEnd();}};\n\t  });\n\t  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\t\n\t  // This can be used to attach properties to mode objects from\n\t  // outside the actual mode definition.\n\t  var modeExtensions = CodeMirror.modeExtensions = {};\n\t  CodeMirror.extendMode = function(mode, properties) {\n\t    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n\t    copyObj(properties, exts);\n\t  };\n\t\n\t  // EXTENSIONS\n\t\n\t  CodeMirror.defineExtension = function(name, func) {\n\t    CodeMirror.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineDocExtension = function(name, func) {\n\t    Doc.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineOption = option;\n\t\n\t  var initHooks = [];\n\t  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\t\n\t  var helpers = CodeMirror.helpers = {};\n\t  CodeMirror.registerHelper = function(type, name, value) {\n\t    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n\t    helpers[type][name] = value;\n\t  };\n\t  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n\t    CodeMirror.registerHelper(type, name, value);\n\t    helpers[type]._global.push({pred: predicate, val: value});\n\t  };\n\t\n\t  // MODE STATE HANDLING\n\t\n\t  // Utility functions for working with state. Exported because nested\n\t  // modes need to do this for their inner modes.\n\t\n\t  var copyState = CodeMirror.copyState = function(mode, state) {\n\t    if (state === true) return state;\n\t    if (mode.copyState) return mode.copyState(state);\n\t    var nstate = {};\n\t    for (var n in state) {\n\t      var val = state[n];\n\t      if (val instanceof Array) val = val.concat([]);\n\t      nstate[n] = val;\n\t    }\n\t    return nstate;\n\t  };\n\t\n\t  var startState = CodeMirror.startState = function(mode, a1, a2) {\n\t    return mode.startState ? mode.startState(a1, a2) : true;\n\t  };\n\t\n\t  // Given a mode and a state (for that mode), find the inner mode and\n\t  // state at the position that the state refers to.\n\t  CodeMirror.innerMode = function(mode, state) {\n\t    while (mode.innerMode) {\n\t      var info = mode.innerMode(state);\n\t      if (!info || info.mode == mode) break;\n\t      state = info.state;\n\t      mode = info.mode;\n\t    }\n\t    return info || {mode: mode, state: state};\n\t  };\n\t\n\t  // STANDARD COMMANDS\n\t\n\t  // Commands are parameter-less actions that can be performed on an\n\t  // editor, mostly used for keybindings.\n\t  var commands = CodeMirror.commands = {\n\t    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n\t    singleSelection: function(cm) {\n\t      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n\t    },\n\t    killLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        if (range.empty()) {\n\t          var len = getLine(cm.doc, range.head.line).text.length;\n\t          if (range.head.ch == len && range.head.line < cm.lastLine())\n\t            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n\t          else\n\t            return {from: range.head, to: Pos(range.head.line, len)};\n\t        } else {\n\t          return {from: range.from(), to: range.to()};\n\t        }\n\t      });\n\t    },\n\t    deleteLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0),\n\t                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n\t      });\n\t    },\n\t    delLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0), to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        return {from: leftPos, to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineRight: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t        return {from: range.from(), to: rightPos };\n\t      });\n\t    },\n\t    undo: function(cm) {cm.undo();},\n\t    redo: function(cm) {cm.redo();},\n\t    undoSelection: function(cm) {cm.undoSelection();},\n\t    redoSelection: function(cm) {cm.redoSelection();},\n\t    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n\t    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n\t    goLineStart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineStartSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        return lineStartSmart(cm, range.head);\n\t      }, {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineEnd: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: -1});\n\t    },\n\t    goLineRight: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeft: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: 0, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeftSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n\t        return pos;\n\t      }, sel_move);\n\t    },\n\t    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n\t    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n\t    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n\t    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n\t    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n\t    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n\t    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n\t    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n\t    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n\t    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n\t    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n\t    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n\t    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n\t    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n\t    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n\t    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n\t    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n\t    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n\t    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n\t    indentMore: function(cm) {cm.indentSelection(\"add\");},\n\t    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n\t    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n\t    insertSoftTab: function(cm) {\n\t      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var pos = ranges[i].from();\n\t        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n\t        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n\t      }\n\t      cm.replaceSelections(spaces);\n\t    },\n\t    defaultTab: function(cm) {\n\t      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n\t      else cm.execCommand(\"insertTab\");\n\t    },\n\t    transposeChars: function(cm) {\n\t      runInOp(cm, function() {\n\t        var ranges = cm.listSelections(), newSel = [];\n\t        for (var i = 0; i < ranges.length; i++) {\n\t          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n\t          if (line) {\n\t            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n\t            if (cur.ch > 0) {\n\t              cur = new Pos(cur.line, cur.ch + 1);\n\t              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n\t                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n\t            } else if (cur.line > cm.doc.first) {\n\t              var prev = getLine(cm.doc, cur.line - 1).text;\n\t              if (prev)\n\t                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n\t                                prev.charAt(prev.length - 1),\n\t                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n\t            }\n\t          }\n\t          newSel.push(new Range(cur, cur));\n\t        }\n\t        cm.setSelections(newSel);\n\t      });\n\t    },\n\t    newlineAndIndent: function(cm) {\n\t      runInOp(cm, function() {\n\t        var len = cm.listSelections().length;\n\t        for (var i = 0; i < len; i++) {\n\t          var range = cm.listSelections()[i];\n\t          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n\t          cm.indentLine(range.from().line + 1, null, true);\n\t        }\n\t        ensureCursorVisible(cm);\n\t      });\n\t    },\n\t    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n\t  };\n\t\n\t\n\t  // STANDARD KEYMAPS\n\t\n\t  var keyMap = CodeMirror.keyMap = {};\n\t\n\t  keyMap.basic = {\n\t    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n\t    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n\t    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n\t    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n\t    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n\t    \"Esc\": \"singleSelection\"\n\t  };\n\t  // Note that the save and find-related commands aren't defined by\n\t  // default. User code or addons can define them. Unknown commands\n\t  // are simply ignored.\n\t  keyMap.pcDefault = {\n\t    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n\t    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n\t    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n\t    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n\t    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n\t    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n\t    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n\t    fallthrough: \"basic\"\n\t  };\n\t  // Very basic readline/emacs-style bindings, which are standard on Mac.\n\t  keyMap.emacsy = {\n\t    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n\t    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n\t    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n\t    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n\t  };\n\t  keyMap.macDefault = {\n\t    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n\t    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n\t    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n\t    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n\t    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n\t    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n\t    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n\t    fallthrough: [\"basic\", \"emacsy\"]\n\t  };\n\t  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\t\n\t  // KEYMAP DISPATCH\n\t\n\t  function normalizeKeyName(name) {\n\t    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n\t    var alt, ctrl, shift, cmd;\n\t    for (var i = 0; i < parts.length - 1; i++) {\n\t      var mod = parts[i];\n\t      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n\t      else if (/^a(lt)?$/i.test(mod)) alt = true;\n\t      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n\t      else if (/^s(hift)$/i.test(mod)) shift = true;\n\t      else throw new Error(\"Unrecognized modifier name: \" + mod);\n\t    }\n\t    if (alt) name = \"Alt-\" + name;\n\t    if (ctrl) name = \"Ctrl-\" + name;\n\t    if (cmd) name = \"Cmd-\" + name;\n\t    if (shift) name = \"Shift-\" + name;\n\t    return name;\n\t  }\n\t\n\t  // This is a kludge to keep keymaps mostly working as raw objects\n\t  // (backwards compatibility) while at the same time support features\n\t  // like normalization and multi-stroke key bindings. It compiles a\n\t  // new normalized keymap, and then updates the old object to reflect\n\t  // this.\n\t  CodeMirror.normalizeKeyMap = function(keymap) {\n\t    var copy = {};\n\t    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n\t      var value = keymap[keyname];\n\t      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n\t      if (value == \"...\") { delete keymap[keyname]; continue; }\n\t\n\t      var keys = map(keyname.split(\" \"), normalizeKeyName);\n\t      for (var i = 0; i < keys.length; i++) {\n\t        var val, name;\n\t        if (i == keys.length - 1) {\n\t          name = keys.join(\" \");\n\t          val = value;\n\t        } else {\n\t          name = keys.slice(0, i + 1).join(\" \");\n\t          val = \"...\";\n\t        }\n\t        var prev = copy[name];\n\t        if (!prev) copy[name] = val;\n\t        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n\t      }\n\t      delete keymap[keyname];\n\t    }\n\t    for (var prop in copy) keymap[prop] = copy[prop];\n\t    return keymap;\n\t  };\n\t\n\t  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n\t    map = getKeyMap(map);\n\t    var found = map.call ? map.call(key, context) : map[key];\n\t    if (found === false) return \"nothing\";\n\t    if (found === \"...\") return \"multi\";\n\t    if (found != null && handle(found)) return \"handled\";\n\t\n\t    if (map.fallthrough) {\n\t      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n\t        return lookupKey(key, map.fallthrough, handle, context);\n\t      for (var i = 0; i < map.fallthrough.length; i++) {\n\t        var result = lookupKey(key, map.fallthrough[i], handle, context);\n\t        if (result) return result;\n\t      }\n\t    }\n\t  };\n\t\n\t  // Modifier key presses don't count as 'real' key presses for the\n\t  // purpose of keymap fallthrough.\n\t  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n\t    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n\t    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n\t  };\n\t\n\t  // Look up the name of a key as indicated by an event object.\n\t  var keyName = CodeMirror.keyName = function(event, noShift) {\n\t    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n\t    var base = keyNames[event.keyCode], name = base;\n\t    if (name == null || event.altGraphKey) return false;\n\t    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n\t    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n\t    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n\t    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n\t    return name;\n\t  };\n\t\n\t  function getKeyMap(val) {\n\t    return typeof val == \"string\" ? keyMap[val] : val;\n\t  }\n\t\n\t  // FROMTEXTAREA\n\t\n\t  CodeMirror.fromTextArea = function(textarea, options) {\n\t    options = options ? copyObj(options) : {};\n\t    options.value = textarea.value;\n\t    if (!options.tabindex && textarea.tabIndex)\n\t      options.tabindex = textarea.tabIndex;\n\t    if (!options.placeholder && textarea.placeholder)\n\t      options.placeholder = textarea.placeholder;\n\t    // Set autofocus to true if this textarea is focused, or if it has\n\t    // autofocus and no other element is focused.\n\t    if (options.autofocus == null) {\n\t      var hasFocus = activeElt();\n\t      options.autofocus = hasFocus == textarea ||\n\t        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n\t    }\n\t\n\t    function save() {textarea.value = cm.getValue();}\n\t    if (textarea.form) {\n\t      on(textarea.form, \"submit\", save);\n\t      // Deplorable hack to make the submit method do the right thing.\n\t      if (!options.leaveSubmitMethodAlone) {\n\t        var form = textarea.form, realSubmit = form.submit;\n\t        try {\n\t          var wrappedSubmit = form.submit = function() {\n\t            save();\n\t            form.submit = realSubmit;\n\t            form.submit();\n\t            form.submit = wrappedSubmit;\n\t          };\n\t        } catch(e) {}\n\t      }\n\t    }\n\t\n\t    options.finishInit = function(cm) {\n\t      cm.save = save;\n\t      cm.getTextArea = function() { return textarea; };\n\t      cm.toTextArea = function() {\n\t        cm.toTextArea = isNaN; // Prevent this from being ran twice\n\t        save();\n\t        textarea.parentNode.removeChild(cm.getWrapperElement());\n\t        textarea.style.display = \"\";\n\t        if (textarea.form) {\n\t          off(textarea.form, \"submit\", save);\n\t          if (typeof textarea.form.submit == \"function\")\n\t            textarea.form.submit = realSubmit;\n\t        }\n\t      };\n\t    };\n\t\n\t    textarea.style.display = \"none\";\n\t    var cm = CodeMirror(function(node) {\n\t      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n\t    }, options);\n\t    return cm;\n\t  };\n\t\n\t  // STRING STREAM\n\t\n\t  // Fed to the mode parsers, provides helper functions to make\n\t  // parsers more succinct.\n\t\n\t  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n\t    this.pos = this.start = 0;\n\t    this.string = string;\n\t    this.tabSize = tabSize || 8;\n\t    this.lastColumnPos = this.lastColumnValue = 0;\n\t    this.lineStart = 0;\n\t  };\n\t\n\t  StringStream.prototype = {\n\t    eol: function() {return this.pos >= this.string.length;},\n\t    sol: function() {return this.pos == this.lineStart;},\n\t    peek: function() {return this.string.charAt(this.pos) || undefined;},\n\t    next: function() {\n\t      if (this.pos < this.string.length)\n\t        return this.string.charAt(this.pos++);\n\t    },\n\t    eat: function(match) {\n\t      var ch = this.string.charAt(this.pos);\n\t      if (typeof match == \"string\") var ok = ch == match;\n\t      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\t      if (ok) {++this.pos; return ch;}\n\t    },\n\t    eatWhile: function(match) {\n\t      var start = this.pos;\n\t      while (this.eat(match)){}\n\t      return this.pos > start;\n\t    },\n\t    eatSpace: function() {\n\t      var start = this.pos;\n\t      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n\t      return this.pos > start;\n\t    },\n\t    skipToEnd: function() {this.pos = this.string.length;},\n\t    skipTo: function(ch) {\n\t      var found = this.string.indexOf(ch, this.pos);\n\t      if (found > -1) {this.pos = found; return true;}\n\t    },\n\t    backUp: function(n) {this.pos -= n;},\n\t    column: function() {\n\t      if (this.lastColumnPos < this.start) {\n\t        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n\t        this.lastColumnPos = this.start;\n\t      }\n\t      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    indentation: function() {\n\t      return countColumn(this.string, null, this.tabSize) -\n\t        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    match: function(pattern, consume, caseInsensitive) {\n\t      if (typeof pattern == \"string\") {\n\t        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n\t        var substr = this.string.substr(this.pos, pattern.length);\n\t        if (cased(substr) == cased(pattern)) {\n\t          if (consume !== false) this.pos += pattern.length;\n\t          return true;\n\t        }\n\t      } else {\n\t        var match = this.string.slice(this.pos).match(pattern);\n\t        if (match && match.index > 0) return null;\n\t        if (match && consume !== false) this.pos += match[0].length;\n\t        return match;\n\t      }\n\t    },\n\t    current: function(){return this.string.slice(this.start, this.pos);},\n\t    hideFirstChars: function(n, inner) {\n\t      this.lineStart += n;\n\t      try { return inner(); }\n\t      finally { this.lineStart -= n; }\n\t    }\n\t  };\n\t\n\t  // TEXTMARKERS\n\t\n\t  // Created with markText and setBookmark methods. A TextMarker is a\n\t  // handle that can be used to clear or find a marked position in the\n\t  // document. Line objects hold arrays (markedSpans) containing\n\t  // {from, to, marker} object pointing to such marker objects, and\n\t  // indicating that such a marker is present on that line. Multiple\n\t  // lines may point to the same marker when it spans across lines.\n\t  // The spans will have null for their from/to properties when the\n\t  // marker continues beyond the start/end of the line. Markers have\n\t  // links back to the lines they currently touch.\n\t\n\t  var nextMarkerId = 0;\n\t\n\t  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n\t    this.lines = [];\n\t    this.type = type;\n\t    this.doc = doc;\n\t    this.id = ++nextMarkerId;\n\t  };\n\t  eventMixin(TextMarker);\n\t\n\t  // Clear the marker.\n\t  TextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n\t    if (withOp) startOperation(cm);\n\t    if (hasHandler(this, \"clear\")) {\n\t      var found = this.find();\n\t      if (found) signalLater(this, \"clear\", found.from, found.to);\n\t    }\n\t    var min = null, max = null;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n\t      else if (cm) {\n\t        if (span.to != null) max = lineNo(line);\n\t        if (span.from != null) min = lineNo(line);\n\t      }\n\t      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\t      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n\t        updateLineHeight(line, textHeight(cm.display));\n\t    }\n\t    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n\t      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n\t      if (len > cm.display.maxLineLength) {\n\t        cm.display.maxLine = visual;\n\t        cm.display.maxLineLength = len;\n\t        cm.display.maxLineChanged = true;\n\t      }\n\t    }\n\t\n\t    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n\t    this.lines.length = 0;\n\t    this.explicitlyCleared = true;\n\t    if (this.atomic && this.doc.cantEdit) {\n\t      this.doc.cantEdit = false;\n\t      if (cm) reCheckSelection(cm.doc);\n\t    }\n\t    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n\t    if (withOp) endOperation(cm);\n\t    if (this.parent) this.parent.clear();\n\t  };\n\t\n\t  // Find the position of the marker in the document. Returns a {from,\n\t  // to} object by default. Side can be passed to get a specific side\n\t  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n\t  // Pos objects returned contain a line object, rather than a line\n\t  // number (used to prevent looking up the same line twice).\n\t  TextMarker.prototype.find = function(side, lineObj) {\n\t    if (side == null && this.type == \"bookmark\") side = 1;\n\t    var from, to;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (span.from != null) {\n\t        from = Pos(lineObj ? line : lineNo(line), span.from);\n\t        if (side == -1) return from;\n\t      }\n\t      if (span.to != null) {\n\t        to = Pos(lineObj ? line : lineNo(line), span.to);\n\t        if (side == 1) return to;\n\t      }\n\t    }\n\t    return from && {from: from, to: to};\n\t  };\n\t\n\t  // Signals that the marker's widget changed, and surrounding layout\n\t  // should be recomputed.\n\t  TextMarker.prototype.changed = function() {\n\t    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n\t    if (!pos || !cm) return;\n\t    runInOp(cm, function() {\n\t      var line = pos.line, lineN = lineNo(pos.line);\n\t      var view = findViewForLine(cm, lineN);\n\t      if (view) {\n\t        clearLineMeasurementCacheFor(view);\n\t        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n\t      }\n\t      cm.curOp.updateMaxLine = true;\n\t      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n\t        var oldHeight = widget.height;\n\t        widget.height = null;\n\t        var dHeight = widgetHeight(widget) - oldHeight;\n\t        if (dHeight)\n\t          updateLineHeight(line, line.height + dHeight);\n\t      }\n\t    });\n\t  };\n\t\n\t  TextMarker.prototype.attachLine = function(line) {\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n\t        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n\t    }\n\t    this.lines.push(line);\n\t  };\n\t  TextMarker.prototype.detachLine = function(line) {\n\t    this.lines.splice(indexOf(this.lines, line), 1);\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n\t    }\n\t  };\n\t\n\t  // Collapsed markers have unique ids, in order to be able to order\n\t  // them, which is needed for uniquely determining an outer marker\n\t  // when they overlap (they may nest, but not partially overlap).\n\t  var nextMarkerId = 0;\n\t\n\t  // Create a marker, wire it up to the right lines, and\n\t  function markText(doc, from, to, options, type) {\n\t    // Shared markers (across linked documents) are handled separately\n\t    // (markTextShared will call out to this again, once per\n\t    // document).\n\t    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n\t    // Ensure we are in an operation.\n\t    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\t\n\t    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n\t    if (options) copyObj(options, marker, false);\n\t    // Don't connect empty markers unless clearWhenEmpty is false\n\t    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n\t      return marker;\n\t    if (marker.replacedWith) {\n\t      // Showing up as a widget implies collapsed (widget replaces text)\n\t      marker.collapsed = true;\n\t      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\t      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n\t      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n\t    }\n\t    if (marker.collapsed) {\n\t      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n\t          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n\t        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n\t      sawCollapsedSpans = true;\n\t    }\n\t\n\t    if (marker.addToHistory)\n\t      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\t\n\t    var curLine = from.line, cm = doc.cm, updateMaxLine;\n\t    doc.iter(curLine, to.line + 1, function(line) {\n\t      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n\t        updateMaxLine = true;\n\t      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n\t      addMarkedSpan(line, new MarkedSpan(marker,\n\t                                         curLine == from.line ? from.ch : null,\n\t                                         curLine == to.line ? to.ch : null));\n\t      ++curLine;\n\t    });\n\t    // lineIsHidden depends on the presence of the spans, so needs a second pass\n\t    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n\t      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n\t    });\n\t\n\t    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\t\n\t    if (marker.readOnly) {\n\t      sawReadOnlySpans = true;\n\t      if (doc.history.done.length || doc.history.undone.length)\n\t        doc.clearHistory();\n\t    }\n\t    if (marker.collapsed) {\n\t      marker.id = ++nextMarkerId;\n\t      marker.atomic = true;\n\t    }\n\t    if (cm) {\n\t      // Sync editor state\n\t      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n\t      if (marker.collapsed)\n\t        regChange(cm, from.line, to.line + 1);\n\t      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n\t        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n\t      if (marker.atomic) reCheckSelection(cm.doc);\n\t      signalLater(cm, \"markerAdded\", cm, marker);\n\t    }\n\t    return marker;\n\t  }\n\t\n\t  // SHARED TEXTMARKERS\n\t\n\t  // A shared marker spans multiple linked documents. It is\n\t  // implemented as a meta-marker-object controlling multiple normal\n\t  // markers.\n\t  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n\t    this.markers = markers;\n\t    this.primary = primary;\n\t    for (var i = 0; i < markers.length; ++i)\n\t      markers[i].parent = this;\n\t  };\n\t  eventMixin(SharedTextMarker);\n\t\n\t  SharedTextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    this.explicitlyCleared = true;\n\t    for (var i = 0; i < this.markers.length; ++i)\n\t      this.markers[i].clear();\n\t    signalLater(this, \"clear\");\n\t  };\n\t  SharedTextMarker.prototype.find = function(side, lineObj) {\n\t    return this.primary.find(side, lineObj);\n\t  };\n\t\n\t  function markTextShared(doc, from, to, options, type) {\n\t    options = copyObj(options);\n\t    options.shared = false;\n\t    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n\t    var widget = options.widgetNode;\n\t    linkedDocs(doc, function(doc) {\n\t      if (widget) options.widgetNode = widget.cloneNode(true);\n\t      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n\t      for (var i = 0; i < doc.linked.length; ++i)\n\t        if (doc.linked[i].isParent) return;\n\t      primary = lst(markers);\n\t    });\n\t    return new SharedTextMarker(markers, primary);\n\t  }\n\t\n\t  function findSharedMarkers(doc) {\n\t    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n\t                         function(m) { return m.parent; });\n\t  }\n\t\n\t  function copySharedMarkers(doc, markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], pos = marker.find();\n\t      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n\t      if (cmp(mFrom, mTo)) {\n\t        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n\t        marker.markers.push(subMark);\n\t        subMark.parent = marker;\n\t      }\n\t    }\n\t  }\n\t\n\t  function detachSharedMarkers(markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], linked = [marker.primary.doc];;\n\t      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n\t      for (var j = 0; j < marker.markers.length; j++) {\n\t        var subMarker = marker.markers[j];\n\t        if (indexOf(linked, subMarker.doc) == -1) {\n\t          subMarker.parent = null;\n\t          marker.markers.splice(j--, 1);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // TEXTMARKER SPANS\n\t\n\t  function MarkedSpan(marker, from, to) {\n\t    this.marker = marker;\n\t    this.from = from; this.to = to;\n\t  }\n\t\n\t  // Search an array of spans for a span matching the given marker.\n\t  function getMarkedSpanFor(spans, marker) {\n\t    if (spans) for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.marker == marker) return span;\n\t    }\n\t  }\n\t  // Remove a span from an array, returning undefined if no spans are\n\t  // left (we don't store arrays for lines without spans).\n\t  function removeMarkedSpan(spans, span) {\n\t    for (var r, i = 0; i < spans.length; ++i)\n\t      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n\t    return r;\n\t  }\n\t  // Add a span to a line.\n\t  function addMarkedSpan(line, span) {\n\t    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n\t    span.marker.attachLine(line);\n\t  }\n\t\n\t  // Used for the algorithm that adjusts markers for a change in the\n\t  // document. These functions cut an array of spans at a given\n\t  // character position, returning an array of remaining chunks (or\n\t  // undefined if nothing remains).\n\t  function markedSpansBefore(old, startCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\t      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n\t        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t  function markedSpansAfter(old, endCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\t      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n\t        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n\t                                              span.to == null ? null : span.to - endCh));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t\n\t  // Given a change object, compute the new set of marker spans that\n\t  // cover the line in which the change took place. Removes spans\n\t  // entirely within the change, reconnects spans belonging to the\n\t  // same marker that appear on both sides of the change, and cuts off\n\t  // spans partially within the change. Returns an array of span\n\t  // arrays with one element for each line in (after) the change.\n\t  function stretchSpansOverChange(doc, change) {\n\t    if (change.full) return null;\n\t    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n\t    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\t    if (!oldFirst && !oldLast) return null;\n\t\n\t    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n\t    // Get the spans that 'stick out' on both sides\n\t    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n\t    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\t\n\t    // Next, merge those two ends\n\t    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n\t    if (first) {\n\t      // Fix up .to properties of first\n\t      for (var i = 0; i < first.length; ++i) {\n\t        var span = first[i];\n\t        if (span.to == null) {\n\t          var found = getMarkedSpanFor(last, span.marker);\n\t          if (!found) span.to = startCh;\n\t          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n\t        }\n\t      }\n\t    }\n\t    if (last) {\n\t      // Fix up .from in last (or move them into first in case of sameLine)\n\t      for (var i = 0; i < last.length; ++i) {\n\t        var span = last[i];\n\t        if (span.to != null) span.to += offset;\n\t        if (span.from == null) {\n\t          var found = getMarkedSpanFor(first, span.marker);\n\t          if (!found) {\n\t            span.from = offset;\n\t            if (sameLine) (first || (first = [])).push(span);\n\t          }\n\t        } else {\n\t          span.from += offset;\n\t          if (sameLine) (first || (first = [])).push(span);\n\t        }\n\t      }\n\t    }\n\t    // Make sure we didn't create any zero-length spans\n\t    if (first) first = clearEmptySpans(first);\n\t    if (last && last != first) last = clearEmptySpans(last);\n\t\n\t    var newMarkers = [first];\n\t    if (!sameLine) {\n\t      // Fill gap with whole-line-spans\n\t      var gap = change.text.length - 2, gapMarkers;\n\t      if (gap > 0 && first)\n\t        for (var i = 0; i < first.length; ++i)\n\t          if (first[i].to == null)\n\t            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n\t      for (var i = 0; i < gap; ++i)\n\t        newMarkers.push(gapMarkers);\n\t      newMarkers.push(last);\n\t    }\n\t    return newMarkers;\n\t  }\n\t\n\t  // Remove spans that are empty and don't have a clearWhenEmpty\n\t  // option of false.\n\t  function clearEmptySpans(spans) {\n\t    for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n\t        spans.splice(i--, 1);\n\t    }\n\t    if (!spans.length) return null;\n\t    return spans;\n\t  }\n\t\n\t  // Used for un/re-doing changes from the history. Combines the\n\t  // result of computing the existing spans with the set of spans that\n\t  // existed in the history (so that deleting around a span and then\n\t  // undoing brings back the span).\n\t  function mergeOldSpans(doc, change) {\n\t    var old = getOldSpans(doc, change);\n\t    var stretched = stretchSpansOverChange(doc, change);\n\t    if (!old) return stretched;\n\t    if (!stretched) return old;\n\t\n\t    for (var i = 0; i < old.length; ++i) {\n\t      var oldCur = old[i], stretchCur = stretched[i];\n\t      if (oldCur && stretchCur) {\n\t        spans: for (var j = 0; j < stretchCur.length; ++j) {\n\t          var span = stretchCur[j];\n\t          for (var k = 0; k < oldCur.length; ++k)\n\t            if (oldCur[k].marker == span.marker) continue spans;\n\t          oldCur.push(span);\n\t        }\n\t      } else if (stretchCur) {\n\t        old[i] = stretchCur;\n\t      }\n\t    }\n\t    return old;\n\t  }\n\t\n\t  // Used to 'clip' out readOnly ranges when making a change.\n\t  function removeReadOnlyRanges(doc, from, to) {\n\t    var markers = null;\n\t    doc.iter(from.line, to.line + 1, function(line) {\n\t      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t        var mark = line.markedSpans[i].marker;\n\t        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n\t          (markers || (markers = [])).push(mark);\n\t      }\n\t    });\n\t    if (!markers) return null;\n\t    var parts = [{from: from, to: to}];\n\t    for (var i = 0; i < markers.length; ++i) {\n\t      var mk = markers[i], m = mk.find(0);\n\t      for (var j = 0; j < parts.length; ++j) {\n\t        var p = parts[j];\n\t        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n\t        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n\t        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n\t          newParts.push({from: p.from, to: m.from});\n\t        if (dto > 0 || !mk.inclusiveRight && !dto)\n\t          newParts.push({from: m.to, to: p.to});\n\t        parts.splice.apply(parts, newParts);\n\t        j += newParts.length - 1;\n\t      }\n\t    }\n\t    return parts;\n\t  }\n\t\n\t  // Connect or disconnect spans from a line.\n\t  function detachMarkedSpans(line) {\n\t    var spans = line.markedSpans;\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.detachLine(line);\n\t    line.markedSpans = null;\n\t  }\n\t  function attachMarkedSpans(line, spans) {\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.attachLine(line);\n\t    line.markedSpans = spans;\n\t  }\n\t\n\t  // Helpers used when computing which overlapping collapsed span\n\t  // counts as the larger one.\n\t  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n\t  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\t\n\t  // Returns a number indicating which of two overlapping collapsed\n\t  // spans is larger (and thus includes the other). Falls back to\n\t  // comparing ids when the spans cover exactly the same range.\n\t  function compareCollapsedMarkers(a, b) {\n\t    var lenDiff = a.lines.length - b.lines.length;\n\t    if (lenDiff != 0) return lenDiff;\n\t    var aPos = a.find(), bPos = b.find();\n\t    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\t    if (fromCmp) return -fromCmp;\n\t    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\t    if (toCmp) return toCmp;\n\t    return b.id - a.id;\n\t  }\n\t\n\t  // Find out whether a line ends or starts in a collapsed span. If\n\t  // so, return the marker for that span.\n\t  function collapsedSpanAtSide(line, start) {\n\t    var sps = sawCollapsedSpans && line.markedSpans, found;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n\t          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n\t        found = sp.marker;\n\t    }\n\t    return found;\n\t  }\n\t  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n\t  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\t\n\t  // Test whether there exists a collapsed span that partially\n\t  // overlaps (covers the start or end, but not both) of a new span.\n\t  // Such overlap is not allowed.\n\t  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n\t    var line = getLine(doc, lineNo);\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var i = 0; i < sps.length; ++i) {\n\t      var sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      var found = sp.marker.find(0);\n\t      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n\t      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\t      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n\t      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n\t          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // A visual line is a line as drawn on the screen. Folding, for\n\t  // example, can cause multiple logical lines to appear on the same\n\t  // visual line. This finds the start of the visual line that the\n\t  // given line is part of (usually that is the line itself).\n\t  function visualLine(line) {\n\t    var merged;\n\t    while (merged = collapsedSpanAtStart(line))\n\t      line = merged.find(-1, true).line;\n\t    return line;\n\t  }\n\t\n\t  // Returns an array of logical lines that continue the visual line\n\t  // started by the argument, or undefined if there are no such lines.\n\t  function visualLineContinued(line) {\n\t    var merged, lines;\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      (lines || (lines = [])).push(line);\n\t    }\n\t    return lines;\n\t  }\n\t\n\t  // Get the line number of the start of the visual line that the\n\t  // given line number is part of.\n\t  function visualLineNo(doc, lineN) {\n\t    var line = getLine(doc, lineN), vis = visualLine(line);\n\t    if (line == vis) return lineN;\n\t    return lineNo(vis);\n\t  }\n\t  // Get the line number of the start of the next visual line after\n\t  // the given line.\n\t  function visualLineEndNo(doc, lineN) {\n\t    if (lineN > doc.lastLine()) return lineN;\n\t    var line = getLine(doc, lineN), merged;\n\t    if (!lineIsHidden(doc, line)) return lineN;\n\t    while (merged = collapsedSpanAtEnd(line))\n\t      line = merged.find(1, true).line;\n\t    return lineNo(line) + 1;\n\t  }\n\t\n\t  // Compute whether a line is hidden. Lines count as hidden when they\n\t  // are part of a visual line that starts with another line, or when\n\t  // they are entirely covered by collapsed, non-widget span.\n\t  function lineIsHidden(doc, line) {\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      if (sp.from == null) return true;\n\t      if (sp.marker.widgetNode) continue;\n\t      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n\t        return true;\n\t    }\n\t  }\n\t  function lineIsHiddenInner(doc, line, span) {\n\t    if (span.to == null) {\n\t      var end = span.marker.find(1, true);\n\t      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n\t    }\n\t    if (span.marker.inclusiveRight && span.to == line.text.length)\n\t      return true;\n\t    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n\t      sp = line.markedSpans[i];\n\t      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n\t          (sp.to == null || sp.to != span.from) &&\n\t          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n\t          lineIsHiddenInner(doc, line, sp)) return true;\n\t    }\n\t  }\n\t\n\t  // LINE WIDGETS\n\t\n\t  // Line widgets are block elements displayed above or below a line.\n\t\n\t  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n\t    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n\t      this[opt] = options[opt];\n\t    this.doc = doc;\n\t    this.node = node;\n\t  };\n\t  eventMixin(LineWidget);\n\t\n\t  function adjustScrollWhenAboveVisible(cm, line, diff) {\n\t    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n\t      addToScrollPos(cm, null, diff);\n\t  }\n\t\n\t  LineWidget.prototype.clear = function() {\n\t    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n\t    if (no == null || !ws) return;\n\t    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n\t    if (!ws.length) line.widgets = null;\n\t    var height = widgetHeight(this);\n\t    updateLineHeight(line, Math.max(0, line.height - height));\n\t    if (cm) runInOp(cm, function() {\n\t      adjustScrollWhenAboveVisible(cm, line, -height);\n\t      regLineChange(cm, no, \"widget\");\n\t    });\n\t  };\n\t  LineWidget.prototype.changed = function() {\n\t    var oldH = this.height, cm = this.doc.cm, line = this.line;\n\t    this.height = null;\n\t    var diff = widgetHeight(this) - oldH;\n\t    if (!diff) return;\n\t    updateLineHeight(line, line.height + diff);\n\t    if (cm) runInOp(cm, function() {\n\t      cm.curOp.forceUpdate = true;\n\t      adjustScrollWhenAboveVisible(cm, line, diff);\n\t    });\n\t  };\n\t\n\t  function widgetHeight(widget) {\n\t    if (widget.height != null) return widget.height;\n\t    var cm = widget.doc.cm;\n\t    if (!cm) return 0;\n\t    if (!contains(document.body, widget.node)) {\n\t      var parentStyle = \"position: relative;\";\n\t      if (widget.coverGutter)\n\t        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n\t      if (widget.noHScroll)\n\t        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n\t      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n\t    }\n\t    return widget.height = widget.node.offsetHeight;\n\t  }\n\t\n\t  function addLineWidget(doc, handle, node, options) {\n\t    var widget = new LineWidget(doc, node, options);\n\t    var cm = doc.cm;\n\t    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n\t    changeLine(doc, handle, \"widget\", function(line) {\n\t      var widgets = line.widgets || (line.widgets = []);\n\t      if (widget.insertAt == null) widgets.push(widget);\n\t      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n\t      widget.line = line;\n\t      if (cm && !lineIsHidden(doc, line)) {\n\t        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n\t        updateLineHeight(line, line.height + widgetHeight(widget));\n\t        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n\t        cm.curOp.forceUpdate = true;\n\t      }\n\t      return true;\n\t    });\n\t    return widget;\n\t  }\n\t\n\t  // LINE DATA STRUCTURE\n\t\n\t  // Line objects. These hold state related to a line, including\n\t  // highlighting info (the styles array).\n\t  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n\t    this.text = text;\n\t    attachMarkedSpans(this, markedSpans);\n\t    this.height = estimateHeight ? estimateHeight(this) : 1;\n\t  };\n\t  eventMixin(Line);\n\t  Line.prototype.lineNo = function() { return lineNo(this); };\n\t\n\t  // Change the content (text, markers) of a line. Automatically\n\t  // invalidates cached information and tries to re-estimate the\n\t  // line's height.\n\t  function updateLine(line, text, markedSpans, estimateHeight) {\n\t    line.text = text;\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    if (line.styles) line.styles = null;\n\t    if (line.order != null) line.order = null;\n\t    detachMarkedSpans(line);\n\t    attachMarkedSpans(line, markedSpans);\n\t    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\t    if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t  }\n\t\n\t  // Detach a line from the document tree and its markers.\n\t  function cleanUpLine(line) {\n\t    line.parent = null;\n\t    detachMarkedSpans(line);\n\t  }\n\t\n\t  function extractLineClasses(type, output) {\n\t    if (type) for (;;) {\n\t      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\t      if (!lineClass) break;\n\t      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n\t      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\t      if (output[prop] == null)\n\t        output[prop] = lineClass[2];\n\t      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n\t        output[prop] += \" \" + lineClass[2];\n\t    }\n\t    return type;\n\t  }\n\t\n\t  function callBlankLine(mode, state) {\n\t    if (mode.blankLine) return mode.blankLine(state);\n\t    if (!mode.innerMode) return;\n\t    var inner = CodeMirror.innerMode(mode, state);\n\t    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n\t  }\n\t\n\t  function readToken(mode, stream, state, inner) {\n\t    for (var i = 0; i < 10; i++) {\n\t      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n\t      var style = mode.token(stream, state);\n\t      if (stream.pos > stream.start) return style;\n\t    }\n\t    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n\t  }\n\t\n\t  // Utility for getTokenAt and getLineTokens\n\t  function takeToken(cm, pos, precise, asArray) {\n\t    function getObj(copy) {\n\t      return {start: stream.start, end: stream.pos,\n\t              string: stream.current(),\n\t              type: style || null,\n\t              state: copy ? copyState(doc.mode, state) : state};\n\t    }\n\t\n\t    var doc = cm.doc, mode = doc.mode, style;\n\t    pos = clipPos(doc, pos);\n\t    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n\t    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n\t    if (asArray) tokens = [];\n\t    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n\t      stream.start = stream.pos;\n\t      style = readToken(mode, stream, state);\n\t      if (asArray) tokens.push(getObj(true));\n\t    }\n\t    return asArray ? tokens : getObj();\n\t  }\n\t\n\t  // Run the given mode's parser over a line, calling f for each token.\n\t  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n\t    var flattenSpans = mode.flattenSpans;\n\t    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n\t    var curStart = 0, curStyle = null;\n\t    var stream = new StringStream(text, cm.options.tabSize), style;\n\t    var inner = cm.options.addModeClass && [null];\n\t    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n\t    while (!stream.eol()) {\n\t      if (stream.pos > cm.options.maxHighlightLength) {\n\t        flattenSpans = false;\n\t        if (forceToEnd) processLine(cm, text, state, stream.pos);\n\t        stream.pos = text.length;\n\t        style = null;\n\t      } else {\n\t        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n\t      }\n\t      if (inner) {\n\t        var mName = inner[0].name;\n\t        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n\t      }\n\t      if (!flattenSpans || curStyle != style) {\n\t        while (curStart < stream.start) {\n\t          curStart = Math.min(stream.start, curStart + 50000);\n\t          f(curStart, curStyle);\n\t        }\n\t        curStyle = style;\n\t      }\n\t      stream.start = stream.pos;\n\t    }\n\t    while (curStart < stream.pos) {\n\t      // Webkit seems to refuse to render text nodes longer than 57444 characters\n\t      var pos = Math.min(stream.pos, curStart + 50000);\n\t      f(pos, curStyle);\n\t      curStart = pos;\n\t    }\n\t  }\n\t\n\t  // Compute a style array (an array starting with a mode generation\n\t  // -- for invalidation -- followed by pairs of end positions and\n\t  // style strings), which is used to highlight the tokens on the\n\t  // line.\n\t  function highlightLine(cm, line, state, forceToEnd) {\n\t    // A styles array always starts with a number identifying the\n\t    // mode/overlays that it is based on (for easy invalidation).\n\t    var st = [cm.state.modeGen], lineClasses = {};\n\t    // Compute the base array of styles\n\t    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n\t      st.push(end, style);\n\t    }, lineClasses, forceToEnd);\n\t\n\t    // Run overlays, adjust style array.\n\t    for (var o = 0; o < cm.state.overlays.length; ++o) {\n\t      var overlay = cm.state.overlays[o], i = 1, at = 0;\n\t      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n\t        var start = i;\n\t        // Ensure there's a token end at the current position, and that i points at it\n\t        while (at < end) {\n\t          var i_end = st[i];\n\t          if (i_end > end)\n\t            st.splice(i, 1, end, st[i+1], i_end);\n\t          i += 2;\n\t          at = Math.min(end, i_end);\n\t        }\n\t        if (!style) return;\n\t        if (overlay.opaque) {\n\t          st.splice(start, i - start, end, \"cm-overlay \" + style);\n\t          i = start + 2;\n\t        } else {\n\t          for (; start < i; start += 2) {\n\t            var cur = st[start+1];\n\t            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n\t          }\n\t        }\n\t      }, lineClasses);\n\t    }\n\t\n\t    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n\t  }\n\t\n\t  function getLineStyles(cm, line, updateFrontier) {\n\t    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n\t      var state = getStateBefore(cm, lineNo(line));\n\t      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n\t      line.stateAfter = state;\n\t      line.styles = result.styles;\n\t      if (result.classes) line.styleClasses = result.classes;\n\t      else if (line.styleClasses) line.styleClasses = null;\n\t      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n\t    }\n\t    return line.styles;\n\t  }\n\t\n\t  // Lightweight form of highlight -- proceed over this line and\n\t  // update state, but don't save a style array. Used for lines that\n\t  // aren't currently visible.\n\t  function processLine(cm, text, state, startAt) {\n\t    var mode = cm.doc.mode;\n\t    var stream = new StringStream(text, cm.options.tabSize);\n\t    stream.start = stream.pos = startAt || 0;\n\t    if (text == \"\") callBlankLine(mode, state);\n\t    while (!stream.eol()) {\n\t      readToken(mode, stream, state);\n\t      stream.start = stream.pos;\n\t    }\n\t  }\n\t\n\t  // Convert a style as returned by a mode (either null, or a string\n\t  // containing one or more styles) to a CSS style. This is cached,\n\t  // and also looks for line-wide styles.\n\t  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n\t  function interpretTokenStyle(style, options) {\n\t    if (!style || /^\\s*$/.test(style)) return null;\n\t    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n\t    return cache[style] ||\n\t      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n\t  }\n\t\n\t  // Render the DOM representation of the text of a line. Also builds\n\t  // up a 'line map', which points at the DOM nodes that represent\n\t  // specific stretches of text, and is used by the measuring code.\n\t  // The returned object contains the DOM node, this map, and\n\t  // information about line-wide styles that were set by the mode.\n\t  function buildLineContent(cm, lineView) {\n\t    // The padding-right forces the element to have a 'border', which\n\t    // is needed on Webkit to be able to get line-level bounding\n\t    // rectangles for it (in measureChar).\n\t    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n\t    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n\t                   col: 0, pos: 0, cm: cm,\n\t                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n\t    lineView.measure = {};\n\t\n\t    // Iterate over the logical lines that make up this visual line.\n\t    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n\t      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n\t      builder.pos = 0;\n\t      builder.addToken = buildToken;\n\t      // Optionally wire in some hacks into the token-rendering\n\t      // algorithm, to deal with browser quirks.\n\t      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n\t        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n\t      builder.map = [];\n\t      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n\t      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n\t      if (line.styleClasses) {\n\t        if (line.styleClasses.bgClass)\n\t          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n\t        if (line.styleClasses.textClass)\n\t          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n\t      }\n\t\n\t      // Ensure at least a single node is present, for measuring.\n\t      if (builder.map.length == 0)\n\t        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\t\n\t      // Store the map and a cache object for the current logical line\n\t      if (i == 0) {\n\t        lineView.measure.map = builder.map;\n\t        lineView.measure.cache = {};\n\t      } else {\n\t        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n\t        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n\t      }\n\t    }\n\t\n\t    // See issue #2901\n\t    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\n\t      builder.content.className = \"cm-tab-wrap-hack\";\n\t\n\t    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n\t    if (builder.pre.className)\n\t      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\t\n\t    return builder;\n\t  }\n\t\n\t  function defaultSpecialCharPlaceholder(ch) {\n\t    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n\t    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n\t    token.setAttribute(\"aria-label\", token.title);\n\t    return token;\n\t  }\n\t\n\t  // Build up the DOM representation for a single token, and add it to\n\t  // the line map. Takes care to render special characters separately.\n\t  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n\t    if (!text) return;\n\t    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;\n\t    var special = builder.cm.state.specialChars, mustWrap = false;\n\t    if (!special.test(text)) {\n\t      builder.col += text.length;\n\t      var content = document.createTextNode(displayText);\n\t      builder.map.push(builder.pos, builder.pos + text.length, content);\n\t      if (ie && ie_version < 9) mustWrap = true;\n\t      builder.pos += text.length;\n\t    } else {\n\t      var content = document.createDocumentFragment(), pos = 0;\n\t      while (true) {\n\t        special.lastIndex = pos;\n\t        var m = special.exec(text);\n\t        var skipped = m ? m.index - pos : text.length - pos;\n\t        if (skipped) {\n\t          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.map.push(builder.pos, builder.pos + skipped, txt);\n\t          builder.col += skipped;\n\t          builder.pos += skipped;\n\t        }\n\t        if (!m) break;\n\t        pos += skipped + 1;\n\t        if (m[0] == \"\\t\") {\n\t          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n\t          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n\t          txt.setAttribute(\"role\", \"presentation\");\n\t          txt.setAttribute(\"cm-text\", \"\\t\");\n\t          builder.col += tabWidth;\n\t        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n\t          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          builder.col += 1;\n\t        } else {\n\t          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.col += 1;\n\t        }\n\t        builder.map.push(builder.pos, builder.pos + 1, txt);\n\t        builder.pos++;\n\t      }\n\t    }\n\t    if (style || startStyle || endStyle || mustWrap || css) {\n\t      var fullStyle = style || \"\";\n\t      if (startStyle) fullStyle += startStyle;\n\t      if (endStyle) fullStyle += endStyle;\n\t      var token = elt(\"span\", [content], fullStyle, css);\n\t      if (title) token.title = title;\n\t      return builder.content.appendChild(token);\n\t    }\n\t    builder.content.appendChild(content);\n\t  }\n\t\n\t  function splitSpaces(old) {\n\t    var out = \" \";\n\t    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n\t    out += \" \";\n\t    return out;\n\t  }\n\t\n\t  // Work around nonsense dimensions being reported for stretches of\n\t  // right-to-left text.\n\t  function buildTokenBadBidi(inner, order) {\n\t    return function(builder, text, style, startStyle, endStyle, title, css) {\n\t      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n\t      var start = builder.pos, end = start + text.length;\n\t      for (;;) {\n\t        // Find the part that overlaps with the start of this text\n\t        for (var i = 0; i < order.length; i++) {\n\t          var part = order[i];\n\t          if (part.to > start && part.from <= start) break;\n\t        }\n\t        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n\t        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n\t        startStyle = null;\n\t        text = text.slice(part.to - start);\n\t        start = part.to;\n\t      }\n\t    };\n\t  }\n\t\n\t  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n\t    var widget = !ignoreWidget && marker.widgetNode;\n\t    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n\t    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n\t      if (!widget)\n\t        widget = builder.content.appendChild(document.createElement(\"span\"));\n\t      widget.setAttribute(\"cm-marker\", marker.id);\n\t    }\n\t    if (widget) {\n\t      builder.cm.display.input.setUneditable(widget);\n\t      builder.content.appendChild(widget);\n\t    }\n\t    builder.pos += size;\n\t  }\n\t\n\t  // Outputs a number of spans to make up a line, taking highlighting\n\t  // and marked text into account.\n\t  function insertLineContent(line, builder, styles) {\n\t    var spans = line.markedSpans, allText = line.text, at = 0;\n\t    if (!spans) {\n\t      for (var i = 1; i < styles.length; i+=2)\n\t        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n\t      return;\n\t    }\n\t\n\t    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n\t    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n\t    for (;;) {\n\t      if (nextChange == pos) { // Update current marker set\n\t        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n\t        collapsed = null; nextChange = Infinity;\n\t        var foundBookmarks = [];\n\t        for (var j = 0; j < spans.length; ++j) {\n\t          var sp = spans[j], m = sp.marker;\n\t          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n\t            foundBookmarks.push(m);\n\t          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n\t            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n\t              nextChange = sp.to;\n\t              spanEndStyle = \"\";\n\t            }\n\t            if (m.className) spanStyle += \" \" + m.className;\n\t            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n\t            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n\t            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n\t            if (m.title && !title) title = m.title;\n\t            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n\t              collapsed = sp;\n\t          } else if (sp.from > pos && nextChange > sp.from) {\n\t            nextChange = sp.from;\n\t          }\n\t        }\n\t        if (collapsed && (collapsed.from || 0) == pos) {\n\t          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n\t                             collapsed.marker, collapsed.from == null);\n\t          if (collapsed.to == null) return;\n\t          if (collapsed.to == pos) collapsed = false;\n\t        }\n\t        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n\t          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n\t      }\n\t      if (pos >= len) break;\n\t\n\t      var upto = Math.min(len, nextChange);\n\t      while (true) {\n\t        if (text) {\n\t          var end = pos + text.length;\n\t          if (!collapsed) {\n\t            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n\t            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n\t                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n\t          }\n\t          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n\t          pos = end;\n\t          spanStartStyle = \"\";\n\t        }\n\t        text = allText.slice(at, at = styles[i++]);\n\t        style = interpretTokenStyle(styles[i++], builder.cm.options);\n\t      }\n\t    }\n\t  }\n\t\n\t  // DOCUMENT DATA STRUCTURE\n\t\n\t  // By default, updates that start and end at the beginning of a line\n\t  // are treated specially, in order to make the association of line\n\t  // widgets and marker elements with the text behave more intuitive.\n\t  function isWholeLineUpdate(doc, change) {\n\t    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n\t      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n\t  }\n\t\n\t  // Perform a change on the document data structure.\n\t  function updateDoc(doc, change, markedSpans, estimateHeight) {\n\t    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n\t    function update(line, text, spans) {\n\t      updateLine(line, text, spans, estimateHeight);\n\t      signalLater(line, \"change\", line, change);\n\t    }\n\t    function linesFor(start, end) {\n\t      for (var i = start, result = []; i < end; ++i)\n\t        result.push(new Line(text[i], spansFor(i), estimateHeight));\n\t      return result;\n\t    }\n\t\n\t    var from = change.from, to = change.to, text = change.text;\n\t    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n\t    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\t\n\t    // Adjust the line structure\n\t    if (change.full) {\n\t      doc.insert(0, linesFor(0, text.length));\n\t      doc.remove(text.length, doc.size - text.length);\n\t    } else if (isWholeLineUpdate(doc, change)) {\n\t      // This is a whole-line replace. Treated specially to make\n\t      // sure line objects move the way they are supposed to.\n\t      var added = linesFor(0, text.length - 1);\n\t      update(lastLine, lastLine.text, lastSpans);\n\t      if (nlines) doc.remove(from.line, nlines);\n\t      if (added.length) doc.insert(from.line, added);\n\t    } else if (firstLine == lastLine) {\n\t      if (text.length == 1) {\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n\t      } else {\n\t        var added = linesFor(1, text.length - 1);\n\t        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t        doc.insert(from.line + 1, added);\n\t      }\n\t    } else if (text.length == 1) {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n\t      doc.remove(from.line + 1, nlines);\n\t    } else {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n\t      var added = linesFor(1, text.length - 1);\n\t      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n\t      doc.insert(from.line + 1, added);\n\t    }\n\t\n\t    signalLater(doc, \"change\", doc, change);\n\t  }\n\t\n\t  // The document is represented as a BTree consisting of leaves, with\n\t  // chunk of lines in them, and branches, with up to ten leaves or\n\t  // other branch nodes below them. The top node is always a branch\n\t  // node, and is the document object itself (meaning it has\n\t  // additional methods and properties).\n\t  //\n\t  // All nodes have parent links. The tree is used both to go from\n\t  // line numbers to line objects, and to go from objects to numbers.\n\t  // It also indexes by height, and is used to convert between height\n\t  // and line object, and to find the total height of the document.\n\t  //\n\t  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\t\n\t  function LeafChunk(lines) {\n\t    this.lines = lines;\n\t    this.parent = null;\n\t    for (var i = 0, height = 0; i < lines.length; ++i) {\n\t      lines[i].parent = this;\n\t      height += lines[i].height;\n\t    }\n\t    this.height = height;\n\t  }\n\t\n\t  LeafChunk.prototype = {\n\t    chunkSize: function() { return this.lines.length; },\n\t    // Remove the n lines at offset 'at'.\n\t    removeInner: function(at, n) {\n\t      for (var i = at, e = at + n; i < e; ++i) {\n\t        var line = this.lines[i];\n\t        this.height -= line.height;\n\t        cleanUpLine(line);\n\t        signalLater(line, \"delete\");\n\t      }\n\t      this.lines.splice(at, n);\n\t    },\n\t    // Helper used to collapse a small branch into a single leaf.\n\t    collapse: function(lines) {\n\t      lines.push.apply(lines, this.lines);\n\t    },\n\t    // Insert the given array of lines at offset 'at', count them as\n\t    // having the given height.\n\t    insertInner: function(at, lines, height) {\n\t      this.height += height;\n\t      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\t      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n\t    },\n\t    // Used to iterate over a part of the tree.\n\t    iterN: function(at, n, op) {\n\t      for (var e = at + n; at < e; ++at)\n\t        if (op(this.lines[at])) return true;\n\t    }\n\t  };\n\t\n\t  function BranchChunk(children) {\n\t    this.children = children;\n\t    var size = 0, height = 0;\n\t    for (var i = 0; i < children.length; ++i) {\n\t      var ch = children[i];\n\t      size += ch.chunkSize(); height += ch.height;\n\t      ch.parent = this;\n\t    }\n\t    this.size = size;\n\t    this.height = height;\n\t    this.parent = null;\n\t  }\n\t\n\t  BranchChunk.prototype = {\n\t    chunkSize: function() { return this.size; },\n\t    removeInner: function(at, n) {\n\t      this.size -= n;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var rm = Math.min(n, sz - at), oldHeight = child.height;\n\t          child.removeInner(at, rm);\n\t          this.height -= oldHeight - child.height;\n\t          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n\t          if ((n -= rm) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t      // If the result is smaller than 25 lines, ensure that it is a\n\t      // single leaf node.\n\t      if (this.size - n < 25 &&\n\t          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n\t        var lines = [];\n\t        this.collapse(lines);\n\t        this.children = [new LeafChunk(lines)];\n\t        this.children[0].parent = this;\n\t      }\n\t    },\n\t    collapse: function(lines) {\n\t      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n\t    },\n\t    insertInner: function(at, lines, height) {\n\t      this.size += lines.length;\n\t      this.height += height;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at <= sz) {\n\t          child.insertInner(at, lines, height);\n\t          if (child.lines && child.lines.length > 50) {\n\t            while (child.lines.length > 50) {\n\t              var spilled = child.lines.splice(child.lines.length - 25, 25);\n\t              var newleaf = new LeafChunk(spilled);\n\t              child.height -= newleaf.height;\n\t              this.children.splice(i + 1, 0, newleaf);\n\t              newleaf.parent = this;\n\t            }\n\t            this.maybeSpill();\n\t          }\n\t          break;\n\t        }\n\t        at -= sz;\n\t      }\n\t    },\n\t    // When a node has grown, check whether it should be split.\n\t    maybeSpill: function() {\n\t      if (this.children.length <= 10) return;\n\t      var me = this;\n\t      do {\n\t        var spilled = me.children.splice(me.children.length - 5, 5);\n\t        var sibling = new BranchChunk(spilled);\n\t        if (!me.parent) { // Become the parent node\n\t          var copy = new BranchChunk(me.children);\n\t          copy.parent = me;\n\t          me.children = [copy, sibling];\n\t          me = copy;\n\t        } else {\n\t          me.size -= sibling.size;\n\t          me.height -= sibling.height;\n\t          var myIndex = indexOf(me.parent.children, me);\n\t          me.parent.children.splice(myIndex + 1, 0, sibling);\n\t        }\n\t        sibling.parent = me.parent;\n\t      } while (me.children.length > 10);\n\t      me.parent.maybeSpill();\n\t    },\n\t    iterN: function(at, n, op) {\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var used = Math.min(n, sz - at);\n\t          if (child.iterN(at, used, op)) return true;\n\t          if ((n -= used) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t    }\n\t  };\n\t\n\t  var nextDocId = 0;\n\t  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n\t    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n\t    if (firstLine == null) firstLine = 0;\n\t\n\t    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n\t    this.first = firstLine;\n\t    this.scrollTop = this.scrollLeft = 0;\n\t    this.cantEdit = false;\n\t    this.cleanGeneration = 1;\n\t    this.frontier = firstLine;\n\t    var start = Pos(firstLine, 0);\n\t    this.sel = simpleSelection(start);\n\t    this.history = new History(null);\n\t    this.id = ++nextDocId;\n\t    this.modeOption = mode;\n\t    this.lineSep = lineSep;\n\t    this.extend = false;\n\t\n\t    if (typeof text == \"string\") text = this.splitLines(text);\n\t    updateDoc(this, {from: start, to: start, text: text});\n\t    setSelection(this, simpleSelection(start), sel_dontScroll);\n\t  };\n\t\n\t  Doc.prototype = createObj(BranchChunk.prototype, {\n\t    constructor: Doc,\n\t    // Iterate over the document. Supports two forms -- with only one\n\t    // argument, it calls that for each line in the document. With\n\t    // three, it iterates over the range given by the first two (with\n\t    // the second being non-inclusive).\n\t    iter: function(from, to, op) {\n\t      if (op) this.iterN(from - this.first, to - from, op);\n\t      else this.iterN(this.first, this.first + this.size, from);\n\t    },\n\t\n\t    // Non-public interface for adding and removing lines.\n\t    insert: function(at, lines) {\n\t      var height = 0;\n\t      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n\t      this.insertInner(at - this.first, lines, height);\n\t    },\n\t    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\t\n\t    // From here, the methods are part of the public interface. Most\n\t    // are also available from CodeMirror (editor) instances.\n\t\n\t    getValue: function(lineSep) {\n\t      var lines = getLines(this, this.first, this.first + this.size);\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    setValue: docMethodOp(function(code) {\n\t      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n\t      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n\t                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n\t      setSelection(this, simpleSelection(top));\n\t    }),\n\t    replaceRange: function(code, from, to, origin) {\n\t      from = clipPos(this, from);\n\t      to = to ? clipPos(this, to) : from;\n\t      replaceRange(this, code, from, to, origin);\n\t    },\n\t    getRange: function(from, to, lineSep) {\n\t      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t\n\t    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\t\n\t    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n\t    getLineNumber: function(line) {return lineNo(line);},\n\t\n\t    getLineHandleVisualStart: function(line) {\n\t      if (typeof line == \"number\") line = getLine(this, line);\n\t      return visualLine(line);\n\t    },\n\t\n\t    lineCount: function() {return this.size;},\n\t    firstLine: function() {return this.first;},\n\t    lastLine: function() {return this.first + this.size - 1;},\n\t\n\t    clipPos: function(pos) {return clipPos(this, pos);},\n\t\n\t    getCursor: function(start) {\n\t      var range = this.sel.primary(), pos;\n\t      if (start == null || start == \"head\") pos = range.head;\n\t      else if (start == \"anchor\") pos = range.anchor;\n\t      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n\t      else pos = range.from();\n\t      return pos;\n\t    },\n\t    listSelections: function() { return this.sel.ranges; },\n\t    somethingSelected: function() {return this.sel.somethingSelected();},\n\t\n\t    setCursor: docMethodOp(function(line, ch, options) {\n\t      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n\t    }),\n\t    setSelection: docMethodOp(function(anchor, head, options) {\n\t      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n\t    }),\n\t    extendSelection: docMethodOp(function(head, other, options) {\n\t      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n\t    }),\n\t    extendSelections: docMethodOp(function(heads, options) {\n\t      extendSelections(this, clipPosArray(this, heads, options));\n\t    }),\n\t    extendSelectionsBy: docMethodOp(function(f, options) {\n\t      extendSelections(this, map(this.sel.ranges, f), options);\n\t    }),\n\t    setSelections: docMethodOp(function(ranges, primary, options) {\n\t      if (!ranges.length) return;\n\t      for (var i = 0, out = []; i < ranges.length; i++)\n\t        out[i] = new Range(clipPos(this, ranges[i].anchor),\n\t                           clipPos(this, ranges[i].head));\n\t      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n\t      setSelection(this, normalizeSelection(out, primary), options);\n\t    }),\n\t    addSelection: docMethodOp(function(anchor, head, options) {\n\t      var ranges = this.sel.ranges.slice(0);\n\t      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n\t      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n\t    }),\n\t\n\t    getSelection: function(lineSep) {\n\t      var ranges = this.sel.ranges, lines;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        lines = lines ? lines.concat(sel) : sel;\n\t      }\n\t      if (lineSep === false) return lines;\n\t      else return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    getSelections: function(lineSep) {\n\t      var parts = [], ranges = this.sel.ranges;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n\t        parts[i] = sel;\n\t      }\n\t      return parts;\n\t    },\n\t    replaceSelection: function(code, collapse, origin) {\n\t      var dup = [];\n\t      for (var i = 0; i < this.sel.ranges.length; i++)\n\t        dup[i] = code;\n\t      this.replaceSelections(dup, collapse, origin || \"+input\");\n\t    },\n\t    replaceSelections: docMethodOp(function(code, collapse, origin) {\n\t      var changes = [], sel = this.sel;\n\t      for (var i = 0; i < sel.ranges.length; i++) {\n\t        var range = sel.ranges[i];\n\t        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n\t      }\n\t      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n\t      for (var i = changes.length - 1; i >= 0; i--)\n\t        makeChange(this, changes[i]);\n\t      if (newSel) setSelectionReplaceHistory(this, newSel);\n\t      else if (this.cm) ensureCursorVisible(this.cm);\n\t    }),\n\t    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n\t    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n\t    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n\t    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\t\n\t    setExtending: function(val) {this.extend = val;},\n\t    getExtending: function() {return this.extend;},\n\t\n\t    historySize: function() {\n\t      var hist = this.history, done = 0, undone = 0;\n\t      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n\t      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n\t      return {undo: done, redo: undone};\n\t    },\n\t    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\t\n\t    markClean: function() {\n\t      this.cleanGeneration = this.changeGeneration(true);\n\t    },\n\t    changeGeneration: function(forceSplit) {\n\t      if (forceSplit)\n\t        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n\t      return this.history.generation;\n\t    },\n\t    isClean: function (gen) {\n\t      return this.history.generation == (gen || this.cleanGeneration);\n\t    },\n\t\n\t    getHistory: function() {\n\t      return {done: copyHistoryArray(this.history.done),\n\t              undone: copyHistoryArray(this.history.undone)};\n\t    },\n\t    setHistory: function(histData) {\n\t      var hist = this.history = new History(this.history.maxGeneration);\n\t      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n\t      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n\t    },\n\t\n\t    addLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        if (!line[prop]) line[prop] = cls;\n\t        else if (classTest(cls).test(line[prop])) return false;\n\t        else line[prop] += \" \" + cls;\n\t        return true;\n\t      });\n\t    }),\n\t    removeLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        var cur = line[prop];\n\t        if (!cur) return false;\n\t        else if (cls == null) line[prop] = null;\n\t        else {\n\t          var found = cur.match(classTest(cls));\n\t          if (!found) return false;\n\t          var end = found.index + found[0].length;\n\t          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n\t        }\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    addLineWidget: docMethodOp(function(handle, node, options) {\n\t      return addLineWidget(this, handle, node, options);\n\t    }),\n\t    removeLineWidget: function(widget) { widget.clear(); },\n\t\n\t    markText: function(from, to, options) {\n\t      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n\t    },\n\t    setBookmark: function(pos, options) {\n\t      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n\t                      insertLeft: options && options.insertLeft,\n\t                      clearWhenEmpty: false, shared: options && options.shared,\n\t                      handleMouseEvents: options && options.handleMouseEvents};\n\t      pos = clipPos(this, pos);\n\t      return markText(this, pos, pos, realOpts, \"bookmark\");\n\t    },\n\t    findMarksAt: function(pos) {\n\t      pos = clipPos(this, pos);\n\t      var markers = [], spans = getLine(this, pos.line).markedSpans;\n\t      if (spans) for (var i = 0; i < spans.length; ++i) {\n\t        var span = spans[i];\n\t        if ((span.from == null || span.from <= pos.ch) &&\n\t            (span.to == null || span.to >= pos.ch))\n\t          markers.push(span.marker.parent || span.marker);\n\t      }\n\t      return markers;\n\t    },\n\t    findMarks: function(from, to, filter) {\n\t      from = clipPos(this, from); to = clipPos(this, to);\n\t      var found = [], lineNo = from.line;\n\t      this.iter(from.line, to.line + 1, function(line) {\n\t        var spans = line.markedSpans;\n\t        if (spans) for (var i = 0; i < spans.length; i++) {\n\t          var span = spans[i];\n\t          if (!(lineNo == from.line && from.ch > span.to ||\n\t                span.from == null && lineNo != from.line||\n\t                lineNo == to.line && span.from > to.ch) &&\n\t              (!filter || filter(span.marker)))\n\t            found.push(span.marker.parent || span.marker);\n\t        }\n\t        ++lineNo;\n\t      });\n\t      return found;\n\t    },\n\t    getAllMarks: function() {\n\t      var markers = [];\n\t      this.iter(function(line) {\n\t        var sps = line.markedSpans;\n\t        if (sps) for (var i = 0; i < sps.length; ++i)\n\t          if (sps[i].from != null) markers.push(sps[i].marker);\n\t      });\n\t      return markers;\n\t    },\n\t\n\t    posFromIndex: function(off) {\n\t      var ch, lineNo = this.first;\n\t      this.iter(function(line) {\n\t        var sz = line.text.length + 1;\n\t        if (sz > off) { ch = off; return true; }\n\t        off -= sz;\n\t        ++lineNo;\n\t      });\n\t      return clipPos(this, Pos(lineNo, ch));\n\t    },\n\t    indexFromPos: function (coords) {\n\t      coords = clipPos(this, coords);\n\t      var index = coords.ch;\n\t      if (coords.line < this.first || coords.ch < 0) return 0;\n\t      this.iter(this.first, coords.line, function (line) {\n\t        index += line.text.length + 1;\n\t      });\n\t      return index;\n\t    },\n\t\n\t    copy: function(copyHistory) {\n\t      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n\t                        this.modeOption, this.first, this.lineSep);\n\t      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n\t      doc.sel = this.sel;\n\t      doc.extend = false;\n\t      if (copyHistory) {\n\t        doc.history.undoDepth = this.history.undoDepth;\n\t        doc.setHistory(this.getHistory());\n\t      }\n\t      return doc;\n\t    },\n\t\n\t    linkedDoc: function(options) {\n\t      if (!options) options = {};\n\t      var from = this.first, to = this.first + this.size;\n\t      if (options.from != null && options.from > from) from = options.from;\n\t      if (options.to != null && options.to < to) to = options.to;\n\t      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n\t      if (options.sharedHist) copy.history = this.history;\n\t      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n\t      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n\t      copySharedMarkers(copy, findSharedMarkers(this));\n\t      return copy;\n\t    },\n\t    unlinkDoc: function(other) {\n\t      if (other instanceof CodeMirror) other = other.doc;\n\t      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n\t        var link = this.linked[i];\n\t        if (link.doc != other) continue;\n\t        this.linked.splice(i, 1);\n\t        other.unlinkDoc(this);\n\t        detachSharedMarkers(findSharedMarkers(this));\n\t        break;\n\t      }\n\t      // If the histories were shared, split them again\n\t      if (other.history == this.history) {\n\t        var splitIds = [other.id];\n\t        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n\t        other.history = new History(null);\n\t        other.history.done = copyHistoryArray(this.history.done, splitIds);\n\t        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n\t      }\n\t    },\n\t    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\t\n\t    getMode: function() {return this.mode;},\n\t    getEditor: function() {return this.cm;},\n\t\n\t    splitLines: function(str) {\n\t      if (this.lineSep) return str.split(this.lineSep);\n\t      return splitLinesAuto(str);\n\t    },\n\t    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n\t  });\n\t\n\t  // Public alias.\n\t  Doc.prototype.eachLine = Doc.prototype.iter;\n\t\n\t  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n\t  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n\t  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n\t    CodeMirror.prototype[prop] = (function(method) {\n\t      return function() {return method.apply(this.doc, arguments);};\n\t    })(Doc.prototype[prop]);\n\t\n\t  eventMixin(Doc);\n\t\n\t  // Call f for all linked documents.\n\t  function linkedDocs(doc, f, sharedHistOnly) {\n\t    function propagate(doc, skip, sharedHist) {\n\t      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n\t        var rel = doc.linked[i];\n\t        if (rel.doc == skip) continue;\n\t        var shared = sharedHist && rel.sharedHist;\n\t        if (sharedHistOnly && !shared) continue;\n\t        f(rel.doc, shared);\n\t        propagate(rel.doc, doc, shared);\n\t      }\n\t    }\n\t    propagate(doc, null, true);\n\t  }\n\t\n\t  // Attach a document to an editor.\n\t  function attachDoc(cm, doc) {\n\t    if (doc.cm) throw new Error(\"This document is already in use.\");\n\t    cm.doc = doc;\n\t    doc.cm = cm;\n\t    estimateLineHeights(cm);\n\t    loadMode(cm);\n\t    if (!cm.options.lineWrapping) findMaxLine(cm);\n\t    cm.options.mode = doc.modeOption;\n\t    regChange(cm);\n\t  }\n\t\n\t  // LINE UTILITIES\n\t\n\t  // Find the line object corresponding to the given line number.\n\t  function getLine(doc, n) {\n\t    n -= doc.first;\n\t    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n\t    for (var chunk = doc; !chunk.lines;) {\n\t      for (var i = 0;; ++i) {\n\t        var child = chunk.children[i], sz = child.chunkSize();\n\t        if (n < sz) { chunk = child; break; }\n\t        n -= sz;\n\t      }\n\t    }\n\t    return chunk.lines[n];\n\t  }\n\t\n\t  // Get the part of a document between two positions, as an array of\n\t  // strings.\n\t  function getBetween(doc, start, end) {\n\t    var out = [], n = start.line;\n\t    doc.iter(start.line, end.line + 1, function(line) {\n\t      var text = line.text;\n\t      if (n == end.line) text = text.slice(0, end.ch);\n\t      if (n == start.line) text = text.slice(start.ch);\n\t      out.push(text);\n\t      ++n;\n\t    });\n\t    return out;\n\t  }\n\t  // Get the lines between from and to, as array of strings.\n\t  function getLines(doc, from, to) {\n\t    var out = [];\n\t    doc.iter(from, to, function(line) { out.push(line.text); });\n\t    return out;\n\t  }\n\t\n\t  // Update the height of a line, propagating the height change\n\t  // upwards to parent nodes.\n\t  function updateLineHeight(line, height) {\n\t    var diff = height - line.height;\n\t    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n\t  }\n\t\n\t  // Given a line object, find its line number by walking up through\n\t  // its parent links.\n\t  function lineNo(line) {\n\t    if (line.parent == null) return null;\n\t    var cur = line.parent, no = indexOf(cur.lines, line);\n\t    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n\t      for (var i = 0;; ++i) {\n\t        if (chunk.children[i] == cur) break;\n\t        no += chunk.children[i].chunkSize();\n\t      }\n\t    }\n\t    return no + cur.first;\n\t  }\n\t\n\t  // Find the line at the given vertical position, using the height\n\t  // information in the document tree.\n\t  function lineAtHeight(chunk, h) {\n\t    var n = chunk.first;\n\t    outer: do {\n\t      for (var i = 0; i < chunk.children.length; ++i) {\n\t        var child = chunk.children[i], ch = child.height;\n\t        if (h < ch) { chunk = child; continue outer; }\n\t        h -= ch;\n\t        n += child.chunkSize();\n\t      }\n\t      return n;\n\t    } while (!chunk.lines);\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i], lh = line.height;\n\t      if (h < lh) break;\n\t      h -= lh;\n\t    }\n\t    return n + i;\n\t  }\n\t\n\t\n\t  // Find the height above the given line.\n\t  function heightAtLine(lineObj) {\n\t    lineObj = visualLine(lineObj);\n\t\n\t    var h = 0, chunk = lineObj.parent;\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i];\n\t      if (line == lineObj) break;\n\t      else h += line.height;\n\t    }\n\t    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n\t      for (var i = 0; i < p.children.length; ++i) {\n\t        var cur = p.children[i];\n\t        if (cur == chunk) break;\n\t        else h += cur.height;\n\t      }\n\t    }\n\t    return h;\n\t  }\n\t\n\t  // Get the bidi ordering for the given line (and cache it). Returns\n\t  // false for lines that are fully left-to-right, and an array of\n\t  // BidiSpan objects otherwise.\n\t  function getOrder(line) {\n\t    var order = line.order;\n\t    if (order == null) order = line.order = bidiOrdering(line.text);\n\t    return order;\n\t  }\n\t\n\t  // HISTORY\n\t\n\t  function History(startGen) {\n\t    // Arrays of change events and selections. Doing something adds an\n\t    // event to done and clears undo. Undoing moves events from done\n\t    // to undone, redoing moves them in the other direction.\n\t    this.done = []; this.undone = [];\n\t    this.undoDepth = Infinity;\n\t    // Used to track when changes can be merged into a single undo\n\t    // event\n\t    this.lastModTime = this.lastSelTime = 0;\n\t    this.lastOp = this.lastSelOp = null;\n\t    this.lastOrigin = this.lastSelOrigin = null;\n\t    // Used by the isClean() method\n\t    this.generation = this.maxGeneration = startGen || 1;\n\t  }\n\t\n\t  // Create a history change event from an updateDoc-style change\n\t  // object.\n\t  function historyChangeFromChange(doc, change) {\n\t    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n\t    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n\t    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n\t    return histChange;\n\t  }\n\t\n\t  // Pop all selection events off the end of a history array. Stop at\n\t  // a change event.\n\t  function clearSelectionEvents(array) {\n\t    while (array.length) {\n\t      var last = lst(array);\n\t      if (last.ranges) array.pop();\n\t      else break;\n\t    }\n\t  }\n\t\n\t  // Find the top change event in the history. Pop off selection\n\t  // events that are in the way.\n\t  function lastChangeEvent(hist, force) {\n\t    if (force) {\n\t      clearSelectionEvents(hist.done);\n\t      return lst(hist.done);\n\t    } else if (hist.done.length && !lst(hist.done).ranges) {\n\t      return lst(hist.done);\n\t    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n\t      hist.done.pop();\n\t      return lst(hist.done);\n\t    }\n\t  }\n\t\n\t  // Register a change in the history. Merges changes that are within\n\t  // a single operation, ore are close together with an origin that\n\t  // allows merging (starting with \"+\") into a single event.\n\t  function addChangeToHistory(doc, change, selAfter, opId) {\n\t    var hist = doc.history;\n\t    hist.undone.length = 0;\n\t    var time = +new Date, cur;\n\t\n\t    if ((hist.lastOp == opId ||\n\t         hist.lastOrigin == change.origin && change.origin &&\n\t         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n\t          change.origin.charAt(0) == \"*\")) &&\n\t        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n\t      // Merge this change into the last event\n\t      var last = lst(cur.changes);\n\t      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n\t        // Optimized case for simple insertion -- don't want to add\n\t        // new changesets for every character typed\n\t        last.to = changeEnd(change);\n\t      } else {\n\t        // Add new sub-event\n\t        cur.changes.push(historyChangeFromChange(doc, change));\n\t      }\n\t    } else {\n\t      // Can not be merged, start a new event.\n\t      var before = lst(hist.done);\n\t      if (!before || !before.ranges)\n\t        pushSelectionToHistory(doc.sel, hist.done);\n\t      cur = {changes: [historyChangeFromChange(doc, change)],\n\t             generation: hist.generation};\n\t      hist.done.push(cur);\n\t      while (hist.done.length > hist.undoDepth) {\n\t        hist.done.shift();\n\t        if (!hist.done[0].ranges) hist.done.shift();\n\t      }\n\t    }\n\t    hist.done.push(selAfter);\n\t    hist.generation = ++hist.maxGeneration;\n\t    hist.lastModTime = hist.lastSelTime = time;\n\t    hist.lastOp = hist.lastSelOp = opId;\n\t    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\t\n\t    if (!last) signal(doc, \"historyAdded\");\n\t  }\n\t\n\t  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n\t    var ch = origin.charAt(0);\n\t    return ch == \"*\" ||\n\t      ch == \"+\" &&\n\t      prev.ranges.length == sel.ranges.length &&\n\t      prev.somethingSelected() == sel.somethingSelected() &&\n\t      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n\t  }\n\t\n\t  // Called whenever the selection changes, sets the new selection as\n\t  // the pending selection in the history, and pushes the old pending\n\t  // selection into the 'done' array when it was significantly\n\t  // different (in number of selected ranges, emptiness, or time).\n\t  function addSelectionToHistory(doc, sel, opId, options) {\n\t    var hist = doc.history, origin = options && options.origin;\n\t\n\t    // A new event is started when the previous origin does not match\n\t    // the current, or the origins don't allow matching. Origins\n\t    // starting with * are always merged, those starting with + are\n\t    // merged when similar and close together in time.\n\t    if (opId == hist.lastSelOp ||\n\t        (origin && hist.lastSelOrigin == origin &&\n\t         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n\t          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n\t      hist.done[hist.done.length - 1] = sel;\n\t    else\n\t      pushSelectionToHistory(sel, hist.done);\n\t\n\t    hist.lastSelTime = +new Date;\n\t    hist.lastSelOrigin = origin;\n\t    hist.lastSelOp = opId;\n\t    if (options && options.clearRedo !== false)\n\t      clearSelectionEvents(hist.undone);\n\t  }\n\t\n\t  function pushSelectionToHistory(sel, dest) {\n\t    var top = lst(dest);\n\t    if (!(top && top.ranges && top.equals(sel)))\n\t      dest.push(sel);\n\t  }\n\t\n\t  // Used to store marked span information in the history.\n\t  function attachLocalSpans(doc, change, from, to) {\n\t    var existing = change[\"spans_\" + doc.id], n = 0;\n\t    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n\t      if (line.markedSpans)\n\t        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n\t      ++n;\n\t    });\n\t  }\n\t\n\t  // When un/re-doing restores text containing marked spans, those\n\t  // that have been explicitly cleared should not be restored.\n\t  function removeClearedSpans(spans) {\n\t    if (!spans) return null;\n\t    for (var i = 0, out; i < spans.length; ++i) {\n\t      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n\t      else if (out) out.push(spans[i]);\n\t    }\n\t    return !out ? spans : out.length ? out : null;\n\t  }\n\t\n\t  // Retrieve and filter the old marked spans stored in a change event.\n\t  function getOldSpans(doc, change) {\n\t    var found = change[\"spans_\" + doc.id];\n\t    if (!found) return null;\n\t    for (var i = 0, nw = []; i < change.text.length; ++i)\n\t      nw.push(removeClearedSpans(found[i]));\n\t    return nw;\n\t  }\n\t\n\t  // Used both to provide a JSON-safe object in .getHistory, and, when\n\t  // detaching a document, to split the history in two\n\t  function copyHistoryArray(events, newGroup, instantiateSel) {\n\t    for (var i = 0, copy = []; i < events.length; ++i) {\n\t      var event = events[i];\n\t      if (event.ranges) {\n\t        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n\t        continue;\n\t      }\n\t      var changes = event.changes, newChanges = [];\n\t      copy.push({changes: newChanges});\n\t      for (var j = 0; j < changes.length; ++j) {\n\t        var change = changes[j], m;\n\t        newChanges.push({from: change.from, to: change.to, text: change.text});\n\t        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n\t          if (indexOf(newGroup, Number(m[1])) > -1) {\n\t            lst(newChanges)[prop] = change[prop];\n\t            delete change[prop];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return copy;\n\t  }\n\t\n\t  // Rebasing/resetting history to deal with externally-sourced changes\n\t\n\t  function rebaseHistSelSingle(pos, from, to, diff) {\n\t    if (to < pos.line) {\n\t      pos.line += diff;\n\t    } else if (from < pos.line) {\n\t      pos.line = from;\n\t      pos.ch = 0;\n\t    }\n\t  }\n\t\n\t  // Tries to rebase an array of history events given a change in the\n\t  // document. If the change touches the same lines as the event, the\n\t  // event, and everything 'behind' it, is discarded. If the change is\n\t  // before the event, the event's positions are updated. Uses a\n\t  // copy-on-write scheme for the positions, to avoid having to\n\t  // reallocate them all on every rebase, but also avoid problems with\n\t  // shared position objects being unsafely updated.\n\t  function rebaseHistArray(array, from, to, diff) {\n\t    for (var i = 0; i < array.length; ++i) {\n\t      var sub = array[i], ok = true;\n\t      if (sub.ranges) {\n\t        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n\t        for (var j = 0; j < sub.ranges.length; j++) {\n\t          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n\t          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n\t        }\n\t        continue;\n\t      }\n\t      for (var j = 0; j < sub.changes.length; ++j) {\n\t        var cur = sub.changes[j];\n\t        if (to < cur.from.line) {\n\t          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n\t          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n\t        } else if (from <= cur.to.line) {\n\t          ok = false;\n\t          break;\n\t        }\n\t      }\n\t      if (!ok) {\n\t        array.splice(0, i + 1);\n\t        i = 0;\n\t      }\n\t    }\n\t  }\n\t\n\t  function rebaseHist(hist, change) {\n\t    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n\t    rebaseHistArray(hist.done, from, to, diff);\n\t    rebaseHistArray(hist.undone, from, to, diff);\n\t  }\n\t\n\t  // EVENT UTILITIES\n\t\n\t  // Due to the fact that we still support jurassic IE versions, some\n\t  // compatibility wrappers are needed.\n\t\n\t  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n\t    if (e.preventDefault) e.preventDefault();\n\t    else e.returnValue = false;\n\t  };\n\t  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n\t    if (e.stopPropagation) e.stopPropagation();\n\t    else e.cancelBubble = true;\n\t  };\n\t  function e_defaultPrevented(e) {\n\t    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n\t  }\n\t  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\t\n\t  function e_target(e) {return e.target || e.srcElement;}\n\t  function e_button(e) {\n\t    var b = e.which;\n\t    if (b == null) {\n\t      if (e.button & 1) b = 1;\n\t      else if (e.button & 2) b = 3;\n\t      else if (e.button & 4) b = 2;\n\t    }\n\t    if (mac && e.ctrlKey && b == 1) b = 3;\n\t    return b;\n\t  }\n\t\n\t  // EVENT HANDLING\n\t\n\t  // Lightweight event framework. on/off also work on DOM nodes,\n\t  // registering native DOM handlers.\n\t\n\t  var on = CodeMirror.on = function(emitter, type, f) {\n\t    if (emitter.addEventListener)\n\t      emitter.addEventListener(type, f, false);\n\t    else if (emitter.attachEvent)\n\t      emitter.attachEvent(\"on\" + type, f);\n\t    else {\n\t      var map = emitter._handlers || (emitter._handlers = {});\n\t      var arr = map[type] || (map[type] = []);\n\t      arr.push(f);\n\t    }\n\t  };\n\t\n\t  var noHandlers = []\n\t  function getHandlers(emitter, type, copy) {\n\t    var arr = emitter._handlers && emitter._handlers[type]\n\t    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n\t    else return arr || noHandlers\n\t  }\n\t\n\t  var off = CodeMirror.off = function(emitter, type, f) {\n\t    if (emitter.removeEventListener)\n\t      emitter.removeEventListener(type, f, false);\n\t    else if (emitter.detachEvent)\n\t      emitter.detachEvent(\"on\" + type, f);\n\t    else {\n\t      var handlers = getHandlers(emitter, type, false)\n\t      for (var i = 0; i < handlers.length; ++i)\n\t        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n\t    }\n\t  };\n\t\n\t  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n\t    var handlers = getHandlers(emitter, type, true)\n\t    if (!handlers.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n\t  };\n\t\n\t  var orphanDelayedCallbacks = null;\n\t\n\t  // Often, we want to signal events at a point where we are in the\n\t  // middle of some work, but don't want the handler to start calling\n\t  // other methods on the editor, which might be in an inconsistent\n\t  // state or simply not expect any other events to happen.\n\t  // signalLater looks whether there are any handlers, and schedules\n\t  // them to be executed when the last operation ends, or, if no\n\t  // operation is active, when a timeout fires.\n\t  function signalLater(emitter, type /*, values...*/) {\n\t    var arr = getHandlers(emitter, type, false)\n\t    if (!arr.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2), list;\n\t    if (operationGroup) {\n\t      list = operationGroup.delayedCallbacks;\n\t    } else if (orphanDelayedCallbacks) {\n\t      list = orphanDelayedCallbacks;\n\t    } else {\n\t      list = orphanDelayedCallbacks = [];\n\t      setTimeout(fireOrphanDelayed, 0);\n\t    }\n\t    function bnd(f) {return function(){f.apply(null, args);};};\n\t    for (var i = 0; i < arr.length; ++i)\n\t      list.push(bnd(arr[i]));\n\t  }\n\t\n\t  function fireOrphanDelayed() {\n\t    var delayed = orphanDelayedCallbacks;\n\t    orphanDelayedCallbacks = null;\n\t    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n\t  }\n\t\n\t  // The DOM events that CodeMirror handles can be overridden by\n\t  // registering a (non-DOM) handler on the editor for the event name,\n\t  // and preventDefault-ing the event in that handler.\n\t  function signalDOMEvent(cm, e, override) {\n\t    if (typeof e == \"string\")\n\t      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n\t    signal(cm, override || e.type, cm, e);\n\t    return e_defaultPrevented(e) || e.codemirrorIgnore;\n\t  }\n\t\n\t  function signalCursorActivity(cm) {\n\t    var arr = cm._handlers && cm._handlers.cursorActivity;\n\t    if (!arr) return;\n\t    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n\t    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n\t      set.push(arr[i]);\n\t  }\n\t\n\t  function hasHandler(emitter, type) {\n\t    return getHandlers(emitter, type).length > 0\n\t  }\n\t\n\t  // Add on and off methods to a constructor's prototype, to make\n\t  // registering events on such objects more convenient.\n\t  function eventMixin(ctor) {\n\t    ctor.prototype.on = function(type, f) {on(this, type, f);};\n\t    ctor.prototype.off = function(type, f) {off(this, type, f);};\n\t  }\n\t\n\t  // MISC UTILITIES\n\t\n\t  // Number of pixels added to scroller and sizer to hide scrollbar\n\t  var scrollerGap = 30;\n\t\n\t  // Returned or thrown by various protocols to signal 'I'm not\n\t  // handling this'.\n\t  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\t\n\t  // Reused option objects for setSelection & friends\n\t  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\t\n\t  function Delayed() {this.id = null;}\n\t  Delayed.prototype.set = function(ms, f) {\n\t    clearTimeout(this.id);\n\t    this.id = setTimeout(f, ms);\n\t  };\n\t\n\t  // Counts the column offset in a string, taking tabs into account.\n\t  // Used mostly to find indentation.\n\t  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n\t    if (end == null) {\n\t      end = string.search(/[^\\s\\u00a0]/);\n\t      if (end == -1) end = string.length;\n\t    }\n\t    for (var i = startIndex || 0, n = startValue || 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", i);\n\t      if (nextTab < 0 || nextTab >= end)\n\t        return n + (end - i);\n\t      n += nextTab - i;\n\t      n += tabSize - (n % tabSize);\n\t      i = nextTab + 1;\n\t    }\n\t  };\n\t\n\t  // The inverse of countColumn -- find the offset that corresponds to\n\t  // a particular column.\n\t  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n\t    for (var pos = 0, col = 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", pos);\n\t      if (nextTab == -1) nextTab = string.length;\n\t      var skipped = nextTab - pos;\n\t      if (nextTab == string.length || col + skipped >= goal)\n\t        return pos + Math.min(skipped, goal - col);\n\t      col += nextTab - pos;\n\t      col += tabSize - (col % tabSize);\n\t      pos = nextTab + 1;\n\t      if (col >= goal) return pos;\n\t    }\n\t  }\n\t\n\t  var spaceStrs = [\"\"];\n\t  function spaceStr(n) {\n\t    while (spaceStrs.length <= n)\n\t      spaceStrs.push(lst(spaceStrs) + \" \");\n\t    return spaceStrs[n];\n\t  }\n\t\n\t  function lst(arr) { return arr[arr.length-1]; }\n\t\n\t  var selectInput = function(node) { node.select(); };\n\t  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n\t    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n\t  else if (ie) // Suppress mysterious IE10 errors\n\t    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\t\n\t  function indexOf(array, elt) {\n\t    for (var i = 0; i < array.length; ++i)\n\t      if (array[i] == elt) return i;\n\t    return -1;\n\t  }\n\t  function map(array, f) {\n\t    var out = [];\n\t    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n\t    return out;\n\t  }\n\t\n\t  function nothing() {}\n\t\n\t  function createObj(base, props) {\n\t    var inst;\n\t    if (Object.create) {\n\t      inst = Object.create(base);\n\t    } else {\n\t      nothing.prototype = base;\n\t      inst = new nothing();\n\t    }\n\t    if (props) copyObj(props, inst);\n\t    return inst;\n\t  };\n\t\n\t  function copyObj(obj, target, overwrite) {\n\t    if (!target) target = {};\n\t    for (var prop in obj)\n\t      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n\t        target[prop] = obj[prop];\n\t    return target;\n\t  }\n\t\n\t  function bind(f) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    return function(){return f.apply(null, args);};\n\t  }\n\t\n\t  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\t  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n\t    return /\\w/.test(ch) || ch > \"\\x80\" &&\n\t      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n\t  };\n\t  function isWordChar(ch, helper) {\n\t    if (!helper) return isWordCharBasic(ch);\n\t    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n\t    return helper.test(ch);\n\t  }\n\t\n\t  function isEmpty(obj) {\n\t    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n\t    return true;\n\t  }\n\t\n\t  // Extending unicode characters. A series of a non-extending char +\n\t  // any number of extending chars is treated as a single unit as far\n\t  // as editing and measuring is concerned. This is not fully correct,\n\t  // since some scripts/fonts/browsers also treat other configurations\n\t  // of code points as a group.\n\t  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\t  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\t\n\t  // DOM UTILITIES\n\t\n\t  function elt(tag, content, className, style) {\n\t    var e = document.createElement(tag);\n\t    if (className) e.className = className;\n\t    if (style) e.style.cssText = style;\n\t    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n\t    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n\t    return e;\n\t  }\n\t\n\t  var range;\n\t  if (document.createRange) range = function(node, start, end, endNode) {\n\t    var r = document.createRange();\n\t    r.setEnd(endNode || node, end);\n\t    r.setStart(node, start);\n\t    return r;\n\t  };\n\t  else range = function(node, start, end) {\n\t    var r = document.body.createTextRange();\n\t    try { r.moveToElementText(node.parentNode); }\n\t    catch(e) { return r; }\n\t    r.collapse(true);\n\t    r.moveEnd(\"character\", end);\n\t    r.moveStart(\"character\", start);\n\t    return r;\n\t  };\n\t\n\t  function removeChildren(e) {\n\t    for (var count = e.childNodes.length; count > 0; --count)\n\t      e.removeChild(e.firstChild);\n\t    return e;\n\t  }\n\t\n\t  function removeChildrenAndAdd(parent, e) {\n\t    return removeChildren(parent).appendChild(e);\n\t  }\n\t\n\t  var contains = CodeMirror.contains = function(parent, child) {\n\t    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n\t      child = child.parentNode;\n\t    if (parent.contains)\n\t      return parent.contains(child);\n\t    do {\n\t      if (child.nodeType == 11) child = child.host;\n\t      if (child == parent) return true;\n\t    } while (child = child.parentNode);\n\t  };\n\t\n\t  function activeElt() {\n\t    var activeElement = document.activeElement;\n\t    while (activeElement && activeElement.root && activeElement.root.activeElement)\n\t      activeElement = activeElement.root.activeElement;\n\t    return activeElement;\n\t  }\n\t  // Older versions of IE throws unspecified error when touching\n\t  // document.activeElement in some cases (during loading, in iframe)\n\t  if (ie && ie_version < 11) activeElt = function() {\n\t    try { return document.activeElement; }\n\t    catch(e) { return document.body; }\n\t  };\n\t\n\t  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n\t  var rmClass = CodeMirror.rmClass = function(node, cls) {\n\t    var current = node.className;\n\t    var match = classTest(cls).exec(current);\n\t    if (match) {\n\t      var after = current.slice(match.index + match[0].length);\n\t      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n\t    }\n\t  };\n\t  var addClass = CodeMirror.addClass = function(node, cls) {\n\t    var current = node.className;\n\t    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n\t  };\n\t  function joinClasses(a, b) {\n\t    var as = a.split(\" \");\n\t    for (var i = 0; i < as.length; i++)\n\t      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n\t    return b;\n\t  }\n\t\n\t  // WINDOW-WIDE EVENTS\n\t\n\t  // These must be handled carefully, because naively registering a\n\t  // handler for each editor will cause the editors to never be\n\t  // garbage collected.\n\t\n\t  function forEachCodeMirror(f) {\n\t    if (!document.body.getElementsByClassName) return;\n\t    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n\t    for (var i = 0; i < byClass.length; i++) {\n\t      var cm = byClass[i].CodeMirror;\n\t      if (cm) f(cm);\n\t    }\n\t  }\n\t\n\t  var globalsRegistered = false;\n\t  function ensureGlobalHandlers() {\n\t    if (globalsRegistered) return;\n\t    registerGlobalHandlers();\n\t    globalsRegistered = true;\n\t  }\n\t  function registerGlobalHandlers() {\n\t    // When the window resizes, we need to refresh active editors.\n\t    var resizeTimer;\n\t    on(window, \"resize\", function() {\n\t      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n\t        resizeTimer = null;\n\t        forEachCodeMirror(onResize);\n\t      }, 100);\n\t    });\n\t    // When the window loses focus, we want to show the editor as blurred\n\t    on(window, \"blur\", function() {\n\t      forEachCodeMirror(onBlur);\n\t    });\n\t  }\n\t\n\t  // FEATURE DETECTION\n\t\n\t  // Detect drag-and-drop\n\t  var dragAndDrop = function() {\n\t    // There is *some* kind of drag-and-drop support in IE6-8, but I\n\t    // couldn't get it to work yet.\n\t    if (ie && ie_version < 9) return false;\n\t    var div = elt('div');\n\t    return \"draggable\" in div || \"dragDrop\" in div;\n\t  }();\n\t\n\t  var zwspSupported;\n\t  function zeroWidthElement(measure) {\n\t    if (zwspSupported == null) {\n\t      var test = elt(\"span\", \"\\u200b\");\n\t      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\t      if (measure.firstChild.offsetHeight != 0)\n\t        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n\t    }\n\t    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n\t      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n\t    node.setAttribute(\"cm-text\", \"\");\n\t    return node;\n\t  }\n\t\n\t  // Feature-detect IE's crummy client rect reporting for bidi text\n\t  var badBidiRects;\n\t  function hasBadBidiRects(measure) {\n\t    if (badBidiRects != null) return badBidiRects;\n\t    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n\t    var r0 = range(txt, 0, 1).getBoundingClientRect();\n\t    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n\t    var r1 = range(txt, 1, 2).getBoundingClientRect();\n\t    return badBidiRects = (r1.right - r0.right < 3);\n\t  }\n\t\n\t  // See if \"\".split is the broken IE version, if so, provide an\n\t  // alternative way to split lines.\n\t  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n\t    var pos = 0, result = [], l = string.length;\n\t    while (pos <= l) {\n\t      var nl = string.indexOf(\"\\n\", pos);\n\t      if (nl == -1) nl = string.length;\n\t      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n\t      var rt = line.indexOf(\"\\r\");\n\t      if (rt != -1) {\n\t        result.push(line.slice(0, rt));\n\t        pos += rt + 1;\n\t      } else {\n\t        result.push(line);\n\t        pos = nl + 1;\n\t      }\n\t    }\n\t    return result;\n\t  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\t\n\t  var hasSelection = window.getSelection ? function(te) {\n\t    try { return te.selectionStart != te.selectionEnd; }\n\t    catch(e) { return false; }\n\t  } : function(te) {\n\t    try {var range = te.ownerDocument.selection.createRange();}\n\t    catch(e) {}\n\t    if (!range || range.parentElement() != te) return false;\n\t    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n\t  };\n\t\n\t  var hasCopyEvent = (function() {\n\t    var e = elt(\"div\");\n\t    if (\"oncopy\" in e) return true;\n\t    e.setAttribute(\"oncopy\", \"return;\");\n\t    return typeof e.oncopy == \"function\";\n\t  })();\n\t\n\t  var badZoomedRects = null;\n\t  function hasBadZoomedRects(measure) {\n\t    if (badZoomedRects != null) return badZoomedRects;\n\t    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n\t    var normal = node.getBoundingClientRect();\n\t    var fromRange = range(node, 0, 1).getBoundingClientRect();\n\t    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n\t  }\n\t\n\t  // KEY NAMES\n\t\n\t  var keyNames = CodeMirror.keyNames = {\n\t    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n\t    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n\t    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n\t    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n\t    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n\t    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n\t    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n\t    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n\t  };\n\t  (function() {\n\t    // Number keys\n\t    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n\t    // Alphabetic keys\n\t    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n\t    // Function keys\n\t    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n\t  })();\n\t\n\t  // BIDI HELPERS\n\t\n\t  function iterateBidiSections(order, from, to, f) {\n\t    if (!order) return f(from, to, \"ltr\");\n\t    var found = false;\n\t    for (var i = 0; i < order.length; ++i) {\n\t      var part = order[i];\n\t      if (part.from < to && part.to > from || from == to && part.to == from) {\n\t        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n\t        found = true;\n\t      }\n\t    }\n\t    if (!found) f(from, to, \"ltr\");\n\t  }\n\t\n\t  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n\t  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\t\n\t  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n\t  function lineRight(line) {\n\t    var order = getOrder(line);\n\t    if (!order) return line.text.length;\n\t    return bidiRight(lst(order));\n\t  }\n\t\n\t  function lineStart(cm, lineN) {\n\t    var line = getLine(cm.doc, lineN);\n\t    var visual = visualLine(line);\n\t    if (visual != line) lineN = lineNo(visual);\n\t    var order = getOrder(visual);\n\t    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n\t    return Pos(lineN, ch);\n\t  }\n\t  function lineEnd(cm, lineN) {\n\t    var merged, line = getLine(cm.doc, lineN);\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      lineN = null;\n\t    }\n\t    var order = getOrder(line);\n\t    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n\t    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n\t  }\n\t  function lineStartSmart(cm, pos) {\n\t    var start = lineStart(cm, pos.line);\n\t    var line = getLine(cm.doc, start.line);\n\t    var order = getOrder(line);\n\t    if (!order || order[0].level == 0) {\n\t      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n\t      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n\t      return Pos(start.line, inWS ? 0 : firstNonWS);\n\t    }\n\t    return start;\n\t  }\n\t\n\t  function compareBidiLevel(order, a, b) {\n\t    var linedir = order[0].level;\n\t    if (a == linedir) return true;\n\t    if (b == linedir) return false;\n\t    return a < b;\n\t  }\n\t  var bidiOther;\n\t  function getBidiPartAt(order, pos) {\n\t    bidiOther = null;\n\t    for (var i = 0, found; i < order.length; ++i) {\n\t      var cur = order[i];\n\t      if (cur.from < pos && cur.to > pos) return i;\n\t      if ((cur.from == pos || cur.to == pos)) {\n\t        if (found == null) {\n\t          found = i;\n\t        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n\t          if (cur.from != cur.to) bidiOther = found;\n\t          return i;\n\t        } else {\n\t          if (cur.from != cur.to) bidiOther = i;\n\t          return found;\n\t        }\n\t      }\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function moveInLine(line, pos, dir, byUnit) {\n\t    if (!byUnit) return pos + dir;\n\t    do pos += dir;\n\t    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n\t    return pos;\n\t  }\n\t\n\t  // This is needed in order to move 'visually' through bi-directional\n\t  // text -- i.e., pressing left should make the cursor go left, even\n\t  // when in RTL text. The tricky part is the 'jumps', where RTL and\n\t  // LTR text touch each other. This often requires the cursor offset\n\t  // to move more than one unit, in order to visually move one unit.\n\t  function moveVisually(line, start, dir, byUnit) {\n\t    var bidi = getOrder(line);\n\t    if (!bidi) return moveLogically(line, start, dir, byUnit);\n\t    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n\t    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\t\n\t    for (;;) {\n\t      if (target > part.from && target < part.to) return target;\n\t      if (target == part.from || target == part.to) {\n\t        if (getBidiPartAt(bidi, target) == pos) return target;\n\t        part = bidi[pos += dir];\n\t        return (dir > 0) == part.level % 2 ? part.to : part.from;\n\t      } else {\n\t        part = bidi[pos += dir];\n\t        if (!part) return null;\n\t        if ((dir > 0) == part.level % 2)\n\t          target = moveInLine(line, part.to, -1, byUnit);\n\t        else\n\t          target = moveInLine(line, part.from, 1, byUnit);\n\t      }\n\t    }\n\t  }\n\t\n\t  function moveLogically(line, start, dir, byUnit) {\n\t    var target = start + dir;\n\t    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n\t    return target < 0 || target > line.text.length ? null : target;\n\t  }\n\t\n\t  // Bidirectional ordering algorithm\n\t  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n\t  // that this (partially) implements.\n\t\n\t  // One-char codes used for character types:\n\t  // L (L):   Left-to-Right\n\t  // R (R):   Right-to-Left\n\t  // r (AL):  Right-to-Left Arabic\n\t  // 1 (EN):  European Number\n\t  // + (ES):  European Number Separator\n\t  // % (ET):  European Number Terminator\n\t  // n (AN):  Arabic Number\n\t  // , (CS):  Common Number Separator\n\t  // m (NSM): Non-Spacing Mark\n\t  // b (BN):  Boundary Neutral\n\t  // s (B):   Paragraph Separator\n\t  // t (S):   Segment Separator\n\t  // w (WS):  Whitespace\n\t  // N (ON):  Other Neutrals\n\t\n\t  // Returns null if characters are ordered as they appear\n\t  // (left-to-right), or an array of sections ({from, to, level}\n\t  // objects) in the order in which they occur visually.\n\t  var bidiOrdering = (function() {\n\t    // Character types for codepoints 0 to 0xff\n\t    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n\t    // Character types for codepoints 0x600 to 0x6ff\n\t    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n\t    function charType(code) {\n\t      if (code <= 0xf7) return lowTypes.charAt(code);\n\t      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n\t      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n\t      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n\t      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n\t      else if (code == 0x200c) return \"b\";\n\t      else return \"L\";\n\t    }\n\t\n\t    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\t    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\t    // Browsers seem to always treat the boundaries of block elements as being L.\n\t    var outerType = \"L\";\n\t\n\t    function BidiSpan(level, from, to) {\n\t      this.level = level;\n\t      this.from = from; this.to = to;\n\t    }\n\t\n\t    return function(str) {\n\t      if (!bidiRE.test(str)) return false;\n\t      var len = str.length, types = [];\n\t      for (var i = 0, type; i < len; ++i)\n\t        types.push(type = charType(str.charCodeAt(i)));\n\t\n\t      // W1. Examine each non-spacing mark (NSM) in the level run, and\n\t      // change the type of the NSM to the type of the previous\n\t      // character. If the NSM is at the start of the level run, it will\n\t      // get the type of sor.\n\t      for (var i = 0, prev = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"m\") types[i] = prev;\n\t        else prev = type;\n\t      }\n\t\n\t      // W2. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, AL, or sor) is found. If an\n\t      // AL is found, change the type of the European number to Arabic\n\t      // number.\n\t      // W3. Change all ALs to R.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n\t        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n\t      }\n\t\n\t      // W4. A single European separator between two European numbers\n\t      // changes to a European number. A single common separator between\n\t      // two numbers of the same type changes to that type.\n\t      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n\t        var type = types[i];\n\t        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n\t        else if (type == \",\" && prev == types[i+1] &&\n\t                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n\t        prev = type;\n\t      }\n\t\n\t      // W5. A sequence of European terminators adjacent to European\n\t      // numbers changes to all European numbers.\n\t      // W6. Otherwise, separators and terminators change to Other\n\t      // Neutral.\n\t      for (var i = 0; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \",\") types[i] = \"N\";\n\t        else if (type == \"%\") {\n\t          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n\t          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // W7. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, or sor) is found. If an L is\n\t      // found, then change the type of the European number to L.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n\t        else if (isStrong.test(type)) cur = type;\n\t      }\n\t\n\t      // N1. A sequence of neutrals takes the direction of the\n\t      // surrounding strong text if the text on both sides has the same\n\t      // direction. European and Arabic numbers act as if they were R in\n\t      // terms of their influence on neutrals. Start-of-level-run (sor)\n\t      // and end-of-level-run (eor) are used at level run boundaries.\n\t      // N2. Any remaining neutrals take the embedding direction.\n\t      for (var i = 0; i < len; ++i) {\n\t        if (isNeutral.test(types[i])) {\n\t          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n\t          var before = (i ? types[i-1] : outerType) == \"L\";\n\t          var after = (end < len ? types[end] : outerType) == \"L\";\n\t          var replace = before || after ? \"L\" : \"R\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // Here we depart from the documented algorithm, in order to avoid\n\t      // building up an actual levels array. Since there are only three\n\t      // levels (0, 1, 2) in an implementation that doesn't take\n\t      // explicit embedding into account, we can build up the order on\n\t      // the fly, without following the level-based algorithm.\n\t      var order = [], m;\n\t      for (var i = 0; i < len;) {\n\t        if (countsAsLeft.test(types[i])) {\n\t          var start = i;\n\t          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n\t          order.push(new BidiSpan(0, start, i));\n\t        } else {\n\t          var pos = i, at = order.length;\n\t          for (++i; i < len && types[i] != \"L\"; ++i) {}\n\t          for (var j = pos; j < i;) {\n\t            if (countsAsNum.test(types[j])) {\n\t              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n\t              var nstart = j;\n\t              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n\t              order.splice(at, 0, new BidiSpan(2, nstart, j));\n\t              pos = j;\n\t            } else ++j;\n\t          }\n\t          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n\t        }\n\t      }\n\t      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n\t        order[0].from = m[0].length;\n\t        order.unshift(new BidiSpan(0, 0, m[0].length));\n\t      }\n\t      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n\t        lst(order).to -= m[0].length;\n\t        order.push(new BidiSpan(0, len - m[0].length, len));\n\t      }\n\t      if (order[0].level == 2)\n\t        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n\t      if (order[0].level != lst(order).level)\n\t        order.push(new BidiSpan(order[0].level, len, len));\n\t\n\t      return order;\n\t    };\n\t  })();\n\t\n\t  // THE END\n\t\n\t  CodeMirror.version = \"5.9.0\";\n\t\n\t  return CodeMirror;\n\t});\n\n\n/***/ },\n/* 352 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t// The primary entry point into fulfilling a GraphQL request.\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _graphql = __webpack_require__(353);\n\t\n\tObject.defineProperty(exports, 'graphql', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _graphql.graphql;\n\t  }\n\t});\n\t\n\t// Produce a GraphQL type schema.\n\t\n\tvar _typeSchema = __webpack_require__(369);\n\t\n\tObject.defineProperty(exports, 'GraphQLSchema', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeSchema.GraphQLSchema;\n\t  }\n\t});\n\t\n\t// Define GraphQL types.\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tObject.defineProperty(exports, 'GraphQLScalarType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeDefinition.GraphQLScalarType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLObjectType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeDefinition.GraphQLObjectType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLInterfaceType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeDefinition.GraphQLInterfaceType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLUnionType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeDefinition.GraphQLUnionType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLEnumType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeDefinition.GraphQLEnumType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLInputObjectType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeDefinition.GraphQLInputObjectType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLList', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeDefinition.GraphQLList;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLNonNull', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeDefinition.GraphQLNonNull;\n\t  }\n\t});\n\t\n\t// Use pre-defined GraphQL scalar types.\n\t\n\tvar _typeScalars = __webpack_require__(374);\n\t\n\tObject.defineProperty(exports, 'GraphQLInt', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeScalars.GraphQLInt;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLFloat', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeScalars.GraphQLFloat;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLString', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeScalars.GraphQLString;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLBoolean', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeScalars.GraphQLBoolean;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLID', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeScalars.GraphQLID;\n\t  }\n\t});\n\t\n\t// Format GraphQL errors.\n\t\n\tvar _errorFormatError = __webpack_require__(366);\n\t\n\tObject.defineProperty(exports, 'formatError', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _errorFormatError.formatError;\n\t  }\n\t});\n\n/***/ },\n/* 353 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * This is the primary entry point function for fulfilling GraphQL operations\n\t * by parsing, validating, and executing a GraphQL document along side a\n\t * GraphQL schema.\n\t *\n\t * More sophisticated GraphQL servers, such as those which persist queries,\n\t * may wish to separate the validation and execution phases to a static time\n\t * tooling step, and a server runtime step.\n\t *\n\t * schema:\n\t *    The GraphQL type system to use when validating and executing a query.\n\t * requestString:\n\t *    A GraphQL language formatted string representing the requested operation.\n\t * rootValue:\n\t *    The value provided as the first argument to resolver functions on the top\n\t *    level type (e.g. the query object type).\n\t * variableValues:\n\t *    A mapping of variable name to runtime value to use for all variables\n\t *    defined in the requestString.\n\t * operationName:\n\t *    The name of the operation to use if requestString contains multiple\n\t *    possible operations. Can be omitted if requestString contains only\n\t *    one operation.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.graphql = graphql;\n\t\n\t/**\n\t * The result of a GraphQL parse, validation and execution.\n\t *\n\t * `data` is the result of a successful execution of the query.\n\t * `errors` is included when any errors occurred as a non-empty array.\n\t */\n\t\n\tvar _languageSource = __webpack_require__(354);\n\t\n\tvar _languageParser = __webpack_require__(355);\n\t\n\tvar _validationValidate = __webpack_require__(368);\n\t\n\tvar _executionExecute = __webpack_require__(406);\n\t\n\tfunction graphql(schema, requestString, rootValue, variableValues, operationName) {\n\t  return new Promise(function (resolve) {\n\t    var source = new _languageSource.Source(requestString || '', 'GraphQL request');\n\t    var documentAST = (0, _languageParser.parse)(source);\n\t    var validationErrors = (0, _validationValidate.validate)(schema, documentAST);\n\t    if (validationErrors.length > 0) {\n\t      resolve({ errors: validationErrors });\n\t    } else {\n\t      resolve((0, _executionExecute.execute)(schema, documentAST, rootValue, variableValues, operationName));\n\t    }\n\t  })['catch'](function (error) {\n\t    return { errors: [error] };\n\t  });\n\t}\n\n/***/ },\n/* 354 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * A representation of source input to GraphQL. The name is optional,\n\t * but is mostly useful for clients who store GraphQL documents in\n\t * source files; for example, if the GraphQL input is in a file Foo.graphql,\n\t * it might be useful for name to be \"Foo.graphql\".\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar Source = function Source(body, name) {\n\t  _classCallCheck(this, Source);\n\t\n\t  this.body = body;\n\t  this.name = name || 'GraphQL';\n\t};\n\t\n\texports.Source = Source;\n\n/***/ },\n/* 355 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Configuration options to control parser behavior\n\t */\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.parse = parse;\n\texports.parseValue = parseValue;\n\texports.parseConstValue = parseConstValue;\n\texports.parseType = parseType;\n\texports.parseNamedType = parseNamedType;\n\t\n\tvar _source = __webpack_require__(354);\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _lexer = __webpack_require__(361);\n\t\n\tvar _kinds = __webpack_require__(359);\n\t\n\t/**\n\t * Given a GraphQL source, parses it into a Document.\n\t * Throws GraphQLError if a syntax error is encountered.\n\t */\n\t\n\tfunction parse(source, options) {\n\t  var sourceObj = source instanceof _source.Source ? source : new _source.Source(source);\n\t  var parser = makeParser(sourceObj, options || {});\n\t  return parseDocument(parser);\n\t}\n\t\n\t/**\n\t * Given a string containing a GraphQL value, parse the AST for that value.\n\t * Throws GraphQLError if a syntax error is encountered.\n\t *\n\t * This is useful within tools that operate upon GraphQL Values directly and\n\t * in isolation of complete GraphQL documents.\n\t */\n\t\n\tfunction parseValue(source, options) {\n\t  var sourceObj = source instanceof _source.Source ? source : new _source.Source(source);\n\t  var parser = makeParser(sourceObj, options || {});\n\t  return parseValueLiteral(parser);\n\t}\n\t\n\t/**\n\t * Converts a name lex token into a name parse node.\n\t */\n\tfunction parseName(parser) {\n\t  var token = expect(parser, _lexer.TokenKind.NAME);\n\t  return {\n\t    kind: _kinds.NAME,\n\t    value: token.value,\n\t    loc: loc(parser, token.start)\n\t  };\n\t}\n\t\n\t// Implements the parsing rules in the Document section.\n\t\n\t/**\n\t * Document : Definition+\n\t */\n\tfunction parseDocument(parser) {\n\t  var start = parser.token.start;\n\t\n\t  var definitions = [];\n\t  do {\n\t    definitions.push(parseDefinition(parser));\n\t  } while (!skip(parser, _lexer.TokenKind.EOF));\n\t\n\t  return {\n\t    kind: _kinds.DOCUMENT,\n\t    definitions: definitions,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * Definition :\n\t *   - OperationDefinition\n\t *   - FragmentDefinition\n\t *   - TypeDefinition\n\t */\n\tfunction parseDefinition(parser) {\n\t  if (peek(parser, _lexer.TokenKind.BRACE_L)) {\n\t    return parseOperationDefinition(parser);\n\t  }\n\t\n\t  if (peek(parser, _lexer.TokenKind.NAME)) {\n\t    switch (parser.token.value) {\n\t      case 'query':\n\t      case 'mutation':\n\t      // Note: subscription is an experimental non-spec addition.\n\t      case 'subscription':\n\t        return parseOperationDefinition(parser);\n\t\n\t      case 'fragment':\n\t        return parseFragmentDefinition(parser);\n\t\n\t      case 'type':\n\t      case 'interface':\n\t      case 'union':\n\t      case 'scalar':\n\t      case 'enum':\n\t      case 'input':\n\t      case 'extend':\n\t        return parseTypeDefinition(parser);\n\t    }\n\t  }\n\t\n\t  throw unexpected(parser);\n\t}\n\t\n\t// Implements the parsing rules in the Operations section.\n\t\n\t/**\n\t * OperationDefinition :\n\t *  - SelectionSet\n\t *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n\t *\n\t * OperationType : one of query mutation\n\t */\n\tfunction parseOperationDefinition(parser) {\n\t  var start = parser.token.start;\n\t  if (peek(parser, _lexer.TokenKind.BRACE_L)) {\n\t    return {\n\t      kind: _kinds.OPERATION_DEFINITION,\n\t      operation: 'query',\n\t      name: null,\n\t      variableDefinitions: null,\n\t      directives: [],\n\t      selectionSet: parseSelectionSet(parser),\n\t      loc: loc(parser, start)\n\t    };\n\t  }\n\t  var operationToken = expect(parser, _lexer.TokenKind.NAME);\n\t  var operation = operationToken.value;\n\t  var name;\n\t  if (peek(parser, _lexer.TokenKind.NAME)) {\n\t    name = parseName(parser);\n\t  }\n\t  return {\n\t    kind: _kinds.OPERATION_DEFINITION,\n\t    operation: operation,\n\t    name: name,\n\t    variableDefinitions: parseVariableDefinitions(parser),\n\t    directives: parseDirectives(parser),\n\t    selectionSet: parseSelectionSet(parser),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * VariableDefinitions : ( VariableDefinition+ )\n\t */\n\tfunction parseVariableDefinitions(parser) {\n\t  return peek(parser, _lexer.TokenKind.PAREN_L) ? many(parser, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n\t}\n\t\n\t/**\n\t * VariableDefinition : Variable : Type DefaultValue?\n\t */\n\tfunction parseVariableDefinition(parser) {\n\t  var start = parser.token.start;\n\t  return {\n\t    kind: _kinds.VARIABLE_DEFINITION,\n\t    variable: parseVariable(parser),\n\t    type: (expect(parser, _lexer.TokenKind.COLON), parseType(parser)),\n\t    defaultValue: skip(parser, _lexer.TokenKind.EQUALS) ? parseValueLiteral(parser, true) : null,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * Variable : $ Name\n\t */\n\tfunction parseVariable(parser) {\n\t  var start = parser.token.start;\n\t  expect(parser, _lexer.TokenKind.DOLLAR);\n\t  return {\n\t    kind: _kinds.VARIABLE,\n\t    name: parseName(parser),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * SelectionSet : { Selection+ }\n\t */\n\tfunction parseSelectionSet(parser) {\n\t  var start = parser.token.start;\n\t  return {\n\t    kind: _kinds.SELECTION_SET,\n\t    selections: many(parser, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * Selection :\n\t *   - Field\n\t *   - FragmentSpread\n\t *   - InlineFragment\n\t */\n\tfunction parseSelection(parser) {\n\t  return peek(parser, _lexer.TokenKind.SPREAD) ? parseFragment(parser) : parseField(parser);\n\t}\n\t\n\t/**\n\t * Field : Alias? Name Arguments? Directives? SelectionSet?\n\t *\n\t * Alias : Name :\n\t */\n\tfunction parseField(parser) {\n\t  var start = parser.token.start;\n\t\n\t  var nameOrAlias = parseName(parser);\n\t  var alias;\n\t  var name;\n\t  if (skip(parser, _lexer.TokenKind.COLON)) {\n\t    alias = nameOrAlias;\n\t    name = parseName(parser);\n\t  } else {\n\t    alias = null;\n\t    name = nameOrAlias;\n\t  }\n\t\n\t  return {\n\t    kind: _kinds.FIELD,\n\t    alias: alias,\n\t    name: name,\n\t    arguments: parseArguments(parser),\n\t    directives: parseDirectives(parser),\n\t    selectionSet: peek(parser, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(parser) : null,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * Arguments : ( Argument+ )\n\t */\n\tfunction parseArguments(parser) {\n\t  return peek(parser, _lexer.TokenKind.PAREN_L) ? many(parser, _lexer.TokenKind.PAREN_L, parseArgument, _lexer.TokenKind.PAREN_R) : [];\n\t}\n\t\n\t/**\n\t * Argument : Name : Value\n\t */\n\tfunction parseArgument(parser) {\n\t  var start = parser.token.start;\n\t  return {\n\t    kind: _kinds.ARGUMENT,\n\t    name: parseName(parser),\n\t    value: (expect(parser, _lexer.TokenKind.COLON), parseValueLiteral(parser, false)),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t// Implements the parsing rules in the Fragments section.\n\t\n\t/**\n\t * Corresponds to both FragmentSpread and InlineFragment in the spec.\n\t *\n\t * FragmentSpread : ... FragmentName Directives?\n\t *\n\t * InlineFragment : ... TypeCondition? Directives? SelectionSet\n\t */\n\tfunction parseFragment(parser) {\n\t  var start = parser.token.start;\n\t  expect(parser, _lexer.TokenKind.SPREAD);\n\t  if (peek(parser, _lexer.TokenKind.NAME) && parser.token.value !== 'on') {\n\t    return {\n\t      kind: _kinds.FRAGMENT_SPREAD,\n\t      name: parseFragmentName(parser),\n\t      directives: parseDirectives(parser),\n\t      loc: loc(parser, start)\n\t    };\n\t  }\n\t  var typeCondition = null;\n\t  if (parser.token.value === 'on') {\n\t    advance(parser);\n\t    typeCondition = parseNamedType(parser);\n\t  }\n\t  return {\n\t    kind: _kinds.INLINE_FRAGMENT,\n\t    typeCondition: typeCondition,\n\t    directives: parseDirectives(parser),\n\t    selectionSet: parseSelectionSet(parser),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * FragmentDefinition :\n\t *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n\t *\n\t * TypeCondition : NamedType\n\t */\n\tfunction parseFragmentDefinition(parser) {\n\t  var start = parser.token.start;\n\t  expectKeyword(parser, 'fragment');\n\t  return {\n\t    kind: _kinds.FRAGMENT_DEFINITION,\n\t    name: parseFragmentName(parser),\n\t    typeCondition: (expectKeyword(parser, 'on'), parseNamedType(parser)),\n\t    directives: parseDirectives(parser),\n\t    selectionSet: parseSelectionSet(parser),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * FragmentName : Name but not `on`\n\t */\n\tfunction parseFragmentName(parser) {\n\t  if (parser.token.value === 'on') {\n\t    throw unexpected(parser);\n\t  }\n\t  return parseName(parser);\n\t}\n\t\n\t// Implements the parsing rules in the Values section.\n\t\n\t/**\n\t * Value[Const] :\n\t *   - [~Const] Variable\n\t *   - IntValue\n\t *   - FloatValue\n\t *   - StringValue\n\t *   - BooleanValue\n\t *   - EnumValue\n\t *   - ListValue[?Const]\n\t *   - ObjectValue[?Const]\n\t *\n\t * BooleanValue : one of `true` `false`\n\t *\n\t * EnumValue : Name but not `true`, `false` or `null`\n\t */\n\tfunction parseValueLiteral(parser, isConst) {\n\t  var token = parser.token;\n\t  switch (token.kind) {\n\t    case _lexer.TokenKind.BRACKET_L:\n\t      return parseList(parser, isConst);\n\t    case _lexer.TokenKind.BRACE_L:\n\t      return parseObject(parser, isConst);\n\t    case _lexer.TokenKind.INT:\n\t      advance(parser);\n\t      return {\n\t        kind: _kinds.INT,\n\t        value: token.value,\n\t        loc: loc(parser, token.start)\n\t      };\n\t    case _lexer.TokenKind.FLOAT:\n\t      advance(parser);\n\t      return {\n\t        kind: _kinds.FLOAT,\n\t        value: token.value,\n\t        loc: loc(parser, token.start)\n\t      };\n\t    case _lexer.TokenKind.STRING:\n\t      advance(parser);\n\t      return {\n\t        kind: _kinds.STRING,\n\t        value: token.value,\n\t        loc: loc(parser, token.start)\n\t      };\n\t    case _lexer.TokenKind.NAME:\n\t      if (token.value === 'true' || token.value === 'false') {\n\t        advance(parser);\n\t        return {\n\t          kind: _kinds.BOOLEAN,\n\t          value: token.value === 'true',\n\t          loc: loc(parser, token.start)\n\t        };\n\t      } else if (token.value !== 'null') {\n\t        advance(parser);\n\t        return {\n\t          kind: _kinds.ENUM,\n\t          value: token.value,\n\t          loc: loc(parser, token.start)\n\t        };\n\t      }\n\t      break;\n\t    case _lexer.TokenKind.DOLLAR:\n\t      if (!isConst) {\n\t        return parseVariable(parser);\n\t      }\n\t      break;\n\t  }\n\t  throw unexpected(parser);\n\t}\n\t\n\tfunction parseConstValue(parser) {\n\t  return parseValueLiteral(parser, true);\n\t}\n\t\n\tfunction parseValueValue(parser) {\n\t  return parseValueLiteral(parser, false);\n\t}\n\t\n\t/**\n\t * ListValue[Const] :\n\t *   - [ ]\n\t *   - [ Value[?Const]+ ]\n\t */\n\tfunction parseList(parser, isConst) {\n\t  var start = parser.token.start;\n\t  var item = isConst ? parseConstValue : parseValueValue;\n\t  return {\n\t    kind: _kinds.LIST,\n\t    values: any(parser, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * ObjectValue[Const] :\n\t *   - { }\n\t *   - { ObjectField[?Const]+ }\n\t */\n\tfunction parseObject(parser, isConst) {\n\t  var start = parser.token.start;\n\t  expect(parser, _lexer.TokenKind.BRACE_L);\n\t  var fields = [];\n\t  while (!skip(parser, _lexer.TokenKind.BRACE_R)) {\n\t    fields.push(parseObjectField(parser, isConst));\n\t  }\n\t  return {\n\t    kind: _kinds.OBJECT,\n\t    fields: fields,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * ObjectField[Const] : Name : Value[?Const]\n\t */\n\tfunction parseObjectField(parser, isConst) {\n\t  var start = parser.token.start;\n\t  return {\n\t    kind: _kinds.OBJECT_FIELD,\n\t    name: parseName(parser),\n\t    value: (expect(parser, _lexer.TokenKind.COLON), parseValueLiteral(parser, isConst)),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t// Implements the parsing rules in the Directives section.\n\t\n\t/**\n\t * Directives : Directive+\n\t */\n\tfunction parseDirectives(parser) {\n\t  var directives = [];\n\t  while (peek(parser, _lexer.TokenKind.AT)) {\n\t    directives.push(parseDirective(parser));\n\t  }\n\t  return directives;\n\t}\n\t\n\t/**\n\t * Directive : @ Name Arguments?\n\t */\n\tfunction parseDirective(parser) {\n\t  var start = parser.token.start;\n\t  expect(parser, _lexer.TokenKind.AT);\n\t  return {\n\t    kind: _kinds.DIRECTIVE,\n\t    name: parseName(parser),\n\t    arguments: parseArguments(parser),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t// Implements the parsing rules in the Types section.\n\t\n\t/**\n\t * Type :\n\t *   - NamedType\n\t *   - ListType\n\t *   - NonNullType\n\t */\n\t\n\tfunction parseType(parser) {\n\t  var start = parser.token.start;\n\t  var type;\n\t  if (skip(parser, _lexer.TokenKind.BRACKET_L)) {\n\t    type = parseType(parser);\n\t    expect(parser, _lexer.TokenKind.BRACKET_R);\n\t    type = {\n\t      kind: _kinds.LIST_TYPE,\n\t      type: type,\n\t      loc: loc(parser, start)\n\t    };\n\t  } else {\n\t    type = parseNamedType(parser);\n\t  }\n\t  if (skip(parser, _lexer.TokenKind.BANG)) {\n\t    return {\n\t      kind: _kinds.NON_NULL_TYPE,\n\t      type: type,\n\t      loc: loc(parser, start)\n\t    };\n\t  }\n\t  return type;\n\t}\n\t\n\t/**\n\t * NamedType : Name\n\t */\n\t\n\tfunction parseNamedType(parser) {\n\t  var start = parser.token.start;\n\t  return {\n\t    kind: _kinds.NAMED_TYPE,\n\t    name: parseName(parser),\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t// Implements the parsing rules in the Type Definition section.\n\t\n\t/**\n\t * TypeDefinition :\n\t *   - ObjectTypeDefinition\n\t *   - InterfaceTypeDefinition\n\t *   - UnionTypeDefinition\n\t *   - ScalarTypeDefinition\n\t *   - EnumTypeDefinition\n\t *   - InputObjectTypeDefinition\n\t *   - TypeExtensionDefinition\n\t */\n\tfunction parseTypeDefinition(parser) {\n\t  if (!peek(parser, _lexer.TokenKind.NAME)) {\n\t    throw unexpected(parser);\n\t  }\n\t  switch (parser.token.value) {\n\t    case 'type':\n\t      return parseObjectTypeDefinition(parser);\n\t    case 'interface':\n\t      return parseInterfaceTypeDefinition(parser);\n\t    case 'union':\n\t      return parseUnionTypeDefinition(parser);\n\t    case 'scalar':\n\t      return parseScalarTypeDefinition(parser);\n\t    case 'enum':\n\t      return parseEnumTypeDefinition(parser);\n\t    case 'input':\n\t      return parseInputObjectTypeDefinition(parser);\n\t    case 'extend':\n\t      return parseTypeExtensionDefinition(parser);\n\t    default:\n\t      throw unexpected(parser);\n\t  }\n\t}\n\t\n\t/**\n\t * ObjectTypeDefinition : type Name ImplementsInterfaces? { FieldDefinition+ }\n\t */\n\tfunction parseObjectTypeDefinition(parser) {\n\t  var start = parser.token.start;\n\t  expectKeyword(parser, 'type');\n\t  var name = parseName(parser);\n\t  var interfaces = parseImplementsInterfaces(parser);\n\t  var fields = any(parser, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n\t  return {\n\t    kind: _kinds.OBJECT_TYPE_DEFINITION,\n\t    name: name,\n\t    interfaces: interfaces,\n\t    fields: fields,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * ImplementsInterfaces : implements NamedType+\n\t */\n\tfunction parseImplementsInterfaces(parser) {\n\t  var types = [];\n\t  if (parser.token.value === 'implements') {\n\t    advance(parser);\n\t    do {\n\t      types.push(parseNamedType(parser));\n\t    } while (!peek(parser, _lexer.TokenKind.BRACE_L));\n\t  }\n\t  return types;\n\t}\n\t\n\t/**\n\t * FieldDefinition : Name ArgumentsDefinition? : Type\n\t */\n\tfunction parseFieldDefinition(parser) {\n\t  var start = parser.token.start;\n\t  var name = parseName(parser);\n\t  var args = parseArgumentDefs(parser);\n\t  expect(parser, _lexer.TokenKind.COLON);\n\t  var type = parseType(parser);\n\t  return {\n\t    kind: _kinds.FIELD_DEFINITION,\n\t    name: name,\n\t    arguments: args,\n\t    type: type,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * ArgumentsDefinition : ( InputValueDefinition+ )\n\t */\n\tfunction parseArgumentDefs(parser) {\n\t  if (!peek(parser, _lexer.TokenKind.PAREN_L)) {\n\t    return [];\n\t  }\n\t  return many(parser, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n\t}\n\t\n\t/**\n\t * InputValueDefinition : Name : Type DefaultValue?\n\t */\n\tfunction parseInputValueDef(parser) {\n\t  var start = parser.token.start;\n\t  var name = parseName(parser);\n\t  expect(parser, _lexer.TokenKind.COLON);\n\t  var type = parseType(parser);\n\t  var defaultValue = null;\n\t  if (skip(parser, _lexer.TokenKind.EQUALS)) {\n\t    defaultValue = parseConstValue(parser);\n\t  }\n\t  return {\n\t    kind: _kinds.INPUT_VALUE_DEFINITION,\n\t    name: name,\n\t    type: type,\n\t    defaultValue: defaultValue,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * InterfaceTypeDefinition : interface Name { FieldDefinition+ }\n\t */\n\tfunction parseInterfaceTypeDefinition(parser) {\n\t  var start = parser.token.start;\n\t  expectKeyword(parser, 'interface');\n\t  var name = parseName(parser);\n\t  var fields = any(parser, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n\t  return {\n\t    kind: _kinds.INTERFACE_TYPE_DEFINITION,\n\t    name: name,\n\t    fields: fields,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * UnionTypeDefinition : union Name = UnionMembers\n\t */\n\tfunction parseUnionTypeDefinition(parser) {\n\t  var start = parser.token.start;\n\t  expectKeyword(parser, 'union');\n\t  var name = parseName(parser);\n\t  expect(parser, _lexer.TokenKind.EQUALS);\n\t  var types = parseUnionMembers(parser);\n\t  return {\n\t    kind: _kinds.UNION_TYPE_DEFINITION,\n\t    name: name,\n\t    types: types,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * UnionMembers :\n\t *   - NamedType\n\t *   - UnionMembers | NamedType\n\t */\n\tfunction parseUnionMembers(parser) {\n\t  var members = [];\n\t  do {\n\t    members.push(parseNamedType(parser));\n\t  } while (skip(parser, _lexer.TokenKind.PIPE));\n\t  return members;\n\t}\n\t\n\t/**\n\t * ScalarTypeDefinition : scalar Name\n\t */\n\tfunction parseScalarTypeDefinition(parser) {\n\t  var start = parser.token.start;\n\t  expectKeyword(parser, 'scalar');\n\t  var name = parseName(parser);\n\t  return {\n\t    kind: _kinds.SCALAR_TYPE_DEFINITION,\n\t    name: name,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * EnumTypeDefinition : enum Name { EnumValueDefinition+ }\n\t */\n\tfunction parseEnumTypeDefinition(parser) {\n\t  var start = parser.token.start;\n\t  expectKeyword(parser, 'enum');\n\t  var name = parseName(parser);\n\t  var values = many(parser, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R);\n\t  return {\n\t    kind: _kinds.ENUM_TYPE_DEFINITION,\n\t    name: name,\n\t    values: values,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * EnumValueDefinition : EnumValue\n\t *\n\t * EnumValue : Name\n\t */\n\tfunction parseEnumValueDefinition(parser) {\n\t  var start = parser.token.start;\n\t  var name = parseName(parser);\n\t  return {\n\t    kind: _kinds.ENUM_VALUE_DEFINITION,\n\t    name: name,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * InputObjectTypeDefinition : input Name { InputValueDefinition+ }\n\t */\n\tfunction parseInputObjectTypeDefinition(parser) {\n\t  var start = parser.token.start;\n\t  expectKeyword(parser, 'input');\n\t  var name = parseName(parser);\n\t  var fields = any(parser, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R);\n\t  return {\n\t    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,\n\t    name: name,\n\t    fields: fields,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t/**\n\t * TypeExtensionDefinition : extend ObjectTypeDefinition\n\t */\n\tfunction parseTypeExtensionDefinition(parser) {\n\t  var start = parser.token.start;\n\t  expectKeyword(parser, 'extend');\n\t  var definition = parseObjectTypeDefinition(parser);\n\t  return {\n\t    kind: _kinds.TYPE_EXTENSION_DEFINITION,\n\t    definition: definition,\n\t    loc: loc(parser, start)\n\t  };\n\t}\n\t\n\t// Core parsing utility functions\n\t\n\t/**\n\t * Returns the parser object that is used to store state throughout the\n\t * process of parsing.\n\t */\n\tfunction makeParser(source, options) {\n\t  var _lexToken = (0, _lexer.lex)(source);\n\t  return {\n\t    _lexToken: _lexToken,\n\t    source: source,\n\t    options: options,\n\t    prevEnd: 0,\n\t    token: _lexToken()\n\t  };\n\t}\n\t\n\t/**\n\t * Returns a location object, used to identify the place in\n\t * the source that created a given parsed object.\n\t */\n\tfunction loc(parser, start) {\n\t  if (parser.options.noLocation) {\n\t    return null;\n\t  }\n\t  if (parser.options.noSource) {\n\t    return { start: start, end: parser.prevEnd };\n\t  }\n\t  return { start: start, end: parser.prevEnd, source: parser.source };\n\t}\n\t\n\t/**\n\t * Moves the internal parser object to the next lexed token.\n\t */\n\tfunction advance(parser) {\n\t  var prevEnd = parser.token.end;\n\t  parser.prevEnd = prevEnd;\n\t  parser.token = parser._lexToken(prevEnd);\n\t}\n\t\n\t/**\n\t * Determines if the next token is of a given kind\n\t */\n\tfunction peek(parser, kind) {\n\t  return parser.token.kind === kind;\n\t}\n\t\n\t/**\n\t * If the next token is of the given kind, return true after advancing\n\t * the parser. Otherwise, do not change the parser state and return false.\n\t */\n\tfunction skip(parser, kind) {\n\t  var match = parser.token.kind === kind;\n\t  if (match) {\n\t    advance(parser);\n\t  }\n\t  return match;\n\t}\n\t\n\t/**\n\t * If the next token is of the given kind, return that token after advancing\n\t * the parser. Otherwise, do not change the parser state and return false.\n\t */\n\tfunction expect(parser, kind) {\n\t  var token = parser.token;\n\t  if (token.kind === kind) {\n\t    advance(parser);\n\t    return token;\n\t  }\n\t  throw (0, _error.syntaxError)(parser.source, token.start, 'Expected ' + (0, _lexer.getTokenKindDesc)(kind) + ', found ' + (0, _lexer.getTokenDesc)(token));\n\t}\n\t\n\t/**\n\t * If the next token is a keyword with the given value, return that token after\n\t * advancing the parser. Otherwise, do not change the parser state and return\n\t * false.\n\t */\n\tfunction expectKeyword(parser, value) {\n\t  var token = parser.token;\n\t  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n\t    advance(parser);\n\t    return token;\n\t  }\n\t  throw (0, _error.syntaxError)(parser.source, token.start, 'Expected \"' + value + '\", found ' + (0, _lexer.getTokenDesc)(token));\n\t}\n\t\n\t/**\n\t * Helper function for creating an error when an unexpected lexed token\n\t * is encountered.\n\t */\n\tfunction unexpected(parser, atToken) {\n\t  var token = atToken || parser.token;\n\t  return (0, _error.syntaxError)(parser.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));\n\t}\n\t\n\t/**\n\t * Returns a possibly empty list of parse nodes, determined by\n\t * the parseFn. This list begins with a lex token of openKind\n\t * and ends with a lex token of closeKind. Advances the parser\n\t * to the next lex token after the closing token.\n\t */\n\tfunction any(parser, openKind, parseFn, closeKind) {\n\t  expect(parser, openKind);\n\t  var nodes = [];\n\t  while (!skip(parser, closeKind)) {\n\t    nodes.push(parseFn(parser));\n\t  }\n\t  return nodes;\n\t}\n\t\n\t/**\n\t * Returns a non-empty list of parse nodes, determined by\n\t * the parseFn. This list begins with a lex token of openKind\n\t * and ends with a lex token of closeKind. Advances the parser\n\t * to the next lex token after the closing token.\n\t */\n\tfunction many(parser, openKind, parseFn, closeKind) {\n\t  expect(parser, openKind);\n\t  var nodes = [parseFn(parser)];\n\t  while (!skip(parser, closeKind)) {\n\t    nodes.push(parseFn(parser));\n\t  }\n\t  return nodes;\n\t}\n\t\n\t/**\n\t * By default, the parser creates AST nodes that know the location\n\t * in the source that they correspond to. This configuration flag\n\t * disables that behavior for performance or testing.\n\t */\n\t\n\t/**\n\t * By default, the parser creates AST nodes that contain a reference\n\t * to the source that they were created from. This configuration flag\n\t * disables that behavior for performance or testing.\n\t */\n\n/***/ },\n/* 356 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _GraphQLError = __webpack_require__(357);\n\t\n\tObject.defineProperty(exports, 'GraphQLError', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _GraphQLError.GraphQLError;\n\t  }\n\t});\n\t\n\tvar _syntaxError = __webpack_require__(364);\n\t\n\tObject.defineProperty(exports, 'syntaxError', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _syntaxError.syntaxError;\n\t  }\n\t});\n\t\n\tvar _locatedError = __webpack_require__(365);\n\t\n\tObject.defineProperty(exports, 'locatedError', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _locatedError.locatedError;\n\t  }\n\t});\n\t\n\tvar _formatError = __webpack_require__(366);\n\t\n\tObject.defineProperty(exports, 'formatError', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _formatError.formatError;\n\t  }\n\t});\n\n/***/ },\n/* 357 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _language = __webpack_require__(358);\n\t\n\tvar GraphQLError = (function (_Error) {\n\t  _inherits(GraphQLError, _Error);\n\t\n\t  function GraphQLError(message,\n\t  // A flow bug keeps us from declaring nodes as an array of Node\n\t  nodes, /* Node */stack, source, positions) {\n\t    _classCallCheck(this, GraphQLError);\n\t\n\t    _get(Object.getPrototypeOf(GraphQLError.prototype), 'constructor', this).call(this, message);\n\t    this.message = message;\n\t\n\t    Object.defineProperty(this, 'stack', { value: stack || message });\n\t    Object.defineProperty(this, 'nodes', { value: nodes });\n\t\n\t    // Note: flow does not yet know about Object.defineProperty with `get`.\n\t    Object.defineProperty(this, 'source', {\n\t      get: function get() {\n\t        if (source) {\n\t          return source;\n\t        }\n\t        if (nodes && nodes.length > 0) {\n\t          var node = nodes[0];\n\t          return node && node.loc && node.loc.source;\n\t        }\n\t      }\n\t    });\n\t\n\t    Object.defineProperty(this, 'positions', {\n\t      get: function get() {\n\t        if (positions) {\n\t          return positions;\n\t        }\n\t        if (nodes) {\n\t          var nodePositions = nodes.map(function (node) {\n\t            return node.loc && node.loc.start;\n\t          });\n\t          if (nodePositions.some(function (p) {\n\t            return p;\n\t          })) {\n\t            return nodePositions;\n\t          }\n\t        }\n\t      }\n\t    });\n\t\n\t    Object.defineProperty(this, 'locations', {\n\t      get: function get() {\n\t        var _this = this;\n\t\n\t        if (this.positions && this.source) {\n\t          return this.positions.map(function (pos) {\n\t            return (0, _language.getLocation)(_this.source, pos);\n\t          });\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  return GraphQLError;\n\t})(Error);\n\t\n\texports.GraphQLError = GraphQLError;\n\n/***/ },\n/* 358 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tvar _kinds = __webpack_require__(359);\n\t\n\tvar Kind = _interopRequireWildcard(_kinds);\n\t\n\tvar _location = __webpack_require__(360);\n\t\n\tObject.defineProperty(exports, 'getLocation', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _location.getLocation;\n\t  }\n\t});\n\texports.Kind = Kind;\n\t\n\tvar _lexer = __webpack_require__(361);\n\t\n\tObject.defineProperty(exports, 'lex', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _lexer.lex;\n\t  }\n\t});\n\t\n\tvar _parser = __webpack_require__(355);\n\t\n\tObject.defineProperty(exports, 'parse', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _parser.parse;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'parseValue', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _parser.parseValue;\n\t  }\n\t});\n\t\n\tvar _printer = __webpack_require__(362);\n\t\n\tObject.defineProperty(exports, 'print', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _printer.print;\n\t  }\n\t});\n\t\n\tvar _source = __webpack_require__(354);\n\t\n\tObject.defineProperty(exports, 'Source', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _source.Source;\n\t  }\n\t});\n\t\n\tvar _visitor = __webpack_require__(363);\n\t\n\tObject.defineProperty(exports, 'visit', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _visitor.visit;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'BREAK', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _visitor.BREAK;\n\t  }\n\t});\n\n/***/ },\n/* 359 */\n/***/ function(module, exports) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t// Name\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar NAME = 'Name';\n\t\n\texports.NAME = NAME;\n\t// Document\n\t\n\tvar DOCUMENT = 'Document';\n\texports.DOCUMENT = DOCUMENT;\n\tvar OPERATION_DEFINITION = 'OperationDefinition';\n\texports.OPERATION_DEFINITION = OPERATION_DEFINITION;\n\tvar VARIABLE_DEFINITION = 'VariableDefinition';\n\texports.VARIABLE_DEFINITION = VARIABLE_DEFINITION;\n\tvar VARIABLE = 'Variable';\n\texports.VARIABLE = VARIABLE;\n\tvar SELECTION_SET = 'SelectionSet';\n\texports.SELECTION_SET = SELECTION_SET;\n\tvar FIELD = 'Field';\n\texports.FIELD = FIELD;\n\tvar ARGUMENT = 'Argument';\n\t\n\texports.ARGUMENT = ARGUMENT;\n\t// Fragments\n\t\n\tvar FRAGMENT_SPREAD = 'FragmentSpread';\n\texports.FRAGMENT_SPREAD = FRAGMENT_SPREAD;\n\tvar INLINE_FRAGMENT = 'InlineFragment';\n\texports.INLINE_FRAGMENT = INLINE_FRAGMENT;\n\tvar FRAGMENT_DEFINITION = 'FragmentDefinition';\n\t\n\texports.FRAGMENT_DEFINITION = FRAGMENT_DEFINITION;\n\t// Values\n\t\n\tvar INT = 'IntValue';\n\texports.INT = INT;\n\tvar FLOAT = 'FloatValue';\n\texports.FLOAT = FLOAT;\n\tvar STRING = 'StringValue';\n\texports.STRING = STRING;\n\tvar BOOLEAN = 'BooleanValue';\n\texports.BOOLEAN = BOOLEAN;\n\tvar ENUM = 'EnumValue';\n\texports.ENUM = ENUM;\n\tvar LIST = 'ListValue';\n\texports.LIST = LIST;\n\tvar OBJECT = 'ObjectValue';\n\texports.OBJECT = OBJECT;\n\tvar OBJECT_FIELD = 'ObjectField';\n\t\n\texports.OBJECT_FIELD = OBJECT_FIELD;\n\t// Directives\n\t\n\tvar DIRECTIVE = 'Directive';\n\t\n\texports.DIRECTIVE = DIRECTIVE;\n\t// Types\n\t\n\tvar NAMED_TYPE = 'NamedType';\n\texports.NAMED_TYPE = NAMED_TYPE;\n\tvar LIST_TYPE = 'ListType';\n\texports.LIST_TYPE = LIST_TYPE;\n\tvar NON_NULL_TYPE = 'NonNullType';\n\t\n\texports.NON_NULL_TYPE = NON_NULL_TYPE;\n\t// Type Definitions\n\t\n\tvar OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition';\n\texports.OBJECT_TYPE_DEFINITION = OBJECT_TYPE_DEFINITION;\n\tvar FIELD_DEFINITION = 'FieldDefinition';\n\texports.FIELD_DEFINITION = FIELD_DEFINITION;\n\tvar INPUT_VALUE_DEFINITION = 'InputValueDefinition';\n\texports.INPUT_VALUE_DEFINITION = INPUT_VALUE_DEFINITION;\n\tvar INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition';\n\texports.INTERFACE_TYPE_DEFINITION = INTERFACE_TYPE_DEFINITION;\n\tvar UNION_TYPE_DEFINITION = 'UnionTypeDefinition';\n\texports.UNION_TYPE_DEFINITION = UNION_TYPE_DEFINITION;\n\tvar SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition';\n\texports.SCALAR_TYPE_DEFINITION = SCALAR_TYPE_DEFINITION;\n\tvar ENUM_TYPE_DEFINITION = 'EnumTypeDefinition';\n\texports.ENUM_TYPE_DEFINITION = ENUM_TYPE_DEFINITION;\n\tvar ENUM_VALUE_DEFINITION = 'EnumValueDefinition';\n\texports.ENUM_VALUE_DEFINITION = ENUM_VALUE_DEFINITION;\n\tvar INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition';\n\texports.INPUT_OBJECT_TYPE_DEFINITION = INPUT_OBJECT_TYPE_DEFINITION;\n\tvar TYPE_EXTENSION_DEFINITION = 'TypeExtensionDefinition';\n\texports.TYPE_EXTENSION_DEFINITION = TYPE_EXTENSION_DEFINITION;\n\n/***/ },\n/* 360 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Represents a location in a Source.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.getLocation = getLocation;\n\t\n\t/**\n\t * Takes a Source and a UTF-8 character offset, and returns the corresponding\n\t * line and column as a SourceLocation.\n\t */\n\t\n\tfunction getLocation(source, position) {\n\t  var line = 1;\n\t  var column = position + 1;\n\t  var lineRegexp = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\t  var match;\n\t  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n\t    line += 1;\n\t    column = position + 1 - (match.index + match[0].length);\n\t  }\n\t  return { line: line, column: column };\n\t}\n\n/***/ },\n/* 361 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*  /\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * A representation of a lexed Token. Value is optional, is it is\n\t * not needed for punctuators like BANG or PAREN_L.\n\t */\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.lex = lex;\n\texports.getTokenDesc = getTokenDesc;\n\texports.getTokenKindDesc = getTokenKindDesc;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\t/**\n\t * Given a Source object, this returns a Lexer for that source.\n\t * A Lexer is a function that acts like a generator in that every time\n\t * it is called, it returns the next token in the Source. Assuming the\n\t * source lexes, the final Token emitted by the lexer will be of kind\n\t * EOF, after which the lexer will repeatedly return EOF tokens whenever\n\t * called.\n\t *\n\t * The argument to the lexer function is optional, and can be used to\n\t * rewind or fast forward the lexer to a new position in the source.\n\t */\n\t\n\tfunction lex(source) {\n\t  var prevPosition = 0;\n\t  return function nextToken(resetPosition) {\n\t    var token = readToken(source, resetPosition === undefined ? prevPosition : resetPosition);\n\t    prevPosition = token.end;\n\t    return token;\n\t  };\n\t}\n\t\n\t/**\n\t * An enum describing the different kinds of tokens that the lexer emits.\n\t */\n\tvar TokenKind = {\n\t  EOF: 1,\n\t  BANG: 2,\n\t  DOLLAR: 3,\n\t  PAREN_L: 4,\n\t  PAREN_R: 5,\n\t  SPREAD: 6,\n\t  COLON: 7,\n\t  EQUALS: 8,\n\t  AT: 9,\n\t  BRACKET_L: 10,\n\t  BRACKET_R: 11,\n\t  BRACE_L: 12,\n\t  PIPE: 13,\n\t  BRACE_R: 14,\n\t  NAME: 15,\n\t  VARIABLE: 16,\n\t  INT: 17,\n\t  FLOAT: 18,\n\t  STRING: 19\n\t};\n\t\n\texports.TokenKind = TokenKind;\n\t/**\n\t * A helper function to describe a token as a string for debugging\n\t */\n\t\n\tfunction getTokenDesc(token) {\n\t  return token.value ? getTokenKindDesc(token.kind) + ' \"' + token.value + '\"' : getTokenKindDesc(token.kind);\n\t}\n\t\n\t/**\n\t * A helper function to describe a token kind as a string for debugging\n\t */\n\t\n\tfunction getTokenKindDesc(kind) {\n\t  return tokenDescription[kind];\n\t}\n\t\n\tvar tokenDescription = {};\n\ttokenDescription[TokenKind.EOF] = 'EOF';\n\ttokenDescription[TokenKind.BANG] = '!';\n\ttokenDescription[TokenKind.DOLLAR] = '$';\n\ttokenDescription[TokenKind.PAREN_L] = '(';\n\ttokenDescription[TokenKind.PAREN_R] = ')';\n\ttokenDescription[TokenKind.SPREAD] = '...';\n\ttokenDescription[TokenKind.COLON] = ':';\n\ttokenDescription[TokenKind.EQUALS] = '=';\n\ttokenDescription[TokenKind.AT] = '@';\n\ttokenDescription[TokenKind.BRACKET_L] = '[';\n\ttokenDescription[TokenKind.BRACKET_R] = ']';\n\ttokenDescription[TokenKind.BRACE_L] = '{';\n\ttokenDescription[TokenKind.PIPE] = '|';\n\ttokenDescription[TokenKind.BRACE_R] = '}';\n\ttokenDescription[TokenKind.NAME] = 'Name';\n\ttokenDescription[TokenKind.VARIABLE] = 'Variable';\n\ttokenDescription[TokenKind.INT] = 'Int';\n\ttokenDescription[TokenKind.FLOAT] = 'Float';\n\ttokenDescription[TokenKind.STRING] = 'String';\n\t\n\tvar charCodeAt = String.prototype.charCodeAt;\n\tvar slice = String.prototype.slice;\n\t\n\t/**\n\t * Helper function for constructing the Token object.\n\t */\n\tfunction makeToken(kind, start, end, value) {\n\t  return { kind: kind, start: start, end: end, value: value };\n\t}\n\t\n\tfunction printCharCode(code) {\n\t  return(\n\t    // NaN/undefined represents access beyond the end of the file.\n\t    isNaN(code) ? '<EOF>' :\n\t    // Trust JSON for ASCII.\n\t    code < 0x007F ? JSON.stringify(String.fromCharCode(code)) :\n\t    // Otherwise print the escaped form.\n\t    '\"\\\\u' + ('00' + code.toString(16).toUpperCase()).slice(-4) + '\"'\n\t  );\n\t}\n\t\n\t/**\n\t * Gets the next token from the source starting at the given position.\n\t *\n\t * This skips over whitespace and comments until it finds the next lexable\n\t * token, then lexes punctuators immediately or calls the appropriate helper\n\t * function for more complicated tokens.\n\t */\n\tfunction readToken(source, fromPosition) {\n\t  var body = source.body;\n\t  var bodyLength = body.length;\n\t\n\t  var position = positionAfterWhitespace(body, fromPosition);\n\t\n\t  if (position >= bodyLength) {\n\t    return makeToken(TokenKind.EOF, position, position);\n\t  }\n\t\n\t  var code = charCodeAt.call(body, position);\n\t\n\t  // SourceCharacter\n\t  if (code < 0x0020 && code !== 0x0009 && code !== 0x000A && code !== 0x000D) {\n\t    throw (0, _error.syntaxError)(source, position, 'Invalid character ' + printCharCode(code) + '.');\n\t  }\n\t\n\t  switch (code) {\n\t    // !\n\t    case 33:\n\t      return makeToken(TokenKind.BANG, position, position + 1);\n\t    // $\n\t    case 36:\n\t      return makeToken(TokenKind.DOLLAR, position, position + 1);\n\t    // (\n\t    case 40:\n\t      return makeToken(TokenKind.PAREN_L, position, position + 1);\n\t    // )\n\t    case 41:\n\t      return makeToken(TokenKind.PAREN_R, position, position + 1);\n\t    // .\n\t    case 46:\n\t      if (charCodeAt.call(body, position + 1) === 46 && charCodeAt.call(body, position + 2) === 46) {\n\t        return makeToken(TokenKind.SPREAD, position, position + 3);\n\t      }\n\t      break;\n\t    // :\n\t    case 58:\n\t      return makeToken(TokenKind.COLON, position, position + 1);\n\t    // =\n\t    case 61:\n\t      return makeToken(TokenKind.EQUALS, position, position + 1);\n\t    // @\n\t    case 64:\n\t      return makeToken(TokenKind.AT, position, position + 1);\n\t    // [\n\t    case 91:\n\t      return makeToken(TokenKind.BRACKET_L, position, position + 1);\n\t    // ]\n\t    case 93:\n\t      return makeToken(TokenKind.BRACKET_R, position, position + 1);\n\t    // {\n\t    case 123:\n\t      return makeToken(TokenKind.BRACE_L, position, position + 1);\n\t    // |\n\t    case 124:\n\t      return makeToken(TokenKind.PIPE, position, position + 1);\n\t    // }\n\t    case 125:\n\t      return makeToken(TokenKind.BRACE_R, position, position + 1);\n\t    // A-Z\n\t    case 65:case 66:case 67:case 68:case 69:case 70:case 71:case 72:\n\t    case 73:case 74:case 75:case 76:case 77:case 78:case 79:case 80:\n\t    case 81:case 82:case 83:case 84:case 85:case 86:case 87:case 88:\n\t    case 89:case 90:\n\t    // _\n\t    case 95:\n\t    // a-z\n\t    case 97:case 98:case 99:case 100:case 101:case 102:case 103:case 104:\n\t    case 105:case 106:case 107:case 108:case 109:case 110:case 111:\n\t    case 112:case 113:case 114:case 115:case 116:case 117:case 118:\n\t    case 119:case 120:case 121:case 122:\n\t      return readName(source, position);\n\t    // -\n\t    case 45:\n\t    // 0-9\n\t    case 48:case 49:case 50:case 51:case 52:\n\t    case 53:case 54:case 55:case 56:case 57:\n\t      return readNumber(source, position, code);\n\t    // \"\n\t    case 34:\n\t      return readString(source, position);\n\t  }\n\t\n\t  throw (0, _error.syntaxError)(source, position, 'Unexpected character ' + printCharCode(code) + '.');\n\t}\n\t\n\t/**\n\t * Reads from body starting at startPosition until it finds a non-whitespace\n\t * or commented character, then returns the position of that character for\n\t * lexing.\n\t */\n\tfunction positionAfterWhitespace(body, startPosition) {\n\t  var bodyLength = body.length;\n\t  var position = startPosition;\n\t  while (position < bodyLength) {\n\t    var code = charCodeAt.call(body, position);\n\t    // Skip Ignored\n\t    if (\n\t    // BOM\n\t    code === 0xFEFF ||\n\t    // White Space\n\t    code === 0x0009 || // tab\n\t    code === 0x0020 || // space\n\t    // Line Terminator\n\t    code === 0x000A || // new line\n\t    code === 0x000D || // carriage return\n\t    // Comma\n\t    code === 0x002C) {\n\t      ++position;\n\t      // Skip comments\n\t    } else if (code === 35) {\n\t        // #\n\t        ++position;\n\t        while (position < bodyLength && (code = charCodeAt.call(body, position)) !== null && (\n\t        // SourceCharacter but not LineTerminator\n\t        code > 0x001F || code === 0x0009) && code !== 0x000A && code !== 0x000D) {\n\t          ++position;\n\t        }\n\t      } else {\n\t        break;\n\t      }\n\t  }\n\t  return position;\n\t}\n\t\n\t/**\n\t * Reads a number token from the source file, either a float\n\t * or an int depending on whether a decimal point appears.\n\t *\n\t * Int:   -?(0|[1-9][0-9]*)\n\t * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n\t */\n\tfunction readNumber(source, start, firstCode) {\n\t  var code = firstCode;\n\t  var body = source.body;\n\t  var position = start;\n\t  var isFloat = false;\n\t\n\t  if (code === 45) {\n\t    // -\n\t    code = charCodeAt.call(body, ++position);\n\t  }\n\t\n\t  if (code === 48) {\n\t    // 0\n\t    code = charCodeAt.call(body, ++position);\n\t    if (code >= 48 && code <= 57) {\n\t      throw (0, _error.syntaxError)(source, position, 'Invalid number, unexpected digit after 0: ' + printCharCode(code) + '.');\n\t    }\n\t  } else {\n\t    position = readDigits(source, position, code);\n\t    code = charCodeAt.call(body, position);\n\t  }\n\t\n\t  if (code === 46) {\n\t    // .\n\t    isFloat = true;\n\t\n\t    code = charCodeAt.call(body, ++position);\n\t    position = readDigits(source, position, code);\n\t    code = charCodeAt.call(body, position);\n\t  }\n\t\n\t  if (code === 69 || code === 101) {\n\t    // E e\n\t    isFloat = true;\n\t\n\t    code = charCodeAt.call(body, ++position);\n\t    if (code === 43 || code === 45) {\n\t      // + -\n\t      code = charCodeAt.call(body, ++position);\n\t    }\n\t    position = readDigits(source, position, code);\n\t  }\n\t\n\t  return makeToken(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, slice.call(body, start, position));\n\t}\n\t\n\t/**\n\t * Returns the new position in the source after reading digits.\n\t */\n\tfunction readDigits(source, start, firstCode) {\n\t  var body = source.body;\n\t  var position = start;\n\t  var code = firstCode;\n\t  if (code >= 48 && code <= 57) {\n\t    // 0 - 9\n\t    do {\n\t      code = charCodeAt.call(body, ++position);\n\t    } while (code >= 48 && code <= 57); // 0 - 9\n\t    return position;\n\t  }\n\t  throw (0, _error.syntaxError)(source, position, 'Invalid number, expected digit but got: ' + printCharCode(code) + '.');\n\t}\n\t\n\t/**\n\t * Reads a string token from the source file.\n\t *\n\t * \"([^\"\\\\\\u000A\\u000D\\u2028\\u2029]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n\t */\n\tfunction readString(source, start) {\n\t  var body = source.body;\n\t  var position = start + 1;\n\t  var chunkStart = position;\n\t  var code = 0;\n\t  var value = '';\n\t\n\t  while (position < body.length && (code = charCodeAt.call(body, position)) !== null &&\n\t  // not LineTerminator\n\t  code !== 0x000A && code !== 0x000D &&\n\t  // not Quote (\")\n\t  code !== 34) {\n\t    // SourceCharacter\n\t    if (code < 0x0020 && code !== 0x0009) {\n\t      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');\n\t    }\n\t\n\t    ++position;\n\t    if (code === 92) {\n\t      // \\\n\t      value += slice.call(body, chunkStart, position - 1);\n\t      code = charCodeAt.call(body, position);\n\t      switch (code) {\n\t        case 34:\n\t          value += '\"';break;\n\t        case 47:\n\t          value += '\\/';break;\n\t        case 92:\n\t          value += '\\\\';break;\n\t        case 98:\n\t          value += '\\b';break;\n\t        case 102:\n\t          value += '\\f';break;\n\t        case 110:\n\t          value += '\\n';break;\n\t        case 114:\n\t          value += '\\r';break;\n\t        case 116:\n\t          value += '\\t';break;\n\t        case 117:\n\t          // u\n\t          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));\n\t          if (charCode < 0) {\n\t            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + ('\\\\u' + body.slice(position + 1, position + 5) + '.'));\n\t          }\n\t          value += String.fromCharCode(charCode);\n\t          position += 4;\n\t          break;\n\t        default:\n\t          throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: \\\\' + String.fromCharCode(code) + '.');\n\t      }\n\t      ++position;\n\t      chunkStart = position;\n\t    }\n\t  }\n\t\n\t  if (code !== 34) {\n\t    // quote (\")\n\t    throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n\t  }\n\t\n\t  value += slice.call(body, chunkStart, position);\n\t  return makeToken(TokenKind.STRING, start, position + 1, value);\n\t}\n\t\n\t/**\n\t * Converts four hexidecimal chars to the integer that the\n\t * string represents. For example, uniCharCode('0','0','0','f')\n\t * will return 15, and uniCharCode('0','0','f','f') returns 255.\n\t *\n\t * Returns a negative number on error, if a char was invalid.\n\t *\n\t * This is implemented by noting that char2hex() returns -1 on error,\n\t * which means the result of ORing the char2hex() will also be negative.\n\t */\n\tfunction uniCharCode(a, b, c, d) {\n\t  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n\t}\n\t\n\t/**\n\t * Converts a hex character to its integer value.\n\t * '0' becomes 0, '9' becomes 9\n\t * 'A' becomes 10, 'F' becomes 15\n\t * 'a' becomes 10, 'f' becomes 15\n\t *\n\t * Returns -1 on error.\n\t */\n\tfunction char2hex(a) {\n\t  return a >= 48 && a <= 57 ? a - 48 : // 0-9\n\t  a >= 65 && a <= 70 ? a - 55 : // A-F\n\t  a >= 97 && a <= 102 ? a - 87 : // a-f\n\t  -1;\n\t}\n\t\n\t/**\n\t * Reads an alphanumeric + underscore name from the source.\n\t *\n\t * [_A-Za-z][_0-9A-Za-z]*\n\t */\n\tfunction readName(source, position) {\n\t  var body = source.body;\n\t  var bodyLength = body.length;\n\t  var end = position + 1;\n\t  var code = 0;\n\t  while (end !== bodyLength && (code = charCodeAt.call(body, end)) !== null && (code === 95 || // _\n\t  code >= 48 && code <= 57 || // 0-9\n\t  code >= 65 && code <= 90 || // A-Z\n\t  code >= 97 && code <= 122) // a-z\n\t  ) {\n\t    ++end;\n\t  }\n\t  return makeToken(TokenKind.NAME, position, end, slice.call(body, position, end));\n\t}\n\n/***/ },\n/* 362 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.print = print;\n\t\n\tvar _visitor = __webpack_require__(363);\n\t\n\t/**\n\t * Converts an AST into a string, using one set of reasonable\n\t * formatting rules.\n\t */\n\t\n\tfunction print(ast) {\n\t  return (0, _visitor.visit)(ast, { leave: printDocASTReducer });\n\t}\n\t\n\tvar printDocASTReducer = {\n\t  Name: function Name(node) {\n\t    return node.value;\n\t  },\n\t  Variable: function Variable(node) {\n\t    return '$' + node.name;\n\t  },\n\t\n\t  // Document\n\t\n\t  Document: function Document(node) {\n\t    return join(node.definitions, '\\n\\n') + '\\n';\n\t  },\n\t\n\t  OperationDefinition: function OperationDefinition(node) {\n\t    var op = node.operation;\n\t    var name = node.name;\n\t    var defs = wrap('(', join(node.variableDefinitions, ', '), ')');\n\t    var directives = join(node.directives, ' ');\n\t    var selectionSet = node.selectionSet;\n\t    return !name ? selectionSet : join([op, join([name, defs]), directives, selectionSet], ' ');\n\t  },\n\t\n\t  VariableDefinition: function VariableDefinition(_ref) {\n\t    var variable = _ref.variable;\n\t    var type = _ref.type;\n\t    var defaultValue = _ref.defaultValue;\n\t    return variable + ': ' + type + wrap(' = ', defaultValue);\n\t  },\n\t\n\t  SelectionSet: function SelectionSet(_ref2) {\n\t    var selections = _ref2.selections;\n\t    return block(selections);\n\t  },\n\t\n\t  Field: function Field(_ref3) {\n\t    var alias = _ref3.alias;\n\t    var name = _ref3.name;\n\t    var args = _ref3.arguments;\n\t    var directives = _ref3.directives;\n\t    var selectionSet = _ref3.selectionSet;\n\t    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n\t  },\n\t\n\t  Argument: function Argument(_ref4) {\n\t    var name = _ref4.name;\n\t    var value = _ref4.value;\n\t    return name + ': ' + value;\n\t  },\n\t\n\t  // Fragments\n\t\n\t  FragmentSpread: function FragmentSpread(_ref5) {\n\t    var name = _ref5.name;\n\t    var directives = _ref5.directives;\n\t    return '...' + name + wrap(' ', join(directives, ' '));\n\t  },\n\t\n\t  InlineFragment: function InlineFragment(_ref6) {\n\t    var typeCondition = _ref6.typeCondition;\n\t    var directives = _ref6.directives;\n\t    var selectionSet = _ref6.selectionSet;\n\t    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n\t  },\n\t\n\t  FragmentDefinition: function FragmentDefinition(_ref7) {\n\t    var name = _ref7.name;\n\t    var typeCondition = _ref7.typeCondition;\n\t    var directives = _ref7.directives;\n\t    var selectionSet = _ref7.selectionSet;\n\t    return 'fragment ' + name + ' on ' + typeCondition + ' ' + wrap('', join(directives, ' '), ' ') + selectionSet;\n\t  },\n\t\n\t  // Value\n\t\n\t  IntValue: function IntValue(_ref8) {\n\t    var value = _ref8.value;\n\t    return value;\n\t  },\n\t  FloatValue: function FloatValue(_ref9) {\n\t    var value = _ref9.value;\n\t    return value;\n\t  },\n\t  StringValue: function StringValue(_ref10) {\n\t    var value = _ref10.value;\n\t    return JSON.stringify(value);\n\t  },\n\t  BooleanValue: function BooleanValue(_ref11) {\n\t    var value = _ref11.value;\n\t    return JSON.stringify(value);\n\t  },\n\t  EnumValue: function EnumValue(_ref12) {\n\t    var value = _ref12.value;\n\t    return value;\n\t  },\n\t  ListValue: function ListValue(_ref13) {\n\t    var values = _ref13.values;\n\t    return '[' + join(values, ', ') + ']';\n\t  },\n\t  ObjectValue: function ObjectValue(_ref14) {\n\t    var fields = _ref14.fields;\n\t    return '{' + join(fields, ', ') + '}';\n\t  },\n\t  ObjectField: function ObjectField(_ref15) {\n\t    var name = _ref15.name;\n\t    var value = _ref15.value;\n\t    return name + ': ' + value;\n\t  },\n\t\n\t  // Directive\n\t\n\t  Directive: function Directive(_ref16) {\n\t    var name = _ref16.name;\n\t    var args = _ref16.arguments;\n\t    return '@' + name + wrap('(', join(args, ', '), ')');\n\t  },\n\t\n\t  // Type\n\t\n\t  NamedType: function NamedType(_ref17) {\n\t    var name = _ref17.name;\n\t    return name;\n\t  },\n\t  ListType: function ListType(_ref18) {\n\t    var type = _ref18.type;\n\t    return '[' + type + ']';\n\t  },\n\t  NonNullType: function NonNullType(_ref19) {\n\t    var type = _ref19.type;\n\t    return type + '!';\n\t  },\n\t\n\t  // Type Definitions\n\t\n\t  ObjectTypeDefinition: function ObjectTypeDefinition(_ref20) {\n\t    var name = _ref20.name;\n\t    var interfaces = _ref20.interfaces;\n\t    var fields = _ref20.fields;\n\t    return 'type ' + name + ' ' + wrap('implements ', join(interfaces, ', '), ' ') + block(fields);\n\t  },\n\t\n\t  FieldDefinition: function FieldDefinition(_ref21) {\n\t    var name = _ref21.name;\n\t    var args = _ref21.arguments;\n\t    var type = _ref21.type;\n\t    return name + wrap('(', join(args, ', '), ')') + ': ' + type;\n\t  },\n\t\n\t  InputValueDefinition: function InputValueDefinition(_ref22) {\n\t    var name = _ref22.name;\n\t    var type = _ref22.type;\n\t    var defaultValue = _ref22.defaultValue;\n\t    return name + ': ' + type + wrap(' = ', defaultValue);\n\t  },\n\t\n\t  InterfaceTypeDefinition: function InterfaceTypeDefinition(_ref23) {\n\t    var name = _ref23.name;\n\t    var fields = _ref23.fields;\n\t    return 'interface ' + name + ' ' + block(fields);\n\t  },\n\t\n\t  UnionTypeDefinition: function UnionTypeDefinition(_ref24) {\n\t    var name = _ref24.name;\n\t    var types = _ref24.types;\n\t    return 'union ' + name + ' = ' + join(types, ' | ');\n\t  },\n\t\n\t  ScalarTypeDefinition: function ScalarTypeDefinition(_ref25) {\n\t    var name = _ref25.name;\n\t    return 'scalar ' + name;\n\t  },\n\t\n\t  EnumTypeDefinition: function EnumTypeDefinition(_ref26) {\n\t    var name = _ref26.name;\n\t    var values = _ref26.values;\n\t    return 'enum ' + name + ' ' + block(values);\n\t  },\n\t\n\t  EnumValueDefinition: function EnumValueDefinition(_ref27) {\n\t    var name = _ref27.name;\n\t    return name;\n\t  },\n\t\n\t  InputObjectTypeDefinition: function InputObjectTypeDefinition(_ref28) {\n\t    var name = _ref28.name;\n\t    var fields = _ref28.fields;\n\t    return 'input ' + name + ' ' + block(fields);\n\t  },\n\t\n\t  TypeExtensionDefinition: function TypeExtensionDefinition(_ref29) {\n\t    var definition = _ref29.definition;\n\t    return 'extend ' + definition;\n\t  }\n\t};\n\t\n\t/**\n\t * Given maybeArray, print an empty string if it is null or empty, otherwise\n\t * print all items together separated by separator if provided\n\t */\n\tfunction join(maybeArray, separator) {\n\t  return maybeArray ? maybeArray.filter(function (x) {\n\t    return x;\n\t  }).join(separator || '') : '';\n\t}\n\t\n\t/**\n\t * Given maybeArray, print an empty string if it is null or empty, otherwise\n\t * print each item on its own line, wrapped in an indented \"{ }\" block.\n\t */\n\tfunction block(maybeArray) {\n\t  return length(maybeArray) ? indent('{\\n' + join(maybeArray, '\\n')) + '\\n}' : '';\n\t}\n\t\n\t/**\n\t * If maybeString is not null or empty, then wrap with start and end, otherwise\n\t * print an empty string.\n\t */\n\tfunction wrap(start, maybeString, end) {\n\t  return maybeString ? start + maybeString + (end || '') : '';\n\t}\n\t\n\tfunction indent(maybeString) {\n\t  return maybeString && maybeString.replace(/\\n/g, '\\n  ');\n\t}\n\t\n\tfunction length(maybeArray) {\n\t  return maybeArray ? maybeArray.length : 0;\n\t}\n\n/***/ },\n/* 363 */\n/***/ function(module, exports) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\t\n\texports.visit = visit;\n\texports.visitInParallel = visitInParallel;\n\texports.visitWithTypeInfo = visitWithTypeInfo;\n\tvar QueryDocumentKeys = {\n\t  Name: [],\n\t\n\t  Document: ['definitions'],\n\t  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n\t  VariableDefinition: ['variable', 'type', 'defaultValue'],\n\t  Variable: ['name'],\n\t  SelectionSet: ['selections'],\n\t  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n\t  Argument: ['name', 'value'],\n\t\n\t  FragmentSpread: ['name', 'directives'],\n\t  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n\t  FragmentDefinition: ['name', 'typeCondition', 'directives', 'selectionSet'],\n\t\n\t  IntValue: [],\n\t  FloatValue: [],\n\t  StringValue: [],\n\t  BooleanValue: [],\n\t  EnumValue: [],\n\t  ListValue: ['values'],\n\t  ObjectValue: ['fields'],\n\t  ObjectField: ['name', 'value'],\n\t\n\t  Directive: ['name', 'arguments'],\n\t\n\t  NamedType: ['name'],\n\t  ListType: ['type'],\n\t  NonNullType: ['type'],\n\t\n\t  ObjectTypeDefinition: ['name', 'interfaces', 'fields'],\n\t  FieldDefinition: ['name', 'arguments', 'type'],\n\t  InputValueDefinition: ['name', 'type', 'defaultValue'],\n\t  InterfaceTypeDefinition: ['name', 'fields'],\n\t  UnionTypeDefinition: ['name', 'types'],\n\t  ScalarTypeDefinition: ['name'],\n\t  EnumTypeDefinition: ['name', 'values'],\n\t  EnumValueDefinition: ['name'],\n\t  InputObjectTypeDefinition: ['name', 'fields'],\n\t  TypeExtensionDefinition: ['definition']\n\t};\n\t\n\texports.QueryDocumentKeys = QueryDocumentKeys;\n\tvar BREAK = {};\n\t\n\texports.BREAK = BREAK;\n\t/**\n\t * visit() will walk through an AST using a depth first traversal, calling\n\t * the visitor's enter function at each node in the traversal, and calling the\n\t * leave function after visiting that node and all of its child nodes.\n\t *\n\t * By returning different values from the enter and leave functions, the\n\t * behavior of the visitor can be altered, including skipping over a sub-tree of\n\t * the AST (by returning false), editing the AST by returning a value or null\n\t * to remove the value, or to stop the whole traversal by returning BREAK.\n\t *\n\t * When using visit() to edit an AST, the original AST will not be modified, and\n\t * a new version of the AST with the changes applied will be returned from the\n\t * visit function.\n\t *\n\t *     var editedAST = visit(ast, {\n\t *       enter(node, key, parent, path, ancestors) {\n\t *         // @return\n\t *         //   undefined: no action\n\t *         //   false: skip visiting this node\n\t *         //   visitor.BREAK: stop visiting altogether\n\t *         //   null: delete this node\n\t *         //   any value: replace this node with the returned value\n\t *       },\n\t *       leave(node, key, parent, path, ancestors) {\n\t *         // @return\n\t *         //   undefined: no action\n\t *         //   false: no action\n\t *         //   visitor.BREAK: stop visiting altogether\n\t *         //   null: delete this node\n\t *         //   any value: replace this node with the returned value\n\t *       }\n\t *     });\n\t *\n\t * Alternatively to providing enter() and leave() functions, a visitor can\n\t * instead provide functions named the same as the kinds of AST nodes, or\n\t * enter/leave visitors at a named key, leading to four permutations of\n\t * visitor API:\n\t *\n\t * 1) Named visitors triggered when entering a node a specific kind.\n\t *\n\t *     visit(ast, {\n\t *       Kind(node) {\n\t *         // enter the \"Kind\" node\n\t *       }\n\t *     })\n\t *\n\t * 2) Named visitors that trigger upon entering and leaving a node of\n\t *    a specific kind.\n\t *\n\t *     visit(ast, {\n\t *       Kind: {\n\t *         enter(node) {\n\t *           // enter the \"Kind\" node\n\t *         }\n\t *         leave(node) {\n\t *           // leave the \"Kind\" node\n\t *         }\n\t *       }\n\t *     })\n\t *\n\t * 3) Generic visitors that trigger upon entering and leaving any node.\n\t *\n\t *     visit(ast, {\n\t *       enter(node) {\n\t *         // enter any node\n\t *       },\n\t *       leave(node) {\n\t *         // leave any node\n\t *       }\n\t *     })\n\t *\n\t * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n\t *\n\t *     visit(ast, {\n\t *       enter: {\n\t *         Kind(node) {\n\t *           // enter the \"Kind\" node\n\t *         }\n\t *       },\n\t *       leave: {\n\t *         Kind(node) {\n\t *           // leave the \"Kind\" node\n\t *         }\n\t *       }\n\t *     })\n\t */\n\t\n\tfunction visit(root, visitor, keyMap) {\n\t  var visitorKeys = keyMap || QueryDocumentKeys;\n\t\n\t  var stack;\n\t  var inArray = Array.isArray(root);\n\t  var keys = [root];\n\t  var index = -1;\n\t  var edits = [];\n\t  var parent;\n\t  var path = [];\n\t  var ancestors = [];\n\t  var newRoot = root;\n\t\n\t  do {\n\t    index++;\n\t    var isLeaving = index === keys.length;\n\t    var key;\n\t    var node;\n\t    var isEdited = isLeaving && edits.length !== 0;\n\t    if (isLeaving) {\n\t      key = ancestors.length === 0 ? undefined : path.pop();\n\t      node = parent;\n\t      parent = ancestors.pop();\n\t      if (isEdited) {\n\t        if (inArray) {\n\t          node = node.slice();\n\t        } else {\n\t          var clone = {};\n\t          for (var k in node) {\n\t            if (node.hasOwnProperty(k)) {\n\t              clone[k] = node[k];\n\t            }\n\t          }\n\t          node = clone;\n\t        }\n\t        var editOffset = 0;\n\t        for (var ii = 0; ii < edits.length; ii++) {\n\t          var _edits$ii = _slicedToArray(edits[ii], 2);\n\t\n\t          var editKey = _edits$ii[0];\n\t          var editValue = _edits$ii[1];\n\t\n\t          if (inArray) {\n\t            editKey -= editOffset;\n\t          }\n\t          if (inArray && editValue === null) {\n\t            node.splice(editKey, 1);\n\t            editOffset++;\n\t          } else {\n\t            node[editKey] = editValue;\n\t          }\n\t        }\n\t      }\n\t      index = stack.index;\n\t      keys = stack.keys;\n\t      edits = stack.edits;\n\t      inArray = stack.inArray;\n\t      stack = stack.prev;\n\t    } else {\n\t      key = parent ? inArray ? index : keys[index] : undefined;\n\t      node = parent ? parent[key] : newRoot;\n\t      if (node === null || node === undefined) {\n\t        continue;\n\t      }\n\t      if (parent) {\n\t        path.push(key);\n\t      }\n\t    }\n\t\n\t    var result = undefined;\n\t    if (!Array.isArray(node)) {\n\t      if (!isNode(node)) {\n\t        throw new Error('Invalid AST Node: ' + JSON.stringify(node));\n\t      }\n\t      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\t      if (visitFn) {\n\t        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\t\n\t        if (result === BREAK) {\n\t          break;\n\t        }\n\t\n\t        if (result === false) {\n\t          if (!isLeaving) {\n\t            path.pop();\n\t            continue;\n\t          }\n\t        } else if (result !== undefined) {\n\t          edits.push([key, result]);\n\t          if (!isLeaving) {\n\t            if (isNode(result)) {\n\t              node = result;\n\t            } else {\n\t              path.pop();\n\t              continue;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (result === undefined && isEdited) {\n\t      edits.push([key, node]);\n\t    }\n\t\n\t    if (!isLeaving) {\n\t      stack = { inArray: inArray, index: index, keys: keys, edits: edits, prev: stack };\n\t      inArray = Array.isArray(node);\n\t      keys = inArray ? node : visitorKeys[node.kind] || [];\n\t      index = -1;\n\t      edits = [];\n\t      if (parent) {\n\t        ancestors.push(parent);\n\t      }\n\t      parent = node;\n\t    }\n\t  } while (stack !== undefined);\n\t\n\t  if (edits.length !== 0) {\n\t    newRoot = edits[0][1];\n\t  }\n\t\n\t  return newRoot;\n\t}\n\t\n\tfunction isNode(maybeNode) {\n\t  return maybeNode && typeof maybeNode.kind === 'string';\n\t}\n\t\n\t/**\n\t * Creates a new visitor instance which delegates to many visitors to run in\n\t * parallel. Each visitor will be visited for each node before moving on.\n\t *\n\t * Visitors must not directly modify the AST nodes and only returning false to\n\t * skip sub-branches is supported.\n\t */\n\t\n\tfunction visitInParallel(visitors) {\n\t  var skipping = new Array(visitors.length);\n\t\n\t  return {\n\t    enter: function enter(node) {\n\t      for (var i = 0; i < visitors.length; i++) {\n\t        if (!skipping[i]) {\n\t          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */false);\n\t          if (fn) {\n\t            var result = fn.apply(visitors[i], arguments);\n\t            if (result === false) {\n\t              skipping[i] = node;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    },\n\t    leave: function leave(node) {\n\t      for (var i = 0; i < visitors.length; i++) {\n\t        if (!skipping[i]) {\n\t          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */true);\n\t          if (fn) {\n\t            fn.apply(visitors[i], arguments);\n\t          }\n\t        } else {\n\t          skipping[i] = null;\n\t        }\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Creates a new visitor instance which maintains a provided TypeInfo instance\n\t * along with visiting visitor.\n\t *\n\t * Visitors must not directly modify the AST nodes and only returning false to\n\t * skip sub-branches is supported.\n\t */\n\t\n\tfunction visitWithTypeInfo(typeInfo, visitor) {\n\t  return {\n\t    enter: function enter(node) {\n\t      typeInfo.enter(node);\n\t      var fn = getVisitFn(visitor, node.kind, /* isLeaving */false);\n\t      if (fn) {\n\t        var result = fn.apply(visitor, arguments);\n\t        if (result === false) {\n\t          typeInfo.leave(node);\n\t          return false;\n\t        }\n\t      }\n\t    },\n\t    leave: function leave(node) {\n\t      var fn = getVisitFn(visitor, node.kind, /* isLeaving */true);\n\t      if (fn) {\n\t        fn.apply(visitor, arguments);\n\t      }\n\t      typeInfo.leave(node);\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Given a visitor instance, if it is leaving or not, and a node kind, return\n\t * the function the visitor runtime should call.\n\t */\n\tfunction getVisitFn(visitor, kind, isLeaving) {\n\t  var kindVisitor = visitor[kind];\n\t  if (kindVisitor) {\n\t    if (!isLeaving && typeof kindVisitor === 'function') {\n\t      // { Kind() {} }\n\t      return kindVisitor;\n\t    }\n\t    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\t    if (typeof kindSpecificVisitor === 'function') {\n\t      // { Kind: { enter() {}, leave() {} } }\n\t      return kindSpecificVisitor;\n\t    }\n\t  } else {\n\t    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\t    if (specificVisitor) {\n\t      if (typeof specificVisitor === 'function') {\n\t        // { enter() {}, leave() {} }\n\t        return specificVisitor;\n\t      }\n\t      var specificKindVisitor = specificVisitor[kind];\n\t      if (typeof specificKindVisitor === 'function') {\n\t        // { enter: { Kind() {} }, leave: { Kind() {} } }\n\t        return specificKindVisitor;\n\t      }\n\t    }\n\t  }\n\t}\n\n/***/ },\n/* 364 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.syntaxError = syntaxError;\n\t\n\tvar _languageLocation = __webpack_require__(360);\n\t\n\tvar _GraphQLError = __webpack_require__(357);\n\t\n\t/**\n\t * Produces a GraphQLError representing a syntax error, containing useful\n\t * descriptive information about the syntax error's position in the source.\n\t */\n\t\n\tfunction syntaxError(source, position, description) {\n\t  var location = (0, _languageLocation.getLocation)(source, position);\n\t  var error = new _GraphQLError.GraphQLError('Syntax Error ' + source.name + ' (' + location.line + ':' + location.column + ') ' + description + '\\n\\n' + highlightSourceAtLocation(source, location), undefined, undefined, source, [position]);\n\t  return error;\n\t}\n\t\n\t/**\n\t * Render a helpful description of the location of the error in the GraphQL\n\t * Source document.\n\t */\n\tfunction highlightSourceAtLocation(source, location) {\n\t  var line = location.line;\n\t  var prevLineNum = (line - 1).toString();\n\t  var lineNum = line.toString();\n\t  var nextLineNum = (line + 1).toString();\n\t  var padLen = nextLineNum.length;\n\t  var lines = source.body.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/g);\n\t  return (line >= 2 ? lpad(padLen, prevLineNum) + ': ' + lines[line - 2] + '\\n' : '') + lpad(padLen, lineNum) + ': ' + lines[line - 1] + '\\n' + Array(2 + padLen + location.column).join(' ') + '^\\n' + (line < lines.length ? lpad(padLen, nextLineNum) + ': ' + lines[line] + '\\n' : '');\n\t}\n\t\n\tfunction lpad(len, str) {\n\t  return Array(len - str.length + 1).join(' ') + str;\n\t}\n\n/***/ },\n/* 365 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.locatedError = locatedError;\n\t\n\tvar _GraphQLError = __webpack_require__(357);\n\t\n\t/**\n\t * Given an arbitrary Error, presumably thrown while attempting to execute a\n\t * GraphQL operation, produce a new GraphQLError aware of the location in the\n\t * document responsible for the original Error.\n\t */\n\t\n\tfunction locatedError(error, nodes) {\n\t  var message = error ? error.message || String(error) : 'An unknown error occurred.';\n\t  var stack = error ? error.stack : null;\n\t  return new _GraphQLError.GraphQLError(message, nodes, stack);\n\t}\n\n/***/ },\n/* 366 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Given a GraphQLError, format it according to the rules described by the\n\t * Response Format, Errors section of the GraphQL Specification.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.formatError = formatError;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tfunction formatError(error) {\n\t  (0, _jsutilsInvariant2['default'])(error, 'Received null or undefined error.');\n\t  return {\n\t    message: error.message,\n\t    locations: error.locations\n\t  };\n\t}\n\n/***/ },\n/* 367 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = invariant;\n\t\n\tfunction invariant(condition, message) {\n\t  if (!condition) {\n\t    throw new Error(message);\n\t  }\n\t}\n\t\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 368 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.validate = validate;\n\texports.visitUsingRules = visitUsingRules;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _languageVisitor = __webpack_require__(363);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tvar Kind = _interopRequireWildcard(_languageKinds);\n\t\n\tvar _typeSchema = __webpack_require__(369);\n\t\n\tvar _utilitiesTypeInfo = __webpack_require__(379);\n\t\n\tvar _specifiedRules = __webpack_require__(381);\n\t\n\t/**\n\t * Implements the \"Validation\" section of the spec.\n\t *\n\t * Validation runs synchronously, returning an array of encountered errors, or\n\t * an empty array if no errors were encountered and the document is valid.\n\t *\n\t * A list of specific validation rules may be provided. If not provided, the\n\t * default list of rules defined by the GraphQL specification will be used.\n\t *\n\t * Each validation rules is a function which returns a visitor\n\t * (see the language/visitor API). Visitor methods are expected to return\n\t * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n\t */\n\t\n\tfunction validate(schema, ast, rules) {\n\t  (0, _jsutilsInvariant2['default'])(schema, 'Must provide schema');\n\t  (0, _jsutilsInvariant2['default'])(ast, 'Must provide document');\n\t  (0, _jsutilsInvariant2['default'])(schema instanceof _typeSchema.GraphQLSchema, 'Schema must be an instance of GraphQLSchema. Also ensure that there are ' + 'not multiple versions of GraphQL installed in your node_modules directory.');\n\t  var typeInfo = new _utilitiesTypeInfo.TypeInfo(schema);\n\t  return visitUsingRules(schema, typeInfo, ast, rules || _specifiedRules.specifiedRules);\n\t}\n\t\n\t/**\n\t * This uses a specialized visitor which runs multiple visitors in parallel,\n\t * while maintaining the visitor skip and break API.\n\t *\n\t * @internal\n\t */\n\t\n\tfunction visitUsingRules(schema, typeInfo, documentAST, rules) {\n\t  var context = new ValidationContext(schema, documentAST, typeInfo);\n\t  var visitors = rules.map(function (rule) {\n\t    return rule(context);\n\t  });\n\t  // Visit the whole document with each instance of all provided rules.\n\t  (0, _languageVisitor.visit)(documentAST, (0, _languageVisitor.visitWithTypeInfo)(typeInfo, (0, _languageVisitor.visitInParallel)(visitors)));\n\t  return context.getErrors();\n\t}\n\t\n\t/**\n\t * An instance of this class is passed as the \"this\" context to all validators,\n\t * allowing access to commonly useful contextual information from within a\n\t * validation rule.\n\t */\n\t\n\tvar ValidationContext = (function () {\n\t  function ValidationContext(schema, ast, typeInfo) {\n\t    _classCallCheck(this, ValidationContext);\n\t\n\t    this._schema = schema;\n\t    this._ast = ast;\n\t    this._typeInfo = typeInfo;\n\t    this._errors = [];\n\t    this._fragmentSpreads = new Map();\n\t    this._recursivelyReferencedFragments = new Map();\n\t    this._variableUsages = new Map();\n\t    this._recursiveVariableUsages = new Map();\n\t  }\n\t\n\t  _createClass(ValidationContext, [{\n\t    key: 'reportError',\n\t    value: function reportError(error) {\n\t      this._errors.push(error);\n\t    }\n\t  }, {\n\t    key: 'getErrors',\n\t    value: function getErrors() {\n\t      return this._errors;\n\t    }\n\t  }, {\n\t    key: 'getSchema',\n\t    value: function getSchema() {\n\t      return this._schema;\n\t    }\n\t  }, {\n\t    key: 'getDocument',\n\t    value: function getDocument() {\n\t      return this._ast;\n\t    }\n\t  }, {\n\t    key: 'getFragment',\n\t    value: function getFragment(name) {\n\t      var fragments = this._fragments;\n\t      if (!fragments) {\n\t        this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n\t          if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n\t            frags[statement.name.value] = statement;\n\t          }\n\t          return frags;\n\t        }, {});\n\t      }\n\t      return fragments[name];\n\t    }\n\t  }, {\n\t    key: 'getFragmentSpreads',\n\t    value: function getFragmentSpreads(node) {\n\t      var spreads = this._fragmentSpreads.get(node);\n\t      if (!spreads) {\n\t        spreads = [];\n\t        var setsToVisit = [node.selectionSet];\n\t        while (setsToVisit.length !== 0) {\n\t          var set = setsToVisit.pop();\n\t          for (var i = 0; i < set.selections.length; i++) {\n\t            var selection = set.selections[i];\n\t            if (selection.kind === Kind.FRAGMENT_SPREAD) {\n\t              spreads.push(selection);\n\t            } else if (selection.selectionSet) {\n\t              setsToVisit.push(selection.selectionSet);\n\t            }\n\t          }\n\t        }\n\t        this._fragmentSpreads.set(node, spreads);\n\t      }\n\t      return spreads;\n\t    }\n\t  }, {\n\t    key: 'getRecursivelyReferencedFragments',\n\t    value: function getRecursivelyReferencedFragments(operation) {\n\t      var fragments = this._recursivelyReferencedFragments.get(operation);\n\t      if (!fragments) {\n\t        fragments = [];\n\t        var collectedNames = Object.create(null);\n\t        var nodesToVisit = [operation];\n\t        while (nodesToVisit.length !== 0) {\n\t          var _node = nodesToVisit.pop();\n\t          var spreads = this.getFragmentSpreads(_node);\n\t          for (var i = 0; i < spreads.length; i++) {\n\t            var fragName = spreads[i].name.value;\n\t            if (collectedNames[fragName] !== true) {\n\t              collectedNames[fragName] = true;\n\t              var fragment = this.getFragment(fragName);\n\t              if (fragment) {\n\t                fragments.push(fragment);\n\t                nodesToVisit.push(fragment);\n\t              }\n\t            }\n\t          }\n\t        }\n\t        this._recursivelyReferencedFragments.set(operation, fragments);\n\t      }\n\t      return fragments;\n\t    }\n\t  }, {\n\t    key: 'getVariableUsages',\n\t    value: function getVariableUsages(node) {\n\t      var _this = this;\n\t\n\t      var usages = this._variableUsages.get(node);\n\t      if (!usages) {\n\t        (function () {\n\t          usages = [];\n\t          var typeInfo = new _utilitiesTypeInfo.TypeInfo(_this._schema);\n\t          (0, _languageVisitor.visit)(node, (0, _languageVisitor.visitWithTypeInfo)(typeInfo, {\n\t            VariableDefinition: function VariableDefinition() {\n\t              return false;\n\t            },\n\t            Variable: function Variable(variable) {\n\t              usages.push({ node: variable, type: typeInfo.getInputType() });\n\t            }\n\t          }));\n\t          _this._variableUsages.set(node, usages);\n\t        })();\n\t      }\n\t      return usages;\n\t    }\n\t  }, {\n\t    key: 'getRecursiveVariableUsages',\n\t    value: function getRecursiveVariableUsages(operation) {\n\t      var usages = this._recursiveVariableUsages.get(operation);\n\t      if (!usages) {\n\t        usages = this.getVariableUsages(operation);\n\t        var fragments = this.getRecursivelyReferencedFragments(operation);\n\t        for (var i = 0; i < fragments.length; i++) {\n\t          Array.prototype.push.apply(usages, this.getVariableUsages(fragments[i]));\n\t        }\n\t        this._recursiveVariableUsages.set(operation, usages);\n\t      }\n\t      return usages;\n\t    }\n\t  }, {\n\t    key: 'getType',\n\t    value: function getType() {\n\t      return this._typeInfo.getType();\n\t    }\n\t  }, {\n\t    key: 'getParentType',\n\t    value: function getParentType() {\n\t      return this._typeInfo.getParentType();\n\t    }\n\t  }, {\n\t    key: 'getInputType',\n\t    value: function getInputType() {\n\t      return this._typeInfo.getInputType();\n\t    }\n\t  }, {\n\t    key: 'getFieldDef',\n\t    value: function getFieldDef() {\n\t      return this._typeInfo.getFieldDef();\n\t    }\n\t  }, {\n\t    key: 'getDirective',\n\t    value: function getDirective() {\n\t      return this._typeInfo.getDirective();\n\t    }\n\t  }, {\n\t    key: 'getArgument',\n\t    value: function getArgument() {\n\t      return this._typeInfo.getArgument();\n\t    }\n\t  }]);\n\t\n\t  return ValidationContext;\n\t})();\n\t\n\texports.ValidationContext = ValidationContext;\n\n/***/ },\n/* 369 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _definition = __webpack_require__(370);\n\t\n\tvar _directives = __webpack_require__(373);\n\t\n\tvar _introspection = __webpack_require__(375);\n\t\n\tvar _jsutilsFind = __webpack_require__(377);\n\t\n\tvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _utilitiesTypeComparators = __webpack_require__(378);\n\t\n\t/**\n\t * Schema Definition\n\t *\n\t * A Schema is created by supplying the root types of each type of operation,\n\t * query and mutation (optional). A schema definition is then supplied to the\n\t * validator and executor.\n\t *\n\t * Example:\n\t *\n\t *     var MyAppSchema = new GraphQLSchema({\n\t *       query: MyAppQueryRootType\n\t *       mutation: MyAppMutationRootType\n\t *     });\n\t *\n\t */\n\t\n\tvar GraphQLSchema = (function () {\n\t  function GraphQLSchema(config) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, GraphQLSchema);\n\t\n\t    (0, _jsutilsInvariant2['default'])(typeof config === 'object', 'Must provide configuration object.');\n\t\n\t    (0, _jsutilsInvariant2['default'])(config.query instanceof _definition.GraphQLObjectType, 'Schema query must be Object Type but got: ' + config.query + '.');\n\t    this._queryType = config.query;\n\t\n\t    (0, _jsutilsInvariant2['default'])(!config.mutation || config.mutation instanceof _definition.GraphQLObjectType, 'Schema mutation must be Object Type if provided but ' + ('got: ' + config.mutation + '.'));\n\t    this._mutationType = config.mutation;\n\t\n\t    (0, _jsutilsInvariant2['default'])(!config.subscription || config.subscription instanceof _definition.GraphQLObjectType, 'Schema subscription must be Object Type if provided but ' + ('got: ' + config.subscription + '.'));\n\t    this._subscriptionType = config.subscription;\n\t\n\t    (0, _jsutilsInvariant2['default'])(!config.directives || Array.isArray(config.directives) && config.directives.every(function (directive) {\n\t      return directive instanceof _directives.GraphQLDirective;\n\t    }), 'Schema directives must be Array<GraphQLDirective> if provided but ' + ('got: ' + config.directives + '.'));\n\t    // Provide `@include() and `@skip()` directives by default.\n\t    this._directives = config.directives || [_directives.GraphQLIncludeDirective, _directives.GraphQLSkipDirective];\n\t\n\t    // Build type map now to detect any errors within this schema.\n\t    this._typeMap = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), _introspection.__Schema].reduce(typeMapReducer, {});\n\t\n\t    // Enforce correct interface implementations\n\t    Object.keys(this._typeMap).forEach(function (typeName) {\n\t      var type = _this._typeMap[typeName];\n\t      if (type instanceof _definition.GraphQLObjectType) {\n\t        type.getInterfaces().forEach(function (iface) {\n\t          return assertObjectImplementsInterface(type, iface);\n\t        });\n\t      }\n\t    });\n\t  }\n\t\n\t  _createClass(GraphQLSchema, [{\n\t    key: 'getQueryType',\n\t    value: function getQueryType() {\n\t      return this._queryType;\n\t    }\n\t  }, {\n\t    key: 'getMutationType',\n\t    value: function getMutationType() {\n\t      return this._mutationType;\n\t    }\n\t  }, {\n\t    key: 'getSubscriptionType',\n\t    value: function getSubscriptionType() {\n\t      return this._subscriptionType;\n\t    }\n\t  }, {\n\t    key: 'getTypeMap',\n\t    value: function getTypeMap() {\n\t      return this._typeMap;\n\t    }\n\t  }, {\n\t    key: 'getType',\n\t    value: function getType(name) {\n\t      return this.getTypeMap()[name];\n\t    }\n\t  }, {\n\t    key: 'getDirectives',\n\t    value: function getDirectives() {\n\t      return this._directives;\n\t    }\n\t  }, {\n\t    key: 'getDirective',\n\t    value: function getDirective(name) {\n\t      return (0, _jsutilsFind2['default'])(this.getDirectives(), function (directive) {\n\t        return directive.name === name;\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return GraphQLSchema;\n\t})();\n\t\n\texports.GraphQLSchema = GraphQLSchema;\n\t\n\tfunction typeMapReducer(_x, _x2) {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    var map = _x,\n\t        type = _x2;\n\t    reducedMap = fieldMap = undefined;\n\t    _again = false;\n\t\n\t    if (!type) {\n\t      return map;\n\t    }\n\t    if (type instanceof _definition.GraphQLList || type instanceof _definition.GraphQLNonNull) {\n\t      _x = map;\n\t      _x2 = type.ofType;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t    if (map[type.name]) {\n\t      (0, _jsutilsInvariant2['default'])(map[type.name] === type, 'Schema must contain unique named types but contains multiple ' + ('types named \"' + type + '\".'));\n\t      return map;\n\t    }\n\t    map[type.name] = type;\n\t\n\t    var reducedMap = map;\n\t\n\t    if (type instanceof _definition.GraphQLUnionType || type instanceof _definition.GraphQLInterfaceType) {\n\t      reducedMap = type.getPossibleTypes().reduce(typeMapReducer, reducedMap);\n\t    }\n\t\n\t    if (type instanceof _definition.GraphQLObjectType) {\n\t      reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n\t    }\n\t\n\t    if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType || type instanceof _definition.GraphQLInputObjectType) {\n\t      var fieldMap = type.getFields();\n\t      Object.keys(fieldMap).forEach(function (fieldName) {\n\t        var field = fieldMap[fieldName];\n\t\n\t        if (field.args) {\n\t          var fieldArgTypes = field.args.map(function (arg) {\n\t            return arg.type;\n\t          });\n\t          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n\t        }\n\t        reducedMap = typeMapReducer(reducedMap, field.type);\n\t      });\n\t    }\n\t\n\t    return reducedMap;\n\t  }\n\t}\n\t\n\tfunction assertObjectImplementsInterface(object, iface) {\n\t  var objectFieldMap = object.getFields();\n\t  var ifaceFieldMap = iface.getFields();\n\t\n\t  // Assert each interface field is implemented.\n\t  Object.keys(ifaceFieldMap).forEach(function (fieldName) {\n\t    var objectField = objectFieldMap[fieldName];\n\t    var ifaceField = ifaceFieldMap[fieldName];\n\t\n\t    // Assert interface field exists on object.\n\t    (0, _jsutilsInvariant2['default'])(objectField, '\"' + iface + '\" expects field \"' + fieldName + '\" but \"' + object + '\" does not ' + 'provide it.');\n\t\n\t    // Assert interface field type is satisfied by object field type, by being\n\t    // a valid subtype. (covariant)\n\t    (0, _jsutilsInvariant2['default'])((0, _utilitiesTypeComparators.isTypeSubTypeOf)(objectField.type, ifaceField.type), iface + '.' + fieldName + ' expects type \"' + ifaceField.type + '\" but ' + (object + '.' + fieldName + ' provides type \"' + objectField.type + '\".'));\n\t\n\t    // Assert each interface field arg is implemented.\n\t    ifaceField.args.forEach(function (ifaceArg) {\n\t      var argName = ifaceArg.name;\n\t      var objectArg = (0, _jsutilsFind2['default'])(objectField.args, function (arg) {\n\t        return arg.name === argName;\n\t      });\n\t\n\t      // Assert interface field arg exists on object field.\n\t      (0, _jsutilsInvariant2['default'])(objectArg, iface + '.' + fieldName + ' expects argument \"' + argName + '\" but ' + (object + '.' + fieldName + ' does not provide it.'));\n\t\n\t      // Assert interface field arg type matches object field arg type.\n\t      // (invariant)\n\t      (0, _jsutilsInvariant2['default'])((0, _utilitiesTypeComparators.isEqualType)(ifaceArg.type, objectArg.type), iface + '.' + fieldName + '(' + argName + ':) expects type \"' + ifaceArg.type + '\" ' + ('but ' + object + '.' + fieldName + '(' + argName + ':) provides ') + ('type \"' + objectArg.type + '\".'));\n\t    });\n\t\n\t    // Assert additional arguments must not be required.\n\t    objectField.args.forEach(function (objectArg) {\n\t      var argName = objectArg.name;\n\t      var ifaceArg = (0, _jsutilsFind2['default'])(ifaceField.args, function (arg) {\n\t        return arg.name === argName;\n\t      });\n\t      if (!ifaceArg) {\n\t        (0, _jsutilsInvariant2['default'])(!(objectArg.type instanceof _definition.GraphQLNonNull), object + '.' + fieldName + '(' + argName + ':) is of required type ' + ('\"' + objectArg.type + '\" but is not also provided by the ') + ('interface ' + iface + '.' + fieldName + '.'));\n\t      }\n\t    });\n\t  });\n\t}\n\n/***/ },\n/* 370 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t// Predicates\n\t\n\t/**\n\t * These are all of the possible kinds of types.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.isType = isType;\n\t\n\t/**\n\t * These types may be used as input types for arguments and directives.\n\t */\n\texports.isInputType = isInputType;\n\t\n\t/**\n\t * These types may be used as output types as the result of fields.\n\t */\n\texports.isOutputType = isOutputType;\n\t\n\t/**\n\t * These types may describe types which may be leaf values.\n\t */\n\texports.isLeafType = isLeafType;\n\t\n\t/**\n\t * These types may describe the parent context of a selection set.\n\t */\n\texports.isCompositeType = isCompositeType;\n\t\n\t/**\n\t * These types may describe the parent context of a selection set.\n\t */\n\texports.isAbstractType = isAbstractType;\n\t\n\t/**\n\t * These types can all accept null as a value.\n\t */\n\texports.getNullableType = getNullableType;\n\t\n\t/**\n\t * These named types do not include modifiers like List or NonNull.\n\t */\n\texports.getNamedType = getNamedType;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\tvar _jsutilsKeyMap = __webpack_require__(372);\n\t\n\tvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tfunction isType(type) {\n\t  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType || type instanceof GraphQLList || type instanceof GraphQLNonNull;\n\t}\n\t\n\tfunction isInputType(type) {\n\t  var namedType = getNamedType(type);\n\t  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLEnumType || namedType instanceof GraphQLInputObjectType;\n\t}\n\t\n\tfunction isOutputType(type) {\n\t  var namedType = getNamedType(type);\n\t  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLObjectType || namedType instanceof GraphQLInterfaceType || namedType instanceof GraphQLUnionType || namedType instanceof GraphQLEnumType;\n\t}\n\t\n\tfunction isLeafType(type) {\n\t  var namedType = getNamedType(type);\n\t  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLEnumType;\n\t}\n\t\n\tfunction isCompositeType(type) {\n\t  return type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;\n\t}\n\t\n\tfunction isAbstractType(type) {\n\t  return type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;\n\t}\n\t\n\tfunction getNullableType(type) {\n\t  return type instanceof GraphQLNonNull ? type.ofType : type;\n\t}\n\t\n\tfunction getNamedType(type) {\n\t  var unmodifiedType = type;\n\t  while (unmodifiedType instanceof GraphQLList || unmodifiedType instanceof GraphQLNonNull) {\n\t    unmodifiedType = unmodifiedType.ofType;\n\t  }\n\t  return unmodifiedType;\n\t}\n\t\n\t/**\n\t * Scalar Type Definition\n\t *\n\t * The leaf values of any request and input values to arguments are\n\t * Scalars (or Enums) and are defined with a name and a series of functions\n\t * used to parse input from ast or variables and to ensure validity.\n\t *\n\t * Example:\n\t *\n\t *     var OddType = new GraphQLScalarType({\n\t *       name: 'Odd',\n\t *       serialize(value) {\n\t *         return value % 2 === 1 ? value : null;\n\t *       }\n\t *     });\n\t *\n\t */\n\t\n\tvar GraphQLScalarType /* <T> */ = (function () {\n\t  /* <T> */\n\t  function GraphQLScalarType(config /* <T> */) {\n\t    _classCallCheck(this, GraphQLScalarType);\n\t\n\t    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n\t    assertValidName(config.name);\n\t    this.name = config.name;\n\t    this.description = config.description;\n\t    (0, _jsutilsInvariant2['default'])(typeof config.serialize === 'function', this + ' must provide \"serialize\" function. If this custom Scalar is ' + 'also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' + 'functions are also provided.');\n\t    if (config.parseValue || config.parseLiteral) {\n\t      (0, _jsutilsInvariant2['default'])(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function', this + ' must provide both \"parseValue\" and \"parseLiteral\" functions.');\n\t    }\n\t    this._scalarConfig = config;\n\t  }\n\t\n\t  _createClass(GraphQLScalarType, [{\n\t    key: 'serialize',\n\t    value: function serialize(value) /* T */{\n\t      var serializer = this._scalarConfig.serialize;\n\t      return serializer(value);\n\t    }\n\t  }, {\n\t    key: 'parseValue',\n\t    value: function parseValue(value) /* T */{\n\t      var parser = this._scalarConfig.parseValue;\n\t      return parser ? parser(value) : null;\n\t    }\n\t  }, {\n\t    key: 'parseLiteral',\n\t    value: function parseLiteral(valueAST) /* T */{\n\t      var parser = this._scalarConfig.parseLiteral;\n\t      return parser ? parser(valueAST) : null;\n\t    }\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this.name;\n\t    }\n\t  }]);\n\t\n\t  return GraphQLScalarType;\n\t})();\n\t\n\texports.GraphQLScalarType = GraphQLScalarType;\n\t/* T */\n\t\n\t/**\n\t * Object Type Definition\n\t *\n\t * Almost all of the GraphQL types you define will be object types. Object types\n\t * have a name, but most importantly describe their fields.\n\t *\n\t * Example:\n\t *\n\t *     var AddressType = new GraphQLObjectType({\n\t *       name: 'Address',\n\t *       fields: {\n\t *         street: { type: GraphQLString },\n\t *         number: { type: GraphQLInt },\n\t *         formatted: {\n\t *           type: GraphQLString,\n\t *           resolve(obj) {\n\t *             return obj.number + ' ' + obj.street\n\t *           }\n\t *         }\n\t *       }\n\t *     });\n\t *\n\t * When two types need to refer to each other, or a type needs to refer to\n\t * itself in a field, you can use a function expression (aka a closure or a\n\t * thunk) to supply the fields lazily.\n\t *\n\t * Example:\n\t *\n\t *     var PersonType = new GraphQLObjectType({\n\t *       name: 'Person',\n\t *       fields: () => ({\n\t *         name: { type: GraphQLString },\n\t *         bestFriend: { type: PersonType },\n\t *       })\n\t *     });\n\t *\n\t */\n\t\n\tvar GraphQLObjectType = (function () {\n\t  function GraphQLObjectType(config) {\n\t    _classCallCheck(this, GraphQLObjectType);\n\t\n\t    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n\t    assertValidName(config.name);\n\t    this.name = config.name;\n\t    this.description = config.description;\n\t    if (config.isTypeOf) {\n\t      (0, _jsutilsInvariant2['default'])(typeof config.isTypeOf === 'function', this + ' must provide \"isTypeOf\" as a function.');\n\t    }\n\t    this.isTypeOf = config.isTypeOf;\n\t    this._typeConfig = config;\n\t    addImplementationToInterfaces(this);\n\t  }\n\t\n\t  _createClass(GraphQLObjectType, [{\n\t    key: 'getFields',\n\t    value: function getFields() {\n\t      return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n\t    }\n\t  }, {\n\t    key: 'getInterfaces',\n\t    value: function getInterfaces() {\n\t      return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));\n\t    }\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this.name;\n\t    }\n\t  }]);\n\t\n\t  return GraphQLObjectType;\n\t})();\n\t\n\texports.GraphQLObjectType = GraphQLObjectType;\n\t\n\tfunction resolveMaybeThunk(thingOrThunk) {\n\t  return typeof thingOrThunk === 'function' ? thingOrThunk() : thingOrThunk;\n\t}\n\t\n\tfunction defineInterfaces(type, interfacesOrThunk) {\n\t  var interfaces = resolveMaybeThunk(interfacesOrThunk);\n\t  if (!interfaces) {\n\t    return [];\n\t  }\n\t  (0, _jsutilsInvariant2['default'])(Array.isArray(interfaces), type + ' interfaces must be an Array or a function which returns an Array.');\n\t  interfaces.forEach(function (iface) {\n\t    (0, _jsutilsInvariant2['default'])(iface instanceof GraphQLInterfaceType, type + ' may only implement Interface types, it cannot ' + ('implement: ' + iface + '.'));\n\t    if (typeof iface.resolveType !== 'function') {\n\t      (0, _jsutilsInvariant2['default'])(typeof type.isTypeOf === 'function', 'Interface Type ' + iface + ' does not provide a \"resolveType\" function ' + ('and implementing Type ' + type + ' does not provide a \"isTypeOf\" ') + 'function. There is no way to resolve this implementing type ' + 'during execution.');\n\t    }\n\t  });\n\t  return interfaces;\n\t}\n\t\n\tfunction defineFieldMap(type, fields) {\n\t  var fieldMap = resolveMaybeThunk(fields);\n\t  (0, _jsutilsInvariant2['default'])(isPlainObj(fieldMap), type + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');\n\t\n\t  var fieldNames = Object.keys(fieldMap);\n\t  (0, _jsutilsInvariant2['default'])(fieldNames.length > 0, type + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');\n\t\n\t  var resultFieldMap = {};\n\t  fieldNames.forEach(function (fieldName) {\n\t    assertValidName(fieldName);\n\t    var field = _extends({}, fieldMap[fieldName], {\n\t      name: fieldName\n\t    });\n\t    (0, _jsutilsInvariant2['default'])(!field.hasOwnProperty('isDeprecated'), type + '.' + fieldName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".');\n\t    (0, _jsutilsInvariant2['default'])(isOutputType(field.type), type + '.' + fieldName + ' field type must be Output Type but ' + ('got: ' + field.type + '.'));\n\t    if (!field.args) {\n\t      field.args = [];\n\t    } else {\n\t      (0, _jsutilsInvariant2['default'])(isPlainObj(field.args), type + '.' + fieldName + ' args must be an object with argument names ' + 'as keys.');\n\t      field.args = Object.keys(field.args).map(function (argName) {\n\t        assertValidName(argName);\n\t        var arg = field.args[argName];\n\t        (0, _jsutilsInvariant2['default'])(isInputType(arg.type), type + '.' + fieldName + '(' + argName + ':) argument type must be ' + ('Input Type but got: ' + arg.type + '.'));\n\t        return {\n\t          name: argName,\n\t          description: arg.description === undefined ? null : arg.description,\n\t          type: arg.type,\n\t          defaultValue: arg.defaultValue === undefined ? null : arg.defaultValue\n\t        };\n\t      });\n\t    }\n\t    resultFieldMap[fieldName] = field;\n\t  });\n\t  return resultFieldMap;\n\t}\n\t\n\tfunction isPlainObj(obj) {\n\t  return obj && typeof obj === 'object' && !Array.isArray(obj);\n\t}\n\t\n\t/**\n\t * Update the interfaces to know about this implementation.\n\t * This is an rare and unfortunate use of mutation in the type definition\n\t * implementations, but avoids an expensive \"getPossibleTypes\"\n\t * implementation for Interface types.\n\t */\n\tfunction addImplementationToInterfaces(impl) {\n\t  impl.getInterfaces().forEach(function (type) {\n\t    type._implementations.push(impl);\n\t  });\n\t}\n\t\n\t/**\n\t * Interface Type Definition\n\t *\n\t * When a field can return one of a heterogeneous set of types, a Interface type\n\t * is used to describe what types are possible, what fields are in common across\n\t * all types, as well as a function to determine which type is actually used\n\t * when the field is resolved.\n\t *\n\t * Example:\n\t *\n\t *     var EntityType = new GraphQLInterfaceType({\n\t *       name: 'Entity',\n\t *       fields: {\n\t *         name: { type: GraphQLString }\n\t *       }\n\t *     });\n\t *\n\t */\n\t\n\tvar GraphQLInterfaceType = (function () {\n\t  function GraphQLInterfaceType(config) {\n\t    _classCallCheck(this, GraphQLInterfaceType);\n\t\n\t    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n\t    assertValidName(config.name);\n\t    this.name = config.name;\n\t    this.description = config.description;\n\t    if (config.resolveType) {\n\t      (0, _jsutilsInvariant2['default'])(typeof config.resolveType === 'function', this + ' must provide \"resolveType\" as a function.');\n\t    }\n\t    this.resolveType = config.resolveType;\n\t    this._typeConfig = config;\n\t    this._implementations = [];\n\t  }\n\t\n\t  _createClass(GraphQLInterfaceType, [{\n\t    key: 'getFields',\n\t    value: function getFields() {\n\t      return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n\t    }\n\t  }, {\n\t    key: 'getPossibleTypes',\n\t    value: function getPossibleTypes() {\n\t      return this._implementations;\n\t    }\n\t  }, {\n\t    key: 'isPossibleType',\n\t    value: function isPossibleType(type) {\n\t      var possibleTypes = this._possibleTypes || (this._possibleTypes = (0, _jsutilsKeyMap2['default'])(this.getPossibleTypes(), function (possibleType) {\n\t        return possibleType.name;\n\t      }));\n\t      return Boolean(possibleTypes[type.name]);\n\t    }\n\t  }, {\n\t    key: 'getObjectType',\n\t    value: function getObjectType(value, info) {\n\t      var resolver = this.resolveType;\n\t      return resolver ? resolver(value, info) : getTypeOf(value, info, this);\n\t    }\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this.name;\n\t    }\n\t  }]);\n\t\n\t  return GraphQLInterfaceType;\n\t})();\n\t\n\texports.GraphQLInterfaceType = GraphQLInterfaceType;\n\t\n\tfunction getTypeOf(value, info, abstractType) {\n\t  var possibleTypes = abstractType.getPossibleTypes();\n\t  for (var i = 0; i < possibleTypes.length; i++) {\n\t    var type = possibleTypes[i];\n\t    if (typeof type.isTypeOf === 'function' && type.isTypeOf(value, info)) {\n\t      return type;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Union Type Definition\n\t *\n\t * When a field can return one of a heterogeneous set of types, a Union type\n\t * is used to describe what types are possible as well as providing a function\n\t * to determine which type is actually used when the field is resolved.\n\t *\n\t * Example:\n\t *\n\t *     var PetType = new GraphQLUnionType({\n\t *       name: 'Pet',\n\t *       types: [ DogType, CatType ],\n\t *       resolveType(value) {\n\t *         if (value instanceof Dog) {\n\t *           return DogType;\n\t *         }\n\t *         if (value instanceof Cat) {\n\t *           return CatType;\n\t *         }\n\t *       }\n\t *     });\n\t *\n\t */\n\t\n\tvar GraphQLUnionType = (function () {\n\t  function GraphQLUnionType(config) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, GraphQLUnionType);\n\t\n\t    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n\t    assertValidName(config.name);\n\t    this.name = config.name;\n\t    this.description = config.description;\n\t    if (config.resolveType) {\n\t      (0, _jsutilsInvariant2['default'])(typeof config.resolveType === 'function', this + ' must provide \"resolveType\" as a function.');\n\t    }\n\t    this.resolveType = config.resolveType;\n\t    (0, _jsutilsInvariant2['default'])(Array.isArray(config.types) && config.types.length > 0, 'Must provide Array of types for Union ' + config.name + '.');\n\t    config.types.forEach(function (type) {\n\t      (0, _jsutilsInvariant2['default'])(type instanceof GraphQLObjectType, _this + ' may only contain Object types, it cannot contain: ' + type + '.');\n\t      if (typeof _this.resolveType !== 'function') {\n\t        (0, _jsutilsInvariant2['default'])(typeof type.isTypeOf === 'function', 'Union Type ' + _this + ' does not provide a \"resolveType\" function ' + ('and possible Type ' + type + ' does not provide a \"isTypeOf\" ') + 'function. There is no way to resolve this possible type ' + 'during execution.');\n\t      }\n\t    });\n\t    this._types = config.types;\n\t    this._typeConfig = config;\n\t  }\n\t\n\t  _createClass(GraphQLUnionType, [{\n\t    key: 'getPossibleTypes',\n\t    value: function getPossibleTypes() {\n\t      return this._types;\n\t    }\n\t  }, {\n\t    key: 'isPossibleType',\n\t    value: function isPossibleType(type) {\n\t      var possibleTypeNames = this._possibleTypeNames;\n\t      if (!possibleTypeNames) {\n\t        this._possibleTypeNames = possibleTypeNames = this.getPossibleTypes().reduce(function (map, possibleType) {\n\t          return (map[possibleType.name] = true, map);\n\t        }, {});\n\t      }\n\t      return possibleTypeNames[type.name] === true;\n\t    }\n\t  }, {\n\t    key: 'getObjectType',\n\t    value: function getObjectType(value, info) {\n\t      var resolver = this._typeConfig.resolveType;\n\t      return resolver ? resolver(value, info) : getTypeOf(value, info, this);\n\t    }\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this.name;\n\t    }\n\t  }]);\n\t\n\t  return GraphQLUnionType;\n\t})();\n\t\n\texports.GraphQLUnionType = GraphQLUnionType;\n\t\n\t/**\n\t * Enum Type Definition\n\t *\n\t * Some leaf values of requests and input values are Enums. GraphQL serializes\n\t * Enum values as strings, however internally Enums can be represented by any\n\t * kind of type, often integers.\n\t *\n\t * Example:\n\t *\n\t *     var RGBType = new GraphQLEnumType({\n\t *       name: 'RGB',\n\t *       values: {\n\t *         RED: { value: 0 },\n\t *         GREEN: { value: 1 },\n\t *         BLUE: { value: 2 }\n\t *       }\n\t *     });\n\t *\n\t * Note: If a value is not provided in a definition, the name of the enum value\n\t * will be used as its internal value.\n\t */\n\t\n\tvar GraphQLEnumType /* <T> */ = (function () {\n\t  function GraphQLEnumType(config /* <T> */) {\n\t    _classCallCheck(this, GraphQLEnumType);\n\t\n\t    this.name = config.name;\n\t    assertValidName(config.name);\n\t    this.description = config.description;\n\t    this._values = defineEnumValues(this, config.values);\n\t    this._enumConfig = config;\n\t  }\n\t\n\t  _createClass(GraphQLEnumType, [{\n\t    key: 'getValues',\n\t    value: function getValues() /* <T> */{\n\t      return this._values;\n\t    }\n\t  }, {\n\t    key: 'serialize',\n\t    value: function serialize(value /* T */) {\n\t      var enumValue = this._getValueLookup().get(value);\n\t      return enumValue ? enumValue.name : null;\n\t    }\n\t  }, {\n\t    key: 'parseValue',\n\t    value: function parseValue(value) /* T */{\n\t      var enumValue = this._getNameLookup()[value];\n\t      if (enumValue) {\n\t        return enumValue.value;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'parseLiteral',\n\t    value: function parseLiteral(valueAST) /* T */{\n\t      if (valueAST.kind === _languageKinds.ENUM) {\n\t        var enumValue = this._getNameLookup()[valueAST.value];\n\t        if (enumValue) {\n\t          return enumValue.value;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_getValueLookup',\n\t    value: function _getValueLookup() {\n\t      if (!this._valueLookup) {\n\t        var lookup = new Map();\n\t        this.getValues().forEach(function (value) {\n\t          lookup.set(value.value, value);\n\t        });\n\t        this._valueLookup = lookup;\n\t      }\n\t      return this._valueLookup;\n\t    }\n\t  }, {\n\t    key: '_getNameLookup',\n\t    value: function _getNameLookup() {\n\t      if (!this._nameLookup) {\n\t        var lookup = Object.create(null);\n\t        this.getValues().forEach(function (value) {\n\t          lookup[value.name] = value;\n\t        });\n\t        this._nameLookup = lookup;\n\t      }\n\t      return this._nameLookup;\n\t    }\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this.name;\n\t    }\n\t  }]);\n\t\n\t  return GraphQLEnumType;\n\t})();\n\t\n\texports.GraphQLEnumType = GraphQLEnumType;\n\t\n\tfunction defineEnumValues(type, valueMap /* <T> */\n\t) /* <T> */{\n\t  (0, _jsutilsInvariant2['default'])(isPlainObj(valueMap), type + ' values must be an object with value names as keys.');\n\t  var valueNames = Object.keys(valueMap);\n\t  (0, _jsutilsInvariant2['default'])(valueNames.length > 0, type + ' values must be an object with value names as keys.');\n\t  return valueNames.map(function (valueName) {\n\t    assertValidName(valueName);\n\t    var value = valueMap[valueName];\n\t    (0, _jsutilsInvariant2['default'])(isPlainObj(value), type + '.' + valueName + ' must refer to an object with a \"value\" key ' + ('representing an internal value but got: ' + value + '.'));\n\t    (0, _jsutilsInvariant2['default'])(!value.hasOwnProperty('isDeprecated'), type + '.' + valueName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".');\n\t    return {\n\t      name: valueName,\n\t      description: value.description,\n\t      deprecationReason: value.deprecationReason,\n\t      value: (0, _jsutilsIsNullish2['default'])(value.value) ? valueName : value.value\n\t    };\n\t  });\n\t}\n\t\n\t/* <T> */ /* T */\n\t\n\t/**\n\t * Input Object Type Definition\n\t *\n\t * An input object defines a structured collection of fields which may be\n\t * supplied to a field argument.\n\t *\n\t * Using `NonNull` will ensure that a value must be provided by the query\n\t *\n\t * Example:\n\t *\n\t *     var GeoPoint = new GraphQLInputObjectType({\n\t *       name: 'GeoPoint',\n\t *       fields: {\n\t *         lat: { type: new GraphQLNonNull(GraphQLFloat) },\n\t *         lon: { type: new GraphQLNonNull(GraphQLFloat) },\n\t *         alt: { type: GraphQLFloat, defaultValue: 0 },\n\t *       }\n\t *     });\n\t *\n\t */\n\t\n\tvar GraphQLInputObjectType = (function () {\n\t  function GraphQLInputObjectType(config) {\n\t    _classCallCheck(this, GraphQLInputObjectType);\n\t\n\t    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n\t    assertValidName(config.name);\n\t    this.name = config.name;\n\t    this.description = config.description;\n\t    this._typeConfig = config;\n\t  }\n\t\n\t  _createClass(GraphQLInputObjectType, [{\n\t    key: 'getFields',\n\t    value: function getFields() {\n\t      return this._fields || (this._fields = this._defineFieldMap());\n\t    }\n\t  }, {\n\t    key: '_defineFieldMap',\n\t    value: function _defineFieldMap() {\n\t      var _this2 = this;\n\t\n\t      var fieldMap = resolveMaybeThunk(this._typeConfig.fields);\n\t      (0, _jsutilsInvariant2['default'])(isPlainObj(fieldMap), this + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');\n\t      var fieldNames = Object.keys(fieldMap);\n\t      (0, _jsutilsInvariant2['default'])(fieldNames.length > 0, this + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');\n\t      var resultFieldMap = {};\n\t      fieldNames.forEach(function (fieldName) {\n\t        assertValidName(fieldName);\n\t        var field = _extends({}, fieldMap[fieldName], {\n\t          name: fieldName\n\t        });\n\t        (0, _jsutilsInvariant2['default'])(isInputType(field.type), _this2 + '.' + fieldName + ' field type must be Input Type but ' + ('got: ' + field.type + '.'));\n\t        resultFieldMap[fieldName] = field;\n\t      });\n\t      return resultFieldMap;\n\t    }\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this.name;\n\t    }\n\t  }]);\n\t\n\t  return GraphQLInputObjectType;\n\t})();\n\t\n\texports.GraphQLInputObjectType = GraphQLInputObjectType;\n\t\n\t/**\n\t * List Modifier\n\t *\n\t * A list is a kind of type marker, a wrapping type which points to another\n\t * type. Lists are often created within the context of defining the fields of\n\t * an object type.\n\t *\n\t * Example:\n\t *\n\t *     var PersonType = new GraphQLObjectType({\n\t *       name: 'Person',\n\t *       fields: () => ({\n\t *         parents: { type: new GraphQLList(Person) },\n\t *         children: { type: new GraphQLList(Person) },\n\t *       })\n\t *     })\n\t *\n\t */\n\t\n\tvar GraphQLList = (function () {\n\t  function GraphQLList(type) {\n\t    _classCallCheck(this, GraphQLList);\n\t\n\t    (0, _jsutilsInvariant2['default'])(isType(type), 'Can only create List of a GraphQLType but got: ' + type + '.');\n\t    this.ofType = type;\n\t  }\n\t\n\t  /**\n\t   * Non-Null Modifier\n\t   *\n\t   * A non-null is a kind of type marker, a wrapping type which points to another\n\t   * type. Non-null types enforce that their values are never null and can ensure\n\t   * an error is raised if this ever occurs during a request. It is useful for\n\t   * fields which you can make a strong guarantee on non-nullability, for example\n\t   * usually the id field of a database row will never be null.\n\t   *\n\t   * Example:\n\t   *\n\t   *     var RowType = new GraphQLObjectType({\n\t   *       name: 'Row',\n\t   *       fields: () => ({\n\t   *         id: { type: new GraphQLNonNull(GraphQLString) },\n\t   *       })\n\t   *     })\n\t   *\n\t   * Note: the enforcement of non-nullability occurs within the executor.\n\t   */\n\t\n\t  _createClass(GraphQLList, [{\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return '[' + String(this.ofType) + ']';\n\t    }\n\t  }]);\n\t\n\t  return GraphQLList;\n\t})();\n\t\n\texports.GraphQLList = GraphQLList;\n\t\n\tvar GraphQLNonNull = (function () {\n\t  function GraphQLNonNull(type) {\n\t    _classCallCheck(this, GraphQLNonNull);\n\t\n\t    (0, _jsutilsInvariant2['default'])(isType(type) && !(type instanceof GraphQLNonNull), 'Can only create NonNull of a Nullable GraphQLType but got: ' + type + '.');\n\t    this.ofType = type;\n\t  }\n\t\n\t  _createClass(GraphQLNonNull, [{\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this.ofType.toString() + '!';\n\t    }\n\t  }]);\n\t\n\t  return GraphQLNonNull;\n\t})();\n\t\n\texports.GraphQLNonNull = GraphQLNonNull;\n\t\n\tvar NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n\t\n\t// Helper to assert that provided names are valid.\n\tfunction assertValidName(name) {\n\t  (0, _jsutilsInvariant2['default'])(NAME_RX.test(name), 'Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but \"' + name + '\" does not.');\n\t}\n\t/* <T> */ /* T */ /* T */\n\t/**\n\t * Optionally provide a custom type resolver function. If one is not provided,\n\t * the default implementation will call `isTypeOf` on each implementing\n\t * Object type.\n\t */\n\t\n\t/**\n\t * Optionally provide a custom type resolver function. If one is not provided,\n\t * the default implementation will call `isTypeOf` on each implementing\n\t * Object type.\n\t */\n\t/* <T> */ /* <T> */ /* T */ /* T */ /* <T> */ /* <T> */ /* <T> */ /* <T> */ /* T */ /* <T> */\n\n/***/ },\n/* 371 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Returns true if a value is null, undefined, or NaN.\n\t */\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = isNullish;\n\t\n\tfunction isNullish(value) {\n\t  return value === null || value === undefined || value !== value;\n\t}\n\t\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 372 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Creates a keyed JS object from an array, given a function to produce the keys\n\t * for each value in the array.\n\t *\n\t * This provides a convenient lookup for the array items if the key function\n\t * produces unique results.\n\t *\n\t *     var phoneBook = [\n\t *       { name: 'Jon', num: '555-1234' },\n\t *       { name: 'Jenny', num: '867-5309' }\n\t *     ]\n\t *\n\t *     // { Jon: { name: 'Jon', num: '555-1234' },\n\t *     //   Jenny: { name: 'Jenny', num: '867-5309' } }\n\t *     var entriesByName = keyMap(\n\t *       phoneBook,\n\t *       entry => entry.name\n\t *     )\n\t *\n\t *     // { name: 'Jenny', num: '857-6309' }\n\t *     var jennyEntry = entriesByName['Jenny']\n\t *\n\t */\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = keyMap;\n\t\n\tfunction keyMap(list, keyFn) {\n\t  return list.reduce(function (map, item) {\n\t    return (map[keyFn(item)] = item, map);\n\t  }, {});\n\t}\n\t\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 373 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _definition = __webpack_require__(370);\n\t\n\tvar _scalars = __webpack_require__(374);\n\t\n\t/**\n\t * Directives are used by the GraphQL runtime as a way of modifying execution\n\t * behavior. Type system creators will usually not create these directly.\n\t */\n\t\n\tvar GraphQLDirective = function GraphQLDirective(config) {\n\t  _classCallCheck(this, GraphQLDirective);\n\t\n\t  this.name = config.name;\n\t  this.description = config.description;\n\t  this.args = config.args || [];\n\t  this.onOperation = Boolean(config.onOperation);\n\t  this.onFragment = Boolean(config.onFragment);\n\t  this.onField = Boolean(config.onField);\n\t};\n\t\n\texports.GraphQLDirective = GraphQLDirective;\n\t\n\t/**\n\t * Used to conditionally include fields or fragments\n\t */\n\tvar GraphQLIncludeDirective = new GraphQLDirective({\n\t  name: 'include',\n\t  description: 'Directs the executor to include this field or fragment only when ' + 'the `if` argument is true.',\n\t  args: [{ name: 'if',\n\t    type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),\n\t    description: 'Included when true.' }],\n\t  onOperation: false,\n\t  onFragment: true,\n\t  onField: true\n\t});\n\t\n\texports.GraphQLIncludeDirective = GraphQLIncludeDirective;\n\t/**\n\t * Used to conditionally skip (exclude) fields or fragments\n\t */\n\tvar GraphQLSkipDirective = new GraphQLDirective({\n\t  name: 'skip',\n\t  description: 'Directs the executor to skip this field or fragment when the `if` ' + 'argument is true.',\n\t  args: [{ name: 'if',\n\t    type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),\n\t    description: 'Skipped when true.' }],\n\t  onOperation: false,\n\t  onFragment: true,\n\t  onField: true\n\t});\n\texports.GraphQLSkipDirective = GraphQLSkipDirective;\n\n/***/ },\n/* 374 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _definition = __webpack_require__(370);\n\t\n\tvar _language = __webpack_require__(358);\n\t\n\t// Integers are only safe when between -(2^53 - 1) and 2^53 - 1 due to being\n\t// encoded in JavaScript and represented in JSON as double-precision floating\n\t// point numbers, as specified by IEEE 754.\n\tvar MAX_INT = 9007199254740991;\n\tvar MIN_INT = -9007199254740991;\n\t\n\tfunction coerceInt(value) {\n\t  var num = Number(value);\n\t  if (num === num && num <= MAX_INT && num >= MIN_INT) {\n\t    return (num < 0 ? Math.ceil : Math.floor)(num);\n\t  }\n\t  return null;\n\t}\n\t\n\tvar GraphQLInt = new _definition.GraphQLScalarType({\n\t  name: 'Int',\n\t  description: 'The `Int` scalar type represents non-fractional signed whole numeric ' + 'values. Int can represent values between -(2^53 - 1) and 2^53 - 1 since ' + 'represented in JSON as double-precision floating point numbers specified' + 'by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).',\n\t  serialize: coerceInt,\n\t  parseValue: coerceInt,\n\t  parseLiteral: function parseLiteral(ast) {\n\t    if (ast.kind === _language.Kind.INT) {\n\t      var num = parseInt(ast.value, 10);\n\t      if (num <= MAX_INT && num >= MIN_INT) {\n\t        return num;\n\t      }\n\t    }\n\t    return null;\n\t  }\n\t});\n\t\n\texports.GraphQLInt = GraphQLInt;\n\tfunction coerceFloat(value) {\n\t  var num = Number(value);\n\t  return num === num ? num : null;\n\t}\n\t\n\tvar GraphQLFloat = new _definition.GraphQLScalarType({\n\t  name: 'Float',\n\t  description: 'The `Float` scalar type represents signed double-precision fractional ' + 'values as specified by ' + '[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ',\n\t  serialize: coerceFloat,\n\t  parseValue: coerceFloat,\n\t  parseLiteral: function parseLiteral(ast) {\n\t    return ast.kind === _language.Kind.FLOAT || ast.kind === _language.Kind.INT ? parseFloat(ast.value) : null;\n\t  }\n\t});\n\t\n\texports.GraphQLFloat = GraphQLFloat;\n\tvar GraphQLString = new _definition.GraphQLScalarType({\n\t  name: 'String',\n\t  description: 'The `String` scalar type represents textual data, represented as UTF-8 ' + 'character sequences. The String type is most often used by GraphQL to ' + 'represent free-form human-readable text.',\n\t  serialize: String,\n\t  parseValue: String,\n\t  parseLiteral: function parseLiteral(ast) {\n\t    return ast.kind === _language.Kind.STRING ? ast.value : null;\n\t  }\n\t});\n\t\n\texports.GraphQLString = GraphQLString;\n\tvar GraphQLBoolean = new _definition.GraphQLScalarType({\n\t  name: 'Boolean',\n\t  description: 'The `Boolean` scalar type represents `true` or `false`.',\n\t  serialize: Boolean,\n\t  parseValue: Boolean,\n\t  parseLiteral: function parseLiteral(ast) {\n\t    return ast.kind === _language.Kind.BOOLEAN ? ast.value : null;\n\t  }\n\t});\n\t\n\texports.GraphQLBoolean = GraphQLBoolean;\n\tvar GraphQLID = new _definition.GraphQLScalarType({\n\t  name: 'ID',\n\t  description: 'The `ID` scalar type represents a unique identifier, often used to ' + 'refetch an object or as key for a cache. The ID type appears in a JSON ' + 'response as a String; however, it is not intended to be human-readable. ' + 'When expected as an input type, any string (such as `\"4\"`) or integer ' + '(such as `4`) input value will be accepted as an ID.',\n\t  serialize: String,\n\t  parseValue: String,\n\t  parseLiteral: function parseLiteral(ast) {\n\t    return ast.kind === _language.Kind.STRING || ast.kind === _language.Kind.INT ? ast.value : null;\n\t  }\n\t});\n\texports.GraphQLID = GraphQLID;\n\n/***/ },\n/* 375 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*  weak */\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\tvar _utilitiesAstFromValue = __webpack_require__(376);\n\t\n\tvar _languagePrinter = __webpack_require__(362);\n\t\n\tvar _definition = __webpack_require__(370);\n\t\n\tvar _scalars = __webpack_require__(374);\n\t\n\tvar __Schema = new _definition.GraphQLObjectType({\n\t  name: '__Schema',\n\t  description: 'A GraphQL Schema defines the capabilities of a GraphQL server. It ' + 'exposes all available types and directives on the server, as well as ' + 'the entry points for query, mutation, and subscription operations.',\n\t  fields: function fields() {\n\t    return {\n\t      types: {\n\t        description: 'A list of all types supported by this server.',\n\t        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),\n\t        resolve: function resolve(schema) {\n\t          var typeMap = schema.getTypeMap();\n\t          return Object.keys(typeMap).map(function (key) {\n\t            return typeMap[key];\n\t          });\n\t        }\n\t      },\n\t      queryType: {\n\t        description: 'The type that query operations will be rooted at.',\n\t        type: new _definition.GraphQLNonNull(__Type),\n\t        resolve: function resolve(schema) {\n\t          return schema.getQueryType();\n\t        }\n\t      },\n\t      mutationType: {\n\t        description: 'If this server supports mutation, the type that ' + 'mutation operations will be rooted at.',\n\t        type: __Type,\n\t        resolve: function resolve(schema) {\n\t          return schema.getMutationType();\n\t        }\n\t      },\n\t      subscriptionType: {\n\t        description: 'If this server support subscription, the type that ' + 'subscription operations will be rooted at.',\n\t        type: __Type,\n\t        resolve: function resolve(schema) {\n\t          return schema.getSubscriptionType();\n\t        }\n\t      },\n\t      directives: {\n\t        description: 'A list of all directives supported by this server.',\n\t        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),\n\t        resolve: function resolve(schema) {\n\t          return schema.getDirectives();\n\t        }\n\t      }\n\t    };\n\t  }\n\t});\n\t\n\texports.__Schema = __Schema;\n\tvar __Directive = new _definition.GraphQLObjectType({\n\t  name: '__Directive',\n\t  description: 'A Directive provides a way to describe alternate runtime execution and ' + 'type validation behavior in a GraphQL document.' + '\\n\\nIn some cases, you need to provide options to alter GraphQL’s ' + 'execution behavior in ways field arguments will not suffice, such as ' + 'conditionally including or skipping a field. Directives provide this by ' + 'describing additional information to the executor.',\n\t  fields: function fields() {\n\t    return {\n\t      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },\n\t      description: { type: _scalars.GraphQLString },\n\t      args: {\n\t        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),\n\t        resolve: function resolve(directive) {\n\t          return directive.args || [];\n\t        }\n\t      },\n\t      onOperation: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) },\n\t      onFragment: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) },\n\t      onField: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) }\n\t    };\n\t  }\n\t});\n\t\n\tvar __Type = new _definition.GraphQLObjectType({\n\t  name: '__Type',\n\t  description: 'The fundamental unit of any GraphQL Schema is the type. There are ' + 'many kinds of types in GraphQL as represented by the `__TypeKind` enum.' + '\\n\\nDepending on the kind of a type, certain fields describe ' + 'information about that type. Scalar types provide no information ' + 'beyond a name and description, while Enum types provide their values. ' + 'Object and Interface types provide the fields they describe. Abstract ' + 'types, Union and Interface, provide the Object types possible ' + 'at runtime. List and NonNull types compose other types.',\n\t  fields: function fields() {\n\t    return {\n\t      kind: {\n\t        type: new _definition.GraphQLNonNull(__TypeKind),\n\t        resolve: function resolve(type) {\n\t          if (type instanceof _definition.GraphQLScalarType) {\n\t            return TypeKind.SCALAR;\n\t          } else if (type instanceof _definition.GraphQLObjectType) {\n\t            return TypeKind.OBJECT;\n\t          } else if (type instanceof _definition.GraphQLInterfaceType) {\n\t            return TypeKind.INTERFACE;\n\t          } else if (type instanceof _definition.GraphQLUnionType) {\n\t            return TypeKind.UNION;\n\t          } else if (type instanceof _definition.GraphQLEnumType) {\n\t            return TypeKind.ENUM;\n\t          } else if (type instanceof _definition.GraphQLInputObjectType) {\n\t            return TypeKind.INPUT_OBJECT;\n\t          } else if (type instanceof _definition.GraphQLList) {\n\t            return TypeKind.LIST;\n\t          } else if (type instanceof _definition.GraphQLNonNull) {\n\t            return TypeKind.NON_NULL;\n\t          }\n\t          throw new Error('Unknown kind of type: ' + type);\n\t        }\n\t      },\n\t      name: { type: _scalars.GraphQLString },\n\t      description: { type: _scalars.GraphQLString },\n\t      fields: {\n\t        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),\n\t        args: {\n\t          includeDeprecated: { type: _scalars.GraphQLBoolean, defaultValue: false }\n\t        },\n\t        resolve: function resolve(type, _ref) {\n\t          var includeDeprecated = _ref.includeDeprecated;\n\t\n\t          if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {\n\t            var fieldMap = type.getFields();\n\t            var fields = Object.keys(fieldMap).map(function (fieldName) {\n\t              return fieldMap[fieldName];\n\t            });\n\t            if (!includeDeprecated) {\n\t              fields = fields.filter(function (field) {\n\t                return !field.deprecationReason;\n\t              });\n\t            }\n\t            return fields;\n\t          }\n\t          return null;\n\t        }\n\t      },\n\t      interfaces: {\n\t        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),\n\t        resolve: function resolve(type) {\n\t          if (type instanceof _definition.GraphQLObjectType) {\n\t            return type.getInterfaces();\n\t          }\n\t        }\n\t      },\n\t      possibleTypes: {\n\t        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),\n\t        resolve: function resolve(type) {\n\t          if (type instanceof _definition.GraphQLInterfaceType || type instanceof _definition.GraphQLUnionType) {\n\t            return type.getPossibleTypes();\n\t          }\n\t        }\n\t      },\n\t      enumValues: {\n\t        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),\n\t        args: {\n\t          includeDeprecated: { type: _scalars.GraphQLBoolean, defaultValue: false }\n\t        },\n\t        resolve: function resolve(type, _ref2) {\n\t          var includeDeprecated = _ref2.includeDeprecated;\n\t\n\t          if (type instanceof _definition.GraphQLEnumType) {\n\t            var values = type.getValues();\n\t            if (!includeDeprecated) {\n\t              values = values.filter(function (value) {\n\t                return !value.deprecationReason;\n\t              });\n\t            }\n\t            return values;\n\t          }\n\t        }\n\t      },\n\t      inputFields: {\n\t        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),\n\t        resolve: function resolve(type) {\n\t          if (type instanceof _definition.GraphQLInputObjectType) {\n\t            var fieldMap = type.getFields();\n\t            return Object.keys(fieldMap).map(function (fieldName) {\n\t              return fieldMap[fieldName];\n\t            });\n\t          }\n\t        }\n\t      },\n\t      ofType: { type: __Type }\n\t    };\n\t  }\n\t});\n\t\n\tvar __Field = new _definition.GraphQLObjectType({\n\t  name: '__Field',\n\t  description: 'Object and Interface types are described by a list of Fields, each of ' + 'which has a name, potentially a list of arguments, and a return type.',\n\t  fields: function fields() {\n\t    return {\n\t      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },\n\t      description: { type: _scalars.GraphQLString },\n\t      args: {\n\t        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),\n\t        resolve: function resolve(field) {\n\t          return field.args || [];\n\t        }\n\t      },\n\t      type: { type: new _definition.GraphQLNonNull(__Type) },\n\t      isDeprecated: {\n\t        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),\n\t        resolve: function resolve(field) {\n\t          return !(0, _jsutilsIsNullish2['default'])(field.deprecationReason);\n\t        }\n\t      },\n\t      deprecationReason: {\n\t        type: _scalars.GraphQLString\n\t      }\n\t    };\n\t  }\n\t});\n\t\n\tvar __InputValue = new _definition.GraphQLObjectType({\n\t  name: '__InputValue',\n\t  description: 'Arguments provided to Fields or Directives and the input fields of an ' + 'InputObject are represented as Input Values which describe their type ' + 'and optionally a default value.',\n\t  fields: function fields() {\n\t    return {\n\t      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },\n\t      description: { type: _scalars.GraphQLString },\n\t      type: { type: new _definition.GraphQLNonNull(__Type) },\n\t      defaultValue: {\n\t        type: _scalars.GraphQLString,\n\t        description: 'A GraphQL-formatted string representing the default value for this ' + 'input value.',\n\t        resolve: function resolve(inputVal) {\n\t          return inputVal.defaultValue == null ? null : (0, _languagePrinter.print)((0, _utilitiesAstFromValue.astFromValue)(inputVal.defaultValue, inputVal));\n\t        }\n\t      }\n\t    };\n\t  }\n\t});\n\t\n\tvar __EnumValue = new _definition.GraphQLObjectType({\n\t  name: '__EnumValue',\n\t  description: 'One possible value for a given Enum. Enum values are unique values, not ' + 'a placeholder for a string or numeric value. However an Enum value is ' + 'returned in a JSON response as a string.',\n\t  fields: {\n\t    name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },\n\t    description: { type: _scalars.GraphQLString },\n\t    isDeprecated: {\n\t      type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),\n\t      resolve: function resolve(enumValue) {\n\t        return !(0, _jsutilsIsNullish2['default'])(enumValue.deprecationReason);\n\t      }\n\t    },\n\t    deprecationReason: {\n\t      type: _scalars.GraphQLString\n\t    }\n\t  }\n\t});\n\t\n\tvar TypeKind = {\n\t  SCALAR: 'SCALAR',\n\t  OBJECT: 'OBJECT',\n\t  INTERFACE: 'INTERFACE',\n\t  UNION: 'UNION',\n\t  ENUM: 'ENUM',\n\t  INPUT_OBJECT: 'INPUT_OBJECT',\n\t  LIST: 'LIST',\n\t  NON_NULL: 'NON_NULL'\n\t};\n\t\n\texports.TypeKind = TypeKind;\n\tvar __TypeKind = new _definition.GraphQLEnumType({\n\t  name: '__TypeKind',\n\t  description: 'An enum describing what kind of type a given `__Type` is.',\n\t  values: {\n\t    SCALAR: {\n\t      value: TypeKind.SCALAR,\n\t      description: 'Indicates this type is a scalar.'\n\t    },\n\t    OBJECT: {\n\t      value: TypeKind.OBJECT,\n\t      description: 'Indicates this type is an object. ' + '`fields` and `interfaces` are valid fields.'\n\t    },\n\t    INTERFACE: {\n\t      value: TypeKind.INTERFACE,\n\t      description: 'Indicates this type is an interface. ' + '`fields` and `possibleTypes` are valid fields.'\n\t    },\n\t    UNION: {\n\t      value: TypeKind.UNION,\n\t      description: 'Indicates this type is a union. ' + '`possibleTypes` is a valid field.'\n\t    },\n\t    ENUM: {\n\t      value: TypeKind.ENUM,\n\t      description: 'Indicates this type is an enum. ' + '`enumValues` is a valid field.'\n\t    },\n\t    INPUT_OBJECT: {\n\t      value: TypeKind.INPUT_OBJECT,\n\t      description: 'Indicates this type is an input object. ' + '`inputFields` is a valid field.'\n\t    },\n\t    LIST: {\n\t      value: TypeKind.LIST,\n\t      description: 'Indicates this type is a list. ' + '`ofType` is a valid field.'\n\t    },\n\t    NON_NULL: {\n\t      value: TypeKind.NON_NULL,\n\t      description: 'Indicates this type is a non-null. ' + '`ofType` is a valid field.'\n\t    }\n\t  }\n\t});\n\t\n\t/**\n\t * Note that these are GraphQLFieldDefinition and not GraphQLFieldConfig,\n\t * so the format for args is different.\n\t */\n\t\n\tvar SchemaMetaFieldDef = {\n\t  name: '__schema',\n\t  type: new _definition.GraphQLNonNull(__Schema),\n\t  description: 'Access the current type schema of this server.',\n\t  args: [],\n\t  resolve: function resolve(source, args, _ref3) {\n\t    var schema = _ref3.schema;\n\t    return schema;\n\t  }\n\t};\n\t\n\texports.SchemaMetaFieldDef = SchemaMetaFieldDef;\n\tvar TypeMetaFieldDef = {\n\t  name: '__type',\n\t  type: __Type,\n\t  description: 'Request the type information of a single type.',\n\t  args: [{ name: 'name', type: new _definition.GraphQLNonNull(_scalars.GraphQLString) }],\n\t  resolve: function resolve(source, _ref4, _ref5) {\n\t    var name = _ref4.name;\n\t    var schema = _ref5.schema;\n\t    return schema.getType(name);\n\t  }\n\t};\n\t\n\texports.TypeMetaFieldDef = TypeMetaFieldDef;\n\tvar TypeNameMetaFieldDef = {\n\t  name: '__typename',\n\t  type: new _definition.GraphQLNonNull(_scalars.GraphQLString),\n\t  description: 'The name of the current Object type at runtime.',\n\t  args: [],\n\t  resolve: function resolve(source, args, _ref6) {\n\t    var parentType = _ref6.parentType;\n\t    return parentType.name;\n\t  }\n\t};\n\texports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;\n\n/***/ },\n/* 376 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.astFromValue = astFromValue;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _typeScalars = __webpack_require__(374);\n\t\n\t/**\n\t * Produces a GraphQL Value AST given a JavaScript value.\n\t *\n\t * Optionally, a GraphQL type may be provided, which will be used to\n\t * disambiguate between value primitives.\n\t *\n\t * | JSON Value    | GraphQL Value        |\n\t * | ------------- | -------------------- |\n\t * | Object        | Input Object         |\n\t * | Array         | List                 |\n\t * | Boolean       | Boolean              |\n\t * | String        | String / Enum Value  |\n\t * | Number        | Int / Float          |\n\t *\n\t */\n\t\n\tfunction astFromValue(_x, _x2) {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    var value = _x,\n\t        type = _x2;\n\t    itemType = stringNum = isIntValue = fields = undefined;\n\t    _again = false;\n\t\n\t    if (type instanceof _typeDefinition.GraphQLNonNull) {\n\t      // Note: we're not checking that the result is non-null.\n\t      // This function is not responsible for validating the input value.\n\t      _x = value;\n\t      _x2 = type.ofType;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    if ((0, _jsutilsIsNullish2['default'])(value)) {\n\t      return null;\n\t    }\n\t\n\t    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n\t    // the value is not an array, convert the value using the list's item type.\n\t    if (Array.isArray(value)) {\n\t      var itemType = type instanceof _typeDefinition.GraphQLList ? type.ofType : null;\n\t      return {\n\t        kind: _languageKinds.LIST,\n\t        values: value.map(function (item) {\n\t          return astFromValue(item, itemType);\n\t        })\n\t      };\n\t    } else if (type instanceof _typeDefinition.GraphQLList) {\n\t      // Because GraphQL will accept single values as a \"list of one\" when\n\t      // expecting a list, if there's a non-array value and an expected list type,\n\t      // create an AST using the list's item type.\n\t      _x = value;\n\t      _x2 = type.ofType;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    if (typeof value === 'boolean') {\n\t      return { kind: _languageKinds.BOOLEAN, value: value };\n\t    }\n\t\n\t    // JavaScript numbers can be Float or Int values. Use the GraphQLType to\n\t    // differentiate if available, otherwise prefer Int if the value is a\n\t    // valid Int.\n\t    if (typeof value === 'number') {\n\t      var stringNum = String(value);\n\t      var isIntValue = /^[0-9]+$/.test(stringNum);\n\t      if (isIntValue) {\n\t        if (type === _typeScalars.GraphQLFloat) {\n\t          return { kind: _languageKinds.FLOAT, value: stringNum + '.0' };\n\t        }\n\t        return { kind: _languageKinds.INT, value: stringNum };\n\t      }\n\t      return { kind: _languageKinds.FLOAT, value: stringNum };\n\t    }\n\t\n\t    // JavaScript strings can be Enum values or String values. Use the\n\t    // GraphQLType to differentiate if possible.\n\t    if (typeof value === 'string') {\n\t      if (type instanceof _typeDefinition.GraphQLEnumType && /^[_a-zA-Z][_a-zA-Z0-9]*$/.test(value)) {\n\t        return { kind: _languageKinds.ENUM, value: value };\n\t      }\n\t      // Use JSON stringify, which uses the same string encoding as GraphQL,\n\t      // then remove the quotes.\n\t      return { kind: _languageKinds.STRING, value: JSON.stringify(value).slice(1, -1) };\n\t    }\n\t\n\t    // last remaining possible typeof\n\t    (0, _jsutilsInvariant2['default'])(typeof value === 'object');\n\t\n\t    // Populate the fields of the input object by creating ASTs from each value\n\t    // in the JavaScript object.\n\t    var fields = [];\n\t    Object.keys(value).forEach(function (fieldName) {\n\t      var fieldType;\n\t      if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n\t        var fieldDef = type.getFields()[fieldName];\n\t        fieldType = fieldDef && fieldDef.type;\n\t      }\n\t      var fieldValue = astFromValue(value[fieldName], fieldType);\n\t      if (fieldValue) {\n\t        fields.push({\n\t          kind: _languageKinds.OBJECT_FIELD,\n\t          name: { kind: _languageKinds.NAME, value: fieldName },\n\t          value: fieldValue\n\t        });\n\t      }\n\t    });\n\t    return { kind: _languageKinds.OBJECT, fields: fields };\n\t  }\n\t}\n\n/***/ },\n/* 377 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = find;\n\t\n\tfunction find(list, predicate) {\n\t  for (var i = 0; i < list.length; i++) {\n\t    if (predicate(list[i])) {\n\t      return list[i];\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 378 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Provided two types, return true if the types are equal (invariant).\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.isEqualType = isEqualType;\n\texports.isTypeSubTypeOf = isTypeSubTypeOf;\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tfunction isEqualType(_x, _x2) {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    var typeA = _x,\n\t        typeB = _x2;\n\t    _again = false;\n\t\n\t    // Equivalent types are equal.\n\t    if (typeA === typeB) {\n\t      return true;\n\t    }\n\t\n\t    // If either type is non-null, the other must also be non-null.\n\t    if (typeA instanceof _typeDefinition.GraphQLNonNull && typeB instanceof _typeDefinition.GraphQLNonNull) {\n\t      _x = typeA.ofType;\n\t      _x2 = typeB.ofType;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    // If either type is a list, the other must also be a list.\n\t    if (typeA instanceof _typeDefinition.GraphQLList && typeB instanceof _typeDefinition.GraphQLList) {\n\t      _x = typeA.ofType;\n\t      _x2 = typeB.ofType;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    // Otherwise the types are not equal.\n\t    return false;\n\t  }\n\t}\n\t\n\t/**\n\t * Provided a type and a super type, return true if the first type is either\n\t * equal or a subset of the second super type (covariant).\n\t */\n\t\n\tfunction isTypeSubTypeOf(_x3, _x4) {\n\t  var _again2 = true;\n\t\n\t  _function2: while (_again2) {\n\t    var maybeSubType = _x3,\n\t        superType = _x4;\n\t    _again2 = false;\n\t\n\t    // Equivalent type is a valid subtype\n\t    if (maybeSubType === superType) {\n\t      return true;\n\t    }\n\t\n\t    // If superType is non-null, maybeSubType must also be nullable.\n\t    if (superType instanceof _typeDefinition.GraphQLNonNull) {\n\t      if (maybeSubType instanceof _typeDefinition.GraphQLNonNull) {\n\t        _x3 = maybeSubType.ofType;\n\t        _x4 = superType.ofType;\n\t        _again2 = true;\n\t        continue _function2;\n\t      }\n\t      return false;\n\t    } else if (maybeSubType instanceof _typeDefinition.GraphQLNonNull) {\n\t      // If superType is nullable, maybeSubType may be non-null.\n\t      _x3 = maybeSubType.ofType;\n\t      _x4 = superType;\n\t      _again2 = true;\n\t      continue _function2;\n\t    }\n\t\n\t    // If superType type is a list, maybeSubType type must also be a list.\n\t    if (superType instanceof _typeDefinition.GraphQLList) {\n\t      if (maybeSubType instanceof _typeDefinition.GraphQLList) {\n\t        _x3 = maybeSubType.ofType;\n\t        _x4 = superType.ofType;\n\t        _again2 = true;\n\t        continue _function2;\n\t      }\n\t      return false;\n\t    } else if (maybeSubType instanceof _typeDefinition.GraphQLList) {\n\t      // If superType is not a list, maybeSubType must also be not a list.\n\t      return false;\n\t    }\n\t\n\t    // If superType type is an abstract type, maybeSubType type may be a currently\n\t    // possible object type.\n\t    if ((0, _typeDefinition.isAbstractType)(superType) && maybeSubType instanceof _typeDefinition.GraphQLObjectType && superType.isPossibleType(maybeSubType)) {\n\t      return true;\n\t    }\n\t\n\t    // Otherwise, the child type is not a valid subtype of the parent type.\n\t    return false;\n\t  }\n\t}\n\n/***/ },\n/* 379 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tvar Kind = _interopRequireWildcard(_languageKinds);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _typeIntrospection = __webpack_require__(375);\n\t\n\tvar _typeFromAST = __webpack_require__(380);\n\t\n\tvar _jsutilsFind = __webpack_require__(377);\n\t\n\tvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\t\n\t/**\n\t * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n\t * of the current field and type definitions at any point in a GraphQL document\n\t * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n\t */\n\t\n\tvar TypeInfo = (function () {\n\t  function TypeInfo(schema,\n\t  // NOTE: this experimental optional second parameter is only needed in order\n\t  // to support non-spec-compliant codebases. You should never need to use it.\n\t  getFieldDefFn) {\n\t    _classCallCheck(this, TypeInfo);\n\t\n\t    this._schema = schema;\n\t    this._typeStack = [];\n\t    this._parentTypeStack = [];\n\t    this._inputTypeStack = [];\n\t    this._fieldDefStack = [];\n\t    this._directive = null;\n\t    this._argument = null;\n\t    this._getFieldDef = getFieldDefFn || getFieldDef;\n\t  }\n\t\n\t  /**\n\t   * Not exactly the same as the executor's definition of getFieldDef, in this\n\t   * statically evaluated environment we do not always have an Object type,\n\t   * and need to handle Interface and Union types.\n\t   */\n\t\n\t  _createClass(TypeInfo, [{\n\t    key: 'getType',\n\t    value: function getType() {\n\t      if (this._typeStack.length > 0) {\n\t        return this._typeStack[this._typeStack.length - 1];\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getParentType',\n\t    value: function getParentType() {\n\t      if (this._parentTypeStack.length > 0) {\n\t        return this._parentTypeStack[this._parentTypeStack.length - 1];\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getInputType',\n\t    value: function getInputType() {\n\t      if (this._inputTypeStack.length > 0) {\n\t        return this._inputTypeStack[this._inputTypeStack.length - 1];\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getFieldDef',\n\t    value: function getFieldDef() {\n\t      if (this._fieldDefStack.length > 0) {\n\t        return this._fieldDefStack[this._fieldDefStack.length - 1];\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getDirective',\n\t    value: function getDirective() {\n\t      return this._directive;\n\t    }\n\t  }, {\n\t    key: 'getArgument',\n\t    value: function getArgument() {\n\t      return this._argument;\n\t    }\n\t\n\t    // Flow does not yet handle this case.\n\t  }, {\n\t    key: 'enter',\n\t    value: function enter(node /* Node */) {\n\t      var schema = this._schema;\n\t      switch (node.kind) {\n\t        case Kind.SELECTION_SET:\n\t          var namedType = (0, _typeDefinition.getNamedType)(this.getType());\n\t          var compositeType;\n\t          if ((0, _typeDefinition.isCompositeType)(namedType)) {\n\t            // isCompositeType is a type refining predicate, so this is safe.\n\t            compositeType = namedType;\n\t          }\n\t          this._parentTypeStack.push(compositeType);\n\t          break;\n\t        case Kind.FIELD:\n\t          var parentType = this.getParentType();\n\t          var fieldDef;\n\t          if (parentType) {\n\t            fieldDef = this._getFieldDef(schema, parentType, node);\n\t          }\n\t          this._fieldDefStack.push(fieldDef);\n\t          this._typeStack.push(fieldDef && fieldDef.type);\n\t          break;\n\t        case Kind.DIRECTIVE:\n\t          this._directive = schema.getDirective(node.name.value);\n\t          break;\n\t        case Kind.OPERATION_DEFINITION:\n\t          var type = undefined;\n\t          if (node.operation === 'query') {\n\t            type = schema.getQueryType();\n\t          } else if (node.operation === 'mutation') {\n\t            type = schema.getMutationType();\n\t          } else if (node.operation === 'subscription') {\n\t            type = schema.getSubscriptionType();\n\t          }\n\t          this._typeStack.push(type);\n\t          break;\n\t        case Kind.INLINE_FRAGMENT:\n\t        case Kind.FRAGMENT_DEFINITION:\n\t          var typeConditionAST = node.typeCondition;\n\t          var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : this.getType();\n\t          this._typeStack.push(outputType);\n\t          break;\n\t        case Kind.VARIABLE_DEFINITION:\n\t          var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n\t          this._inputTypeStack.push(inputType);\n\t          break;\n\t        case Kind.ARGUMENT:\n\t          var argDef;\n\t          var argType;\n\t          var fieldOrDirective = this.getDirective() || this.getFieldDef();\n\t          if (fieldOrDirective) {\n\t            argDef = (0, _jsutilsFind2['default'])(fieldOrDirective.args, function (arg) {\n\t              return arg.name === node.name.value;\n\t            });\n\t            if (argDef) {\n\t              argType = argDef.type;\n\t            }\n\t          }\n\t          this._argument = argDef;\n\t          this._inputTypeStack.push(argType);\n\t          break;\n\t        case Kind.LIST:\n\t          var listType = (0, _typeDefinition.getNullableType)(this.getInputType());\n\t          this._inputTypeStack.push(listType instanceof _typeDefinition.GraphQLList ? listType.ofType : undefined);\n\t          break;\n\t        case Kind.OBJECT_FIELD:\n\t          var objectType = (0, _typeDefinition.getNamedType)(this.getInputType());\n\t          var fieldType;\n\t          if (objectType instanceof _typeDefinition.GraphQLInputObjectType) {\n\t            var inputField = objectType.getFields()[node.name.value];\n\t            fieldType = inputField ? inputField.type : undefined;\n\t          }\n\t          this._inputTypeStack.push(fieldType);\n\t          break;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'leave',\n\t    value: function leave(node) {\n\t      switch (node.kind) {\n\t        case Kind.SELECTION_SET:\n\t          this._parentTypeStack.pop();\n\t          break;\n\t        case Kind.FIELD:\n\t          this._fieldDefStack.pop();\n\t          this._typeStack.pop();\n\t          break;\n\t        case Kind.DIRECTIVE:\n\t          this._directive = null;\n\t          break;\n\t        case Kind.OPERATION_DEFINITION:\n\t        case Kind.INLINE_FRAGMENT:\n\t        case Kind.FRAGMENT_DEFINITION:\n\t          this._typeStack.pop();\n\t          break;\n\t        case Kind.VARIABLE_DEFINITION:\n\t          this._inputTypeStack.pop();\n\t          break;\n\t        case Kind.ARGUMENT:\n\t          this._argument = null;\n\t          this._inputTypeStack.pop();\n\t          break;\n\t        case Kind.LIST:\n\t        case Kind.OBJECT_FIELD:\n\t          this._inputTypeStack.pop();\n\t          break;\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return TypeInfo;\n\t})();\n\t\n\texports.TypeInfo = TypeInfo;\n\tfunction getFieldDef(schema, parentType, fieldAST) {\n\t  var name = fieldAST.name.value;\n\t  if (name === _typeIntrospection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n\t    return _typeIntrospection.SchemaMetaFieldDef;\n\t  }\n\t  if (name === _typeIntrospection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n\t    return _typeIntrospection.TypeMetaFieldDef;\n\t  }\n\t  if (name === _typeIntrospection.TypeNameMetaFieldDef.name && (parentType instanceof _typeDefinition.GraphQLObjectType || parentType instanceof _typeDefinition.GraphQLInterfaceType || parentType instanceof _typeDefinition.GraphQLUnionType)) {\n\t    return _typeIntrospection.TypeNameMetaFieldDef;\n\t  }\n\t  if (parentType instanceof _typeDefinition.GraphQLObjectType || parentType instanceof _typeDefinition.GraphQLInterfaceType) {\n\t    return parentType.getFields()[name];\n\t  }\n\t}\n\t// It may disappear in the future.\n\n/***/ },\n/* 380 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.typeFromAST = typeFromAST;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tfunction typeFromAST(schema, inputTypeAST) {\n\t  var innerType;\n\t  if (inputTypeAST.kind === _languageKinds.LIST_TYPE) {\n\t    innerType = typeFromAST(schema, inputTypeAST.type);\n\t    return innerType && new _typeDefinition.GraphQLList(innerType);\n\t  }\n\t  if (inputTypeAST.kind === _languageKinds.NON_NULL_TYPE) {\n\t    innerType = typeFromAST(schema, inputTypeAST.type);\n\t    return innerType && new _typeDefinition.GraphQLNonNull(innerType);\n\t  }\n\t  (0, _jsutilsInvariant2['default'])(inputTypeAST.kind === _languageKinds.NAMED_TYPE, 'Must be a named type.');\n\t  return schema.getType(inputTypeAST.name.value);\n\t}\n\n/***/ },\n/* 381 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t// Spec Section: \"Operation Name Uniqueness\"\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _rulesUniqueOperationNames = __webpack_require__(382);\n\t\n\t// Spec Section: \"Lone Anonymous Operation\"\n\t\n\tvar _rulesLoneAnonymousOperation = __webpack_require__(383);\n\t\n\t// Spec Section: \"Fragment Spread Type Existence\"\n\t\n\tvar _rulesKnownTypeNames = __webpack_require__(384);\n\t\n\t// Spec Section: \"Fragments on Composite Types\"\n\t\n\tvar _rulesFragmentsOnCompositeTypes = __webpack_require__(385);\n\t\n\t// Spec Section: \"Variables are Input Types\"\n\t\n\tvar _rulesVariablesAreInputTypes = __webpack_require__(386);\n\t\n\t// Spec Section: \"Leaf Field Selections\"\n\t\n\tvar _rulesScalarLeafs = __webpack_require__(387);\n\t\n\t// Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\t\n\tvar _rulesFieldsOnCorrectType = __webpack_require__(388);\n\t\n\t// Spec Section: \"Fragment Name Uniqueness\"\n\t\n\tvar _rulesUniqueFragmentNames = __webpack_require__(389);\n\t\n\t// Spec Section: \"Fragment spread target defined\"\n\t\n\tvar _rulesKnownFragmentNames = __webpack_require__(390);\n\t\n\t// Spec Section: \"Fragments must be used\"\n\t\n\tvar _rulesNoUnusedFragments = __webpack_require__(391);\n\t\n\t// Spec Section: \"Fragment spread is possible\"\n\t\n\tvar _rulesPossibleFragmentSpreads = __webpack_require__(392);\n\t\n\t// Spec Section: \"Fragments must not form cycles\"\n\t\n\tvar _rulesNoFragmentCycles = __webpack_require__(393);\n\t\n\t// Spec Section: \"All Variable Used Defined\"\n\t\n\tvar _rulesNoUndefinedVariables = __webpack_require__(394);\n\t\n\t// Spec Section: \"All Variables Used\"\n\t\n\tvar _rulesNoUnusedVariables = __webpack_require__(395);\n\t\n\t// Spec Section: \"Directives Are Defined\"\n\t\n\tvar _rulesKnownDirectives = __webpack_require__(396);\n\t\n\t// Spec Section: \"Argument Names\"\n\t\n\tvar _rulesKnownArgumentNames = __webpack_require__(397);\n\t\n\t// Spec Section: \"Argument Uniqueness\"\n\t\n\tvar _rulesUniqueArgumentNames = __webpack_require__(398);\n\t\n\t// Spec Section: \"Argument Values Type Correctness\"\n\t\n\tvar _rulesArgumentsOfCorrectType = __webpack_require__(399);\n\t\n\t// Spec Section: \"Argument Optionality\"\n\t\n\tvar _rulesProvidedNonNullArguments = __webpack_require__(401);\n\t\n\t// Spec Section: \"Variable Default Values Are Correctly Typed\"\n\t\n\tvar _rulesDefaultValuesOfCorrectType = __webpack_require__(402);\n\t\n\t// Spec Section: \"All Variable Usages Are Allowed\"\n\t\n\tvar _rulesVariablesInAllowedPosition = __webpack_require__(403);\n\t\n\t// Spec Section: \"Field Selection Merging\"\n\t\n\tvar _rulesOverlappingFieldsCanBeMerged = __webpack_require__(404);\n\t\n\t// Spec Section: \"Input Object Field Uniqueness\"\n\t\n\tvar _rulesUniqueInputFieldNames = __webpack_require__(405);\n\t\n\t/**\n\t * This set includes all validation rules defined by the GraphQL spec.\n\t */\n\tvar specifiedRules = [_rulesUniqueOperationNames.UniqueOperationNames, _rulesLoneAnonymousOperation.LoneAnonymousOperation, _rulesKnownTypeNames.KnownTypeNames, _rulesFragmentsOnCompositeTypes.FragmentsOnCompositeTypes, _rulesVariablesAreInputTypes.VariablesAreInputTypes, _rulesScalarLeafs.ScalarLeafs, _rulesFieldsOnCorrectType.FieldsOnCorrectType, _rulesUniqueFragmentNames.UniqueFragmentNames, _rulesKnownFragmentNames.KnownFragmentNames, _rulesNoUnusedFragments.NoUnusedFragments, _rulesPossibleFragmentSpreads.PossibleFragmentSpreads, _rulesNoFragmentCycles.NoFragmentCycles, _rulesNoUndefinedVariables.NoUndefinedVariables, _rulesNoUnusedVariables.NoUnusedVariables, _rulesKnownDirectives.KnownDirectives, _rulesKnownArgumentNames.KnownArgumentNames, _rulesUniqueArgumentNames.UniqueArgumentNames, _rulesArgumentsOfCorrectType.ArgumentsOfCorrectType, _rulesProvidedNonNullArguments.ProvidedNonNullArguments, _rulesDefaultValuesOfCorrectType.DefaultValuesOfCorrectType, _rulesVariablesInAllowedPosition.VariablesInAllowedPosition, _rulesOverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged, _rulesUniqueInputFieldNames.UniqueInputFieldNames];\n\texports.specifiedRules = specifiedRules;\n\n/***/ },\n/* 382 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.duplicateOperationNameMessage = duplicateOperationNameMessage;\n\texports.UniqueOperationNames = UniqueOperationNames;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction duplicateOperationNameMessage(operationName) {\n\t  return 'There can only be one operation named \"' + operationName + '\".';\n\t}\n\t\n\t/**\n\t * Unique operation names\n\t *\n\t * A GraphQL document is only valid if all defined operations have unique names.\n\t */\n\t\n\tfunction UniqueOperationNames(context) {\n\t  var knownOperationNames = Object.create(null);\n\t  return {\n\t    OperationDefinition: function OperationDefinition(node) {\n\t      var operationName = node.name;\n\t      if (operationName) {\n\t        if (knownOperationNames[operationName.value]) {\n\t          context.reportError(new _error.GraphQLError(duplicateOperationNameMessage(operationName.value), [knownOperationNames[operationName.value], operationName]));\n\t        } else {\n\t          knownOperationNames[operationName.value] = operationName;\n\t        }\n\t      }\n\t      return false;\n\t    },\n\t    FragmentDefinition: function FragmentDefinition() {\n\t      return false;\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 383 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.anonOperationNotAloneMessage = anonOperationNotAloneMessage;\n\texports.LoneAnonymousOperation = LoneAnonymousOperation;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tfunction anonOperationNotAloneMessage() {\n\t  return 'This anonymous operation must be the only defined operation.';\n\t}\n\t\n\t/**\n\t * Lone anonymous operation\n\t *\n\t * A GraphQL document is only valid if when it contains an anonymous operation\n\t * (the query short-hand) that it contains only that one operation definition.\n\t */\n\t\n\tfunction LoneAnonymousOperation(context) {\n\t  var operationCount = 0;\n\t  return {\n\t    Document: function Document(node) {\n\t      operationCount = node.definitions.filter(function (definition) {\n\t        return definition.kind === _languageKinds.OPERATION_DEFINITION;\n\t      }).length;\n\t    },\n\t    OperationDefinition: function OperationDefinition(node) {\n\t      if (!node.name && operationCount > 1) {\n\t        context.reportError(new _error.GraphQLError(anonOperationNotAloneMessage(), [node]));\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 384 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.unknownTypeMessage = unknownTypeMessage;\n\texports.KnownTypeNames = KnownTypeNames;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction unknownTypeMessage(type) {\n\t  return 'Unknown type \"' + type + '\".';\n\t}\n\t\n\t/**\n\t * Known type names\n\t *\n\t * A GraphQL document is only valid if referenced types (specifically\n\t * variable definitions and fragment conditions) are defined by the type schema.\n\t */\n\t\n\tfunction KnownTypeNames(context) {\n\t  return {\n\t    NamedType: function NamedType(node) {\n\t      var typeName = node.name.value;\n\t      var type = context.getSchema().getType(typeName);\n\t      if (!type) {\n\t        context.reportError(new _error.GraphQLError(unknownTypeMessage(typeName), [node]));\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 385 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.inlineFragmentOnNonCompositeErrorMessage = inlineFragmentOnNonCompositeErrorMessage;\n\texports.fragmentOnNonCompositeErrorMessage = fragmentOnNonCompositeErrorMessage;\n\texports.FragmentsOnCompositeTypes = FragmentsOnCompositeTypes;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _languagePrinter = __webpack_require__(362);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tfunction inlineFragmentOnNonCompositeErrorMessage(type) {\n\t  return 'Fragment cannot condition on non composite type \"' + type + '\".';\n\t}\n\t\n\tfunction fragmentOnNonCompositeErrorMessage(fragName, type) {\n\t  return 'Fragment \"' + fragName + '\" cannot condition on non composite ' + ('type \"' + type + '\".');\n\t}\n\t\n\t/**\n\t * Fragments on composite type\n\t *\n\t * Fragments use a type condition to determine if they apply, since fragments\n\t * can only be spread into a composite type (object, interface, or union), the\n\t * type condition must also be a composite type.\n\t */\n\t\n\tfunction FragmentsOnCompositeTypes(context) {\n\t  return {\n\t    InlineFragment: function InlineFragment(node) {\n\t      var type = context.getType();\n\t      if (node.typeCondition && type && !(0, _typeDefinition.isCompositeType)(type)) {\n\t        context.reportError(new _error.GraphQLError(inlineFragmentOnNonCompositeErrorMessage((0, _languagePrinter.print)(node.typeCondition)), [node.typeCondition]));\n\t      }\n\t    },\n\t    FragmentDefinition: function FragmentDefinition(node) {\n\t      var type = context.getType();\n\t      if (type && !(0, _typeDefinition.isCompositeType)(type)) {\n\t        context.reportError(new _error.GraphQLError(fragmentOnNonCompositeErrorMessage(node.name.value, (0, _languagePrinter.print)(node.typeCondition)), [node.typeCondition]));\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 386 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.nonInputTypeOnVarMessage = nonInputTypeOnVarMessage;\n\texports.VariablesAreInputTypes = VariablesAreInputTypes;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _languagePrinter = __webpack_require__(362);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _utilitiesTypeFromAST = __webpack_require__(380);\n\t\n\tfunction nonInputTypeOnVarMessage(variableName, typeName) {\n\t  return 'Variable \"$' + variableName + '\" cannot be non-input type \"' + typeName + '\".';\n\t}\n\t\n\t/**\n\t * Variables are input types\n\t *\n\t * A GraphQL operation is only valid if all the variables it defines are of\n\t * input types (scalar, enum, or input object).\n\t */\n\t\n\tfunction VariablesAreInputTypes(context) {\n\t  return {\n\t    VariableDefinition: function VariableDefinition(node) {\n\t      var type = (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), node.type);\n\t\n\t      // If the variable type is not an input type, return an error.\n\t      if (type && !(0, _typeDefinition.isInputType)(type)) {\n\t        var variableName = node.variable.name.value;\n\t        context.reportError(new _error.GraphQLError(nonInputTypeOnVarMessage(variableName, (0, _languagePrinter.print)(node.type)), [node.type]));\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 387 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.noSubselectionAllowedMessage = noSubselectionAllowedMessage;\n\texports.requiredSubselectionMessage = requiredSubselectionMessage;\n\texports.ScalarLeafs = ScalarLeafs;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tfunction noSubselectionAllowedMessage(field, type) {\n\t  return 'Field \"' + field + '\" of type \"' + type + '\" must not have a sub selection.';\n\t}\n\t\n\tfunction requiredSubselectionMessage(field, type) {\n\t  return 'Field \"' + field + '\" of type \"' + type + '\" must have a sub selection.';\n\t}\n\t\n\t/**\n\t * Scalar leafs\n\t *\n\t * A GraphQL document is valid only if all leaf fields (fields without\n\t * sub selections) are of scalar or enum types.\n\t */\n\t\n\tfunction ScalarLeafs(context) {\n\t  return {\n\t    Field: function Field(node) {\n\t      var type = context.getType();\n\t      if (type) {\n\t        if ((0, _typeDefinition.isLeafType)(type)) {\n\t          if (node.selectionSet) {\n\t            context.reportError(new _error.GraphQLError(noSubselectionAllowedMessage(node.name.value, type), [node.selectionSet]));\n\t          }\n\t        } else if (!node.selectionSet) {\n\t          context.reportError(new _error.GraphQLError(requiredSubselectionMessage(node.name.value, type), [node]));\n\t        }\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 388 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.undefinedFieldMessage = undefinedFieldMessage;\n\texports.FieldsOnCorrectType = FieldsOnCorrectType;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction undefinedFieldMessage(fieldName, type) {\n\t  return 'Cannot query field \"' + fieldName + '\" on \"' + type + '\".';\n\t}\n\t\n\t/**\n\t * Fields on correct type\n\t *\n\t * A GraphQL document is only valid if all fields selected are defined by the\n\t * parent type, or are an allowed meta field such as __typenamme\n\t */\n\t\n\tfunction FieldsOnCorrectType(context) {\n\t  return {\n\t    Field: function Field(node) {\n\t      var type = context.getParentType();\n\t      if (type) {\n\t        var fieldDef = context.getFieldDef();\n\t        if (!fieldDef) {\n\t          context.reportError(new _error.GraphQLError(undefinedFieldMessage(node.name.value, type.name), [node]));\n\t        }\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 389 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.duplicateFragmentNameMessage = duplicateFragmentNameMessage;\n\texports.UniqueFragmentNames = UniqueFragmentNames;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction duplicateFragmentNameMessage(fragName) {\n\t  return 'There can only be one fragment named \"' + fragName + '\".';\n\t}\n\t\n\t/**\n\t * Unique fragment names\n\t *\n\t * A GraphQL document is only valid if all defined fragments have unique names.\n\t */\n\t\n\tfunction UniqueFragmentNames(context) {\n\t  var knownFragmentNames = Object.create(null);\n\t  return {\n\t    OperationDefinition: function OperationDefinition() {\n\t      return false;\n\t    },\n\t    FragmentDefinition: function FragmentDefinition(node) {\n\t      var fragmentName = node.name.value;\n\t      if (knownFragmentNames[fragmentName]) {\n\t        context.reportError(new _error.GraphQLError(duplicateFragmentNameMessage(fragmentName), [knownFragmentNames[fragmentName], node.name]));\n\t      } else {\n\t        knownFragmentNames[fragmentName] = node.name;\n\t      }\n\t      return false;\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 390 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.unknownFragmentMessage = unknownFragmentMessage;\n\texports.KnownFragmentNames = KnownFragmentNames;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction unknownFragmentMessage(fragName) {\n\t  return 'Unknown fragment \"' + fragName + '\".';\n\t}\n\t\n\t/**\n\t * Known fragment names\n\t *\n\t * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n\t * to fragments defined in the same document.\n\t */\n\t\n\tfunction KnownFragmentNames(context) {\n\t  return {\n\t    FragmentSpread: function FragmentSpread(node) {\n\t      var fragmentName = node.name.value;\n\t      var fragment = context.getFragment(fragmentName);\n\t      if (!fragment) {\n\t        context.reportError(new _error.GraphQLError(unknownFragmentMessage(fragmentName), [node.name]));\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 391 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.unusedFragMessage = unusedFragMessage;\n\texports.NoUnusedFragments = NoUnusedFragments;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction unusedFragMessage(fragName) {\n\t  return 'Fragment \"' + fragName + '\" is never used.';\n\t}\n\t\n\t/**\n\t * No unused fragments\n\t *\n\t * A GraphQL document is only valid if all fragment definitions are spread\n\t * within operations, or spread within other fragments spread within operations.\n\t */\n\t\n\tfunction NoUnusedFragments(context) {\n\t  var operationDefs = [];\n\t  var fragmentDefs = [];\n\t\n\t  return {\n\t    OperationDefinition: function OperationDefinition(node) {\n\t      operationDefs.push(node);\n\t      return false;\n\t    },\n\t    FragmentDefinition: function FragmentDefinition(node) {\n\t      fragmentDefs.push(node);\n\t      return false;\n\t    },\n\t    Document: {\n\t      leave: function leave() {\n\t        var fragmentNameUsed = Object.create(null);\n\t        operationDefs.forEach(function (operation) {\n\t          context.getRecursivelyReferencedFragments(operation).forEach(function (fragment) {\n\t            fragmentNameUsed[fragment.name.value] = true;\n\t          });\n\t        });\n\t\n\t        fragmentDefs.forEach(function (fragmentDef) {\n\t          var fragName = fragmentDef.name.value;\n\t          if (fragmentNameUsed[fragName] !== true) {\n\t            context.reportError(new _error.GraphQLError(unusedFragMessage(fragName), [fragmentDef]));\n\t          }\n\t        });\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 392 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.typeIncompatibleSpreadMessage = typeIncompatibleSpreadMessage;\n\texports.typeIncompatibleAnonSpreadMessage = typeIncompatibleAnonSpreadMessage;\n\texports.PossibleFragmentSpreads = PossibleFragmentSpreads;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _jsutilsKeyMap = __webpack_require__(372);\n\t\n\tvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _utilitiesTypeFromAST = __webpack_require__(380);\n\t\n\tfunction typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n\t  return 'Fragment \"' + fragName + '\" cannot be spread here as objects of ' + ('type \"' + parentType + '\" can never be of type \"' + fragType + '\".');\n\t}\n\t\n\tfunction typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n\t  return 'Fragment cannot be spread here as objects of ' + ('type \"' + parentType + '\" can never be of type \"' + fragType + '\".');\n\t}\n\t\n\t/**\n\t * Possible fragment spread\n\t *\n\t * A fragment spread is only valid if the type condition could ever possibly\n\t * be true: if there is a non-empty intersection of the possible parent types,\n\t * and possible types which pass the type condition.\n\t */\n\t\n\tfunction PossibleFragmentSpreads(context) {\n\t  return {\n\t    InlineFragment: function InlineFragment(node) {\n\t      var fragType = context.getType();\n\t      var parentType = context.getParentType();\n\t      if (fragType && parentType && !doTypesOverlap(fragType, parentType)) {\n\t        context.reportError(new _error.GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));\n\t      }\n\t    },\n\t    FragmentSpread: function FragmentSpread(node) {\n\t      var fragName = node.name.value;\n\t      var fragType = getFragmentType(context, fragName);\n\t      var parentType = context.getParentType();\n\t      if (fragType && parentType && !doTypesOverlap(fragType, parentType)) {\n\t        context.reportError(new _error.GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tfunction getFragmentType(context, name) {\n\t  var frag = context.getFragment(name);\n\t  return frag && (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);\n\t}\n\t\n\tfunction doTypesOverlap(t1, t2) {\n\t  if (t1 === t2) {\n\t    return true;\n\t  }\n\t  if (t1 instanceof _typeDefinition.GraphQLObjectType) {\n\t    if (t2 instanceof _typeDefinition.GraphQLObjectType) {\n\t      return false;\n\t    }\n\t    return t2.getPossibleTypes().indexOf(t1) !== -1;\n\t  }\n\t  if (t1 instanceof _typeDefinition.GraphQLInterfaceType || t1 instanceof _typeDefinition.GraphQLUnionType) {\n\t    if (t2 instanceof _typeDefinition.GraphQLObjectType) {\n\t      return t1.getPossibleTypes().indexOf(t2) !== -1;\n\t    }\n\t    var t1TypeNames = (0, _jsutilsKeyMap2['default'])(t1.getPossibleTypes(), function (type) {\n\t      return type.name;\n\t    });\n\t    return t2.getPossibleTypes().some(function (type) {\n\t      return t1TypeNames[type.name];\n\t    });\n\t  }\n\t}\n\n/***/ },\n/* 393 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.cycleErrorMessage = cycleErrorMessage;\n\texports.NoFragmentCycles = NoFragmentCycles;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction cycleErrorMessage(fragName, spreadNames) {\n\t  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n\t  return 'Cannot spread fragment \"' + fragName + '\" within itself' + via + '.';\n\t}\n\t\n\tfunction NoFragmentCycles(context) {\n\t  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n\t  // are not redundantly reported.\n\t  var visitedFrags = Object.create(null);\n\t\n\t  // Array of AST nodes used to produce meaningful errors\n\t  var spreadPath = [];\n\t\n\t  // Position in the spread path\n\t  var spreadPathIndexByName = Object.create(null);\n\t\n\t  return {\n\t    OperationDefinition: function OperationDefinition() {\n\t      return false;\n\t    },\n\t    FragmentDefinition: function FragmentDefinition(node) {\n\t      if (!visitedFrags[node.name.value]) {\n\t        detectCycleRecursive(node);\n\t      }\n\t      return false;\n\t    }\n\t  };\n\t\n\t  // This does a straight-forward DFS to find cycles.\n\t  // It does not terminate when a cycle was found but continues to explore\n\t  // the graph to find all possible cycles.\n\t  function detectCycleRecursive(fragment) {\n\t    var fragmentName = fragment.name.value;\n\t    visitedFrags[fragmentName] = true;\n\t\n\t    var spreadNodes = context.getFragmentSpreads(fragment);\n\t    if (spreadNodes.length === 0) {\n\t      return;\n\t    }\n\t\n\t    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\t\n\t    for (var i = 0; i < spreadNodes.length; i++) {\n\t      var spreadNode = spreadNodes[i];\n\t      var spreadName = spreadNode.name.value;\n\t      var cycleIndex = spreadPathIndexByName[spreadName];\n\t\n\t      if (cycleIndex === undefined) {\n\t        spreadPath.push(spreadNode);\n\t        if (!visitedFrags[spreadName]) {\n\t          var spreadFragment = context.getFragment(spreadName);\n\t          if (spreadFragment) {\n\t            detectCycleRecursive(spreadFragment);\n\t          }\n\t        }\n\t        spreadPath.pop();\n\t      } else {\n\t        var cyclePath = spreadPath.slice(cycleIndex);\n\t        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {\n\t          return s.name.value;\n\t        })), cyclePath.concat(spreadNode)));\n\t      }\n\t    }\n\t\n\t    spreadPathIndexByName[fragmentName] = undefined;\n\t  }\n\t}\n\n/***/ },\n/* 394 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.undefinedVarMessage = undefinedVarMessage;\n\texports.NoUndefinedVariables = NoUndefinedVariables;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction undefinedVarMessage(varName, opName) {\n\t  return opName ? 'Variable \"$' + varName + '\" is not defined by operation \"' + opName + '\".' : 'Variable \"$' + varName + '\" is not defined.';\n\t}\n\t\n\t/**\n\t * No undefined variables\n\t *\n\t * A GraphQL operation is only valid if all variables encountered, both directly\n\t * and via fragment spreads, are defined by that operation.\n\t */\n\t\n\tfunction NoUndefinedVariables(context) {\n\t  var variableNameDefined = Object.create(null);\n\t\n\t  return {\n\t    OperationDefinition: {\n\t      enter: function enter() {\n\t        variableNameDefined = Object.create(null);\n\t      },\n\t      leave: function leave(operation) {\n\t        var usages = context.getRecursiveVariableUsages(operation);\n\t\n\t        usages.forEach(function (_ref) {\n\t          var node = _ref.node;\n\t\n\t          var varName = node.name.value;\n\t          if (variableNameDefined[varName] !== true) {\n\t            context.reportError(new _error.GraphQLError(undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));\n\t          }\n\t        });\n\t      }\n\t    },\n\t    VariableDefinition: function VariableDefinition(varDefAST) {\n\t      variableNameDefined[varDefAST.variable.name.value] = true;\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 395 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.unusedVariableMessage = unusedVariableMessage;\n\texports.NoUnusedVariables = NoUnusedVariables;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction unusedVariableMessage(varName) {\n\t  return 'Variable \"$' + varName + '\" is never used.';\n\t}\n\t\n\t/**\n\t * No unused variables\n\t *\n\t * A GraphQL operation is only valid if all variables defined by an operation\n\t * are used, either directly or within a spread fragment.\n\t */\n\t\n\tfunction NoUnusedVariables(context) {\n\t  var variableDefs = [];\n\t\n\t  return {\n\t    OperationDefinition: {\n\t      enter: function enter() {\n\t        variableDefs = [];\n\t      },\n\t      leave: function leave(operation) {\n\t        var variableNameUsed = Object.create(null);\n\t        var usages = context.getRecursiveVariableUsages(operation);\n\t\n\t        usages.forEach(function (_ref) {\n\t          var node = _ref.node;\n\t\n\t          variableNameUsed[node.name.value] = true;\n\t        });\n\t\n\t        variableDefs.forEach(function (variableDef) {\n\t          var variableName = variableDef.variable.name.value;\n\t          if (variableNameUsed[variableName] !== true) {\n\t            context.reportError(new _error.GraphQLError(unusedVariableMessage(variableName), [variableDef]));\n\t          }\n\t        });\n\t      }\n\t    },\n\t    VariableDefinition: function VariableDefinition(def) {\n\t      variableDefs.push(def);\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 396 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.unknownDirectiveMessage = unknownDirectiveMessage;\n\texports.misplacedDirectiveMessage = misplacedDirectiveMessage;\n\texports.KnownDirectives = KnownDirectives;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _jsutilsFind = __webpack_require__(377);\n\t\n\tvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tfunction unknownDirectiveMessage(directiveName) {\n\t  return 'Unknown directive \"' + directiveName + '\".';\n\t}\n\t\n\tfunction misplacedDirectiveMessage(directiveName, placement) {\n\t  return 'Directive \"' + directiveName + '\" may not be used on \"' + placement + '\".';\n\t}\n\t\n\t/**\n\t * Known directives\n\t *\n\t * A GraphQL document is only valid if all `@directives` are known by the\n\t * schema and legally positioned.\n\t */\n\t\n\tfunction KnownDirectives(context) {\n\t  return {\n\t    Directive: function Directive(node, key, parent, path, ancestors) {\n\t      var directiveDef = (0, _jsutilsFind2['default'])(context.getSchema().getDirectives(), function (def) {\n\t        return def.name === node.name.value;\n\t      });\n\t      if (!directiveDef) {\n\t        context.reportError(new _error.GraphQLError(unknownDirectiveMessage(node.name.value), [node]));\n\t        return;\n\t      }\n\t      var appliedTo = ancestors[ancestors.length - 1];\n\t      switch (appliedTo.kind) {\n\t        case _languageKinds.OPERATION_DEFINITION:\n\t          if (!directiveDef.onOperation) {\n\t            context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, 'operation'), [node]));\n\t          }\n\t          break;\n\t        case _languageKinds.FIELD:\n\t          if (!directiveDef.onField) {\n\t            context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, 'field'), [node]));\n\t          }\n\t          break;\n\t        case _languageKinds.FRAGMENT_SPREAD:\n\t        case _languageKinds.INLINE_FRAGMENT:\n\t        case _languageKinds.FRAGMENT_DEFINITION:\n\t          if (!directiveDef.onFragment) {\n\t            context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, 'fragment'), [node]));\n\t          }\n\t          break;\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 397 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.unknownArgMessage = unknownArgMessage;\n\texports.unknownDirectiveArgMessage = unknownDirectiveArgMessage;\n\texports.KnownArgumentNames = KnownArgumentNames;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _jsutilsFind = __webpack_require__(377);\n\t\n\tvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tfunction unknownArgMessage(argName, fieldName, type) {\n\t  return 'Unknown argument \"' + argName + '\" on field \"' + fieldName + '\" of ' + ('type \"' + type + '\".');\n\t}\n\t\n\tfunction unknownDirectiveArgMessage(argName, directiveName) {\n\t  return 'Unknown argument \"' + argName + '\" on directive \"@' + directiveName + '\".';\n\t}\n\t\n\t/**\n\t * Known argument names\n\t *\n\t * A GraphQL field is only valid if all supplied arguments are defined by\n\t * that field.\n\t */\n\t\n\tfunction KnownArgumentNames(context) {\n\t  return {\n\t    Argument: function Argument(node, key, parent, path, ancestors) {\n\t      var argumentOf = ancestors[ancestors.length - 1];\n\t      if (argumentOf.kind === _languageKinds.FIELD) {\n\t        var fieldDef = context.getFieldDef();\n\t        if (fieldDef) {\n\t          var fieldArgDef = (0, _jsutilsFind2['default'])(fieldDef.args, function (arg) {\n\t            return arg.name === node.name.value;\n\t          });\n\t          if (!fieldArgDef) {\n\t            var parentType = context.getParentType();\n\t            (0, _jsutilsInvariant2['default'])(parentType);\n\t            context.reportError(new _error.GraphQLError(unknownArgMessage(node.name.value, fieldDef.name, parentType.name), [node]));\n\t          }\n\t        }\n\t      } else if (argumentOf.kind === _languageKinds.DIRECTIVE) {\n\t        var directive = context.getDirective();\n\t        if (directive) {\n\t          var directiveArgDef = (0, _jsutilsFind2['default'])(directive.args, function (arg) {\n\t            return arg.name === node.name.value;\n\t          });\n\t          if (!directiveArgDef) {\n\t            context.reportError(new _error.GraphQLError(unknownDirectiveArgMessage(node.name.value, directive.name), [node]));\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 398 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.duplicateArgMessage = duplicateArgMessage;\n\texports.UniqueArgumentNames = UniqueArgumentNames;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction duplicateArgMessage(argName) {\n\t  return 'There can be only one argument named \"' + argName + '\".';\n\t}\n\t\n\t/**\n\t * Unique argument names\n\t *\n\t * A GraphQL field or directive is only valid if all supplied arguments are\n\t * uniquely named.\n\t */\n\t\n\tfunction UniqueArgumentNames(context) {\n\t  var knownArgNames = Object.create(null);\n\t  return {\n\t    Field: function Field() {\n\t      knownArgNames = Object.create(null);\n\t    },\n\t    Directive: function Directive() {\n\t      knownArgNames = Object.create(null);\n\t    },\n\t    Argument: function Argument(node) {\n\t      var argName = node.name.value;\n\t      if (knownArgNames[argName]) {\n\t        context.reportError(new _error.GraphQLError(duplicateArgMessage(argName), [knownArgNames[argName], node.name]));\n\t      } else {\n\t        knownArgNames[argName] = node.name;\n\t      }\n\t      return false;\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 399 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.badValueMessage = badValueMessage;\n\texports.ArgumentsOfCorrectType = ArgumentsOfCorrectType;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _languagePrinter = __webpack_require__(362);\n\t\n\tvar _utilitiesIsValidLiteralValue = __webpack_require__(400);\n\t\n\tfunction badValueMessage(argName, type, value, verboseErrors) {\n\t  var message = verboseErrors ? '\\n' + verboseErrors.join('\\n') : '';\n\t  return 'Argument \"' + argName + '\" has invalid value ' + value + '.' + message;\n\t}\n\t\n\t/**\n\t * Argument values of correct type\n\t *\n\t * A GraphQL document is only valid if all field argument literal values are\n\t * of the type expected by their position.\n\t */\n\t\n\tfunction ArgumentsOfCorrectType(context) {\n\t  return {\n\t    Argument: function Argument(argAST) {\n\t      var argDef = context.getArgument();\n\t      if (argDef) {\n\t        var errors = (0, _utilitiesIsValidLiteralValue.isValidLiteralValue)(argDef.type, argAST.value);\n\t        if (errors && errors.length > 0) {\n\t          context.reportError(new _error.GraphQLError(badValueMessage(argAST.name.value, argDef.type, (0, _languagePrinter.print)(argAST.value), errors), [argAST.value]));\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 400 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.isValidLiteralValue = isValidLiteralValue;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\tvar _languagePrinter = __webpack_require__(362);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsKeyMap = __webpack_require__(372);\n\t\n\tvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\t/**\n\t * Utility for validators which determines if a value literal AST is valid given\n\t * an input type.\n\t *\n\t * Note that this only validates literal values, variables are assumed to\n\t * provide values of the correct type.\n\t */\n\t\n\tfunction isValidLiteralValue(_x, _x2) {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    var type = _x,\n\t        valueAST = _x2;\n\t    ofType = itemType = fields = errors = fieldASTs = _iteratorNormalCompletion = _didIteratorError = _iteratorError = fieldASTMap = _iteratorNormalCompletion2 = _didIteratorError2 = _iteratorError2 = parseResult = undefined;\n\t    _again = false;\n\t\n\t    // A value must be provided if the type is non-null.\n\t    if (type instanceof _typeDefinition.GraphQLNonNull) {\n\t      var ofType = type.ofType;\n\t      if (!valueAST) {\n\t        if (ofType.name) {\n\t          return ['Expected \"' + ofType.name + '!\", found null.'];\n\t        }\n\t        return ['Expected non-null value, found null.'];\n\t      }\n\t      _x = ofType;\n\t      _x2 = valueAST;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    if (!valueAST) {\n\t      return [];\n\t    }\n\t\n\t    // This function only tests literals, and assumes variables will provide\n\t    // values of the correct type.\n\t    if (valueAST.kind === _languageKinds.VARIABLE) {\n\t      return [];\n\t    }\n\t\n\t    // Lists accept a non-list value as a list of one.\n\t    if (type instanceof _typeDefinition.GraphQLList) {\n\t      var itemType = type.ofType;\n\t      if (valueAST.kind === _languageKinds.LIST) {\n\t        return valueAST.values.reduce(function (acc, itemAST, index) {\n\t          var errors = isValidLiteralValue(itemType, itemAST);\n\t          return acc.concat(errors.map(function (error) {\n\t            return 'In element #' + index + ': ' + error;\n\t          }));\n\t        }, []);\n\t      }\n\t      _x = itemType;\n\t      _x2 = valueAST;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    // Input objects check each defined field and look for undefined fields.\n\t    if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n\t      if (valueAST.kind !== _languageKinds.OBJECT) {\n\t        return ['Expected \"' + type.name + '\", found not an object.'];\n\t      }\n\t      var fields = type.getFields();\n\t\n\t      var errors = [];\n\t\n\t      // Ensure every provided field is defined.\n\t      var fieldASTs = valueAST.fields;\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = fieldASTs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var providedFieldAST = _step.value;\n\t\n\t          if (!fields[providedFieldAST.name.value]) {\n\t            errors.push('In field \"' + providedFieldAST.name.value + '\": Unknown field.');\n\t          }\n\t        }\n\t\n\t        // Ensure every defined field is valid.\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator['return']) {\n\t            _iterator['return']();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      var fieldASTMap = (0, _jsutilsKeyMap2['default'])(fieldASTs, function (fieldAST) {\n\t        return fieldAST.name.value;\n\t      });\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = Object.keys(fields)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var fieldName = _step2.value;\n\t\n\t          var result = isValidLiteralValue(fields[fieldName].type, fieldASTMap[fieldName] && fieldASTMap[fieldName].value);\n\t          errors.push.apply(errors, _toConsumableArray(result.map(function (error) {\n\t            return 'In field \"' + fieldName + '\": ' + error;\n\t          })));\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n\t            _iterator2['return']();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return errors;\n\t    }\n\t\n\t    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLScalarType || type instanceof _typeDefinition.GraphQLEnumType, 'Must be input type');\n\t\n\t    // Scalar/Enum input checks to ensure the type can parse the value to\n\t    // a non-null value.\n\t    var parseResult = type.parseLiteral(valueAST);\n\t    if ((0, _jsutilsIsNullish2['default'])(parseResult)) {\n\t      return ['Expected type \"' + type.name + '\", found ' + (0, _languagePrinter.print)(valueAST) + '.'];\n\t    }\n\t\n\t    return [];\n\t  }\n\t}\n\n/***/ },\n/* 401 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.missingFieldArgMessage = missingFieldArgMessage;\n\texports.missingDirectiveArgMessage = missingDirectiveArgMessage;\n\texports.ProvidedNonNullArguments = ProvidedNonNullArguments;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _jsutilsKeyMap = __webpack_require__(372);\n\t\n\tvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tfunction missingFieldArgMessage(fieldName, argName, type) {\n\t  return 'Field \"' + fieldName + '\" argument \"' + argName + '\" of type \"' + type + '\" ' + 'is required but not provided.';\n\t}\n\t\n\tfunction missingDirectiveArgMessage(directiveName, argName, type) {\n\t  return 'Directive \"@' + directiveName + '\" argument \"' + argName + '\" of type ' + ('\"' + type + '\" is required but not provided.');\n\t}\n\t\n\t/**\n\t * Provided required arguments\n\t *\n\t * A field or directive is only valid if all required (non-null) field arguments\n\t * have been provided.\n\t */\n\t\n\tfunction ProvidedNonNullArguments(context) {\n\t  return {\n\t    Field: {\n\t      // Validate on leave to allow for deeper errors to appear first.\n\t      leave: function leave(fieldAST) {\n\t        var fieldDef = context.getFieldDef();\n\t        if (!fieldDef) {\n\t          return false;\n\t        }\n\t        var argASTs = fieldAST.arguments || [];\n\t\n\t        var argASTMap = (0, _jsutilsKeyMap2['default'])(argASTs, function (arg) {\n\t          return arg.name.value;\n\t        });\n\t        fieldDef.args.forEach(function (argDef) {\n\t          var argAST = argASTMap[argDef.name];\n\t          if (!argAST && argDef.type instanceof _typeDefinition.GraphQLNonNull) {\n\t            context.reportError(new _error.GraphQLError(missingFieldArgMessage(fieldAST.name.value, argDef.name, argDef.type), [fieldAST]));\n\t          }\n\t        });\n\t      }\n\t    },\n\t\n\t    Directive: {\n\t      // Validate on leave to allow for deeper errors to appear first.\n\t      leave: function leave(directiveAST) {\n\t        var directiveDef = context.getDirective();\n\t        if (!directiveDef) {\n\t          return false;\n\t        }\n\t        var argASTs = directiveAST.arguments || [];\n\t\n\t        var argASTMap = (0, _jsutilsKeyMap2['default'])(argASTs, function (arg) {\n\t          return arg.name.value;\n\t        });\n\t        directiveDef.args.forEach(function (argDef) {\n\t          var argAST = argASTMap[argDef.name];\n\t          if (!argAST && argDef.type instanceof _typeDefinition.GraphQLNonNull) {\n\t            context.reportError(new _error.GraphQLError(missingDirectiveArgMessage(directiveAST.name.value, argDef.name, argDef.type), [directiveAST]));\n\t          }\n\t        });\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 402 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.defaultForNonNullArgMessage = defaultForNonNullArgMessage;\n\texports.badValueForDefaultArgMessage = badValueForDefaultArgMessage;\n\texports.DefaultValuesOfCorrectType = DefaultValuesOfCorrectType;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _languagePrinter = __webpack_require__(362);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _utilitiesIsValidLiteralValue = __webpack_require__(400);\n\t\n\tfunction defaultForNonNullArgMessage(varName, type, guessType) {\n\t  return 'Variable \"$' + varName + '\" of type \"' + type + '\" is required and will not ' + ('use the default value. Perhaps you meant to use type \"' + guessType + '\".');\n\t}\n\t\n\tfunction badValueForDefaultArgMessage(varName, type, value, verboseErrors) {\n\t  var message = verboseErrors ? '\\n' + verboseErrors.join('\\n') : '';\n\t  return 'Variable \"$' + varName + ' has invalid default value ' + value + '.' + message;\n\t}\n\t\n\t/**\n\t * Variable default values of correct type\n\t *\n\t * A GraphQL document is only valid if all variable default values are of the\n\t * type expected by their definition.\n\t */\n\t\n\tfunction DefaultValuesOfCorrectType(context) {\n\t  return {\n\t    VariableDefinition: function VariableDefinition(varDefAST) {\n\t      var name = varDefAST.variable.name.value;\n\t      var defaultValue = varDefAST.defaultValue;\n\t      var type = context.getInputType();\n\t      if (type instanceof _typeDefinition.GraphQLNonNull && defaultValue) {\n\t        context.reportError(new _error.GraphQLError(defaultForNonNullArgMessage(name, type, type.ofType), [defaultValue]));\n\t      }\n\t      if (type && defaultValue) {\n\t        var errors = (0, _utilitiesIsValidLiteralValue.isValidLiteralValue)(type, defaultValue);\n\t        if (errors && errors.length > 0) {\n\t          context.reportError(new _error.GraphQLError(badValueForDefaultArgMessage(name, type, (0, _languagePrinter.print)(defaultValue), errors), [defaultValue]));\n\t        }\n\t      }\n\t      return false;\n\t    },\n\t    SelectionSet: function SelectionSet() {\n\t      return false;\n\t    },\n\t    FragmentDefinition: function FragmentDefinition() {\n\t      return false;\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 403 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.badVarPosMessage = badVarPosMessage;\n\texports.VariablesInAllowedPosition = VariablesInAllowedPosition;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _utilitiesTypeComparators = __webpack_require__(378);\n\t\n\tvar _utilitiesTypeFromAST = __webpack_require__(380);\n\t\n\tfunction badVarPosMessage(varName, varType, expectedType) {\n\t  return 'Variable \"$' + varName + '\" of type \"' + varType + '\" used in position ' + ('expecting type \"' + expectedType + '\".');\n\t}\n\t\n\t/**\n\t * Variables passed to field arguments conform to type\n\t */\n\t\n\tfunction VariablesInAllowedPosition(context) {\n\t  var varDefMap = Object.create(null);\n\t\n\t  return {\n\t    OperationDefinition: {\n\t      enter: function enter() {\n\t        varDefMap = Object.create(null);\n\t      },\n\t      leave: function leave(operation) {\n\t        var usages = context.getRecursiveVariableUsages(operation);\n\t\n\t        usages.forEach(function (_ref) {\n\t          var node = _ref.node;\n\t          var type = _ref.type;\n\t\n\t          var varName = node.name.value;\n\t          var varDef = varDefMap[varName];\n\t          if (varDef && type) {\n\t            // A var type is allowed if it is the same or more strict (e.g. is\n\t            // a subtype of) than the expected type. It can be more strict if\n\t            // the variable type is non-null when the expected type is nullable.\n\t            // If both are list types, the variable item type can be more strict\n\t            // than the expected item type (contravariant).\n\t            var varType = (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), varDef.type);\n\t            if (varType && !(0, _utilitiesTypeComparators.isTypeSubTypeOf)(effectiveType(varType, varDef), type)) {\n\t              context.reportError(new _error.GraphQLError(badVarPosMessage(varName, varType, type), [varDef, node]));\n\t            }\n\t          }\n\t        });\n\t      }\n\t    },\n\t    VariableDefinition: function VariableDefinition(varDefAST) {\n\t      varDefMap[varDefAST.variable.name.value] = varDefAST;\n\t    }\n\t  };\n\t}\n\t\n\t// If a variable definition has a default value, it's effectively non-null.\n\tfunction effectiveType(varType, varDef) {\n\t  return !varDef.defaultValue || varType instanceof _typeDefinition.GraphQLNonNull ? varType : new _typeDefinition.GraphQLNonNull(varType);\n\t}\n\n/***/ },\n/* 404 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.fieldsConflictMessage = fieldsConflictMessage;\n\texports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;\n\t\n\t// Field name and reason.\n\t\n\t// Reason is a string, or a nested list of conflicts.\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _jsutilsFind = __webpack_require__(377);\n\t\n\tvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tvar _languagePrinter = __webpack_require__(362);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _utilitiesTypeComparators = __webpack_require__(378);\n\t\n\tvar _utilitiesTypeFromAST = __webpack_require__(380);\n\t\n\tfunction fieldsConflictMessage(responseName, reason) {\n\t  return 'Fields \"' + responseName + '\" conflict because ' + reasonMessage(reason) + '.';\n\t}\n\t\n\tfunction reasonMessage(reason) {\n\t  if (Array.isArray(reason)) {\n\t    return reason.map(function (_ref) {\n\t      var _ref2 = _slicedToArray(_ref, 2);\n\t\n\t      var responseName = _ref2[0];\n\t      var subreason = _ref2[1];\n\t      return 'subfields \"' + responseName + '\" conflict because ' + reasonMessage(subreason);\n\t    }).join(' and ');\n\t  }\n\t  return reason;\n\t}\n\t\n\t/**\n\t * Overlapping fields can be merged\n\t *\n\t * A selection set is only valid if all fields (including spreading any\n\t * fragments) either correspond to distinct response names or can be merged\n\t * without ambiguity.\n\t */\n\t\n\tfunction OverlappingFieldsCanBeMerged(context) {\n\t  var comparedSet = new PairSet();\n\t\n\t  function findConflicts(fieldMap) {\n\t    var conflicts = [];\n\t    Object.keys(fieldMap).forEach(function (responseName) {\n\t      var fields = fieldMap[responseName];\n\t      if (fields.length > 1) {\n\t        for (var i = 0; i < fields.length; i++) {\n\t          for (var j = i; j < fields.length; j++) {\n\t            var conflict = findConflict(responseName, fields[i], fields[j]);\n\t            if (conflict) {\n\t              conflicts.push(conflict);\n\t            }\n\t          }\n\t        }\n\t      }\n\t    });\n\t    return conflicts;\n\t  }\n\t\n\t  function findConflict(responseName, field1, field2) {\n\t    var _field1 = _slicedToArray(field1, 3);\n\t\n\t    var parentType1 = _field1[0];\n\t    var ast1 = _field1[1];\n\t    var def1 = _field1[2];\n\t\n\t    var _field2 = _slicedToArray(field2, 3);\n\t\n\t    var parentType2 = _field2[0];\n\t    var ast2 = _field2[1];\n\t    var def2 = _field2[2];\n\t\n\t    // Not a pair.\n\t    if (ast1 === ast2) {\n\t      return;\n\t    }\n\t\n\t    // If the statically known parent types could not possibly apply at the same\n\t    // time, then it is safe to permit them to diverge as they will not present\n\t    // any ambiguity by differing.\n\t    // It is known that two parent types could never overlap if they are\n\t    // different Object types. Interface or Union types might overlap - if not\n\t    // in the current state of the schema, then perhaps in some future version,\n\t    // thus may not safely diverge.\n\t    if (parentType1 !== parentType2 && parentType1 instanceof _typeDefinition.GraphQLObjectType && parentType2 instanceof _typeDefinition.GraphQLObjectType) {\n\t      return;\n\t    }\n\t\n\t    // Memoize, do not report the same issue twice.\n\t    if (comparedSet.has(ast1, ast2)) {\n\t      return;\n\t    }\n\t    comparedSet.add(ast1, ast2);\n\t\n\t    var name1 = ast1.name.value;\n\t    var name2 = ast2.name.value;\n\t    if (name1 !== name2) {\n\t      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [ast1], [ast2]];\n\t    }\n\t\n\t    var type1 = def1 && def1.type;\n\t    var type2 = def2 && def2.type;\n\t    if (type1 && type2 && !(0, _utilitiesTypeComparators.isEqualType)(type1, type2)) {\n\t      return [[responseName, 'they return differing types ' + type1 + ' and ' + type2], [ast1], [ast2]];\n\t    }\n\t\n\t    if (!sameArguments(ast1.arguments || [], ast2.arguments || [])) {\n\t      return [[responseName, 'they have differing arguments'], [ast1], [ast2]];\n\t    }\n\t\n\t    var selectionSet1 = ast1.selectionSet;\n\t    var selectionSet2 = ast2.selectionSet;\n\t    if (selectionSet1 && selectionSet2) {\n\t      var visitedFragmentNames = {};\n\t      var subfieldMap = collectFieldASTsAndDefs(context, (0, _typeDefinition.getNamedType)(type1), selectionSet1, visitedFragmentNames);\n\t      subfieldMap = collectFieldASTsAndDefs(context, (0, _typeDefinition.getNamedType)(type2), selectionSet2, visitedFragmentNames, subfieldMap);\n\t      var conflicts = findConflicts(subfieldMap);\n\t      if (conflicts.length > 0) {\n\t        return [[responseName, conflicts.map(function (_ref3) {\n\t          var _ref32 = _slicedToArray(_ref3, 1);\n\t\n\t          var reason = _ref32[0];\n\t          return reason;\n\t        })], conflicts.reduce(function (allFields, _ref4) {\n\t          var _ref42 = _slicedToArray(_ref4, 2);\n\t\n\t          var fields1 = _ref42[1];\n\t          return allFields.concat(fields1);\n\t        }, [ast1]), conflicts.reduce(function (allFields, _ref5) {\n\t          var _ref52 = _slicedToArray(_ref5, 3);\n\t\n\t          var fields2 = _ref52[2];\n\t          return allFields.concat(fields2);\n\t        }, [ast2])];\n\t      }\n\t    }\n\t  }\n\t\n\t  return {\n\t    SelectionSet: {\n\t      // Note: we validate on the reverse traversal so deeper conflicts will be\n\t      // caught first, for clearer error messages.\n\t      leave: function leave(selectionSet) {\n\t        var fieldMap = collectFieldASTsAndDefs(context, context.getParentType(), selectionSet);\n\t        var conflicts = findConflicts(fieldMap);\n\t        conflicts.forEach(function (_ref6) {\n\t          var _ref62 = _slicedToArray(_ref6, 3);\n\t\n\t          var _ref62$0 = _slicedToArray(_ref62[0], 2);\n\t\n\t          var responseName = _ref62$0[0];\n\t          var reason = _ref62$0[1];\n\t          var fields1 = _ref62[1];\n\t          var fields2 = _ref62[2];\n\t          return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n\t        });\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tfunction sameArguments(arguments1, arguments2) {\n\t  if (arguments1.length !== arguments2.length) {\n\t    return false;\n\t  }\n\t  return arguments1.every(function (argument1) {\n\t    var argument2 = (0, _jsutilsFind2['default'])(arguments2, function (argument) {\n\t      return argument.name.value === argument1.name.value;\n\t    });\n\t    if (!argument2) {\n\t      return false;\n\t    }\n\t    return sameValue(argument1.value, argument2.value);\n\t  });\n\t}\n\t\n\tfunction sameValue(value1, value2) {\n\t  return !value1 && !value2 || (0, _languagePrinter.print)(value1) === (0, _languagePrinter.print)(value2);\n\t}\n\t\n\t/**\n\t * Given a selectionSet, adds all of the fields in that selection to\n\t * the passed in map of fields, and returns it at the end.\n\t *\n\t * Note: This is not the same as execution's collectFields because at static\n\t * time we do not know what object type will be used, so we unconditionally\n\t * spread in all fragments.\n\t */\n\tfunction collectFieldASTsAndDefs(context, parentType, selectionSet, visitedFragmentNames, astAndDefs) {\n\t  var _visitedFragmentNames = visitedFragmentNames || {};\n\t  var _astAndDefs = astAndDefs || {};\n\t  for (var i = 0; i < selectionSet.selections.length; i++) {\n\t    var selection = selectionSet.selections[i];\n\t    switch (selection.kind) {\n\t      case _languageKinds.FIELD:\n\t        var fieldName = selection.name.value;\n\t        var fieldDef;\n\t        if (parentType instanceof _typeDefinition.GraphQLObjectType || parentType instanceof _typeDefinition.GraphQLInterfaceType) {\n\t          fieldDef = parentType.getFields()[fieldName];\n\t        }\n\t        var responseName = selection.alias ? selection.alias.value : fieldName;\n\t        if (!_astAndDefs[responseName]) {\n\t          _astAndDefs[responseName] = [];\n\t        }\n\t        _astAndDefs[responseName].push([parentType, selection, fieldDef]);\n\t        break;\n\t      case _languageKinds.INLINE_FRAGMENT:\n\t        var typeCondition = selection.typeCondition;\n\t        var inlineFragmentType = typeCondition ? (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), selection.typeCondition) : parentType;\n\t        _astAndDefs = collectFieldASTsAndDefs(context, inlineFragmentType, selection.selectionSet, _visitedFragmentNames, _astAndDefs);\n\t        break;\n\t      case _languageKinds.FRAGMENT_SPREAD:\n\t        var fragName = selection.name.value;\n\t        if (_visitedFragmentNames[fragName]) {\n\t          continue;\n\t        }\n\t        _visitedFragmentNames[fragName] = true;\n\t        var fragment = context.getFragment(fragName);\n\t        if (!fragment) {\n\t          continue;\n\t        }\n\t        var fragmentType = (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);\n\t        _astAndDefs = collectFieldASTsAndDefs(context, fragmentType, fragment.selectionSet, _visitedFragmentNames, _astAndDefs);\n\t        break;\n\t    }\n\t  }\n\t  return _astAndDefs;\n\t}\n\t\n\t/**\n\t * A way to keep track of pairs of things when the ordering of the pair does\n\t * not matter. We do this by maintaining a sort of double adjacency sets.\n\t */\n\t\n\tvar PairSet = (function () {\n\t  function PairSet() {\n\t    _classCallCheck(this, PairSet);\n\t\n\t    this._data = new Map();\n\t  }\n\t\n\t  _createClass(PairSet, [{\n\t    key: 'has',\n\t    value: function has(a, b) {\n\t      var first = this._data.get(a);\n\t      return first && first.has(b);\n\t    }\n\t  }, {\n\t    key: 'add',\n\t    value: function add(a, b) {\n\t      _pairSetAdd(this._data, a, b);\n\t      _pairSetAdd(this._data, b, a);\n\t    }\n\t  }]);\n\t\n\t  return PairSet;\n\t})();\n\t\n\tfunction _pairSetAdd(data, a, b) {\n\t  var set = data.get(a);\n\t  if (!set) {\n\t    set = new Set();\n\t    data.set(a, set);\n\t  }\n\t  set.add(b);\n\t}\n\n/***/ },\n/* 405 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.duplicateInputFieldMessage = duplicateInputFieldMessage;\n\texports.UniqueInputFieldNames = UniqueInputFieldNames;\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tfunction duplicateInputFieldMessage(fieldName) {\n\t  return 'There can be only one input field named \"' + fieldName + '\".';\n\t}\n\t\n\t/**\n\t * Unique input field names\n\t *\n\t * A GraphQL input object value is only valid if all supplied fields are\n\t * uniquely named.\n\t */\n\t\n\tfunction UniqueInputFieldNames(context) {\n\t  var knownNameStack = [];\n\t  var knownNames = Object.create(null);\n\t\n\t  return {\n\t    ObjectValue: {\n\t      enter: function enter() {\n\t        knownNameStack.push(knownNames);\n\t        knownNames = Object.create(null);\n\t      },\n\t      leave: function leave() {\n\t        knownNames = knownNameStack.pop();\n\t      }\n\t    },\n\t    ObjectField: function ObjectField(node) {\n\t      var fieldName = node.name.value;\n\t      if (knownNames[fieldName]) {\n\t        context.reportError(new _error.GraphQLError(duplicateInputFieldMessage(fieldName), [knownNames[fieldName], node.name]));\n\t      } else {\n\t        knownNames[fieldName] = node.name;\n\t      }\n\t      return false;\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 406 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Terminology\n\t *\n\t * \"Definitions\" are the generic name for top-level statements in the document.\n\t * Examples of this include:\n\t * 1) Operations (such as a query)\n\t * 2) Fragments\n\t *\n\t * \"Operations\" are a generic name for requests in the document.\n\t * Examples of this include:\n\t * 1) query,\n\t * 2) mutation\n\t *\n\t * \"Selections\" are the definitions that can appear legally and at\n\t * single level of the query. These include:\n\t * 1) field references e.g \"a\"\n\t * 2) fragment \"spreads\" e.g. \"...c\"\n\t * 3) inline fragment \"spreads\" e.g. \"...on Type { a }\"\n\t */\n\t\n\t/**\n\t * Data that must be available at all points during query execution.\n\t *\n\t * Namely, schema of the type system that is currently executing,\n\t * and the fragments defined in the query document\n\t */\n\t'use strict';\n\t\n\t/**\n\t * The result of execution. `data` is the result of executing the\n\t * query, `errors` is null if no errors occurred, and is a\n\t * non-empty array if an error occurred.\n\t */\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.execute = execute;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _jsutilsFind = __webpack_require__(377);\n\t\n\tvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\tvar _utilitiesTypeFromAST = __webpack_require__(380);\n\t\n\tvar _language = __webpack_require__(358);\n\t\n\tvar _values = __webpack_require__(407);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _typeSchema = __webpack_require__(369);\n\t\n\tvar _typeIntrospection = __webpack_require__(375);\n\t\n\tvar _typeDirectives = __webpack_require__(373);\n\t\n\t/**\n\t * Implements the \"Evaluating requests\" section of the GraphQL specification.\n\t *\n\t * Returns a Promise that will eventually be resolved and never rejected.\n\t *\n\t * If the arguments to this function do not result in a legal execution context,\n\t * a GraphQLError will be thrown immediately explaining the invalid input.\n\t */\n\t\n\tfunction execute(schema, documentAST, rootValue, variableValues, operationName) {\n\t  (0, _jsutilsInvariant2['default'])(schema, 'Must provide schema');\n\t  (0, _jsutilsInvariant2['default'])(schema instanceof _typeSchema.GraphQLSchema, 'Schema must be an instance of GraphQLSchema. Also ensure that there are ' + 'not multiple versions of GraphQL installed in your node_modules directory.');\n\t\n\t  // If a valid context cannot be created due to incorrect arguments,\n\t  // this will throw an error.\n\t  var context = buildExecutionContext(schema, documentAST, rootValue, variableValues, operationName);\n\t\n\t  // Return a Promise that will eventually resolve to the data described by\n\t  // The \"Response\" section of the GraphQL specification.\n\t  //\n\t  // If errors are encountered while executing a GraphQL field, only that\n\t  // field and its descendants will be omitted, and sibling fields will still\n\t  // be executed. An execution which encounters errors will still result in a\n\t  // resolved Promise.\n\t  return new Promise(function (resolve) {\n\t    resolve(executeOperation(context, context.operation, rootValue));\n\t  })['catch'](function (error) {\n\t    // Errors from sub-fields of a NonNull type may propagate to the top level,\n\t    // at which point we still log the error and null the parent field, which\n\t    // in this case is the entire response.\n\t    context.errors.push(error);\n\t    return null;\n\t  }).then(function (data) {\n\t    if (!context.errors.length) {\n\t      return { data: data };\n\t    }\n\t    return { data: data, errors: context.errors };\n\t  });\n\t}\n\t\n\t/**\n\t * Constructs a ExecutionContext object from the arguments passed to\n\t * execute, which we will pass throughout the other execution methods.\n\t *\n\t * Throws a GraphQLError if a valid execution context cannot be created.\n\t */\n\tfunction buildExecutionContext(schema, documentAST, rootValue, rawVariableValues, operationName) {\n\t  var errors = [];\n\t  var operation;\n\t  var fragments = {};\n\t  documentAST.definitions.forEach(function (definition) {\n\t    switch (definition.kind) {\n\t      case _language.Kind.OPERATION_DEFINITION:\n\t        if (!operationName && operation) {\n\t          throw new _error.GraphQLError('Must provide operation name if query contains multiple operations.');\n\t        }\n\t        if (!operationName || definition.name && definition.name.value === operationName) {\n\t          operation = definition;\n\t        }\n\t        break;\n\t      case _language.Kind.FRAGMENT_DEFINITION:\n\t        fragments[definition.name.value] = definition;\n\t        break;\n\t      default:\n\t        throw new _error.GraphQLError('GraphQL cannot execute a request containing a ' + definition.kind + '.', definition);\n\t    }\n\t  });\n\t  if (!operation) {\n\t    if (!operationName) {\n\t      throw new _error.GraphQLError('Unknown operation named \"' + operationName + '\".');\n\t    } else {\n\t      throw new _error.GraphQLError('Must provide an operation.');\n\t    }\n\t  }\n\t  var variableValues = (0, _values.getVariableValues)(schema, operation.variableDefinitions || [], rawVariableValues || {});\n\t  var exeContext = { schema: schema, fragments: fragments, rootValue: rootValue, operation: operation, variableValues: variableValues, errors: errors };\n\t  return exeContext;\n\t}\n\t\n\t/**\n\t * Implements the \"Evaluating operations\" section of the spec.\n\t */\n\tfunction executeOperation(exeContext, operation, rootValue) {\n\t  var type = getOperationRootType(exeContext.schema, operation);\n\t  var fields = collectFields(exeContext, type, operation.selectionSet, {}, {});\n\t  if (operation.operation === 'mutation') {\n\t    return executeFieldsSerially(exeContext, type, rootValue, fields);\n\t  }\n\t  return executeFields(exeContext, type, rootValue, fields);\n\t}\n\t\n\t/**\n\t * Extracts the root type of the operation from the schema.\n\t */\n\tfunction getOperationRootType(schema, operation) {\n\t  switch (operation.operation) {\n\t    case 'query':\n\t      return schema.getQueryType();\n\t    case 'mutation':\n\t      var mutationType = schema.getMutationType();\n\t      if (!mutationType) {\n\t        throw new _error.GraphQLError('Schema is not configured for mutations', [operation]);\n\t      }\n\t      return mutationType;\n\t    case 'subscription':\n\t      var subscriptionType = schema.getSubscriptionType();\n\t      if (!subscriptionType) {\n\t        throw new _error.GraphQLError('Schema is not configured for subscriptions', [operation]);\n\t      }\n\t      return subscriptionType;\n\t    default:\n\t      throw new _error.GraphQLError('Can only execute queries, mutations and subscriptions', [operation]);\n\t  }\n\t}\n\t\n\t/**\n\t * Implements the \"Evaluating selection sets\" section of the spec\n\t * for \"write\" mode.\n\t */\n\tfunction executeFieldsSerially(exeContext, parentType, sourceValue, fields) {\n\t  return Object.keys(fields).reduce(function (prevPromise, responseName) {\n\t    return prevPromise.then(function (results) {\n\t      var fieldASTs = fields[responseName];\n\t      var result = resolveField(exeContext, parentType, sourceValue, fieldASTs);\n\t      if (result === undefined) {\n\t        return results;\n\t      }\n\t      if (isThenable(result)) {\n\t        return result.then(function (resolvedResult) {\n\t          results[responseName] = resolvedResult;\n\t          return results;\n\t        });\n\t      }\n\t      results[responseName] = result;\n\t      return results;\n\t    });\n\t  }, Promise.resolve({}));\n\t}\n\t\n\t/**\n\t * Implements the \"Evaluating selection sets\" section of the spec\n\t * for \"read\" mode.\n\t */\n\tfunction executeFields(exeContext, parentType, sourceValue, fields) {\n\t  var containsPromise = false;\n\t\n\t  var finalResults = Object.keys(fields).reduce(function (results, responseName) {\n\t    var fieldASTs = fields[responseName];\n\t    var result = resolveField(exeContext, parentType, sourceValue, fieldASTs);\n\t    if (result === undefined) {\n\t      return results;\n\t    }\n\t    results[responseName] = result;\n\t    if (isThenable(result)) {\n\t      containsPromise = true;\n\t    }\n\t    return results;\n\t  }, {});\n\t\n\t  // If there are no promises, we can just return the object\n\t  if (!containsPromise) {\n\t    return finalResults;\n\t  }\n\t\n\t  // Otherwise, results is a map from field name to the result\n\t  // of resolving that field, which is possibly a promise. Return\n\t  // a promise that will return this same map, but with any\n\t  // promises replaced with the values they resolved to.\n\t  return promiseForObject(finalResults);\n\t}\n\t\n\t/**\n\t * Given a selectionSet, adds all of the fields in that selection to\n\t * the passed in map of fields, and returns it at the end.\n\t *\n\t * CollectFields requires the \"runtime type\" of an object. For a field which\n\t * returns and Interface or Union type, the \"runtime type\" will be the actual\n\t * Object type returned by that field.\n\t */\n\tfunction collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\n\t  for (var i = 0; i < selectionSet.selections.length; i++) {\n\t    var selection = selectionSet.selections[i];\n\t    switch (selection.kind) {\n\t      case _language.Kind.FIELD:\n\t        if (!shouldIncludeNode(exeContext, selection.directives)) {\n\t          continue;\n\t        }\n\t        var name = getFieldEntryKey(selection);\n\t        if (!fields[name]) {\n\t          fields[name] = [];\n\t        }\n\t        fields[name].push(selection);\n\t        break;\n\t      case _language.Kind.INLINE_FRAGMENT:\n\t        if (!shouldIncludeNode(exeContext, selection.directives) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\n\t          continue;\n\t        }\n\t        collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n\t        break;\n\t      case _language.Kind.FRAGMENT_SPREAD:\n\t        var fragName = selection.name.value;\n\t        if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection.directives)) {\n\t          continue;\n\t        }\n\t        visitedFragmentNames[fragName] = true;\n\t        var fragment = exeContext.fragments[fragName];\n\t        if (!fragment || !shouldIncludeNode(exeContext, fragment.directives) || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n\t          continue;\n\t        }\n\t        collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n\t        break;\n\t    }\n\t  }\n\t  return fields;\n\t}\n\t\n\t/**\n\t * Determines if a field should be included based on the @include and @skip\n\t * directives, where @skip has higher precidence than @include.\n\t */\n\tfunction shouldIncludeNode(exeContext, directives) {\n\t  var skipAST = directives && (0, _jsutilsFind2['default'])(directives, function (directive) {\n\t    return directive.name.value === _typeDirectives.GraphQLSkipDirective.name;\n\t  });\n\t  if (skipAST) {\n\t    var _getArgumentValues = (0, _values.getArgumentValues)(_typeDirectives.GraphQLSkipDirective.args, skipAST.arguments, exeContext.variableValues);\n\t\n\t    var skipIf = _getArgumentValues['if'];\n\t\n\t    return !skipIf;\n\t  }\n\t\n\t  var includeAST = directives && (0, _jsutilsFind2['default'])(directives, function (directive) {\n\t    return directive.name.value === _typeDirectives.GraphQLIncludeDirective.name;\n\t  });\n\t  if (includeAST) {\n\t    var _getArgumentValues2 = (0, _values.getArgumentValues)(_typeDirectives.GraphQLIncludeDirective.args, includeAST.arguments, exeContext.variableValues);\n\t\n\t    var includeIf = _getArgumentValues2['if'];\n\t\n\t    return Boolean(includeIf);\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\t/**\n\t * Determines if a fragment is applicable to the given type.\n\t */\n\tfunction doesFragmentConditionMatch(exeContext, fragment, type) {\n\t  var typeConditionAST = fragment.typeCondition;\n\t  if (!typeConditionAST) {\n\t    return true;\n\t  }\n\t  var conditionalType = (0, _utilitiesTypeFromAST.typeFromAST)(exeContext.schema, typeConditionAST);\n\t  if (conditionalType === type) {\n\t    return true;\n\t  }\n\t  if ((0, _typeDefinition.isAbstractType)(conditionalType)) {\n\t    return conditionalType.isPossibleType(type);\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * This function transforms a JS object `{[key: string]: Promise<any>}` into\n\t * a `Promise<{[key: string]: any}>`\n\t *\n\t * This is akin to bluebird's `Promise.props`, but implemented only using\n\t * `Promise.all` so it will work with any implementation of ES6 promises.\n\t */\n\tfunction promiseForObject(object) {\n\t  var keys = Object.keys(object);\n\t  var valuesAndPromises = keys.map(function (name) {\n\t    return object[name];\n\t  });\n\t  return Promise.all(valuesAndPromises).then(function (values) {\n\t    return values.reduce(function (resolvedObject, value, i) {\n\t      resolvedObject[keys[i]] = value;\n\t      return resolvedObject;\n\t    }, {});\n\t  });\n\t}\n\t\n\t/**\n\t * Implements the logic to compute the key of a given field’s entry\n\t */\n\tfunction getFieldEntryKey(node) {\n\t  return node.alias ? node.alias.value : node.name.value;\n\t}\n\t\n\t/**\n\t * Resolves the field on the given source object. In particular, this\n\t * figures out the value that the field returns by calling its resolve function,\n\t * then calls completeValue to complete promises, serialize scalars, or execute\n\t * the sub-selection-set for objects.\n\t */\n\tfunction resolveField(exeContext, parentType, source, fieldASTs) {\n\t  var fieldAST = fieldASTs[0];\n\t  var fieldName = fieldAST.name.value;\n\t\n\t  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);\n\t  if (!fieldDef) {\n\t    return;\n\t  }\n\t\n\t  var returnType = fieldDef.type;\n\t  var resolveFn = fieldDef.resolve || defaultResolveFn;\n\t\n\t  // Build a JS object of arguments from the field.arguments AST, using the\n\t  // variables scope to fulfill any variable references.\n\t  // TODO: find a way to memoize, in case this field is within a List type.\n\t  var args = (0, _values.getArgumentValues)(fieldDef.args, fieldAST.arguments, exeContext.variableValues);\n\t\n\t  // The resolve function's optional third argument is a collection of\n\t  // information about the current execution state.\n\t  var info = {\n\t    fieldName: fieldName,\n\t    fieldASTs: fieldASTs,\n\t    returnType: returnType,\n\t    parentType: parentType,\n\t    schema: exeContext.schema,\n\t    fragments: exeContext.fragments,\n\t    rootValue: exeContext.rootValue,\n\t    operation: exeContext.operation,\n\t    variableValues: exeContext.variableValues\n\t  };\n\t\n\t  // Get the resolve function, regardless of if its result is normal\n\t  // or abrupt (error).\n\t  var result = resolveOrError(resolveFn, source, args, info);\n\t\n\t  return completeValueCatchingError(exeContext, returnType, fieldASTs, info, result);\n\t}\n\t\n\t// Isolates the \"ReturnOrAbrupt\" behavior to not de-opt the `resolveField`\n\t// function. Returns the result of resolveFn or the abrupt-return Error object.\n\tfunction resolveOrError(resolveFn, source, args, info) {\n\t  try {\n\t    return resolveFn(source, args, info);\n\t  } catch (error) {\n\t    // Sometimes a non-error is thrown, wrap it as an Error for a\n\t    // consistent interface.\n\t    return error instanceof Error ? error : new Error(error);\n\t  }\n\t}\n\t\n\t// This is a small wrapper around completeValue which detects and logs errors\n\t// in the execution context.\n\tfunction completeValueCatchingError(exeContext, returnType, fieldASTs, info, result) {\n\t  // If the field type is non-nullable, then it is resolved without any\n\t  // protection from errors.\n\t  if (returnType instanceof _typeDefinition.GraphQLNonNull) {\n\t    return completeValue(exeContext, returnType, fieldASTs, info, result);\n\t  }\n\t\n\t  // Otherwise, error protection is applied, logging the error and resolving\n\t  // a null value for this field if one is encountered.\n\t  try {\n\t    var completed = completeValue(exeContext, returnType, fieldASTs, info, result);\n\t    if (isThenable(completed)) {\n\t      // If `completeValue` returned a rejected promise, log the rejection\n\t      // error and resolve to null.\n\t      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n\t      // to take a second callback for the error case.\n\t      return completed.then(undefined, function (error) {\n\t        exeContext.errors.push(error);\n\t        return Promise.resolve(null);\n\t      });\n\t    }\n\t    return completed;\n\t  } catch (error) {\n\t    // If `completeValue` returned abruptly (threw an error), log the error\n\t    // and return null.\n\t    exeContext.errors.push(error);\n\t    return null;\n\t  }\n\t}\n\t\n\t/**\n\t * Implements the instructions for completeValue as defined in the\n\t * \"Field entries\" section of the spec.\n\t *\n\t * If the field type is Non-Null, then this recursively completes the value\n\t * for the inner type. It throws a field error if that completion returns null,\n\t * as per the \"Nullability\" section of the spec.\n\t *\n\t * If the field type is a List, then this recursively completes the value\n\t * for the inner type on each item in the list.\n\t *\n\t * If the field type is a Scalar or Enum, ensures the completed value is a legal\n\t * value of the type by calling the `serialize` method of GraphQL type\n\t * definition.\n\t *\n\t * Otherwise, the field type expects a sub-selection set, and will complete the\n\t * value by evaluating all sub-selections.\n\t */\n\tfunction completeValue(exeContext, returnType, fieldASTs, info, result) {\n\t  // If result is a Promise, apply-lift over completeValue.\n\t  if (isThenable(result)) {\n\t    return result.then(\n\t    // Once resolved to a value, complete that value.\n\t    function (resolved) {\n\t      return completeValue(exeContext, returnType, fieldASTs, info, resolved);\n\t    },\n\t    // If rejected, create a located error, and continue to reject.\n\t    function (error) {\n\t      return Promise.reject((0, _error.locatedError)(error, fieldASTs));\n\t    });\n\t  }\n\t\n\t  // If result is an Error, throw a located error.\n\t  if (result instanceof Error) {\n\t    throw (0, _error.locatedError)(result, fieldASTs);\n\t  }\n\t\n\t  // If field type is NonNull, complete for inner type, and throw field error\n\t  // if result is null.\n\t  if (returnType instanceof _typeDefinition.GraphQLNonNull) {\n\t    var completed = completeValue(exeContext, returnType.ofType, fieldASTs, info, result);\n\t    if (completed === null) {\n\t      throw new _error.GraphQLError('Cannot return null for non-nullable ' + ('field ' + info.parentType + '.' + info.fieldName + '.'), fieldASTs);\n\t    }\n\t    return completed;\n\t  }\n\t\n\t  // If result is null-like, return null.\n\t  if ((0, _jsutilsIsNullish2['default'])(result)) {\n\t    return null;\n\t  }\n\t\n\t  // If field type is List, complete each item in the list with the inner type\n\t  if (returnType instanceof _typeDefinition.GraphQLList) {\n\t    (0, _jsutilsInvariant2['default'])(Array.isArray(result), 'User Error: expected iterable, but did not find one.');\n\t\n\t    // This is specified as a simple map, however we're optimizing the path\n\t    // where the list contains no Promises by avoiding creating another Promise.\n\t    var itemType = returnType.ofType;\n\t    var containsPromise = false;\n\t    var completedResults = result.map(function (item) {\n\t      var completedItem = completeValueCatchingError(exeContext, itemType, fieldASTs, info, item);\n\t      if (!containsPromise && isThenable(completedItem)) {\n\t        containsPromise = true;\n\t      }\n\t      return completedItem;\n\t    });\n\t\n\t    return containsPromise ? Promise.all(completedResults) : completedResults;\n\t  }\n\t\n\t  // If field type is Scalar or Enum, serialize to a valid value, returning\n\t  // null if serialization is not possible.\n\t  if (returnType instanceof _typeDefinition.GraphQLScalarType || returnType instanceof _typeDefinition.GraphQLEnumType) {\n\t    (0, _jsutilsInvariant2['default'])(returnType.serialize, 'Missing serialize method on type');\n\t    var serializedResult = returnType.serialize(result);\n\t    return (0, _jsutilsIsNullish2['default'])(serializedResult) ? null : serializedResult;\n\t  }\n\t\n\t  // Field type must be Object, Interface or Union and expect sub-selections.\n\t  var runtimeType;\n\t\n\t  if (returnType instanceof _typeDefinition.GraphQLObjectType) {\n\t    runtimeType = returnType;\n\t  } else if ((0, _typeDefinition.isAbstractType)(returnType)) {\n\t    var abstractType = returnType;\n\t    runtimeType = abstractType.getObjectType(result, info);\n\t    if (runtimeType && !abstractType.isPossibleType(runtimeType)) {\n\t      throw new _error.GraphQLError('Runtime Object type \"' + runtimeType + '\" is not a possible type ' + ('for \"' + abstractType + '\".'), fieldASTs);\n\t    }\n\t  }\n\t\n\t  if (!runtimeType) {\n\t    return null;\n\t  }\n\t\n\t  // If there is an isTypeOf predicate function, call it with the\n\t  // current result. If isTypeOf returns false, then raise an error rather\n\t  // than continuing execution.\n\t  if (runtimeType.isTypeOf && !runtimeType.isTypeOf(result, info)) {\n\t    throw new _error.GraphQLError('Expected value of type \"' + runtimeType + '\" but got: ' + result + '.', fieldASTs);\n\t  }\n\t\n\t  // Collect sub-fields to execute to complete this value.\n\t  var subFieldASTs = {};\n\t  var visitedFragmentNames = {};\n\t  for (var i = 0; i < fieldASTs.length; i++) {\n\t    var selectionSet = fieldASTs[i].selectionSet;\n\t    if (selectionSet) {\n\t      subFieldASTs = collectFields(exeContext, runtimeType, selectionSet, subFieldASTs, visitedFragmentNames);\n\t    }\n\t  }\n\t\n\t  return executeFields(exeContext, runtimeType, result, subFieldASTs);\n\t}\n\t\n\t/**\n\t * If a resolve function is not given, then a default resolve behavior is used\n\t * which takes the property of the source object of the same name as the field\n\t * and returns it as the result, or if it's a function, returns the result\n\t * of calling that function.\n\t */\n\tfunction defaultResolveFn(source, args, _ref) {\n\t  var fieldName = _ref.fieldName;\n\t\n\t  var property = source[fieldName];\n\t  return typeof property === 'function' ? property.call(source) : property;\n\t}\n\t\n\t/**\n\t * Checks to see if this object acts like a Promise, i.e. has a \"then\"\n\t * function.\n\t */\n\tfunction isThenable(value) {\n\t  return value && typeof value === 'object' && typeof value.then === 'function';\n\t}\n\t\n\t/**\n\t * This method looks up the field on the given type defintion.\n\t * It has special casing for the two introspection fields, __schema\n\t * and __typename. __typename is special because it can always be\n\t * queried as a field, even in situations where no other fields\n\t * are allowed, like on a Union. __schema could get automatically\n\t * added to the query type, but that would require mutating type\n\t * definitions, which would cause issues.\n\t */\n\tfunction getFieldDef(schema, parentType, fieldName) {\n\t  if (fieldName === _typeIntrospection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n\t    return _typeIntrospection.SchemaMetaFieldDef;\n\t  } else if (fieldName === _typeIntrospection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n\t    return _typeIntrospection.TypeMetaFieldDef;\n\t  } else if (fieldName === _typeIntrospection.TypeNameMetaFieldDef.name) {\n\t    return _typeIntrospection.TypeNameMetaFieldDef;\n\t  }\n\t  return parentType.getFields()[fieldName];\n\t}\n\n/***/ },\n/* 407 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Prepares an object map of variableValues of the correct type based on the\n\t * provided variable definitions and arbitrary input. If the input cannot be\n\t * parsed to match the variable definitions, a GraphQLError will be thrown.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.getVariableValues = getVariableValues;\n\texports.getArgumentValues = getArgumentValues;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _error = __webpack_require__(356);\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\tvar _jsutilsKeyMap = __webpack_require__(372);\n\t\n\tvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\t\n\tvar _utilitiesTypeFromAST = __webpack_require__(380);\n\t\n\tvar _utilitiesValueFromAST = __webpack_require__(408);\n\t\n\tvar _utilitiesIsValidJSValue = __webpack_require__(409);\n\t\n\tvar _languagePrinter = __webpack_require__(362);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tfunction getVariableValues(schema, definitionASTs, inputs) {\n\t  return definitionASTs.reduce(function (values, defAST) {\n\t    var varName = defAST.variable.name.value;\n\t    values[varName] = getVariableValue(schema, defAST, inputs[varName]);\n\t    return values;\n\t  }, {});\n\t}\n\t\n\t/**\n\t * Prepares an object map of argument values given a list of argument\n\t * definitions and list of argument AST nodes.\n\t */\n\t\n\tfunction getArgumentValues(argDefs, argASTs, variableValues) {\n\t  if (!argDefs || !argASTs) {\n\t    return {};\n\t  }\n\t  var argASTMap = (0, _jsutilsKeyMap2['default'])(argASTs, function (arg) {\n\t    return arg.name.value;\n\t  });\n\t  return argDefs.reduce(function (result, argDef) {\n\t    var name = argDef.name;\n\t    var valueAST = argASTMap[name] ? argASTMap[name].value : null;\n\t    var value = (0, _utilitiesValueFromAST.valueFromAST)(valueAST, argDef.type, variableValues);\n\t    if ((0, _jsutilsIsNullish2['default'])(value)) {\n\t      value = argDef.defaultValue;\n\t    }\n\t    if (!(0, _jsutilsIsNullish2['default'])(value)) {\n\t      result[name] = value;\n\t    }\n\t    return result;\n\t  }, {});\n\t}\n\t\n\t/**\n\t * Given a variable definition, and any value of input, return a value which\n\t * adheres to the variable definition, or throw an error.\n\t */\n\tfunction getVariableValue(schema, definitionAST, input) {\n\t  var type = (0, _utilitiesTypeFromAST.typeFromAST)(schema, definitionAST.type);\n\t  var variable = definitionAST.variable;\n\t  if (!type || !(0, _typeDefinition.isInputType)(type)) {\n\t    throw new _error.GraphQLError('Variable \"$' + variable.name.value + '\" expected value of type ' + ('\"' + (0, _languagePrinter.print)(definitionAST.type) + '\" which cannot be used as an input type.'), [definitionAST]);\n\t  }\n\t  var inputType = type;\n\t  var errors = (0, _utilitiesIsValidJSValue.isValidJSValue)(input, inputType);\n\t  if (!errors.length) {\n\t    if ((0, _jsutilsIsNullish2['default'])(input)) {\n\t      var defaultValue = definitionAST.defaultValue;\n\t      if (defaultValue) {\n\t        return (0, _utilitiesValueFromAST.valueFromAST)(defaultValue, inputType);\n\t      }\n\t    }\n\t    return coerceValue(inputType, input);\n\t  }\n\t  if ((0, _jsutilsIsNullish2['default'])(input)) {\n\t    throw new _error.GraphQLError('Variable \"$' + variable.name.value + '\" of required type ' + ('\"' + (0, _languagePrinter.print)(definitionAST.type) + '\" was not provided.'), [definitionAST]);\n\t  }\n\t  var message = errors ? '\\n' + errors.join('\\n') : '';\n\t  throw new _error.GraphQLError('Variable \"$' + variable.name.value + '\" got invalid value ' + (JSON.stringify(input) + '.' + message), [definitionAST]);\n\t}\n\t\n\t/**\n\t * Given a type and any value, return a runtime value coerced to match the type.\n\t */\n\tfunction coerceValue(_x, _x2) {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    var type = _x,\n\t        value = _x2;\n\t    nullableType = itemType = fields = parsed = undefined;\n\t    _again = false;\n\t\n\t    if (type instanceof _typeDefinition.GraphQLNonNull) {\n\t      // Note: we're not checking that the result of coerceValue is non-null.\n\t\n\t      var nullableType = type.ofType;\n\t      _x = nullableType;\n\t      _x2 = value;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    if ((0, _jsutilsIsNullish2['default'])(value)) {\n\t      return null;\n\t    }\n\t\n\t    if (type instanceof _typeDefinition.GraphQLList) {\n\t      var itemType = type.ofType;\n\t      // TODO: support iterable input\n\t      if (Array.isArray(value)) {\n\t        return value.map(function (item) {\n\t          return coerceValue(itemType, item);\n\t        });\n\t      }\n\t      return [coerceValue(itemType, value)];\n\t    }\n\t\n\t    if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n\t      var fields = type.getFields();\n\t      return Object.keys(fields).reduce(function (obj, fieldName) {\n\t        var field = fields[fieldName];\n\t        var fieldValue = coerceValue(field.type, value[fieldName]);\n\t        if ((0, _jsutilsIsNullish2['default'])(fieldValue)) {\n\t          fieldValue = field.defaultValue;\n\t        }\n\t        if (!(0, _jsutilsIsNullish2['default'])(fieldValue)) {\n\t          obj[fieldName] = fieldValue;\n\t        }\n\t        return obj;\n\t      }, {});\n\t    }\n\t\n\t    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLScalarType || type instanceof _typeDefinition.GraphQLEnumType, 'Must be input type');\n\t\n\t    var parsed = type.parseValue(value);\n\t    if (!(0, _jsutilsIsNullish2['default'])(parsed)) {\n\t      return parsed;\n\t    }\n\t  }\n\t}\n\t// We only call this function after calling isValidJSValue.\n\n/***/ },\n/* 408 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Produces a JavaScript value given a GraphQL Value AST.\n\t *\n\t * A GraphQL type must be provided, which will be used to interpret different\n\t * GraphQL Value literals.\n\t *\n\t * | GraphQL Value        | JSON Value    |\n\t * | -------------------- | ------------- |\n\t * | Input Object         | Object        |\n\t * | List                 | Array         |\n\t * | Boolean              | Boolean       |\n\t * | String / Enum Value  | String        |\n\t * | Int / Float          | Number        |\n\t *\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.valueFromAST = valueFromAST;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _jsutilsKeyMap = __webpack_require__(372);\n\t\n\tvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tvar Kind = _interopRequireWildcard(_languageKinds);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tfunction valueFromAST(_x, _x2, _x3) {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    var valueAST = _x,\n\t        type = _x2,\n\t        variables = _x3;\n\t    nullableType = variableName = itemType = fields = fieldASTs = parsed = undefined;\n\t    _again = false;\n\t\n\t    if (type instanceof _typeDefinition.GraphQLNonNull) {\n\t      var nullableType = type.ofType;\n\t      // Note: we're not checking that the result of valueFromAST is non-null.\n\t      // We're assuming that this query has been validated and the value used\n\t      // here is of the correct type.\n\t      _x = valueAST;\n\t      _x2 = nullableType;\n\t      _x3 = variables;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    if (!valueAST) {\n\t      return null;\n\t    }\n\t\n\t    if (valueAST.kind === Kind.VARIABLE) {\n\t      var variableName = valueAST.name.value;\n\t      if (!variables || !variables.hasOwnProperty(variableName)) {\n\t        return null;\n\t      }\n\t      // Note: we're not doing any checking that this variable is correct. We're\n\t      // assuming that this query has been validated and the variable usage here\n\t      // is of the correct type.\n\t      return variables[variableName];\n\t    }\n\t\n\t    if (type instanceof _typeDefinition.GraphQLList) {\n\t      var itemType = type.ofType;\n\t      if (valueAST.kind === Kind.LIST) {\n\t        return valueAST.values.map(function (itemAST) {\n\t          return valueFromAST(itemAST, itemType, variables);\n\t        });\n\t      }\n\t      return [valueFromAST(valueAST, itemType, variables)];\n\t    }\n\t\n\t    if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n\t      var fields = type.getFields();\n\t      if (valueAST.kind !== Kind.OBJECT) {\n\t        return null;\n\t      }\n\t      var fieldASTs = (0, _jsutilsKeyMap2['default'])(valueAST.fields, function (field) {\n\t        return field.name.value;\n\t      });\n\t      return Object.keys(fields).reduce(function (obj, fieldName) {\n\t        var field = fields[fieldName];\n\t        var fieldAST = fieldASTs[fieldName];\n\t        var fieldValue = valueFromAST(fieldAST && fieldAST.value, field.type, variables);\n\t        if ((0, _jsutilsIsNullish2['default'])(fieldValue)) {\n\t          fieldValue = field.defaultValue;\n\t        }\n\t        if (!(0, _jsutilsIsNullish2['default'])(fieldValue)) {\n\t          obj[fieldName] = fieldValue;\n\t        }\n\t        return obj;\n\t      }, {});\n\t    }\n\t\n\t    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLScalarType || type instanceof _typeDefinition.GraphQLEnumType, 'Must be input type');\n\t\n\t    var parsed = type.parseLiteral(valueAST);\n\t    if (!(0, _jsutilsIsNullish2['default'])(parsed)) {\n\t      return parsed;\n\t    }\n\t  }\n\t}\n\n/***/ },\n/* 409 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Given a JavaScript value and a GraphQL type, determine if the value will be\n\t * accepted for that type. This is primarily useful for validating the\n\t * runtime values of query variables.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.isValidJSValue = isValidJSValue;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tfunction isValidJSValue(_x, _x2) {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    var value = _x,\n\t        type = _x2;\n\t    ofType = itemType = fields = errors = _iteratorNormalCompletion = _didIteratorError = _iteratorError = _iteratorNormalCompletion2 = _didIteratorError2 = _iteratorError2 = parseResult = undefined;\n\t    _again = false;\n\t\n\t    // A value must be provided if the type is non-null.\n\t    if (type instanceof _typeDefinition.GraphQLNonNull) {\n\t      var ofType = type.ofType;\n\t      if ((0, _jsutilsIsNullish2['default'])(value)) {\n\t        if (ofType.name) {\n\t          return ['Expected \"' + ofType.name + '!\", found null.'];\n\t        }\n\t        return ['Expected non-null value, found null.'];\n\t      }\n\t      _x = value;\n\t      _x2 = ofType;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    if ((0, _jsutilsIsNullish2['default'])(value)) {\n\t      return [];\n\t    }\n\t\n\t    // Lists accept a non-list value as a list of one.\n\t    if (type instanceof _typeDefinition.GraphQLList) {\n\t      var itemType = type.ofType;\n\t      if (Array.isArray(value)) {\n\t        return value.reduce(function (acc, item, index) {\n\t          var errors = isValidJSValue(item, itemType);\n\t          return acc.concat(errors.map(function (error) {\n\t            return 'In element #' + index + ': ' + error;\n\t          }));\n\t        }, []);\n\t      }\n\t      _x = value;\n\t      _x2 = itemType;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t\n\t    // Input objects check each defined field.\n\t    if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n\t      if (typeof value !== 'object') {\n\t        return ['Expected \"' + type.name + '\", found not an object.'];\n\t      }\n\t      var fields = type.getFields();\n\t\n\t      var errors = [];\n\t\n\t      // Ensure every provided field is defined.\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = Object.keys(value)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var providedField = _step.value;\n\t\n\t          if (!fields[providedField]) {\n\t            errors.push('In field \"${providedField}\": Unknown field.');\n\t          }\n\t        }\n\t\n\t        // Ensure every defined field is valid.\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator['return']) {\n\t            _iterator['return']();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = Object.keys(fields)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var fieldName = _step2.value;\n\t\n\t          var newErrors = isValidJSValue(value[fieldName], fields[fieldName].type);\n\t          errors.push.apply(errors, _toConsumableArray(newErrors.map(function (error) {\n\t            return 'In field \"' + fieldName + '\": ' + error;\n\t          })));\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n\t            _iterator2['return']();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return errors;\n\t    }\n\t\n\t    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLScalarType || type instanceof _typeDefinition.GraphQLEnumType, 'Must be input type');\n\t\n\t    // Scalar/Enum input checks to ensure the type can parse the value to\n\t    // a non-null value.\n\t    var parseResult = type.parseValue(value);\n\t    if ((0, _jsutilsIsNullish2['default'])(parseResult)) {\n\t      return ['Expected type \"' + type.name + '\", found ' + JSON.stringify(value) + '.'];\n\t    }\n\t\n\t    return [];\n\t  }\n\t}\n\n/***/ },\n/* 410 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t// The primary React component to use.\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(411).GraphiQL;\n\n/***/ },\n/* 411 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _reactDom = __webpack_require__(155);\n\t\n\tvar _reactDom2 = _interopRequireDefault(_reactDom);\n\t\n\tvar _graphqlType = __webpack_require__(412);\n\t\n\tvar _graphqlUtilities = __webpack_require__(413);\n\t\n\tvar _graphqlJsutilsFind = __webpack_require__(377);\n\t\n\tvar _graphqlJsutilsFind2 = _interopRequireDefault(_graphqlJsutilsFind);\n\t\n\tvar _ExecuteButton = __webpack_require__(422);\n\t\n\tvar _QueryEditor = __webpack_require__(423);\n\t\n\tvar _VariableEditor = __webpack_require__(439);\n\t\n\tvar _ResultViewer = __webpack_require__(443);\n\t\n\tvar _DocExplorer = __webpack_require__(444);\n\t\n\tvar _utilityFillLeafs = __webpack_require__(445);\n\t\n\tvar _utilityElementPosition = __webpack_require__(446);\n\t\n\tvar _utilityIntrospectionQueries = __webpack_require__(447);\n\t\n\t/**\n\t * GraphiQL\n\t *\n\t * This React component is responsible for rendering the GraphiQL editor.\n\t *\n\t * Props:\n\t *\n\t *   - fetcher: a function which accepts GraphQL-HTTP parameters and returns\n\t *     a Promise which resolves to the GraphQL parsed JSON response.\n\t *\n\t *   - schema: an optional GraphQLSchema instance. If one is not provided,\n\t *     GraphiQL will fetch one using introspection.\n\t *\n\t *   - query: an optional GraphQL string to use as the initial displayed query,\n\t *     if not provided, the stored query or defaultQuery will be used.\n\t *\n\t *   - response: an optional JSON string to use as the initial displayed\n\t *     response. If not provided, no response will be initialy shown. You might\n\t *     provide this if illustrating the result of the initial query.\n\t *\n\t *   - storage: an instance of [Storage][] GraphiQL will use to persist state.\n\t *     Only `getItem` and `setItem` are called. Default: window.localStorage\n\t *\n\t *   - defaultQuery: an optional GraphQL string to use instead of a\n\t *     blank screen when a query was not found in the local cache.\n\t *\n\t *   - variables: an optional GraphQL string to use as the initial displayed\n\t *     query variables, if not provided, the stored variables will be used.\n\t *\n\t *   - onEditQuery: an optional function which will be called when the Query\n\t *     editor changes. The argument to the function will be the query string.\n\t *\n\t *   - onEditVariables: an optional function which will be called when the Query\n\t *     varible editor changes. The argument to the function will be the\n\t *     variables string.\n\t *\n\t *   - getDefaultFieldNames: an optional function used to provide default fields\n\t *     to non-leaf fields which invalidly lack a selection set.\n\t *     Accepts a GraphQLType instance and returns an array of field names.\n\t *     If not provided, a default behavior will be used.\n\t *\n\t * Children:\n\t *\n\t *   - <GraphiQL.Logo> Replace the GraphiQL logo with your own.\n\t *\n\t *   - <GraphiQL.Toolbar> Add a custom toolbar above GraphiQL.\n\t *\n\t *   - <GraphiQL.Footer> Add a custom footer below GraphiQL Results.\n\t *\n\t *\n\t * [Storage]: https://developer.mozilla.org/en-US/docs/Web/API/Storage\n\t */\n\t\n\tvar GraphiQL = (function (_React$Component) {\n\t  _inherits(GraphiQL, _React$Component);\n\t\n\t  /**\n\t   * Inspect the query, automatically filling in selection sets for non-leaf\n\t   * fields which do not yet have them.\n\t   *\n\t   * @public\n\t   */\n\t\n\t  GraphiQL.prototype.autoCompleteLeafs = function autoCompleteLeafs() {\n\t    var _fillLeafs = _utilityFillLeafs.fillLeafs(this.state.schema, this.state.query, this.props.getDefaultFieldNames);\n\t\n\t    var insertions = _fillLeafs.insertions;\n\t    var result = _fillLeafs.result;\n\t\n\t    if (insertions && insertions.length > 0) {\n\t      var editor = this.refs.queryEditor.getCodeMirror();\n\t      editor.operation(function () {\n\t        var cursor = editor.getCursor();\n\t        var cursorIndex = editor.indexFromPos(cursor);\n\t        editor.setValue(result);\n\t        var added = 0;\n\t        var markers = insertions.map(function (_ref) {\n\t          var index = _ref.index;\n\t          var string = _ref.string;\n\t          return editor.markText(editor.posFromIndex(index + added), editor.posFromIndex(index + (added += string.length)), {\n\t            className: 'autoInsertedLeaf',\n\t            clearOnEnter: true,\n\t            title: 'Automatically added leaf fields'\n\t          });\n\t        });\n\t        setTimeout(function () {\n\t          return markers.forEach(function (marker) {\n\t            return marker.clear();\n\t          });\n\t        }, 7000);\n\t        var newCursorIndex = cursorIndex;\n\t        insertions.forEach(function (_ref2) {\n\t          var index = _ref2.index;\n\t          var string = _ref2.string;\n\t\n\t          if (index < cursorIndex) {\n\t            newCursorIndex += string.length;\n\t          }\n\t        });\n\t        var newCursor = editor.posFromIndex(newCursorIndex);\n\t        editor.setCursor(newCursor);\n\t      });\n\t    }\n\t\n\t    return result;\n\t  };\n\t\n\t  // Lifecycle\n\t\n\t  _createClass(GraphiQL, null, [{\n\t    key: 'propTypes',\n\t    value: {\n\t      fetcher: _react.PropTypes.func.isRequired,\n\t      schema: _react.PropTypes.instanceOf(_graphqlType.GraphQLSchema),\n\t      query: _react.PropTypes.string,\n\t      response: _react.PropTypes.string,\n\t      storage: _react.PropTypes.shape({\n\t        getItem: _react.PropTypes.func,\n\t        setItem: _react.PropTypes.func\n\t      }),\n\t      defaultQuery: _react.PropTypes.string,\n\t      variables: _react.PropTypes.string,\n\t      onEditQuery: _react.PropTypes.func,\n\t      onEditVariables: _react.PropTypes.func,\n\t      getDefaultFieldNames: _react.PropTypes.func\n\t    },\n\t    enumerable: true\n\t  }]);\n\t\n\t  function GraphiQL(props) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, GraphiQL);\n\t\n\t    _React$Component.call(this);\n\t\n\t    // Ensure props are correct\n\t\n\t    this._runEditorQuery = function () {\n\t      _this._editorQueryID++;\n\t      var queryID = _this._editorQueryID;\n\t\n\t      // Use the edited query after autoCompleteLeafs() runs or,\n\t      // in case autoCompletion fails (the function returns undefined),\n\t      // the current query from the editor.\n\t      var editedQuery = _this.autoCompleteLeafs() || _this.state.query;\n\t\n\t      _this._fetchQuery(editedQuery, _this.state.variables, function (result) {\n\t        if (queryID === _this._editorQueryID) {\n\t          _this.setState({ response: JSON.stringify(result, null, 2) });\n\t        }\n\t      });\n\t    };\n\t\n\t    this._onEditQuery = function (value) {\n\t      _this._storageSet('query', value);\n\t      _this.setState({ query: value });\n\t      if (_this.props.onEditQuery) {\n\t        return _this.props.onEditQuery(value);\n\t      }\n\t    };\n\t\n\t    this._onEditVariables = function (value) {\n\t      _this._storageSet('variables', value);\n\t      _this.setState({ variables: value });\n\t      if (_this.props.onEditVariables) {\n\t        _this.props.onEditVariables(value);\n\t      }\n\t    };\n\t\n\t    this._onHintInformationRender = function (elem) {\n\t      elem.addEventListener('click', _this._onClickHintInformation);\n\t\n\t      var onRemoveFn;\n\t      elem.addEventListener('DOMNodeRemoved', onRemoveFn = function () {\n\t        elem.removeEventListener('DOMNodeRemoved', onRemoveFn);\n\t        elem.removeEventListener('click', _this._onClickHintInformation);\n\t      });\n\t    };\n\t\n\t    this._onClickHintInformation = function (event) {\n\t      if (event.target.className === 'typeName') {\n\t        var typeName = event.target.innerHTML;\n\t        var schema = _this.state.schema;\n\t        if (schema) {\n\t          var type = schema.getType(typeName);\n\t          if (type) {\n\t            _this.setState({ docsOpen: true }, function () {\n\t              _this.refs.docExplorer.showDoc(type);\n\t            });\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    this._onToggleDocs = function () {\n\t      _this.setState({ docsOpen: !_this.state.docsOpen });\n\t    };\n\t\n\t    this._onResizeStart = function (downEvent) {\n\t      if (!_this._didClickDragBar(downEvent)) {\n\t        return;\n\t      }\n\t\n\t      downEvent.preventDefault();\n\t\n\t      var offset = downEvent.clientX - _utilityElementPosition.getLeft(downEvent.target);\n\t\n\t      var onMouseMove = function onMouseMove(moveEvent) {\n\t        if (moveEvent.buttons === 0) {\n\t          return onMouseUp();\n\t        }\n\t\n\t        var editorBar = _reactDom2['default'].findDOMNode(_this.refs.editorBar);\n\t        var leftSize = moveEvent.clientX - _utilityElementPosition.getLeft(editorBar) - offset;\n\t        var rightSize = editorBar.clientWidth - leftSize;\n\t        _this.setState({ editorFlex: leftSize / rightSize });\n\t      };\n\t\n\t      var onMouseUp = (function (_onMouseUp) {\n\t        function onMouseUp() {\n\t          return _onMouseUp.apply(this, arguments);\n\t        }\n\t\n\t        onMouseUp.toString = function () {\n\t          return _onMouseUp.toString();\n\t        };\n\t\n\t        return onMouseUp;\n\t      })(function () {\n\t        _this._storageSet('editorFlex', _this.state.editorFlex);\n\t\n\t        document.removeEventListener('mousemove', onMouseMove);\n\t        document.removeEventListener('mouseup', onMouseUp);\n\t        onMouseMove = null;\n\t        onMouseUp = null;\n\t      });\n\t\n\t      document.addEventListener('mousemove', onMouseMove);\n\t      document.addEventListener('mouseup', onMouseUp);\n\t    };\n\t\n\t    this._onDocsResizeStart = function (downEvent) {\n\t      downEvent.preventDefault();\n\t\n\t      var hadWidth = _this.state.docsWidth;\n\t      var offset = downEvent.clientX - _utilityElementPosition.getLeft(downEvent.target);\n\t\n\t      var onMouseMove = function onMouseMove(moveEvent) {\n\t        if (moveEvent.buttons === 0) {\n\t          return onMouseUp();\n\t        }\n\t\n\t        var app = _reactDom2['default'].findDOMNode(_this);\n\t        var cursorPos = moveEvent.clientX - _utilityElementPosition.getLeft(app) - offset;\n\t        var docsSize = app.clientWidth - cursorPos;\n\t\n\t        if (docsSize < 100) {\n\t          _this.setState({ docsOpen: false });\n\t        } else {\n\t          _this.setState({\n\t            docsOpen: true,\n\t            docsWidth: Math.min(docsSize, 650)\n\t          });\n\t        }\n\t      };\n\t\n\t      var onMouseUp = (function (_onMouseUp2) {\n\t        function onMouseUp() {\n\t          return _onMouseUp2.apply(this, arguments);\n\t        }\n\t\n\t        onMouseUp.toString = function () {\n\t          return _onMouseUp2.toString();\n\t        };\n\t\n\t        return onMouseUp;\n\t      })(function () {\n\t        if (_this.state.docsOpen) {\n\t          _this._storageSet('docExplorerWidth', _this.state.docsWidth);\n\t        } else {\n\t          _this.setState({ docsWidth: hadWidth });\n\t        }\n\t\n\t        document.removeEventListener('mousemove', onMouseMove);\n\t        document.removeEventListener('mouseup', onMouseUp);\n\t        onMouseMove = null;\n\t        onMouseUp = null;\n\t      });\n\t\n\t      document.addEventListener('mousemove', onMouseMove);\n\t      document.addEventListener('mouseup', onMouseUp);\n\t    };\n\t\n\t    this._onVariableResizeStart = function (downEvent) {\n\t      downEvent.preventDefault();\n\t\n\t      var didMove = false;\n\t      var wasOpen = _this.state.variableEditorOpen;\n\t      var hadHeight = _this.state.variableEditorHeight;\n\t      var offset = downEvent.clientY - _utilityElementPosition.getTop(downEvent.target);\n\t\n\t      var onMouseMove = function onMouseMove(moveEvent) {\n\t        if (moveEvent.buttons === 0) {\n\t          return onMouseUp();\n\t        }\n\t\n\t        didMove = true;\n\t\n\t        var editorBar = _reactDom2['default'].findDOMNode(_this.refs.editorBar);\n\t        var topSize = moveEvent.clientY - _utilityElementPosition.getTop(editorBar) - offset;\n\t        var bottomSize = editorBar.clientHeight - topSize;\n\t        if (bottomSize < 60) {\n\t          _this.setState({\n\t            variableEditorOpen: false,\n\t            variableEditorHeight: hadHeight\n\t          });\n\t        } else {\n\t          _this.setState({\n\t            variableEditorOpen: true,\n\t            variableEditorHeight: bottomSize\n\t          });\n\t        }\n\t      };\n\t\n\t      var onMouseUp = (function (_onMouseUp3) {\n\t        function onMouseUp() {\n\t          return _onMouseUp3.apply(this, arguments);\n\t        }\n\t\n\t        onMouseUp.toString = function () {\n\t          return _onMouseUp3.toString();\n\t        };\n\t\n\t        return onMouseUp;\n\t      })(function () {\n\t        if (didMove) {\n\t          _this._storageSet('variableEditorHeight', _this.state.variableEditorHeight);\n\t        } else {\n\t          _this.setState({ variableEditorOpen: !wasOpen });\n\t        }\n\t\n\t        document.removeEventListener('mousemove', onMouseMove);\n\t        document.removeEventListener('mouseup', onMouseUp);\n\t        onMouseMove = null;\n\t        onMouseUp = null;\n\t      });\n\t\n\t      document.addEventListener('mousemove', onMouseMove);\n\t      document.addEventListener('mouseup', onMouseUp);\n\t    };\n\t\n\t    if (typeof props.fetcher !== 'function') {\n\t      throw new TypeError('GraphiQL requires a fetcher function.');\n\t    }\n\t\n\t    // Cache the storage instance\n\t    this._storage = props.storage || window.localStorage;\n\t\n\t    // Determine the initial query to display.\n\t    var query = props.query || this._storageGet('query') || props.defaultQuery || defaultQuery;\n\t\n\t    // Determine the initial variables to display.\n\t    var variables = props.variables || this._storageGet('variables');\n\t\n\t    // Initialize state\n\t    this.state = {\n\t      schema: props.schema,\n\t      query: query,\n\t      variables: variables,\n\t      response: props.response,\n\t      editorFlex: this._storageGet('editorFlex') || 1,\n\t      variableEditorOpen: Boolean(variables),\n\t      variableEditorHeight: this._storageGet('variableEditorHeight') || 200,\n\t      docsOpen: false,\n\t      docsWidth: this._storageGet('docExplorerWidth') || 350\n\t    };\n\t\n\t    // Ensure only the last executed editor query is rendered.\n\t    this._editorQueryID = 0;\n\t  }\n\t\n\t  // Configure the UI by providing this Component as a child of GraphiQL.\n\t\n\t  GraphiQL.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n\t    var nextQuery = this.state.query;\n\t    var nextVariables = this.state.variables;\n\t    var nextResponse = this.state.response;\n\t    if (nextProps.query && nextProps.query !== nextQuery) {\n\t      nextQuery = nextProps.query;\n\t    }\n\t    if (nextProps.variables && nextProps.variables !== nextVariables) {\n\t      nextVariables = nextProps.variables;\n\t    }\n\t    if (nextProps.response && nextProps.response !== nextResponse) {\n\t      nextResponse = nextProps.response;\n\t    }\n\t    this.setState({\n\t      query: nextQuery,\n\t      variables: nextVariables,\n\t      response: nextResponse\n\t    });\n\t  };\n\t\n\t  GraphiQL.prototype.componentDidMount = function componentDidMount() {\n\t    var _this2 = this;\n\t\n\t    if (!this.state.schema) {\n\t      var fetcher = this.props.fetcher;\n\t\n\t      // Try the stock introspection query first, falling back on the\n\t      // sans-subscriptions query for services which do not yet support it.\n\t      fetcher({ query: _utilityIntrospectionQueries.introspectionQuery })['catch'](function () {\n\t        return fetcher({ query: _utilityIntrospectionQueries.introspectionQuerySansSubscriptions });\n\t      }).then(function (result) {\n\t        if (!result.data) {\n\t          _this2.setState({ response: JSON.stringify(result, null, 2) });\n\t        } else {\n\t          _this2.setState({ schema: _graphqlUtilities.buildClientSchema(result.data) });\n\t        }\n\t      })['catch'](function (error) {\n\t        _this2.setState({ response: error && error.stack || error });\n\t      });\n\t    }\n\t  };\n\t\n\t  GraphiQL.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n\t    // When UI-altering state changes, simulate a window resize event so all\n\t    // CodeMirror instances become properly rendered.\n\t    if (this.state.variableEditorOpen !== prevState.variableEditorOpen || this.state.variableEditorHeight !== prevState.variableEditorHeight) {\n\t      window.dispatchEvent(new Event('resize'));\n\t    }\n\t  };\n\t\n\t  GraphiQL.prototype.render = function render() {\n\t    var children = [];\n\t    _react2['default'].Children.forEach(this.props.children, function (child) {\n\t      children.push(child);\n\t    });\n\t\n\t    var logo = _graphqlJsutilsFind2['default'](children, function (child) {\n\t      return child.type === GraphiQL.Logo;\n\t    }) || _react2['default'].createElement(GraphiQL.Logo, null);\n\t\n\t    var toolbar = _graphqlJsutilsFind2['default'](children, function (child) {\n\t      return child.type === GraphiQL.Toolbar;\n\t    });\n\t    var footer = _graphqlJsutilsFind2['default'](children, function (child) {\n\t      return child.type === GraphiQL.Footer;\n\t    });\n\t\n\t    var queryWrapStyle = {\n\t      WebkitFlex: this.state.editorFlex,\n\t      flex: this.state.editorFlex\n\t    };\n\t\n\t    var docWrapStyle = {\n\t      display: this.state.docsOpen ? 'block' : 'none',\n\t      width: this.state.docsWidth\n\t    };\n\t\n\t    var variableOpen = this.state.variableEditorOpen;\n\t    var variableStyle = {\n\t      height: variableOpen ? this.state.variableEditorHeight : null\n\t    };\n\t\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      { id: 'graphiql-container' },\n\t      _react2['default'].createElement(\n\t        'div',\n\t        { className: 'editorWrap' },\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'topBarWrap' },\n\t          _react2['default'].createElement(\n\t            'div',\n\t            { className: 'topBar' },\n\t            logo,\n\t            _react2['default'].createElement(_ExecuteButton.ExecuteButton, { onClick: this._runEditorQuery }),\n\t            toolbar\n\t          ),\n\t          !this.state.docsOpen && _react2['default'].createElement(\n\t            'button',\n\t            { className: 'docExplorerShow', onClick: this._onToggleDocs },\n\t            'Docs'\n\t          )\n\t        ),\n\t        _react2['default'].createElement(\n\t          'div',\n\t          {\n\t            ref: 'editorBar',\n\t            className: 'editorBar',\n\t            onMouseDown: this._onResizeStart\n\t          },\n\t          _react2['default'].createElement(\n\t            'div',\n\t            { className: 'queryWrap', style: queryWrapStyle },\n\t            _react2['default'].createElement(_QueryEditor.QueryEditor, {\n\t              ref: 'queryEditor',\n\t              schema: this.state.schema,\n\t              value: this.state.query,\n\t              onEdit: this._onEditQuery,\n\t              onHintInformationRender: this._onHintInformationRender\n\t            }),\n\t            _react2['default'].createElement(\n\t              'div',\n\t              { className: 'variable-editor', style: variableStyle },\n\t              _react2['default'].createElement(\n\t                'div',\n\t                {\n\t                  className: 'variable-editor-title',\n\t                  style: { cursor: variableOpen ? 'row-resize' : 'n-resize' },\n\t                  onMouseDown: this._onVariableResizeStart\n\t                },\n\t                'Query Variables'\n\t              ),\n\t              _react2['default'].createElement(_VariableEditor.VariableEditor, {\n\t                value: this.state.variables,\n\t                onEdit: this._onEditVariables\n\t              })\n\t            )\n\t          ),\n\t          _react2['default'].createElement(\n\t            'div',\n\t            { className: 'resultWrap' },\n\t            _react2['default'].createElement(_ResultViewer.ResultViewer, { ref: 'result', value: this.state.response }),\n\t            footer\n\t          )\n\t        )\n\t      ),\n\t      _react2['default'].createElement(\n\t        'div',\n\t        { className: 'docExplorerWrap', style: docWrapStyle },\n\t        _react2['default'].createElement('div', {\n\t          className: 'docExplorerResizer',\n\t          onMouseDown: this._onDocsResizeStart\n\t        }),\n\t        _react2['default'].createElement(\n\t          _DocExplorer.DocExplorer,\n\t          { ref: 'docExplorer', schema: this.state.schema },\n\t          _react2['default'].createElement(\n\t            'div',\n\t            { className: 'docExplorerHide', onClick: this._onToggleDocs },\n\t            '✕'\n\t          )\n\t        )\n\t      )\n\t    );\n\t  };\n\t\n\t  // Private methods\n\t\n\t  GraphiQL.prototype._storageGet = function _storageGet(name) {\n\t    return this._storage.getItem('graphiql:' + name);\n\t  };\n\t\n\t  GraphiQL.prototype._storageSet = function _storageSet(name, value) {\n\t    this._storage.setItem('graphiql:' + name, value);\n\t  };\n\t\n\t  GraphiQL.prototype._fetchQuery = function _fetchQuery(query, variables, cb) {\n\t    var _this3 = this;\n\t\n\t    this.props.fetcher({ query: query, variables: variables }).then(cb)['catch'](function (error) {\n\t      _this3.setState({ response: error && error.stack || error });\n\t    });\n\t  };\n\t\n\t  GraphiQL.prototype._didClickDragBar = function _didClickDragBar(event) {\n\t    // Only for primary unmodified clicks\n\t    if (event.button !== 0 || event.ctrlKey) {\n\t      return false;\n\t    }\n\t    var target = event.target;\n\t    // We use codemirror's gutter as the drag bar.\n\t    if (target.className.indexOf('CodeMirror-gutter') !== 0) {\n\t      return false;\n\t    }\n\t    // Specifically the result window's drag bar.\n\t    var resultWindow = _reactDom2['default'].findDOMNode(this.refs.result);\n\t    while (target) {\n\t      if (target === resultWindow) {\n\t        return true;\n\t      }\n\t      target = target.parentNode;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  return GraphiQL;\n\t})(_react2['default'].Component);\n\t\n\texports.GraphiQL = GraphiQL;\n\tGraphiQL.Logo = (function (_React$Component2) {\n\t  _inherits(GraphiQLLogo, _React$Component2);\n\t\n\t  function GraphiQLLogo() {\n\t    _classCallCheck(this, GraphiQLLogo);\n\t\n\t    _React$Component2.apply(this, arguments);\n\t  }\n\t\n\t  GraphiQLLogo.prototype.render = function render() {\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      { className: 'title' },\n\t      this.props.children || _react2['default'].createElement(\n\t        'span',\n\t        null,\n\t        'Graph',\n\t        _react2['default'].createElement(\n\t          'em',\n\t          null,\n\t          'i'\n\t        ),\n\t        'QL'\n\t      )\n\t    );\n\t  };\n\t\n\t  return GraphiQLLogo;\n\t})(_react2['default'].Component);\n\t\n\t// Configure the UI by providing this Component as a child of GraphiQL.\n\tGraphiQL.Toolbar = (function (_React$Component3) {\n\t  _inherits(GraphiQLToolbar, _React$Component3);\n\t\n\t  function GraphiQLToolbar() {\n\t    _classCallCheck(this, GraphiQLToolbar);\n\t\n\t    _React$Component3.apply(this, arguments);\n\t  }\n\t\n\t  GraphiQLToolbar.prototype.render = function render() {\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      { className: 'toolbar' },\n\t      this.props.children\n\t    );\n\t  };\n\t\n\t  return GraphiQLToolbar;\n\t})(_react2['default'].Component);\n\t\n\t// Configure the UI by providing this Component as a child of GraphiQL.\n\tGraphiQL.Footer = (function (_React$Component4) {\n\t  _inherits(GraphiQLFooter, _React$Component4);\n\t\n\t  function GraphiQLFooter() {\n\t    _classCallCheck(this, GraphiQLFooter);\n\t\n\t    _React$Component4.apply(this, arguments);\n\t  }\n\t\n\t  GraphiQLFooter.prototype.render = function render() {\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      { className: 'footer' },\n\t      this.props.children\n\t    );\n\t  };\n\t\n\t  return GraphiQLFooter;\n\t})(_react2['default'].Component);\n\t\n\tvar defaultQuery = '# Welcome to GraphiQL\\n#\\n# GraphiQL is an in-browser IDE for writing, validating, and\\n# testing GraphQL queries.\\n#\\n# Type queries into this side of the screen, and you will\\n# see intelligent typeaheads aware of the current GraphQL type schema and\\n# live syntax and validation errors highlighted within the text.\\n#\\n# To bring up the auto-complete at any point, just press Ctrl-Space.\\n#\\n# Press the run button above, or Cmd-Enter to execute the query, and the result\\n# will appear in the pane to the right.\\n\\n';\n\n/***/ },\n/* 412 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t// GraphQL Schema definition\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _schema = __webpack_require__(369);\n\t\n\tObject.defineProperty(exports, 'GraphQLSchema', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _schema.GraphQLSchema;\n\t  }\n\t});\n\t\n\tvar _definition = __webpack_require__(370);\n\t\n\tObject.defineProperty(exports, 'isType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.isType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'isInputType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.isInputType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'isOutputType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.isOutputType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'isLeafType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.isLeafType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'isCompositeType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.isCompositeType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'isAbstractType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.isAbstractType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'getNullableType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.getNullableType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'getNamedType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.getNamedType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLScalarType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.GraphQLScalarType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLObjectType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.GraphQLObjectType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLInterfaceType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.GraphQLInterfaceType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLUnionType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.GraphQLUnionType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLEnumType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.GraphQLEnumType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLInputObjectType', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.GraphQLInputObjectType;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLList', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.GraphQLList;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLNonNull', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _definition.GraphQLNonNull;\n\t  }\n\t});\n\t\n\t// Common built-in scalar instances.\n\t\n\tvar _scalars = __webpack_require__(374);\n\t\n\tObject.defineProperty(exports, 'GraphQLInt', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _scalars.GraphQLInt;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLFloat', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _scalars.GraphQLFloat;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLString', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _scalars.GraphQLString;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLBoolean', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _scalars.GraphQLBoolean;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'GraphQLID', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _scalars.GraphQLID;\n\t  }\n\t});\n\t\n\t// Predicates\n\t\n\t// Un-modifiers\n\t\n\t// Definitions\n\n/***/ },\n/* 413 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t// The GraphQL query recommended for a full schema introspection.\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _introspectionQuery = __webpack_require__(414);\n\t\n\tObject.defineProperty(exports, 'introspectionQuery', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _introspectionQuery.introspectionQuery;\n\t  }\n\t});\n\t\n\t// Gets the target Operation from a Document\n\t\n\tvar _getOperationAST = __webpack_require__(415);\n\t\n\tObject.defineProperty(exports, 'getOperationAST', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _getOperationAST.getOperationAST;\n\t  }\n\t});\n\t\n\t// Build a GraphQLSchema from an introspection result.\n\t\n\tvar _buildClientSchema = __webpack_require__(416);\n\t\n\tObject.defineProperty(exports, 'buildClientSchema', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _buildClientSchema.buildClientSchema;\n\t  }\n\t});\n\t\n\t// Build a GraphQLSchema from a parsed GraphQL Schema language AST.\n\t\n\tvar _buildASTSchema = __webpack_require__(418);\n\t\n\tObject.defineProperty(exports, 'buildASTSchema', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _buildASTSchema.buildASTSchema;\n\t  }\n\t});\n\t\n\t// Extends an existing GraphQLSchema from a parsed GraphQL Schema language AST.\n\t\n\tvar _extendSchema = __webpack_require__(419);\n\t\n\tObject.defineProperty(exports, 'extendSchema', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _extendSchema.extendSchema;\n\t  }\n\t});\n\t\n\t// Print a GraphQLSchema to GraphQL Schema language.\n\t\n\tvar _schemaPrinter = __webpack_require__(420);\n\t\n\tObject.defineProperty(exports, 'printSchema', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _schemaPrinter.printSchema;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'printIntrospectionSchema', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _schemaPrinter.printIntrospectionSchema;\n\t  }\n\t});\n\t\n\t// Create a GraphQLType from a GraphQL language AST.\n\t\n\tvar _typeFromAST = __webpack_require__(380);\n\t\n\tObject.defineProperty(exports, 'typeFromAST', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _typeFromAST.typeFromAST;\n\t  }\n\t});\n\t\n\t// Create a JavaScript value from a GraphQL language AST.\n\t\n\tvar _valueFromAST = __webpack_require__(408);\n\t\n\tObject.defineProperty(exports, 'valueFromAST', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _valueFromAST.valueFromAST;\n\t  }\n\t});\n\t\n\t// Create a GraphQL language AST from a JavaScript value.\n\t\n\tvar _astFromValue = __webpack_require__(376);\n\t\n\tObject.defineProperty(exports, 'astFromValue', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _astFromValue.astFromValue;\n\t  }\n\t});\n\t\n\t// A helper to use within recursive-descent visitors which need to be aware of\n\t// the GraphQL type system.\n\t\n\tvar _TypeInfo = __webpack_require__(379);\n\t\n\tObject.defineProperty(exports, 'TypeInfo', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _TypeInfo.TypeInfo;\n\t  }\n\t});\n\t\n\t// Determine if JavaScript values adhere to a GraphQL type.\n\t\n\tvar _isValidJSValue = __webpack_require__(409);\n\t\n\tObject.defineProperty(exports, 'isValidJSValue', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _isValidJSValue.isValidJSValue;\n\t  }\n\t});\n\t\n\t// Determine if AST values adhere to a GraphQL type.\n\t\n\tvar _isValidLiteralValue = __webpack_require__(400);\n\t\n\tObject.defineProperty(exports, 'isValidLiteralValue', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _isValidLiteralValue.isValidLiteralValue;\n\t  }\n\t});\n\t\n\t// Concatenates multiple AST together.\n\t\n\tvar _concatAST = __webpack_require__(421);\n\t\n\tObject.defineProperty(exports, 'concatAST', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _concatAST.concatAST;\n\t  }\n\t});\n\n/***/ },\n/* 414 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar introspectionQuery = '\\n  query IntrospectionQuery {\\n    __schema {\\n      queryType { name }\\n      mutationType { name }\\n      subscriptionType { name }\\n      types {\\n        ...FullType\\n      }\\n      directives {\\n        name\\n        description\\n        args {\\n          ...InputValue\\n        }\\n        onOperation\\n        onFragment\\n        onField\\n      }\\n    }\\n  }\\n\\n  fragment FullType on __Type {\\n    kind\\n    name\\n    description\\n    fields(includeDeprecated: true) {\\n      name\\n      description\\n      args {\\n        ...InputValue\\n      }\\n      type {\\n        ...TypeRef\\n      }\\n      isDeprecated\\n      deprecationReason\\n    }\\n    inputFields {\\n      ...InputValue\\n    }\\n    interfaces {\\n      ...TypeRef\\n    }\\n    enumValues(includeDeprecated: true) {\\n      name\\n      description\\n      isDeprecated\\n      deprecationReason\\n    }\\n    possibleTypes {\\n      ...TypeRef\\n    }\\n  }\\n\\n  fragment InputValue on __InputValue {\\n    name\\n    description\\n    type { ...TypeRef }\\n    defaultValue\\n  }\\n\\n  fragment TypeRef on __Type {\\n    kind\\n    name\\n    ofType {\\n      kind\\n      name\\n      ofType {\\n        kind\\n        name\\n        ofType {\\n          kind\\n          name\\n        }\\n      }\\n    }\\n  }\\n';\n\t\n\texports.introspectionQuery = introspectionQuery;\n\n/***/ },\n/* 415 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Returns an operation AST given a document AST and optionally an operation\n\t * name. If a name is not provided, an operation is only returned if only one is\n\t * provided in the document.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.getOperationAST = getOperationAST;\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tfunction getOperationAST(documentAST, operationName) {\n\t  var operation = null;\n\t  for (var i = 0; i < documentAST.definitions.length; i++) {\n\t    var definition = documentAST.definitions[i];\n\t    if (definition.kind === _languageKinds.OPERATION_DEFINITION) {\n\t      if (!operationName) {\n\t        // If no operation name was provided, only return an Operation if there\n\t        // is one defined in the document. Upon encountering the second, return\n\t        // null.\n\t        if (operation) {\n\t          return null;\n\t        }\n\t        operation = definition;\n\t      } else if (definition.name && definition.name.value === operationName) {\n\t        return definition;\n\t      }\n\t    }\n\t  }\n\t  return operation;\n\t}\n\n/***/ },\n/* 416 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Build a GraphQLSchema for use by client tools.\n\t *\n\t * Given the result of a client running the introspection query, creates and\n\t * returns a GraphQLSchema instance which can be then used with all graphql-js\n\t * tools, but cannot be used to execute a query, as introspection does not\n\t * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n\t * server-internal mechanisms.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.buildClientSchema = buildClientSchema;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsKeyMap = __webpack_require__(372);\n\t\n\tvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\t\n\tvar _jsutilsKeyValMap = __webpack_require__(417);\n\t\n\tvar _jsutilsKeyValMap2 = _interopRequireDefault(_jsutilsKeyValMap);\n\t\n\tvar _valueFromAST = __webpack_require__(408);\n\t\n\tvar _languageParser = __webpack_require__(355);\n\t\n\tvar _typeSchema = __webpack_require__(369);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _typeScalars = __webpack_require__(374);\n\t\n\tvar _typeDirectives = __webpack_require__(373);\n\t\n\tvar _typeIntrospection = __webpack_require__(375);\n\t\n\tfunction buildClientSchema(introspection) {\n\t\n\t  // Get the schema from the introspection result.\n\t  var schemaIntrospection = introspection.__schema;\n\t\n\t  // Converts the list of types into a keyMap based on the type names.\n\t  var typeIntrospectionMap = (0, _jsutilsKeyMap2['default'])(schemaIntrospection.types, function (type) {\n\t    return type.name;\n\t  });\n\t\n\t  // A cache to use to store the actual GraphQLType definition objects by name.\n\t  // Initialize to the GraphQL built in scalars. All functions below are inline\n\t  // so that this type def cache is within the scope of the closure.\n\t  var typeDefCache = {\n\t    String: _typeScalars.GraphQLString,\n\t    Int: _typeScalars.GraphQLInt,\n\t    Float: _typeScalars.GraphQLFloat,\n\t    Boolean: _typeScalars.GraphQLBoolean,\n\t    ID: _typeScalars.GraphQLID\n\t  };\n\t\n\t  // Given a type reference in introspection, return the GraphQLType instance.\n\t  // preferring cached instances before building new instances.\n\t  function getType(typeRef) {\n\t    if (typeRef.kind === _typeIntrospection.TypeKind.LIST) {\n\t      var itemRef = typeRef.ofType;\n\t      if (!itemRef) {\n\t        throw new Error('Decorated type deeper than introspection query.');\n\t      }\n\t      return new _typeDefinition.GraphQLList(getType(itemRef));\n\t    }\n\t    if (typeRef.kind === _typeIntrospection.TypeKind.NON_NULL) {\n\t      var nullableRef = typeRef.ofType;\n\t      if (!nullableRef) {\n\t        throw new Error('Decorated type deeper than introspection query.');\n\t      }\n\t      var nullableType = getType(nullableRef);\n\t      return new _typeDefinition.GraphQLNonNull(nullableType);\n\t    }\n\t    return getNamedType(typeRef.name);\n\t  }\n\t\n\t  function getNamedType(typeName) {\n\t    if (typeDefCache[typeName]) {\n\t      return typeDefCache[typeName];\n\t    }\n\t    var typeIntrospection = typeIntrospectionMap[typeName];\n\t    if (!typeIntrospection) {\n\t      throw new Error('Invalid or incomplete schema, unknown type: ' + typeName + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n\t    }\n\t    var typeDef = buildType(typeIntrospection);\n\t    typeDefCache[typeName] = typeDef;\n\t    return typeDef;\n\t  }\n\t\n\t  function getInputType(typeRef) {\n\t    var type = getType(typeRef);\n\t    (0, _jsutilsInvariant2['default'])((0, _typeDefinition.isInputType)(type), 'Introspection must provide input type for arguments.');\n\t    return type;\n\t  }\n\t\n\t  function getOutputType(typeRef) {\n\t    var type = getType(typeRef);\n\t    (0, _jsutilsInvariant2['default'])((0, _typeDefinition.isOutputType)(type), 'Introspection must provide output type for fields.');\n\t    return type;\n\t  }\n\t\n\t  function getObjectType(typeRef) {\n\t    var type = getType(typeRef);\n\t    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLObjectType, 'Introspection must provide object type for possibleTypes.');\n\t    return type;\n\t  }\n\t\n\t  function getInterfaceType(typeRef) {\n\t    var type = getType(typeRef);\n\t    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLInterfaceType, 'Introspection must provide interface type for interfaces.');\n\t    return type;\n\t  }\n\t\n\t  // Given a type's introspection result, construct the correct\n\t  // GraphQLType instance.\n\t  function buildType(type) {\n\t    switch (type.kind) {\n\t      case _typeIntrospection.TypeKind.SCALAR:\n\t        return buildScalarDef(type);\n\t      case _typeIntrospection.TypeKind.OBJECT:\n\t        return buildObjectDef(type);\n\t      case _typeIntrospection.TypeKind.INTERFACE:\n\t        return buildInterfaceDef(type);\n\t      case _typeIntrospection.TypeKind.UNION:\n\t        return buildUnionDef(type);\n\t      case _typeIntrospection.TypeKind.ENUM:\n\t        return buildEnumDef(type);\n\t      case _typeIntrospection.TypeKind.INPUT_OBJECT:\n\t        return buildInputObjectDef(type);\n\t      default:\n\t        throw new Error('Invalid or incomplete schema, unknown kind: ' + type.kind + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n\t    }\n\t  }\n\t\n\t  function buildScalarDef(scalarIntrospection) {\n\t    return new _typeDefinition.GraphQLScalarType({\n\t      name: scalarIntrospection.name,\n\t      description: scalarIntrospection.description,\n\t      serialize: function serialize() {\n\t        return null;\n\t      },\n\t      // Note: validation calls the parse functions to determine if a\n\t      // literal value is correct. Returning null would cause use of custom\n\t      // scalars to always fail validation. Returning false causes them to\n\t      // always pass validation.\n\t      parseValue: function parseValue() {\n\t        return false;\n\t      },\n\t      parseLiteral: function parseLiteral() {\n\t        return false;\n\t      }\n\t    });\n\t  }\n\t\n\t  function buildObjectDef(objectIntrospection) {\n\t    return new _typeDefinition.GraphQLObjectType({\n\t      name: objectIntrospection.name,\n\t      description: objectIntrospection.description,\n\t      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n\t      fields: function fields() {\n\t        return buildFieldDefMap(objectIntrospection);\n\t      }\n\t    });\n\t  }\n\t\n\t  function buildInterfaceDef(interfaceIntrospection) {\n\t    return new _typeDefinition.GraphQLInterfaceType({\n\t      name: interfaceIntrospection.name,\n\t      description: interfaceIntrospection.description,\n\t      fields: function fields() {\n\t        return buildFieldDefMap(interfaceIntrospection);\n\t      },\n\t      resolveType: function resolveType() {\n\t        throw new Error('Client Schema cannot be used for execution.');\n\t      }\n\t    });\n\t  }\n\t\n\t  function buildUnionDef(unionIntrospection) {\n\t    return new _typeDefinition.GraphQLUnionType({\n\t      name: unionIntrospection.name,\n\t      description: unionIntrospection.description,\n\t      types: unionIntrospection.possibleTypes.map(getObjectType),\n\t      resolveType: function resolveType() {\n\t        throw new Error('Client Schema cannot be used for execution.');\n\t      }\n\t    });\n\t  }\n\t\n\t  function buildEnumDef(enumIntrospection) {\n\t    return new _typeDefinition.GraphQLEnumType({\n\t      name: enumIntrospection.name,\n\t      description: enumIntrospection.description,\n\t      values: (0, _jsutilsKeyValMap2['default'])(enumIntrospection.enumValues, function (valueIntrospection) {\n\t        return valueIntrospection.name;\n\t      }, function (valueIntrospection) {\n\t        return {\n\t          description: valueIntrospection.description,\n\t          deprecationReason: valueIntrospection.deprecationReason\n\t        };\n\t      })\n\t    });\n\t  }\n\t\n\t  function buildInputObjectDef(inputObjectIntrospection) {\n\t    return new _typeDefinition.GraphQLInputObjectType({\n\t      name: inputObjectIntrospection.name,\n\t      description: inputObjectIntrospection.description,\n\t      fields: function fields() {\n\t        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n\t      }\n\t    });\n\t  }\n\t\n\t  function buildFieldDefMap(typeIntrospection) {\n\t    return (0, _jsutilsKeyValMap2['default'])(typeIntrospection.fields, function (fieldIntrospection) {\n\t      return fieldIntrospection.name;\n\t    }, function (fieldIntrospection) {\n\t      return {\n\t        description: fieldIntrospection.description,\n\t        deprecationReason: fieldIntrospection.deprecationReason,\n\t        type: getOutputType(fieldIntrospection.type),\n\t        args: buildInputValueDefMap(fieldIntrospection.args),\n\t        resolve: function resolve() {\n\t          throw new Error('Client Schema cannot be used for execution.');\n\t        }\n\t      };\n\t    });\n\t  }\n\t\n\t  function buildInputValueDefMap(inputValueIntrospections) {\n\t    return (0, _jsutilsKeyValMap2['default'])(inputValueIntrospections, function (inputValue) {\n\t      return inputValue.name;\n\t    }, buildInputValue);\n\t  }\n\t\n\t  function buildInputValue(inputValueIntrospection) {\n\t    var type = getInputType(inputValueIntrospection.type);\n\t    var defaultValue = inputValueIntrospection.defaultValue ? (0, _valueFromAST.valueFromAST)((0, _languageParser.parseValue)(inputValueIntrospection.defaultValue), type) : null;\n\t    return {\n\t      name: inputValueIntrospection.name,\n\t      description: inputValueIntrospection.description,\n\t      type: type,\n\t      defaultValue: defaultValue\n\t    };\n\t  }\n\t\n\t  function buildDirective(directiveIntrospection) {\n\t    return new _typeDirectives.GraphQLDirective({\n\t      name: directiveIntrospection.name,\n\t      description: directiveIntrospection.description,\n\t      args: directiveIntrospection.args.map(buildInputValue),\n\t      onOperation: directiveIntrospection.onOperation,\n\t      onFragment: directiveIntrospection.onFragment,\n\t      onField: directiveIntrospection.onField\n\t    });\n\t  }\n\t\n\t  // Iterate through all types, getting the type definition for each, ensuring\n\t  // that any type not directly referenced by a field will get created.\n\t  schemaIntrospection.types.forEach(function (typeIntrospection) {\n\t    return getNamedType(typeIntrospection.name);\n\t  });\n\t\n\t  // Get the root Query, Mutation, and Subscription types.\n\t  var queryType = getObjectType(schemaIntrospection.queryType);\n\t\n\t  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n\t\n\t  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;\n\t\n\t  // Get the directives supported by Introspection, assuming empty-set if\n\t  // directives were not queried for.\n\t  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];\n\t\n\t  // Then produce and return a Schema with these types.\n\t  return new _typeSchema.GraphQLSchema({\n\t    query: queryType,\n\t    mutation: mutationType,\n\t    subscription: subscriptionType,\n\t    directives: directives\n\t  });\n\t}\n\n/***/ },\n/* 417 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Creates a keyed JS object from an array, given a function to produce the keys\n\t * and a function to produce the values from each item in the array.\n\t *\n\t *     var phoneBook = [\n\t *       { name: 'Jon', num: '555-1234' },\n\t *       { name: 'Jenny', num: '867-5309' }\n\t *     ]\n\t *\n\t *     // { Jon: '555-1234', Jenny: '867-5309' }\n\t *     var phonesByName = keyValMap(\n\t *       phoneBook,\n\t *       entry => entry.name,\n\t *       entry => entry.num\n\t *     )\n\t *\n\t */\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = keyValMap;\n\t\n\tfunction keyValMap(list, keyFn, valFn) {\n\t  return list.reduce(function (map, item) {\n\t    return (map[keyFn(item)] = valFn(item), map);\n\t  }, {});\n\t}\n\t\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 418 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.buildASTSchema = buildASTSchema;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\tvar _jsutilsKeyMap = __webpack_require__(372);\n\t\n\tvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\t\n\tvar _jsutilsKeyValMap = __webpack_require__(417);\n\t\n\tvar _jsutilsKeyValMap2 = _interopRequireDefault(_jsutilsKeyValMap);\n\t\n\tvar _valueFromAST = __webpack_require__(408);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tvar _type = __webpack_require__(412);\n\t\n\tfunction buildWrappedType(innerType, inputTypeAST) {\n\t  if (inputTypeAST.kind === _languageKinds.LIST_TYPE) {\n\t    return new _type.GraphQLList(buildWrappedType(innerType, inputTypeAST.type));\n\t  }\n\t  if (inputTypeAST.kind === _languageKinds.NON_NULL_TYPE) {\n\t    return new _type.GraphQLNonNull(buildWrappedType(innerType, inputTypeAST.type));\n\t  }\n\t  return innerType;\n\t}\n\t\n\tfunction getInnerTypeName(_x) {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    var typeAST = _x;\n\t    _again = false;\n\t\n\t    if (typeAST.kind === _languageKinds.LIST_TYPE || typeAST.kind === _languageKinds.NON_NULL_TYPE) {\n\t      _x = typeAST.type;\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t    return typeAST.name.value;\n\t  }\n\t}\n\t\n\t/**\n\t * This takes the ast of a schema document produced by parseSchema in\n\t * src/language/schema/parser.js.\n\t *\n\t * Given that AST it constructs a GraphQLSchema. As constructed\n\t * they are not particularly useful for non-introspection queries\n\t * since they have no resolve methods.\n\t */\n\t\n\tfunction buildASTSchema(ast, queryTypeName, mutationTypeName, subscriptionTypeName) {\n\t\n\t  if ((0, _jsutilsIsNullish2['default'])(ast)) {\n\t    throw new Error('must pass in ast');\n\t  }\n\t  if ((0, _jsutilsIsNullish2['default'])(queryTypeName)) {\n\t    throw new Error('must pass in query type');\n\t  }\n\t\n\t  var typeDefs = ast.definitions.filter(function (d) {\n\t    switch (d.kind) {\n\t      case _languageKinds.OBJECT_TYPE_DEFINITION:\n\t      case _languageKinds.INTERFACE_TYPE_DEFINITION:\n\t      case _languageKinds.ENUM_TYPE_DEFINITION:\n\t      case _languageKinds.UNION_TYPE_DEFINITION:\n\t      case _languageKinds.SCALAR_TYPE_DEFINITION:\n\t      case _languageKinds.INPUT_OBJECT_TYPE_DEFINITION:\n\t        return true;\n\t    }\n\t  });\n\t\n\t  var astMap = (0, _jsutilsKeyMap2['default'])(typeDefs, function (d) {\n\t    return d.name.value;\n\t  });\n\t\n\t  if ((0, _jsutilsIsNullish2['default'])(astMap[queryTypeName])) {\n\t    throw new Error('Specified query type ' + queryTypeName + ' not found in document.');\n\t  }\n\t\n\t  if (!(0, _jsutilsIsNullish2['default'])(mutationTypeName) && (0, _jsutilsIsNullish2['default'])(astMap[mutationTypeName])) {\n\t    throw new Error('Specified mutation type ' + mutationTypeName + ' not found in document.');\n\t  }\n\t\n\t  if (!(0, _jsutilsIsNullish2['default'])(subscriptionTypeName) && (0, _jsutilsIsNullish2['default'])(astMap[subscriptionTypeName])) {\n\t    throw new Error('Specified subscription type ' + subscriptionTypeName + ' not found in document.');\n\t  }\n\t\n\t  /**\n\t   * This generates a function that allows you to produce\n\t   * type definitions on demand. We produce the function\n\t   * in order to close over the memoization dictionaries\n\t   * that need to be retained over multiple functions calls.\n\t   **/\n\t  function getTypeDefProducer() {\n\t\n\t    var innerTypeMap = {\n\t      String: _type.GraphQLString,\n\t      Int: _type.GraphQLInt,\n\t      Float: _type.GraphQLFloat,\n\t      Boolean: _type.GraphQLBoolean,\n\t      ID: _type.GraphQLID\n\t    };\n\t\n\t    return function (typeAST) {\n\t      var typeName = getInnerTypeName(typeAST);\n\t      if (!(0, _jsutilsIsNullish2['default'])(innerTypeMap[typeName])) {\n\t        return buildWrappedType(innerTypeMap[typeName], typeAST);\n\t      }\n\t\n\t      if ((0, _jsutilsIsNullish2['default'])(astMap[typeName])) {\n\t        throw new Error('Type ' + typeName + ' not found in document');\n\t      }\n\t\n\t      var innerTypeDef = makeSchemaDef(astMap[typeName]);\n\t      if ((0, _jsutilsIsNullish2['default'])(innerTypeDef)) {\n\t        throw new Error('Nothing constructed for ' + typeName);\n\t      }\n\t      innerTypeMap[typeName] = innerTypeDef;\n\t      return buildWrappedType(innerTypeDef, typeAST);\n\t    };\n\t  }\n\t\n\t  var produceTypeDef = getTypeDefProducer(ast);\n\t\n\t  ast.definitions.forEach(produceTypeDef);\n\t\n\t  var queryType = produceTypeDef(astMap[queryTypeName]);\n\t\n\t  var schemaBody = {\n\t    query: queryType\n\t  };\n\t\n\t  if (!(0, _jsutilsIsNullish2['default'])(mutationTypeName)) {\n\t    schemaBody.mutation = produceTypeDef(astMap[mutationTypeName]);\n\t  }\n\t\n\t  if (!(0, _jsutilsIsNullish2['default'])(subscriptionTypeName)) {\n\t    schemaBody.subscription = produceTypeDef(astMap[subscriptionTypeName]);\n\t  }\n\t\n\t  return new _type.GraphQLSchema(schemaBody);\n\t\n\t  function makeSchemaDef(def) {\n\t    if ((0, _jsutilsIsNullish2['default'])(def)) {\n\t      throw new Error('def must be defined');\n\t    }\n\t    switch (def.kind) {\n\t      case _languageKinds.OBJECT_TYPE_DEFINITION:\n\t        return makeTypeDef(def);\n\t      case _languageKinds.INTERFACE_TYPE_DEFINITION:\n\t        return makeInterfaceDef(def);\n\t      case _languageKinds.ENUM_TYPE_DEFINITION:\n\t        return makeEnumDef(def);\n\t      case _languageKinds.UNION_TYPE_DEFINITION:\n\t        return makeUnionDef(def);\n\t      case _languageKinds.SCALAR_TYPE_DEFINITION:\n\t        return makeScalarDef(def);\n\t      case _languageKinds.INPUT_OBJECT_TYPE_DEFINITION:\n\t        return makeInputObjectDef(def);\n\t      default:\n\t        throw new Error(def.kind + ' not supported');\n\t    }\n\t  }\n\t\n\t  function makeTypeDef(def) {\n\t    var typeName = def.name.value;\n\t    var config = {\n\t      name: typeName,\n\t      fields: function fields() {\n\t        return makeFieldDefMap(def);\n\t      },\n\t      interfaces: function interfaces() {\n\t        return makeImplementedInterfaces(def);\n\t      }\n\t    };\n\t    return new _type.GraphQLObjectType(config);\n\t  }\n\t\n\t  function makeFieldDefMap(def) {\n\t    return (0, _jsutilsKeyValMap2['default'])(def.fields, function (field) {\n\t      return field.name.value;\n\t    }, function (field) {\n\t      return {\n\t        type: produceTypeDef(field.type),\n\t        args: makeInputValues(field.arguments)\n\t      };\n\t    });\n\t  }\n\t\n\t  function makeImplementedInterfaces(def) {\n\t    return def.interfaces.map(function (inter) {\n\t      return produceTypeDef(inter);\n\t    });\n\t  }\n\t\n\t  function makeInputValues(values) {\n\t    return (0, _jsutilsKeyValMap2['default'])(values, function (value) {\n\t      return value.name.value;\n\t    }, function (value) {\n\t      var type = produceTypeDef(value.type);\n\t      return { type: type, defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type) };\n\t    });\n\t  }\n\t\n\t  function makeInterfaceDef(def) {\n\t    var typeName = def.name.value;\n\t    var config = {\n\t      name: typeName,\n\t      resolveType: function resolveType() {\n\t        return null;\n\t      },\n\t      fields: function fields() {\n\t        return makeFieldDefMap(def);\n\t      }\n\t    };\n\t    return new _type.GraphQLInterfaceType(config);\n\t  }\n\t\n\t  function makeEnumDef(def) {\n\t    var enumType = new _type.GraphQLEnumType({\n\t      name: def.name.value,\n\t      values: (0, _jsutilsKeyValMap2['default'])(def.values, function (v) {\n\t        return v.name.value;\n\t      }, function () {\n\t        return {};\n\t      })\n\t    });\n\t\n\t    return enumType;\n\t  }\n\t\n\t  function makeUnionDef(def) {\n\t    return new _type.GraphQLUnionType({\n\t      name: def.name.value,\n\t      resolveType: function resolveType() {\n\t        return null;\n\t      },\n\t      types: def.types.map(function (t) {\n\t        return produceTypeDef(t);\n\t      })\n\t    });\n\t  }\n\t\n\t  function makeScalarDef(def) {\n\t    return new _type.GraphQLScalarType({\n\t      name: def.name.value,\n\t      serialize: function serialize() {\n\t        return null;\n\t      },\n\t      // Note: validation calls the parse functions to determine if a\n\t      // literal value is correct. Returning null would cause use of custom\n\t      // scalars to always fail validation. Returning false causes them to\n\t      // always pass validation.\n\t      parseValue: function parseValue() {\n\t        return false;\n\t      },\n\t      parseLiteral: function parseLiteral() {\n\t        return false;\n\t      }\n\t    });\n\t  }\n\t\n\t  function makeInputObjectDef(def) {\n\t    return new _type.GraphQLInputObjectType({\n\t      name: def.name.value,\n\t      fields: function fields() {\n\t        return makeInputValues(def.fields);\n\t      }\n\t    });\n\t  }\n\t}\n\n/***/ },\n/* 419 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Produces a new schema given an existing schema and a document which may\n\t * contain GraphQL type extensions and definitions. The original schema will\n\t * remain unaltered.\n\t *\n\t * Because a schema represents a graph of references, a schema cannot be\n\t * extended without effectively making an entire copy. We do not know until it's\n\t * too late if subgraphs remain unchanged.\n\t *\n\t * This algorithm copies the provided schema, applying extensions while\n\t * producing the copy. The original schema remains unaltered.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.extendSchema = extendSchema;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsKeyMap = __webpack_require__(372);\n\t\n\tvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\t\n\tvar _jsutilsKeyValMap = __webpack_require__(417);\n\t\n\tvar _jsutilsKeyValMap2 = _interopRequireDefault(_jsutilsKeyValMap);\n\t\n\tvar _valueFromAST = __webpack_require__(408);\n\t\n\tvar _errorGraphQLError = __webpack_require__(357);\n\t\n\tvar _typeSchema = __webpack_require__(369);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tvar _typeScalars = __webpack_require__(374);\n\t\n\tvar _languageKinds = __webpack_require__(359);\n\t\n\tfunction extendSchema(schema, documentAST) {\n\t  (0, _jsutilsInvariant2['default'])(schema instanceof _typeSchema.GraphQLSchema, 'Must provide valid GraphQLSchema');\n\t\n\t  (0, _jsutilsInvariant2['default'])(documentAST && documentAST.kind === _languageKinds.DOCUMENT, 'Must provide valid Document AST');\n\t\n\t  // Collect the type definitions and extensions found in the document.\n\t  var typeDefinitionMap = {};\n\t  var typeExtensionsMap = {};\n\t\n\t  for (var i = 0; i < documentAST.definitions.length; i++) {\n\t    var def = documentAST.definitions[i];\n\t    switch (def.kind) {\n\t      case _languageKinds.OBJECT_TYPE_DEFINITION:\n\t      case _languageKinds.INTERFACE_TYPE_DEFINITION:\n\t      case _languageKinds.ENUM_TYPE_DEFINITION:\n\t      case _languageKinds.UNION_TYPE_DEFINITION:\n\t      case _languageKinds.SCALAR_TYPE_DEFINITION:\n\t      case _languageKinds.INPUT_OBJECT_TYPE_DEFINITION:\n\t        // Sanity check that none of the defined types conflict with the\n\t        // schema's existing types.\n\t        var typeName = def.name.value;\n\t        if (schema.getType(typeName)) {\n\t          throw new _errorGraphQLError.GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n\t        }\n\t        typeDefinitionMap[typeName] = def;\n\t        break;\n\t      case _languageKinds.TYPE_EXTENSION_DEFINITION:\n\t        // Sanity check that this type extension exists within the\n\t        // schema's existing types.\n\t        var extendedTypeName = def.definition.name.value;\n\t        var existingType = schema.getType(extendedTypeName);\n\t        if (!existingType) {\n\t          throw new _errorGraphQLError.GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def.definition]);\n\t        }\n\t        if (!(existingType instanceof _typeDefinition.GraphQLObjectType)) {\n\t          throw new _errorGraphQLError.GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def.definition]);\n\t        }\n\t        var extensions = typeExtensionsMap[extendedTypeName];\n\t        if (extensions) {\n\t          extensions.push(def);\n\t        } else {\n\t          extensions = [def];\n\t        }\n\t        typeExtensionsMap[extendedTypeName] = extensions;\n\t        break;\n\t    }\n\t  }\n\t\n\t  // If this document contains no new types, then return the same unmodified\n\t  // GraphQLSchema instance.\n\t  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0) {\n\t    return schema;\n\t  }\n\t\n\t  // A cache to use to store the actual GraphQLType definition objects by name.\n\t  // Initialize to the GraphQL built in scalars. All functions below are inline\n\t  // so that this type def cache is within the scope of the closure.\n\t  var typeDefCache = {\n\t    String: _typeScalars.GraphQLString,\n\t    Int: _typeScalars.GraphQLInt,\n\t    Float: _typeScalars.GraphQLFloat,\n\t    Boolean: _typeScalars.GraphQLBoolean,\n\t    ID: _typeScalars.GraphQLID\n\t  };\n\t\n\t  // Get the root Query, Mutation, and Subscription types.\n\t  var queryType = getTypeFromDef(schema.getQueryType());\n\t\n\t  var existingMutationType = schema.getMutationType();\n\t  var mutationType = existingMutationType ? getTypeFromDef(existingMutationType) : null;\n\t\n\t  var existingSubscriptionType = schema.getSubscriptionType();\n\t  var subscriptionType = existingSubscriptionType ? getTypeFromDef(existingSubscriptionType) : null;\n\t\n\t  // Iterate through all types, getting the type definition for each, ensuring\n\t  // that any type not directly referenced by a field will get created.\n\t  Object.keys(schema.getTypeMap()).forEach(function (typeName) {\n\t    return getTypeFromDef(schema.getType(typeName));\n\t  });\n\t\n\t  // Do the same with new types.\n\t  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n\t    return getTypeFromAST(typeDefinitionMap[typeName]);\n\t  });\n\t\n\t  // Then produce and return a Schema with these types.\n\t  return new _typeSchema.GraphQLSchema({\n\t    query: queryType,\n\t    mutation: mutationType,\n\t    subscription: subscriptionType,\n\t    // Copy directives.\n\t    directives: schema.getDirectives()\n\t  });\n\t\n\t  // Below are functions used for producing this schema that have closed over\n\t  // this scope and have access to the schema, cache, and newly defined types.\n\t\n\t  function getTypeFromDef(typeDef) {\n\t    var type = _getNamedType(typeDef.name);\n\t    (0, _jsutilsInvariant2['default'])(type, 'Invalid schema');\n\t    return type;\n\t  }\n\t\n\t  function getTypeFromAST(astNode) {\n\t    var type = _getNamedType(astNode.name.value);\n\t    if (!type) {\n\t      throw new _errorGraphQLError.GraphQLError('Unknown type: \"' + astNode.name.value + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [astNode]);\n\t    }\n\t    return type;\n\t  }\n\t\n\t  // Given a name, returns a type from either the existing schema or an\n\t  // added type.\n\t  function _getNamedType(typeName) {\n\t    var cachedTypeDef = typeDefCache[typeName];\n\t    if (cachedTypeDef) {\n\t      return cachedTypeDef;\n\t    }\n\t\n\t    var existingType = schema.getType(typeName);\n\t    if (existingType) {\n\t      var typeDef = extendType(existingType);\n\t      typeDefCache[typeName] = typeDef;\n\t      return typeDef;\n\t    }\n\t\n\t    var typeAST = typeDefinitionMap[typeName];\n\t    if (typeAST) {\n\t      var typeDef = buildType(typeAST);\n\t      typeDefCache[typeName] = typeDef;\n\t      return typeDef;\n\t    }\n\t  }\n\t\n\t  // Given a type's introspection result, construct the correct\n\t  // GraphQLType instance.\n\t  function extendType(type) {\n\t    if (type instanceof _typeDefinition.GraphQLObjectType) {\n\t      return extendObjectType(type);\n\t    }\n\t    if (type instanceof _typeDefinition.GraphQLInterfaceType) {\n\t      return extendInterfaceType(type);\n\t    }\n\t    if (type instanceof _typeDefinition.GraphQLUnionType) {\n\t      return extendUnionType(type);\n\t    }\n\t    return type;\n\t  }\n\t\n\t  function extendObjectType(type) {\n\t    return new _typeDefinition.GraphQLObjectType({\n\t      name: type.name,\n\t      description: type.description,\n\t      interfaces: function interfaces() {\n\t        return extendImplementedInterfaces(type);\n\t      },\n\t      fields: function fields() {\n\t        return extendFieldMap(type);\n\t      }\n\t    });\n\t  }\n\t\n\t  function extendInterfaceType(type) {\n\t    return new _typeDefinition.GraphQLInterfaceType({\n\t      name: type.name,\n\t      description: type.description,\n\t      fields: function fields() {\n\t        return extendFieldMap(type);\n\t      },\n\t      resolveType: throwClientSchemaExecutionError\n\t    });\n\t  }\n\t\n\t  function extendUnionType(type) {\n\t    return new _typeDefinition.GraphQLUnionType({\n\t      name: type.name,\n\t      description: type.description,\n\t      types: type.getPossibleTypes().map(getTypeFromDef),\n\t      resolveType: throwClientSchemaExecutionError\n\t    });\n\t  }\n\t\n\t  function extendImplementedInterfaces(type) {\n\t    var interfaces = type.getInterfaces().map(getTypeFromDef);\n\t\n\t    // If there are any extensions to the interfaces, apply those here.\n\t    var extensions = typeExtensionsMap[type.name];\n\t    if (extensions) {\n\t      extensions.forEach(function (extension) {\n\t        extension.definition.interfaces.forEach(function (namedType) {\n\t          var interfaceName = namedType.name.value;\n\t          if (interfaces.some(function (def) {\n\t            return def.name === interfaceName;\n\t          })) {\n\t            throw new _errorGraphQLError.GraphQLError('\\'Type \"' + type.name + '\" already implements \"' + interfaceName + '\". ' + 'It cannot also be implemented in this type extension.', [namedType]);\n\t          }\n\t          interfaces.push(getTypeFromAST(namedType));\n\t        });\n\t      });\n\t    }\n\t\n\t    return interfaces;\n\t  }\n\t\n\t  function extendFieldMap(type) {\n\t    var newFieldMap = {};\n\t    var oldFieldMap = type.getFields();\n\t    Object.keys(oldFieldMap).forEach(function (fieldName) {\n\t      var field = oldFieldMap[fieldName];\n\t      newFieldMap[fieldName] = {\n\t        description: field.description,\n\t        deprecationReason: field.deprecationReason,\n\t        type: extendFieldType(field.type),\n\t        args: (0, _jsutilsKeyMap2['default'])(field.args, function (arg) {\n\t          return arg.name;\n\t        }),\n\t        resolve: throwClientSchemaExecutionError\n\t      };\n\t    });\n\t\n\t    // If there are any extensions to the fields, apply those here.\n\t    var extensions = typeExtensionsMap[type.name];\n\t    if (extensions) {\n\t      extensions.forEach(function (extension) {\n\t        extension.definition.fields.forEach(function (field) {\n\t          var fieldName = field.name.value;\n\t          if (oldFieldMap[fieldName]) {\n\t            throw new _errorGraphQLError.GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n\t          }\n\t          newFieldMap[fieldName] = {\n\t            type: buildFieldType(field.type),\n\t            args: buildInputValues(field.arguments),\n\t            resolve: throwClientSchemaExecutionError\n\t          };\n\t        });\n\t      });\n\t    }\n\t\n\t    return newFieldMap;\n\t  }\n\t\n\t  function extendFieldType(type) {\n\t    if (type instanceof _typeDefinition.GraphQLList) {\n\t      return new _typeDefinition.GraphQLList(extendFieldType(type.ofType));\n\t    }\n\t    if (type instanceof _typeDefinition.GraphQLNonNull) {\n\t      return new _typeDefinition.GraphQLNonNull(extendFieldType(type.ofType));\n\t    }\n\t    return getTypeFromDef(type);\n\t  }\n\t\n\t  function buildType(typeAST) {\n\t    switch (typeAST.kind) {\n\t      case _languageKinds.OBJECT_TYPE_DEFINITION:\n\t        return buildObjectType(typeAST);\n\t      case _languageKinds.INTERFACE_TYPE_DEFINITION:\n\t        return buildInterfaceType(typeAST);\n\t      case _languageKinds.UNION_TYPE_DEFINITION:\n\t        return buildUnionType(typeAST);\n\t      case _languageKinds.SCALAR_TYPE_DEFINITION:\n\t        return buildScalarType(typeAST);\n\t      case _languageKinds.ENUM_TYPE_DEFINITION:\n\t        return buildEnumType(typeAST);\n\t      case _languageKinds.INPUT_OBJECT_TYPE_DEFINITION:\n\t        return buildInputObjectType(typeAST);\n\t    }\n\t  }\n\t\n\t  function buildObjectType(typeAST) {\n\t    return new _typeDefinition.GraphQLObjectType({\n\t      name: typeAST.name.value,\n\t      interfaces: function interfaces() {\n\t        return buildImplementedInterfaces(typeAST);\n\t      },\n\t      fields: function fields() {\n\t        return buildFieldMap(typeAST);\n\t      }\n\t    });\n\t  }\n\t\n\t  function buildInterfaceType(typeAST) {\n\t    return new _typeDefinition.GraphQLInterfaceType({\n\t      name: typeAST.name.value,\n\t      fields: function fields() {\n\t        return buildFieldMap(typeAST);\n\t      },\n\t      resolveType: throwClientSchemaExecutionError\n\t    });\n\t  }\n\t\n\t  function buildUnionType(typeAST) {\n\t    return new _typeDefinition.GraphQLUnionType({\n\t      name: typeAST.name.value,\n\t      types: typeAST.types.map(getTypeFromAST),\n\t      resolveType: throwClientSchemaExecutionError\n\t    });\n\t  }\n\t\n\t  function buildScalarType(typeAST) {\n\t    return new _typeDefinition.GraphQLScalarType({\n\t      name: typeAST.name.value,\n\t      serialize: function serialize() {\n\t        return null;\n\t      },\n\t      // Note: validation calls the parse functions to determine if a\n\t      // literal value is correct. Returning null would cause use of custom\n\t      // scalars to always fail validation. Returning false causes them to\n\t      // always pass validation.\n\t      parseValue: function parseValue() {\n\t        return false;\n\t      },\n\t      parseLiteral: function parseLiteral() {\n\t        return false;\n\t      }\n\t    });\n\t  }\n\t\n\t  function buildEnumType(typeAST) {\n\t    return new _typeDefinition.GraphQLEnumType({\n\t      name: typeAST.name.value,\n\t      values: (0, _jsutilsKeyValMap2['default'])(typeAST.values, function (v) {\n\t        return v.name.value;\n\t      }, function () {\n\t        return {};\n\t      })\n\t    });\n\t  }\n\t\n\t  function buildInputObjectType(typeAST) {\n\t    return new _typeDefinition.GraphQLInputObjectType({\n\t      name: typeAST.name.value,\n\t      fields: function fields() {\n\t        return buildInputValues(typeAST.fields);\n\t      }\n\t    });\n\t  }\n\t\n\t  function buildImplementedInterfaces(typeAST) {\n\t    return typeAST.interfaces.map(getTypeFromAST);\n\t  }\n\t\n\t  function buildFieldMap(typeAST) {\n\t    return (0, _jsutilsKeyValMap2['default'])(typeAST.fields, function (field) {\n\t      return field.name.value;\n\t    }, function (field) {\n\t      return {\n\t        type: buildFieldType(field.type),\n\t        args: buildInputValues(field.arguments),\n\t        resolve: throwClientSchemaExecutionError\n\t      };\n\t    });\n\t  }\n\t\n\t  function buildInputValues(values) {\n\t    return (0, _jsutilsKeyValMap2['default'])(values, function (value) {\n\t      return value.name.value;\n\t    }, function (value) {\n\t      var type = buildFieldType(value.type);\n\t      return {\n\t        type: type,\n\t        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type)\n\t      };\n\t    });\n\t  }\n\t\n\t  function buildFieldType(typeAST) {\n\t    if (typeAST.kind === _languageKinds.LIST_TYPE) {\n\t      return new _typeDefinition.GraphQLList(buildFieldType(typeAST.type));\n\t    }\n\t    if (typeAST.kind === _languageKinds.NON_NULL_TYPE) {\n\t      return new _typeDefinition.GraphQLNonNull(buildFieldType(typeAST.type));\n\t    }\n\t    return getTypeFromAST(typeAST);\n\t  }\n\t}\n\t\n\tfunction throwClientSchemaExecutionError() {\n\t  throw new Error('Client Schema cannot be used for execution.');\n\t}\n\n/***/ },\n/* 420 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.printSchema = printSchema;\n\texports.printIntrospectionSchema = printIntrospectionSchema;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _jsutilsInvariant = __webpack_require__(367);\n\t\n\tvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\t\n\tvar _jsutilsIsNullish = __webpack_require__(371);\n\t\n\tvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\t\n\tvar _utilitiesAstFromValue = __webpack_require__(376);\n\t\n\tvar _languagePrinter = __webpack_require__(362);\n\t\n\tvar _typeDefinition = __webpack_require__(370);\n\t\n\tfunction printSchema(schema) {\n\t  return printFilteredSchema(schema, isDefinedType);\n\t}\n\t\n\tfunction printIntrospectionSchema(schema) {\n\t  return printFilteredSchema(schema, isIntrospectionType);\n\t}\n\t\n\tfunction isDefinedType(typename) {\n\t  return !isIntrospectionType(typename) && !isBuiltInScalar(typename);\n\t}\n\t\n\tfunction isIntrospectionType(typename) {\n\t  return typename.indexOf('__') === 0;\n\t}\n\t\n\tfunction isBuiltInScalar(typename) {\n\t  return typename === 'String' || typename === 'Boolean' || typename === 'Int' || typename === 'Float' || typename === 'ID';\n\t}\n\t\n\tfunction printFilteredSchema(schema, typeFilter) {\n\t  var typeMap = schema.getTypeMap();\n\t  var types = Object.keys(typeMap).filter(typeFilter).sort(function (name1, name2) {\n\t    return name1.localeCompare(name2);\n\t  }).map(function (typeName) {\n\t    return typeMap[typeName];\n\t  });\n\t  return types.map(printType).join('\\n\\n') + '\\n';\n\t}\n\t\n\tfunction printType(type) {\n\t  if (type instanceof _typeDefinition.GraphQLScalarType) {\n\t    return printScalar(type);\n\t  } else if (type instanceof _typeDefinition.GraphQLObjectType) {\n\t    return printObject(type);\n\t  } else if (type instanceof _typeDefinition.GraphQLInterfaceType) {\n\t    return printInterface(type);\n\t  } else if (type instanceof _typeDefinition.GraphQLUnionType) {\n\t    return printUnion(type);\n\t  } else if (type instanceof _typeDefinition.GraphQLEnumType) {\n\t    return printEnum(type);\n\t  }\n\t  (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLInputObjectType);\n\t  return printInputObject(type);\n\t}\n\t\n\tfunction printScalar(type) {\n\t  return 'scalar ' + type.name;\n\t}\n\t\n\tfunction printObject(type) {\n\t  var interfaces = type.getInterfaces();\n\t  var implementedInterfaces = interfaces.length ? ' implements ' + interfaces.map(function (i) {\n\t    return i.name;\n\t  }).join(', ') : '';\n\t  return 'type ' + type.name + implementedInterfaces + ' {\\n' + printFields(type) + '\\n' + '}';\n\t}\n\t\n\tfunction printInterface(type) {\n\t  return 'interface ' + type.name + ' {\\n' + printFields(type) + '\\n' + '}';\n\t}\n\t\n\tfunction printUnion(type) {\n\t  return 'union ' + type.name + ' = ' + type.getPossibleTypes().join(' | ');\n\t}\n\t\n\tfunction printEnum(type) {\n\t  var values = type.getValues();\n\t  return 'enum ' + type.name + ' {\\n' + values.map(function (v) {\n\t    return '  ' + v.name;\n\t  }).join('\\n') + '\\n' + '}';\n\t}\n\t\n\tfunction printInputObject(type) {\n\t  var fieldMap = type.getFields();\n\t  var fields = Object.keys(fieldMap).map(function (fieldName) {\n\t    return fieldMap[fieldName];\n\t  });\n\t  return 'input ' + type.name + ' {\\n' + fields.map(function (f) {\n\t    return '  ' + printInputValue(f);\n\t  }).join('\\n') + '\\n' + '}';\n\t}\n\t\n\tfunction printFields(type) {\n\t  var fieldMap = type.getFields();\n\t  var fields = Object.keys(fieldMap).map(function (fieldName) {\n\t    return fieldMap[fieldName];\n\t  });\n\t  return fields.map(function (f) {\n\t    return '  ' + f.name + printArgs(f) + ': ' + f.type;\n\t  }).join('\\n');\n\t}\n\t\n\tfunction printArgs(field) {\n\t  if (field.args.length === 0) {\n\t    return '';\n\t  }\n\t  return '(' + field.args.map(printInputValue).join(', ') + ')';\n\t}\n\t\n\tfunction printInputValue(arg) {\n\t  var argDecl = arg.name + ': ' + arg.type;\n\t  if (!(0, _jsutilsIsNullish2['default'])(arg.defaultValue)) {\n\t    argDecl += ' = ' + (0, _languagePrinter.print)((0, _utilitiesAstFromValue.astFromValue)(arg.defaultValue, arg.type));\n\t  }\n\t  return argDecl;\n\t}\n\n/***/ },\n/* 421 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t/**\n\t * Provided a collection of ASTs, presumably each from different files,\n\t * concatenate the ASTs together into batched AST, useful for validating many\n\t * GraphQL source files which together represent one conceptual application.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.concatAST = concatAST;\n\t\n\tfunction concatAST(asts) {\n\t  var batchDefinitions = [];\n\t  for (var i = 0; i < asts.length; i++) {\n\t    var definitions = asts[i].definitions;\n\t    for (var j = 0; j < definitions.length; j++) {\n\t      batchDefinitions.push(definitions[j]);\n\t    }\n\t  }\n\t  return {\n\t    kind: 'Document',\n\t    definitions: batchDefinitions\n\t  };\n\t}\n\n/***/ },\n/* 422 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\t/**\n\t * ExecuteButton\n\t *\n\t * What a nice round shiny button. Cmd/Ctrl-Enter is the shortcut.\n\t */\n\t\n\tvar ExecuteButton = (function (_React$Component) {\n\t  _inherits(ExecuteButton, _React$Component);\n\t\n\t  function ExecuteButton() {\n\t    _classCallCheck(this, ExecuteButton);\n\t\n\t    _React$Component.apply(this, arguments);\n\t  }\n\t\n\t  ExecuteButton.prototype.render = function render() {\n\t    return _react2[\"default\"].createElement(\n\t      \"button\",\n\t      {\n\t        className: \"execute-button\",\n\t        onClick: this.props.onClick,\n\t        title: \"Execute Query (Ctrl-Enter)\" },\n\t      _react2[\"default\"].createElement(\n\t        \"svg\",\n\t        { width: \"34\", height: \"34\" },\n\t        _react2[\"default\"].createElement(\"path\", { d: \"M 11 9 L 24 16 L 11 23 z\" })\n\t      )\n\t    );\n\t  };\n\t\n\t  ExecuteButton.prototype.componentDidMount = function componentDidMount() {\n\t    var _this = this;\n\t\n\t    this.keyHandler = function (event) {\n\t      if ((event.metaKey || event.ctrlKey) && event.keyCode === 13) {\n\t        event.preventDefault();\n\t        if (_this.props.onClick) {\n\t          _this.props.onClick();\n\t        }\n\t      }\n\t    };\n\t    document.addEventListener('keydown', this.keyHandler, true);\n\t  };\n\t\n\t  ExecuteButton.prototype.componentWillUnmount = function componentWillUnmount() {\n\t    document.removeEventListener('keydown', this.keyHandler, true);\n\t  };\n\t\n\t  _createClass(ExecuteButton, null, [{\n\t    key: \"propTypes\",\n\t    value: {\n\t      onClick: _react.PropTypes.func\n\t    },\n\t    enumerable: true\n\t  }]);\n\t\n\t  return ExecuteButton;\n\t})(_react2[\"default\"].Component);\n\t\n\texports.ExecuteButton = ExecuteButton;\n\n/***/ },\n/* 423 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _reactDom = __webpack_require__(155);\n\t\n\tvar _reactDom2 = _interopRequireDefault(_reactDom);\n\t\n\tvar _marked = __webpack_require__(424);\n\t\n\tvar _marked2 = _interopRequireDefault(_marked);\n\t\n\tvar _codemirror = __webpack_require__(351);\n\t\n\tvar _codemirror2 = _interopRequireDefault(_codemirror);\n\t\n\tvar _graphqlType = __webpack_require__(412);\n\t\n\t__webpack_require__(425);\n\t\n\t__webpack_require__(426);\n\t\n\t__webpack_require__(427);\n\t\n\t__webpack_require__(428);\n\t\n\t__webpack_require__(429);\n\t\n\t__webpack_require__(431);\n\t\n\t__webpack_require__(432);\n\t\n\t__webpack_require__(433);\n\t\n\t__webpack_require__(435);\n\t\n\t__webpack_require__(436);\n\t\n\t__webpack_require__(438);\n\t\n\t/**\n\t * QueryEditor\n\t *\n\t * Maintains an instance of CodeMirror responsible for editing a GraphQL query.\n\t *\n\t * Props:\n\t *\n\t *   - schema: A GraphQLSchema instance enabling editor linting and hinting.\n\t *   - value: The text of the editor.\n\t *   - onEdit: A function called when the editor changes, given the edited text.\n\t *\n\t */\n\t\n\tvar QueryEditor = (function (_React$Component) {\n\t  _inherits(QueryEditor, _React$Component);\n\t\n\t  _createClass(QueryEditor, null, [{\n\t    key: 'propTypes',\n\t    value: {\n\t      schema: _react.PropTypes.instanceOf(_graphqlType.GraphQLSchema),\n\t      value: _react.PropTypes.string,\n\t      onEdit: _react.PropTypes.func\n\t    },\n\t    enumerable: true\n\t  }]);\n\t\n\t  function QueryEditor(props) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, QueryEditor);\n\t\n\t    _React$Component.call(this);\n\t\n\t    // Keep a cached version of the value, this cache will be updated when the\n\t    // editor is updated, which can later be used to protect the editor from\n\t    // unnecessary updates during the update lifecycle.\n\t\n\t    this._onKeyUp = function (cm, event) {\n\t      var code = event.keyCode;\n\t      if (code >= 65 && code <= 90 || // letters\n\t      !event.shiftKey && code >= 48 && code <= 57 || // numbers\n\t      event.shiftKey && code === 189 || // underscore\n\t      event.shiftKey && code === 50 || // @\n\t      event.shiftKey && code === 57 // (\n\t      ) {\n\t          _this.editor.execCommand('autocomplete');\n\t        }\n\t    };\n\t\n\t    this._onEdit = function () {\n\t      if (!_this.ignoreChangeEvent) {\n\t        _this.cachedValue = _this.editor.getValue();\n\t        if (_this.props.onEdit) {\n\t          _this.props.onEdit(_this.cachedValue);\n\t        }\n\t      }\n\t    };\n\t\n\t    this._onHasCompletion = function (cm, data) {\n\t      var wrapper;\n\t      var information;\n\t\n\t      // When a hint result is selected, we touch the UI.\n\t      _codemirror2['default'].on(data, 'select', function (ctx, el) {\n\t        // Only the first time (usually when the hint UI is first displayed)\n\t        // do we create the wrapping node.\n\t        if (!wrapper) {\n\t          // Wrap the existing hint UI, so we have a place to put information.\n\t          var hintsUl = el.parentNode;\n\t          var container = hintsUl.parentNode;\n\t          wrapper = document.createElement('div');\n\t          container.appendChild(wrapper);\n\t\n\t          // CodeMirror vertically inverts the hint UI if there is not enough\n\t          // space below the cursor. Since this modified UI appends to the bottom\n\t          // of CodeMirror's existing UI, it could cover the cursor. This adjusts\n\t          // the positioning of the hint UI to accomodate.\n\t          var top = hintsUl.style.top;\n\t          var bottom = '';\n\t          var cursorTop = cm.cursorCoords().top;\n\t          if (parseInt(top, 10) < cursorTop) {\n\t            top = '';\n\t            bottom = window.innerHeight - cursorTop + 3 + 'px';\n\t          }\n\t\n\t          // Style the wrapper, remove positioning from hints. Note that usage\n\t          // of this option will need to specify CSS to remove some styles from\n\t          // the existing hint UI.\n\t          wrapper.className = 'CodeMirror-hints-wrapper';\n\t          wrapper.style.left = hintsUl.style.left;\n\t          wrapper.style.top = top;\n\t          wrapper.style.bottom = bottom;\n\t          hintsUl.style.left = '';\n\t          hintsUl.style.top = '';\n\t\n\t          // This \"information\" node will contain the additional info about the\n\t          // highlighted typeahead option.\n\t          information = document.createElement('div');\n\t          information.className = 'CodeMirror-hint-information';\n\t          if (bottom) {\n\t            wrapper.appendChild(information);\n\t            wrapper.appendChild(hintsUl);\n\t          } else {\n\t            wrapper.appendChild(hintsUl);\n\t            wrapper.appendChild(information);\n\t          }\n\t\n\t          // When CodeMirror attempts to remove the hint UI, we detect that it was\n\t          // removed from our wrapper and in turn remove the wrapper from the\n\t          // original container.\n\t          var onRemoveFn;\n\t          wrapper.addEventListener('DOMNodeRemoved', onRemoveFn = function (event) {\n\t            if (event.target === hintsUl) {\n\t              wrapper.removeEventListener('DOMNodeRemoved', onRemoveFn);\n\t              wrapper.parentNode.removeChild(wrapper);\n\t              wrapper = null;\n\t              information = null;\n\t              onRemoveFn = null;\n\t            }\n\t          });\n\t        }\n\t\n\t        // Now that the UI has been set up, add info to information.\n\t        var description = ctx.description ? _marked2['default'](ctx.description, { smartypants: true }) : 'Self descriptive.';\n\t        var type = ctx.type ? '<span class=\"infoType\">' + renderType(ctx.type) + '</span>' : '';\n\t\n\t        information.innerHTML = '<div class=\"content\">' + (description.slice(0, 3) === '<p>' ? '<p>' + type + description.slice(3) : type + description) + '</div>';\n\t\n\t        // Additional rendering?\n\t        var onHintInformationRender = _this.props.onHintInformationRender;\n\t        if (onHintInformationRender) {\n\t          onHintInformationRender(information);\n\t        }\n\t      });\n\t    };\n\t\n\t    this.cachedValue = props.value || '';\n\t  }\n\t\n\t  /**\n\t   * Public API for retrieving the CodeMirror instance from this\n\t   * React component.\n\t   */\n\t\n\t  QueryEditor.prototype.getCodeMirror = function getCodeMirror() {\n\t    return this.editor;\n\t  };\n\t\n\t  QueryEditor.prototype.componentDidMount = function componentDidMount() {\n\t    var _this2 = this;\n\t\n\t    this.editor = _codemirror2['default'](_reactDom2['default'].findDOMNode(this), {\n\t      value: this.props.value || '',\n\t      lineNumbers: true,\n\t      tabSize: 2,\n\t      mode: 'graphql',\n\t      theme: 'graphiql',\n\t      keyMap: 'sublime',\n\t      autoCloseBrackets: true,\n\t      matchBrackets: true,\n\t      showCursorWhenSelecting: true,\n\t      foldGutter: {\n\t        minFoldSize: 4\n\t      },\n\t      lint: {\n\t        schema: this.props.schema\n\t      },\n\t      hintOptions: {\n\t        schema: this.props.schema,\n\t        closeOnUnfocus: false,\n\t        completeSingle: false\n\t      },\n\t      gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n\t      extraKeys: {\n\t        'Cmd-Space': function CmdSpace() {\n\t          return _this2.editor.showHint({ completeSingle: true });\n\t        },\n\t        'Ctrl-Space': function CtrlSpace() {\n\t          return _this2.editor.showHint({ completeSingle: true });\n\t        },\n\t\n\t        // Editor improvements\n\t        'Ctrl-Left': 'goSubwordLeft',\n\t        'Ctrl-Right': 'goSubwordRight',\n\t        'Alt-Left': 'goGroupLeft',\n\t        'Alt-Right': 'goGroupRight'\n\t      }\n\t    });\n\t\n\t    this.editor.on('change', this._onEdit);\n\t    this.editor.on('keyup', this._onKeyUp);\n\t    this.editor.on('hasCompletion', this._onHasCompletion);\n\t  };\n\t\n\t  QueryEditor.prototype.componentWillUnmount = function componentWillUnmount() {\n\t    this.editor.off('change', this._onEdit);\n\t    this.editor.off('keyup', this._onKeyUp);\n\t    this.editor.off('hasCompletion', this._onHasCompletion);\n\t    this.editor = null;\n\t  };\n\t\n\t  QueryEditor.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n\t    // Ensure the changes caused by this update are not interpretted as\n\t    // user-input changes which could otherwise result in an infinite\n\t    // event loop.\n\t    this.ignoreChangeEvent = true;\n\t    if (this.props.schema !== prevProps.schema) {\n\t      this.editor.options.lint.schema = this.props.schema;\n\t      this.editor.options.hintOptions.schema = this.props.schema;\n\t      _codemirror2['default'].signal(this.editor, 'change', this.editor);\n\t    }\n\t    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {\n\t      this.cachedValue = this.props.value;\n\t      this.editor.setValue(this.props.value);\n\t    }\n\t    this.ignoreChangeEvent = false;\n\t  };\n\t\n\t  QueryEditor.prototype.render = function render() {\n\t    return _react2['default'].createElement('div', { className: 'query-editor' });\n\t  };\n\t\n\t  return QueryEditor;\n\t})(_react2['default'].Component);\n\t\n\texports.QueryEditor = QueryEditor;\n\t\n\tfunction renderType(type) {\n\t  if (type instanceof _graphqlType.GraphQLNonNull) {\n\t    return renderType(type.ofType) + '!';\n\t  }\n\t  if (type instanceof _graphqlType.GraphQLList) {\n\t    return '[' + renderType(type.ofType) + ']';\n\t  }\n\t  return '<a class=\"typeName\">' + type.name + '</a>';\n\t}\n\t\n\t/**\n\t * Render a custom UI for CodeMirror's hint which includes additional info\n\t * about the type and description for the selected context.\n\t */\n\n/***/ },\n/* 424 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * marked - a markdown parser\n\t * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n\t * https://github.com/chjj/marked\n\t */\n\t\n\t;(function() {\n\t\n\t/**\n\t * Block-Level Grammar\n\t */\n\t\n\tvar block = {\n\t  newline: /^\\n+/,\n\t  code: /^( {4}[^\\n]+\\n*)+/,\n\t  fences: noop,\n\t  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n\t  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n\t  nptable: noop,\n\t  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n\t  blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\n\t  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n\t  html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\n\t  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n\t  table: noop,\n\t  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n\t  text: /^[^\\n]+/\n\t};\n\t\n\tblock.bullet = /(?:[*+-]|\\d+\\.)/;\n\tblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\n\tblock.item = replace(block.item, 'gm')\n\t  (/bull/g, block.bullet)\n\t  ();\n\t\n\tblock.list = replace(block.list)\n\t  (/bull/g, block.bullet)\n\t  ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\n\t  ('def', '\\\\n+(?=' + block.def.source + ')')\n\t  ();\n\t\n\tblock.blockquote = replace(block.blockquote)\n\t  ('def', block.def)\n\t  ();\n\t\n\tblock._tag = '(?!(?:'\n\t  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\n\t  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\n\t  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\n\t\n\tblock.html = replace(block.html)\n\t  ('comment', /<!--[\\s\\S]*?-->/)\n\t  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n\t  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n\t  (/tag/g, block._tag)\n\t  ();\n\t\n\tblock.paragraph = replace(block.paragraph)\n\t  ('hr', block.hr)\n\t  ('heading', block.heading)\n\t  ('lheading', block.lheading)\n\t  ('blockquote', block.blockquote)\n\t  ('tag', '<' + block._tag)\n\t  ('def', block.def)\n\t  ();\n\t\n\t/**\n\t * Normal Block Grammar\n\t */\n\t\n\tblock.normal = merge({}, block);\n\t\n\t/**\n\t * GFM Block Grammar\n\t */\n\t\n\tblock.gfm = merge({}, block.normal, {\n\t  fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\n\t  paragraph: /^/,\n\t  heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\n\t});\n\t\n\tblock.gfm.paragraph = replace(block.paragraph)\n\t  ('(?!', '(?!'\n\t    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\n\t    + block.list.source.replace('\\\\1', '\\\\3') + '|')\n\t  ();\n\t\n\t/**\n\t * GFM + Tables Block Grammar\n\t */\n\t\n\tblock.tables = merge({}, block.gfm, {\n\t  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n\t  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\n\t});\n\t\n\t/**\n\t * Block Lexer\n\t */\n\t\n\tfunction Lexer(options) {\n\t  this.tokens = [];\n\t  this.tokens.links = {};\n\t  this.options = options || marked.defaults;\n\t  this.rules = block.normal;\n\t\n\t  if (this.options.gfm) {\n\t    if (this.options.tables) {\n\t      this.rules = block.tables;\n\t    } else {\n\t      this.rules = block.gfm;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Expose Block Rules\n\t */\n\t\n\tLexer.rules = block;\n\t\n\t/**\n\t * Static Lex Method\n\t */\n\t\n\tLexer.lex = function(src, options) {\n\t  var lexer = new Lexer(options);\n\t  return lexer.lex(src);\n\t};\n\t\n\t/**\n\t * Preprocessing\n\t */\n\t\n\tLexer.prototype.lex = function(src) {\n\t  src = src\n\t    .replace(/\\r\\n|\\r/g, '\\n')\n\t    .replace(/\\t/g, '    ')\n\t    .replace(/\\u00a0/g, ' ')\n\t    .replace(/\\u2424/g, '\\n');\n\t\n\t  return this.token(src, true);\n\t};\n\t\n\t/**\n\t * Lexing\n\t */\n\t\n\tLexer.prototype.token = function(src, top, bq) {\n\t  var src = src.replace(/^ +$/gm, '')\n\t    , next\n\t    , loose\n\t    , cap\n\t    , bull\n\t    , b\n\t    , item\n\t    , space\n\t    , i\n\t    , l;\n\t\n\t  while (src) {\n\t    // newline\n\t    if (cap = this.rules.newline.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      if (cap[0].length > 1) {\n\t        this.tokens.push({\n\t          type: 'space'\n\t        });\n\t      }\n\t    }\n\t\n\t    // code\n\t    if (cap = this.rules.code.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      cap = cap[0].replace(/^ {4}/gm, '');\n\t      this.tokens.push({\n\t        type: 'code',\n\t        text: !this.options.pedantic\n\t          ? cap.replace(/\\n+$/, '')\n\t          : cap\n\t      });\n\t      continue;\n\t    }\n\t\n\t    // fences (gfm)\n\t    if (cap = this.rules.fences.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      this.tokens.push({\n\t        type: 'code',\n\t        lang: cap[2],\n\t        text: cap[3] || ''\n\t      });\n\t      continue;\n\t    }\n\t\n\t    // heading\n\t    if (cap = this.rules.heading.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      this.tokens.push({\n\t        type: 'heading',\n\t        depth: cap[1].length,\n\t        text: cap[2]\n\t      });\n\t      continue;\n\t    }\n\t\n\t    // table no leading pipe (gfm)\n\t    if (top && (cap = this.rules.nptable.exec(src))) {\n\t      src = src.substring(cap[0].length);\n\t\n\t      item = {\n\t        type: 'table',\n\t        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n\t        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n\t        cells: cap[3].replace(/\\n$/, '').split('\\n')\n\t      };\n\t\n\t      for (i = 0; i < item.align.length; i++) {\n\t        if (/^ *-+: *$/.test(item.align[i])) {\n\t          item.align[i] = 'right';\n\t        } else if (/^ *:-+: *$/.test(item.align[i])) {\n\t          item.align[i] = 'center';\n\t        } else if (/^ *:-+ *$/.test(item.align[i])) {\n\t          item.align[i] = 'left';\n\t        } else {\n\t          item.align[i] = null;\n\t        }\n\t      }\n\t\n\t      for (i = 0; i < item.cells.length; i++) {\n\t        item.cells[i] = item.cells[i].split(/ *\\| */);\n\t      }\n\t\n\t      this.tokens.push(item);\n\t\n\t      continue;\n\t    }\n\t\n\t    // lheading\n\t    if (cap = this.rules.lheading.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      this.tokens.push({\n\t        type: 'heading',\n\t        depth: cap[2] === '=' ? 1 : 2,\n\t        text: cap[1]\n\t      });\n\t      continue;\n\t    }\n\t\n\t    // hr\n\t    if (cap = this.rules.hr.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      this.tokens.push({\n\t        type: 'hr'\n\t      });\n\t      continue;\n\t    }\n\t\n\t    // blockquote\n\t    if (cap = this.rules.blockquote.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t\n\t      this.tokens.push({\n\t        type: 'blockquote_start'\n\t      });\n\t\n\t      cap = cap[0].replace(/^ *> ?/gm, '');\n\t\n\t      // Pass `top` to keep the current\n\t      // \"toplevel\" state. This is exactly\n\t      // how markdown.pl works.\n\t      this.token(cap, top, true);\n\t\n\t      this.tokens.push({\n\t        type: 'blockquote_end'\n\t      });\n\t\n\t      continue;\n\t    }\n\t\n\t    // list\n\t    if (cap = this.rules.list.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      bull = cap[2];\n\t\n\t      this.tokens.push({\n\t        type: 'list_start',\n\t        ordered: bull.length > 1\n\t      });\n\t\n\t      // Get each top-level item.\n\t      cap = cap[0].match(this.rules.item);\n\t\n\t      next = false;\n\t      l = cap.length;\n\t      i = 0;\n\t\n\t      for (; i < l; i++) {\n\t        item = cap[i];\n\t\n\t        // Remove the list item's bullet\n\t        // so it is seen as the next token.\n\t        space = item.length;\n\t        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\t\n\t        // Outdent whatever the\n\t        // list item contains. Hacky.\n\t        if (~item.indexOf('\\n ')) {\n\t          space -= item.length;\n\t          item = !this.options.pedantic\n\t            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n\t            : item.replace(/^ {1,4}/gm, '');\n\t        }\n\t\n\t        // Determine whether the next list item belongs here.\n\t        // Backpedal if it does not belong in this list.\n\t        if (this.options.smartLists && i !== l - 1) {\n\t          b = block.bullet.exec(cap[i + 1])[0];\n\t          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n\t            src = cap.slice(i + 1).join('\\n') + src;\n\t            i = l - 1;\n\t          }\n\t        }\n\t\n\t        // Determine whether item is loose or not.\n\t        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n\t        // for discount behavior.\n\t        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\t        if (i !== l - 1) {\n\t          next = item.charAt(item.length - 1) === '\\n';\n\t          if (!loose) loose = next;\n\t        }\n\t\n\t        this.tokens.push({\n\t          type: loose\n\t            ? 'loose_item_start'\n\t            : 'list_item_start'\n\t        });\n\t\n\t        // Recurse.\n\t        this.token(item, false, bq);\n\t\n\t        this.tokens.push({\n\t          type: 'list_item_end'\n\t        });\n\t      }\n\t\n\t      this.tokens.push({\n\t        type: 'list_end'\n\t      });\n\t\n\t      continue;\n\t    }\n\t\n\t    // html\n\t    if (cap = this.rules.html.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      this.tokens.push({\n\t        type: this.options.sanitize\n\t          ? 'paragraph'\n\t          : 'html',\n\t        pre: !this.options.sanitizer\n\t          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n\t        text: cap[0]\n\t      });\n\t      continue;\n\t    }\n\t\n\t    // def\n\t    if ((!bq && top) && (cap = this.rules.def.exec(src))) {\n\t      src = src.substring(cap[0].length);\n\t      this.tokens.links[cap[1].toLowerCase()] = {\n\t        href: cap[2],\n\t        title: cap[3]\n\t      };\n\t      continue;\n\t    }\n\t\n\t    // table (gfm)\n\t    if (top && (cap = this.rules.table.exec(src))) {\n\t      src = src.substring(cap[0].length);\n\t\n\t      item = {\n\t        type: 'table',\n\t        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n\t        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n\t        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\n\t      };\n\t\n\t      for (i = 0; i < item.align.length; i++) {\n\t        if (/^ *-+: *$/.test(item.align[i])) {\n\t          item.align[i] = 'right';\n\t        } else if (/^ *:-+: *$/.test(item.align[i])) {\n\t          item.align[i] = 'center';\n\t        } else if (/^ *:-+ *$/.test(item.align[i])) {\n\t          item.align[i] = 'left';\n\t        } else {\n\t          item.align[i] = null;\n\t        }\n\t      }\n\t\n\t      for (i = 0; i < item.cells.length; i++) {\n\t        item.cells[i] = item.cells[i]\n\t          .replace(/^ *\\| *| *\\| *$/g, '')\n\t          .split(/ *\\| */);\n\t      }\n\t\n\t      this.tokens.push(item);\n\t\n\t      continue;\n\t    }\n\t\n\t    // top-level paragraph\n\t    if (top && (cap = this.rules.paragraph.exec(src))) {\n\t      src = src.substring(cap[0].length);\n\t      this.tokens.push({\n\t        type: 'paragraph',\n\t        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n\t          ? cap[1].slice(0, -1)\n\t          : cap[1]\n\t      });\n\t      continue;\n\t    }\n\t\n\t    // text\n\t    if (cap = this.rules.text.exec(src)) {\n\t      // Top-level should never reach here.\n\t      src = src.substring(cap[0].length);\n\t      this.tokens.push({\n\t        type: 'text',\n\t        text: cap[0]\n\t      });\n\t      continue;\n\t    }\n\t\n\t    if (src) {\n\t      throw new\n\t        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n\t    }\n\t  }\n\t\n\t  return this.tokens;\n\t};\n\t\n\t/**\n\t * Inline-Level Grammar\n\t */\n\t\n\tvar inline = {\n\t  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n\t  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\n\t  url: noop,\n\t  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\n\t  link: /^!?\\[(inside)\\]\\(href\\)/,\n\t  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n\t  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n\t  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n\t  em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n\t  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n\t  br: /^ {2,}\\n(?!\\s*$)/,\n\t  del: noop,\n\t  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\n\t};\n\t\n\tinline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\n\tinline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\n\t\n\tinline.link = replace(inline.link)\n\t  ('inside', inline._inside)\n\t  ('href', inline._href)\n\t  ();\n\t\n\tinline.reflink = replace(inline.reflink)\n\t  ('inside', inline._inside)\n\t  ();\n\t\n\t/**\n\t * Normal Inline Grammar\n\t */\n\t\n\tinline.normal = merge({}, inline);\n\t\n\t/**\n\t * Pedantic Inline Grammar\n\t */\n\t\n\tinline.pedantic = merge({}, inline.normal, {\n\t  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n\t  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\n\t});\n\t\n\t/**\n\t * GFM Inline Grammar\n\t */\n\t\n\tinline.gfm = merge({}, inline.normal, {\n\t  escape: replace(inline.escape)('])', '~|])')(),\n\t  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n\t  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n\t  text: replace(inline.text)\n\t    (']|', '~]|')\n\t    ('|', '|https?://|')\n\t    ()\n\t});\n\t\n\t/**\n\t * GFM + Line Breaks Inline Grammar\n\t */\n\t\n\tinline.breaks = merge({}, inline.gfm, {\n\t  br: replace(inline.br)('{2,}', '*')(),\n\t  text: replace(inline.gfm.text)('{2,}', '*')()\n\t});\n\t\n\t/**\n\t * Inline Lexer & Compiler\n\t */\n\t\n\tfunction InlineLexer(links, options) {\n\t  this.options = options || marked.defaults;\n\t  this.links = links;\n\t  this.rules = inline.normal;\n\t  this.renderer = this.options.renderer || new Renderer;\n\t  this.renderer.options = this.options;\n\t\n\t  if (!this.links) {\n\t    throw new\n\t      Error('Tokens array requires a `links` property.');\n\t  }\n\t\n\t  if (this.options.gfm) {\n\t    if (this.options.breaks) {\n\t      this.rules = inline.breaks;\n\t    } else {\n\t      this.rules = inline.gfm;\n\t    }\n\t  } else if (this.options.pedantic) {\n\t    this.rules = inline.pedantic;\n\t  }\n\t}\n\t\n\t/**\n\t * Expose Inline Rules\n\t */\n\t\n\tInlineLexer.rules = inline;\n\t\n\t/**\n\t * Static Lexing/Compiling Method\n\t */\n\t\n\tInlineLexer.output = function(src, links, options) {\n\t  var inline = new InlineLexer(links, options);\n\t  return inline.output(src);\n\t};\n\t\n\t/**\n\t * Lexing/Compiling\n\t */\n\t\n\tInlineLexer.prototype.output = function(src) {\n\t  var out = ''\n\t    , link\n\t    , text\n\t    , href\n\t    , cap;\n\t\n\t  while (src) {\n\t    // escape\n\t    if (cap = this.rules.escape.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      out += cap[1];\n\t      continue;\n\t    }\n\t\n\t    // autolink\n\t    if (cap = this.rules.autolink.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      if (cap[2] === '@') {\n\t        text = cap[1].charAt(6) === ':'\n\t          ? this.mangle(cap[1].substring(7))\n\t          : this.mangle(cap[1]);\n\t        href = this.mangle('mailto:') + text;\n\t      } else {\n\t        text = escape(cap[1]);\n\t        href = text;\n\t      }\n\t      out += this.renderer.link(href, null, text);\n\t      continue;\n\t    }\n\t\n\t    // url (gfm)\n\t    if (!this.inLink && (cap = this.rules.url.exec(src))) {\n\t      src = src.substring(cap[0].length);\n\t      text = escape(cap[1]);\n\t      href = text;\n\t      out += this.renderer.link(href, null, text);\n\t      continue;\n\t    }\n\t\n\t    // tag\n\t    if (cap = this.rules.tag.exec(src)) {\n\t      if (!this.inLink && /^<a /i.test(cap[0])) {\n\t        this.inLink = true;\n\t      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n\t        this.inLink = false;\n\t      }\n\t      src = src.substring(cap[0].length);\n\t      out += this.options.sanitize\n\t        ? this.options.sanitizer\n\t          ? this.options.sanitizer(cap[0])\n\t          : escape(cap[0])\n\t        : cap[0]\n\t      continue;\n\t    }\n\t\n\t    // link\n\t    if (cap = this.rules.link.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      this.inLink = true;\n\t      out += this.outputLink(cap, {\n\t        href: cap[2],\n\t        title: cap[3]\n\t      });\n\t      this.inLink = false;\n\t      continue;\n\t    }\n\t\n\t    // reflink, nolink\n\t    if ((cap = this.rules.reflink.exec(src))\n\t        || (cap = this.rules.nolink.exec(src))) {\n\t      src = src.substring(cap[0].length);\n\t      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n\t      link = this.links[link.toLowerCase()];\n\t      if (!link || !link.href) {\n\t        out += cap[0].charAt(0);\n\t        src = cap[0].substring(1) + src;\n\t        continue;\n\t      }\n\t      this.inLink = true;\n\t      out += this.outputLink(cap, link);\n\t      this.inLink = false;\n\t      continue;\n\t    }\n\t\n\t    // strong\n\t    if (cap = this.rules.strong.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      out += this.renderer.strong(this.output(cap[2] || cap[1]));\n\t      continue;\n\t    }\n\t\n\t    // em\n\t    if (cap = this.rules.em.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      out += this.renderer.em(this.output(cap[2] || cap[1]));\n\t      continue;\n\t    }\n\t\n\t    // code\n\t    if (cap = this.rules.code.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      out += this.renderer.codespan(escape(cap[2], true));\n\t      continue;\n\t    }\n\t\n\t    // br\n\t    if (cap = this.rules.br.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      out += this.renderer.br();\n\t      continue;\n\t    }\n\t\n\t    // del (gfm)\n\t    if (cap = this.rules.del.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      out += this.renderer.del(this.output(cap[1]));\n\t      continue;\n\t    }\n\t\n\t    // text\n\t    if (cap = this.rules.text.exec(src)) {\n\t      src = src.substring(cap[0].length);\n\t      out += this.renderer.text(escape(this.smartypants(cap[0])));\n\t      continue;\n\t    }\n\t\n\t    if (src) {\n\t      throw new\n\t        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n\t    }\n\t  }\n\t\n\t  return out;\n\t};\n\t\n\t/**\n\t * Compile Link\n\t */\n\t\n\tInlineLexer.prototype.outputLink = function(cap, link) {\n\t  var href = escape(link.href)\n\t    , title = link.title ? escape(link.title) : null;\n\t\n\t  return cap[0].charAt(0) !== '!'\n\t    ? this.renderer.link(href, title, this.output(cap[1]))\n\t    : this.renderer.image(href, title, escape(cap[1]));\n\t};\n\t\n\t/**\n\t * Smartypants Transformations\n\t */\n\t\n\tInlineLexer.prototype.smartypants = function(text) {\n\t  if (!this.options.smartypants) return text;\n\t  return text\n\t    // em-dashes\n\t    .replace(/---/g, '\\u2014')\n\t    // en-dashes\n\t    .replace(/--/g, '\\u2013')\n\t    // opening singles\n\t    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n\t    // closing singles & apostrophes\n\t    .replace(/'/g, '\\u2019')\n\t    // opening doubles\n\t    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n\t    // closing doubles\n\t    .replace(/\"/g, '\\u201d')\n\t    // ellipses\n\t    .replace(/\\.{3}/g, '\\u2026');\n\t};\n\t\n\t/**\n\t * Mangle Links\n\t */\n\t\n\tInlineLexer.prototype.mangle = function(text) {\n\t  if (!this.options.mangle) return text;\n\t  var out = ''\n\t    , l = text.length\n\t    , i = 0\n\t    , ch;\n\t\n\t  for (; i < l; i++) {\n\t    ch = text.charCodeAt(i);\n\t    if (Math.random() > 0.5) {\n\t      ch = 'x' + ch.toString(16);\n\t    }\n\t    out += '&#' + ch + ';';\n\t  }\n\t\n\t  return out;\n\t};\n\t\n\t/**\n\t * Renderer\n\t */\n\t\n\tfunction Renderer(options) {\n\t  this.options = options || {};\n\t}\n\t\n\tRenderer.prototype.code = function(code, lang, escaped) {\n\t  if (this.options.highlight) {\n\t    var out = this.options.highlight(code, lang);\n\t    if (out != null && out !== code) {\n\t      escaped = true;\n\t      code = out;\n\t    }\n\t  }\n\t\n\t  if (!lang) {\n\t    return '<pre><code>'\n\t      + (escaped ? code : escape(code, true))\n\t      + '\\n</code></pre>';\n\t  }\n\t\n\t  return '<pre><code class=\"'\n\t    + this.options.langPrefix\n\t    + escape(lang, true)\n\t    + '\">'\n\t    + (escaped ? code : escape(code, true))\n\t    + '\\n</code></pre>\\n';\n\t};\n\t\n\tRenderer.prototype.blockquote = function(quote) {\n\t  return '<blockquote>\\n' + quote + '</blockquote>\\n';\n\t};\n\t\n\tRenderer.prototype.html = function(html) {\n\t  return html;\n\t};\n\t\n\tRenderer.prototype.heading = function(text, level, raw) {\n\t  return '<h'\n\t    + level\n\t    + ' id=\"'\n\t    + this.options.headerPrefix\n\t    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\n\t    + '\">'\n\t    + text\n\t    + '</h'\n\t    + level\n\t    + '>\\n';\n\t};\n\t\n\tRenderer.prototype.hr = function() {\n\t  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n\t};\n\t\n\tRenderer.prototype.list = function(body, ordered) {\n\t  var type = ordered ? 'ol' : 'ul';\n\t  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\n\t};\n\t\n\tRenderer.prototype.listitem = function(text) {\n\t  return '<li>' + text + '</li>\\n';\n\t};\n\t\n\tRenderer.prototype.paragraph = function(text) {\n\t  return '<p>' + text + '</p>\\n';\n\t};\n\t\n\tRenderer.prototype.table = function(header, body) {\n\t  return '<table>\\n'\n\t    + '<thead>\\n'\n\t    + header\n\t    + '</thead>\\n'\n\t    + '<tbody>\\n'\n\t    + body\n\t    + '</tbody>\\n'\n\t    + '</table>\\n';\n\t};\n\t\n\tRenderer.prototype.tablerow = function(content) {\n\t  return '<tr>\\n' + content + '</tr>\\n';\n\t};\n\t\n\tRenderer.prototype.tablecell = function(content, flags) {\n\t  var type = flags.header ? 'th' : 'td';\n\t  var tag = flags.align\n\t    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\n\t    : '<' + type + '>';\n\t  return tag + content + '</' + type + '>\\n';\n\t};\n\t\n\t// span level renderer\n\tRenderer.prototype.strong = function(text) {\n\t  return '<strong>' + text + '</strong>';\n\t};\n\t\n\tRenderer.prototype.em = function(text) {\n\t  return '<em>' + text + '</em>';\n\t};\n\t\n\tRenderer.prototype.codespan = function(text) {\n\t  return '<code>' + text + '</code>';\n\t};\n\t\n\tRenderer.prototype.br = function() {\n\t  return this.options.xhtml ? '<br/>' : '<br>';\n\t};\n\t\n\tRenderer.prototype.del = function(text) {\n\t  return '<del>' + text + '</del>';\n\t};\n\t\n\tRenderer.prototype.link = function(href, title, text) {\n\t  if (this.options.sanitize) {\n\t    try {\n\t      var prot = decodeURIComponent(unescape(href))\n\t        .replace(/[^\\w:]/g, '')\n\t        .toLowerCase();\n\t    } catch (e) {\n\t      return '';\n\t    }\n\t    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {\n\t      return '';\n\t    }\n\t  }\n\t  var out = '<a href=\"' + href + '\"';\n\t  if (title) {\n\t    out += ' title=\"' + title + '\"';\n\t  }\n\t  out += '>' + text + '</a>';\n\t  return out;\n\t};\n\t\n\tRenderer.prototype.image = function(href, title, text) {\n\t  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\t  if (title) {\n\t    out += ' title=\"' + title + '\"';\n\t  }\n\t  out += this.options.xhtml ? '/>' : '>';\n\t  return out;\n\t};\n\t\n\tRenderer.prototype.text = function(text) {\n\t  return text;\n\t};\n\t\n\t/**\n\t * Parsing & Compiling\n\t */\n\t\n\tfunction Parser(options) {\n\t  this.tokens = [];\n\t  this.token = null;\n\t  this.options = options || marked.defaults;\n\t  this.options.renderer = this.options.renderer || new Renderer;\n\t  this.renderer = this.options.renderer;\n\t  this.renderer.options = this.options;\n\t}\n\t\n\t/**\n\t * Static Parse Method\n\t */\n\t\n\tParser.parse = function(src, options, renderer) {\n\t  var parser = new Parser(options, renderer);\n\t  return parser.parse(src);\n\t};\n\t\n\t/**\n\t * Parse Loop\n\t */\n\t\n\tParser.prototype.parse = function(src) {\n\t  this.inline = new InlineLexer(src.links, this.options, this.renderer);\n\t  this.tokens = src.reverse();\n\t\n\t  var out = '';\n\t  while (this.next()) {\n\t    out += this.tok();\n\t  }\n\t\n\t  return out;\n\t};\n\t\n\t/**\n\t * Next Token\n\t */\n\t\n\tParser.prototype.next = function() {\n\t  return this.token = this.tokens.pop();\n\t};\n\t\n\t/**\n\t * Preview Next Token\n\t */\n\t\n\tParser.prototype.peek = function() {\n\t  return this.tokens[this.tokens.length - 1] || 0;\n\t};\n\t\n\t/**\n\t * Parse Text Tokens\n\t */\n\t\n\tParser.prototype.parseText = function() {\n\t  var body = this.token.text;\n\t\n\t  while (this.peek().type === 'text') {\n\t    body += '\\n' + this.next().text;\n\t  }\n\t\n\t  return this.inline.output(body);\n\t};\n\t\n\t/**\n\t * Parse Current Token\n\t */\n\t\n\tParser.prototype.tok = function() {\n\t  switch (this.token.type) {\n\t    case 'space': {\n\t      return '';\n\t    }\n\t    case 'hr': {\n\t      return this.renderer.hr();\n\t    }\n\t    case 'heading': {\n\t      return this.renderer.heading(\n\t        this.inline.output(this.token.text),\n\t        this.token.depth,\n\t        this.token.text);\n\t    }\n\t    case 'code': {\n\t      return this.renderer.code(this.token.text,\n\t        this.token.lang,\n\t        this.token.escaped);\n\t    }\n\t    case 'table': {\n\t      var header = ''\n\t        , body = ''\n\t        , i\n\t        , row\n\t        , cell\n\t        , flags\n\t        , j;\n\t\n\t      // header\n\t      cell = '';\n\t      for (i = 0; i < this.token.header.length; i++) {\n\t        flags = { header: true, align: this.token.align[i] };\n\t        cell += this.renderer.tablecell(\n\t          this.inline.output(this.token.header[i]),\n\t          { header: true, align: this.token.align[i] }\n\t        );\n\t      }\n\t      header += this.renderer.tablerow(cell);\n\t\n\t      for (i = 0; i < this.token.cells.length; i++) {\n\t        row = this.token.cells[i];\n\t\n\t        cell = '';\n\t        for (j = 0; j < row.length; j++) {\n\t          cell += this.renderer.tablecell(\n\t            this.inline.output(row[j]),\n\t            { header: false, align: this.token.align[j] }\n\t          );\n\t        }\n\t\n\t        body += this.renderer.tablerow(cell);\n\t      }\n\t      return this.renderer.table(header, body);\n\t    }\n\t    case 'blockquote_start': {\n\t      var body = '';\n\t\n\t      while (this.next().type !== 'blockquote_end') {\n\t        body += this.tok();\n\t      }\n\t\n\t      return this.renderer.blockquote(body);\n\t    }\n\t    case 'list_start': {\n\t      var body = ''\n\t        , ordered = this.token.ordered;\n\t\n\t      while (this.next().type !== 'list_end') {\n\t        body += this.tok();\n\t      }\n\t\n\t      return this.renderer.list(body, ordered);\n\t    }\n\t    case 'list_item_start': {\n\t      var body = '';\n\t\n\t      while (this.next().type !== 'list_item_end') {\n\t        body += this.token.type === 'text'\n\t          ? this.parseText()\n\t          : this.tok();\n\t      }\n\t\n\t      return this.renderer.listitem(body);\n\t    }\n\t    case 'loose_item_start': {\n\t      var body = '';\n\t\n\t      while (this.next().type !== 'list_item_end') {\n\t        body += this.tok();\n\t      }\n\t\n\t      return this.renderer.listitem(body);\n\t    }\n\t    case 'html': {\n\t      var html = !this.token.pre && !this.options.pedantic\n\t        ? this.inline.output(this.token.text)\n\t        : this.token.text;\n\t      return this.renderer.html(html);\n\t    }\n\t    case 'paragraph': {\n\t      return this.renderer.paragraph(this.inline.output(this.token.text));\n\t    }\n\t    case 'text': {\n\t      return this.renderer.paragraph(this.parseText());\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Helpers\n\t */\n\t\n\tfunction escape(html, encode) {\n\t  return html\n\t    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n\t    .replace(/</g, '&lt;')\n\t    .replace(/>/g, '&gt;')\n\t    .replace(/\"/g, '&quot;')\n\t    .replace(/'/g, '&#39;');\n\t}\n\t\n\tfunction unescape(html) {\n\t  return html.replace(/&([#\\w]+);/g, function(_, n) {\n\t    n = n.toLowerCase();\n\t    if (n === 'colon') return ':';\n\t    if (n.charAt(0) === '#') {\n\t      return n.charAt(1) === 'x'\n\t        ? String.fromCharCode(parseInt(n.substring(2), 16))\n\t        : String.fromCharCode(+n.substring(1));\n\t    }\n\t    return '';\n\t  });\n\t}\n\t\n\tfunction replace(regex, opt) {\n\t  regex = regex.source;\n\t  opt = opt || '';\n\t  return function self(name, val) {\n\t    if (!name) return new RegExp(regex, opt);\n\t    val = val.source || val;\n\t    val = val.replace(/(^|[^\\[])\\^/g, '$1');\n\t    regex = regex.replace(name, val);\n\t    return self;\n\t  };\n\t}\n\t\n\tfunction noop() {}\n\tnoop.exec = noop;\n\t\n\tfunction merge(obj) {\n\t  var i = 1\n\t    , target\n\t    , key;\n\t\n\t  for (; i < arguments.length; i++) {\n\t    target = arguments[i];\n\t    for (key in target) {\n\t      if (Object.prototype.hasOwnProperty.call(target, key)) {\n\t        obj[key] = target[key];\n\t      }\n\t    }\n\t  }\n\t\n\t  return obj;\n\t}\n\t\n\t\n\t/**\n\t * Marked\n\t */\n\t\n\tfunction marked(src, opt, callback) {\n\t  if (callback || typeof opt === 'function') {\n\t    if (!callback) {\n\t      callback = opt;\n\t      opt = null;\n\t    }\n\t\n\t    opt = merge({}, marked.defaults, opt || {});\n\t\n\t    var highlight = opt.highlight\n\t      , tokens\n\t      , pending\n\t      , i = 0;\n\t\n\t    try {\n\t      tokens = Lexer.lex(src, opt)\n\t    } catch (e) {\n\t      return callback(e);\n\t    }\n\t\n\t    pending = tokens.length;\n\t\n\t    var done = function(err) {\n\t      if (err) {\n\t        opt.highlight = highlight;\n\t        return callback(err);\n\t      }\n\t\n\t      var out;\n\t\n\t      try {\n\t        out = Parser.parse(tokens, opt);\n\t      } catch (e) {\n\t        err = e;\n\t      }\n\t\n\t      opt.highlight = highlight;\n\t\n\t      return err\n\t        ? callback(err)\n\t        : callback(null, out);\n\t    };\n\t\n\t    if (!highlight || highlight.length < 3) {\n\t      return done();\n\t    }\n\t\n\t    delete opt.highlight;\n\t\n\t    if (!pending) return done();\n\t\n\t    for (; i < tokens.length; i++) {\n\t      (function(token) {\n\t        if (token.type !== 'code') {\n\t          return --pending || done();\n\t        }\n\t        return highlight(token.text, token.lang, function(err, code) {\n\t          if (err) return done(err);\n\t          if (code == null || code === token.text) {\n\t            return --pending || done();\n\t          }\n\t          token.text = code;\n\t          token.escaped = true;\n\t          --pending || done();\n\t        });\n\t      })(tokens[i]);\n\t    }\n\t\n\t    return;\n\t  }\n\t  try {\n\t    if (opt) opt = merge({}, marked.defaults, opt);\n\t    return Parser.parse(Lexer.lex(src, opt), opt);\n\t  } catch (e) {\n\t    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\n\t    if ((opt || marked.defaults).silent) {\n\t      return '<p>An error occured:</p><pre>'\n\t        + escape(e.message + '', true)\n\t        + '</pre>';\n\t    }\n\t    throw e;\n\t  }\n\t}\n\t\n\t/**\n\t * Options\n\t */\n\t\n\tmarked.options =\n\tmarked.setOptions = function(opt) {\n\t  merge(marked.defaults, opt);\n\t  return marked;\n\t};\n\t\n\tmarked.defaults = {\n\t  gfm: true,\n\t  tables: true,\n\t  breaks: false,\n\t  pedantic: false,\n\t  sanitize: false,\n\t  sanitizer: null,\n\t  mangle: true,\n\t  smartLists: false,\n\t  silent: false,\n\t  highlight: null,\n\t  langPrefix: 'lang-',\n\t  smartypants: false,\n\t  headerPrefix: '',\n\t  renderer: new Renderer,\n\t  xhtml: false\n\t};\n\t\n\t/**\n\t * Expose\n\t */\n\t\n\tmarked.Parser = Parser;\n\tmarked.parser = Parser.parse;\n\t\n\tmarked.Renderer = Renderer;\n\t\n\tmarked.Lexer = Lexer;\n\tmarked.lexer = Lexer.lex;\n\t\n\tmarked.InlineLexer = InlineLexer;\n\tmarked.inlineLexer = InlineLexer.output;\n\t\n\tmarked.parse = marked;\n\t\n\tif (true) {\n\t  module.exports = marked;\n\t} else if (typeof define === 'function' && define.amd) {\n\t  define(function() { return marked; });\n\t} else {\n\t  this.marked = marked;\n\t}\n\t\n\t}).call(function() {\n\t  return this || (typeof window !== 'undefined' ? window : global);\n\t}());\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 425 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n\t  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\t\n\t  // This is the old interface, kept around for now to stay\n\t  // backwards-compatible.\n\t  CodeMirror.showHint = function(cm, getHints, options) {\n\t    if (!getHints) return cm.showHint(options);\n\t    if (options && options.async) getHints.async = true;\n\t    var newOpts = {hint: getHints};\n\t    if (options) for (var prop in options) newOpts[prop] = options[prop];\n\t    return cm.showHint(newOpts);\n\t  };\n\t\n\t  CodeMirror.defineExtension(\"showHint\", function(options) {\n\t    options = parseOptions(this, this.getCursor(\"start\"), options);\n\t    var selections = this.listSelections()\n\t    if (selections.length > 1) return;\n\t    // By default, don't allow completion when something is selected.\n\t    // A hint function can have a `supportsSelection` property to\n\t    // indicate that it can handle selections.\n\t    if (this.somethingSelected()) {\n\t      if (!options.hint.supportsSelection) return;\n\t      // Don't try with cross-line selections\n\t      for (var i = 0; i < selections.length; i++)\n\t        if (selections[i].head.line != selections[i].anchor.line) return;\n\t    }\n\t\n\t    if (this.state.completionActive) this.state.completionActive.close();\n\t    var completion = this.state.completionActive = new Completion(this, options);\n\t    if (!completion.options.hint) return;\n\t\n\t    CodeMirror.signal(this, \"startCompletion\", this);\n\t    completion.update(true);\n\t  });\n\t\n\t  function Completion(cm, options) {\n\t    this.cm = cm;\n\t    this.options = options;\n\t    this.widget = null;\n\t    this.debounce = 0;\n\t    this.tick = 0;\n\t    this.startPos = this.cm.getCursor(\"start\");\n\t    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\t\n\t    var self = this;\n\t    cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n\t  }\n\t\n\t  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n\t    return setTimeout(fn, 1000/60);\n\t  };\n\t  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\t\n\t  Completion.prototype = {\n\t    close: function() {\n\t      if (!this.active()) return;\n\t      this.cm.state.completionActive = null;\n\t      this.tick = null;\n\t      this.cm.off(\"cursorActivity\", this.activityFunc);\n\t\n\t      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n\t      if (this.widget) this.widget.close();\n\t      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n\t    },\n\t\n\t    active: function() {\n\t      return this.cm.state.completionActive == this;\n\t    },\n\t\n\t    pick: function(data, i) {\n\t      var completion = data.list[i];\n\t      if (completion.hint) completion.hint(this.cm, data, completion);\n\t      else this.cm.replaceRange(getText(completion), completion.from || data.from,\n\t                                completion.to || data.to, \"complete\");\n\t      CodeMirror.signal(data, \"pick\", completion);\n\t      this.close();\n\t    },\n\t\n\t    cursorActivity: function() {\n\t      if (this.debounce) {\n\t        cancelAnimationFrame(this.debounce);\n\t        this.debounce = 0;\n\t      }\n\t\n\t      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n\t      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n\t          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||\n\t          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n\t        this.close();\n\t      } else {\n\t        var self = this;\n\t        this.debounce = requestAnimationFrame(function() {self.update();});\n\t        if (this.widget) this.widget.disable();\n\t      }\n\t    },\n\t\n\t    update: function(first) {\n\t      if (this.tick == null) return;\n\t      if (!this.options.hint.async) {\n\t        this.finishUpdate(this.options.hint(this.cm, this.options), first);\n\t      } else {\n\t        var myTick = ++this.tick, self = this;\n\t        this.options.hint(this.cm, function(data) {\n\t          if (self.tick == myTick) self.finishUpdate(data, first);\n\t        }, this.options);\n\t      }\n\t    },\n\t\n\t    finishUpdate: function(data, first) {\n\t      if (this.data) CodeMirror.signal(this.data, \"update\");\n\t      if (data && this.data && CodeMirror.cmpPos(data.from, this.data.from)) data = null;\n\t      this.data = data;\n\t\n\t      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n\t      if (this.widget) this.widget.close();\n\t      if (data && data.list.length) {\n\t        if (picked && data.list.length == 1) {\n\t          this.pick(data, 0);\n\t        } else {\n\t          this.widget = new Widget(this, data);\n\t          CodeMirror.signal(data, \"shown\");\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  function parseOptions(cm, pos, options) {\n\t    var editor = cm.options.hintOptions;\n\t    var out = {};\n\t    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n\t    if (editor) for (var prop in editor)\n\t      if (editor[prop] !== undefined) out[prop] = editor[prop];\n\t    if (options) for (var prop in options)\n\t      if (options[prop] !== undefined) out[prop] = options[prop];\n\t    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n\t    return out;\n\t  }\n\t\n\t  function getText(completion) {\n\t    if (typeof completion == \"string\") return completion;\n\t    else return completion.text;\n\t  }\n\t\n\t  function buildKeyMap(completion, handle) {\n\t    var baseMap = {\n\t      Up: function() {handle.moveFocus(-1);},\n\t      Down: function() {handle.moveFocus(1);},\n\t      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n\t      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n\t      Home: function() {handle.setFocus(0);},\n\t      End: function() {handle.setFocus(handle.length - 1);},\n\t      Enter: handle.pick,\n\t      Tab: handle.pick,\n\t      Esc: handle.close\n\t    };\n\t    var custom = completion.options.customKeys;\n\t    var ourMap = custom ? {} : baseMap;\n\t    function addBinding(key, val) {\n\t      var bound;\n\t      if (typeof val != \"string\")\n\t        bound = function(cm) { return val(cm, handle); };\n\t      // This mechanism is deprecated\n\t      else if (baseMap.hasOwnProperty(val))\n\t        bound = baseMap[val];\n\t      else\n\t        bound = val;\n\t      ourMap[key] = bound;\n\t    }\n\t    if (custom)\n\t      for (var key in custom) if (custom.hasOwnProperty(key))\n\t        addBinding(key, custom[key]);\n\t    var extra = completion.options.extraKeys;\n\t    if (extra)\n\t      for (var key in extra) if (extra.hasOwnProperty(key))\n\t        addBinding(key, extra[key]);\n\t    return ourMap;\n\t  }\n\t\n\t  function getHintElement(hintsElement, el) {\n\t    while (el && el != hintsElement) {\n\t      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n\t      el = el.parentNode;\n\t    }\n\t  }\n\t\n\t  function Widget(completion, data) {\n\t    this.completion = completion;\n\t    this.data = data;\n\t    this.picked = false;\n\t    var widget = this, cm = completion.cm;\n\t\n\t    var hints = this.hints = document.createElement(\"ul\");\n\t    hints.className = \"CodeMirror-hints\";\n\t    this.selectedHint = data.selectedHint || 0;\n\t\n\t    var completions = data.list;\n\t    for (var i = 0; i < completions.length; ++i) {\n\t      var elt = hints.appendChild(document.createElement(\"li\")), cur = completions[i];\n\t      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n\t      if (cur.className != null) className = cur.className + \" \" + className;\n\t      elt.className = className;\n\t      if (cur.render) cur.render(elt, data, cur);\n\t      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));\n\t      elt.hintId = i;\n\t    }\n\t\n\t    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n\t    var left = pos.left, top = pos.bottom, below = true;\n\t    hints.style.left = left + \"px\";\n\t    hints.style.top = top + \"px\";\n\t    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n\t    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);\n\t    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n\t    (completion.options.container || document.body).appendChild(hints);\n\t    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;\n\t    if (overlapY > 0) {\n\t      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);\n\t      if (curTop - height > 0) { // Fits above cursor\n\t        hints.style.top = (top = pos.top - height) + \"px\";\n\t        below = false;\n\t      } else if (height > winH) {\n\t        hints.style.height = (winH - 5) + \"px\";\n\t        hints.style.top = (top = pos.bottom - box.top) + \"px\";\n\t        var cursor = cm.getCursor();\n\t        if (data.from.ch != cursor.ch) {\n\t          pos = cm.cursorCoords(cursor);\n\t          hints.style.left = (left = pos.left) + \"px\";\n\t          box = hints.getBoundingClientRect();\n\t        }\n\t      }\n\t    }\n\t    var overlapX = box.right - winW;\n\t    if (overlapX > 0) {\n\t      if (box.right - box.left > winW) {\n\t        hints.style.width = (winW - 5) + \"px\";\n\t        overlapX -= (box.right - box.left) - winW;\n\t      }\n\t      hints.style.left = (left = pos.left - overlapX) + \"px\";\n\t    }\n\t\n\t    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n\t      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n\t      setFocus: function(n) { widget.changeActive(n); },\n\t      menuSize: function() { return widget.screenAmount(); },\n\t      length: completions.length,\n\t      close: function() { completion.close(); },\n\t      pick: function() { widget.pick(); },\n\t      data: data\n\t    }));\n\t\n\t    if (completion.options.closeOnUnfocus) {\n\t      var closingOnBlur;\n\t      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n\t      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n\t    }\n\t\n\t    var startScroll = cm.getScrollInfo();\n\t    cm.on(\"scroll\", this.onScroll = function() {\n\t      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n\t      var newTop = top + startScroll.top - curScroll.top;\n\t      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n\t      if (!below) point += hints.offsetHeight;\n\t      if (point <= editor.top || point >= editor.bottom) return completion.close();\n\t      hints.style.top = newTop + \"px\";\n\t      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n\t    });\n\t\n\t    CodeMirror.on(hints, \"dblclick\", function(e) {\n\t      var t = getHintElement(hints, e.target || e.srcElement);\n\t      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n\t    });\n\t\n\t    CodeMirror.on(hints, \"click\", function(e) {\n\t      var t = getHintElement(hints, e.target || e.srcElement);\n\t      if (t && t.hintId != null) {\n\t        widget.changeActive(t.hintId);\n\t        if (completion.options.completeOnSingleClick) widget.pick();\n\t      }\n\t    });\n\t\n\t    CodeMirror.on(hints, \"mousedown\", function() {\n\t      setTimeout(function(){cm.focus();}, 20);\n\t    });\n\t\n\t    if (completion.options.completeOnSingleClick)\n\t      CodeMirror.on(hints, \"mousemove\", function(e) {\n\t        var elt = getHintElement(hints, e.target || e.srcElement);\n\t        if (elt && elt.hintId != null)\n\t          widget.changeActive(elt.hintId);\n\t      });\n\t\n\t    CodeMirror.signal(data, \"select\", completions[0], hints.firstChild);\n\t    return true;\n\t  }\n\t\n\t  Widget.prototype = {\n\t    close: function() {\n\t      if (this.completion.widget != this) return;\n\t      this.completion.widget = null;\n\t      this.hints.parentNode.removeChild(this.hints);\n\t      this.completion.cm.removeKeyMap(this.keyMap);\n\t\n\t      var cm = this.completion.cm;\n\t      if (this.completion.options.closeOnUnfocus) {\n\t        cm.off(\"blur\", this.onBlur);\n\t        cm.off(\"focus\", this.onFocus);\n\t      }\n\t      cm.off(\"scroll\", this.onScroll);\n\t    },\n\t\n\t    disable: function() {\n\t      this.completion.cm.removeKeyMap(this.keyMap);\n\t      var widget = this;\n\t      this.keyMap = {Enter: function() { widget.picked = true; }};\n\t      this.completion.cm.addKeyMap(this.keyMap);\n\t    },\n\t\n\t    pick: function() {\n\t      this.completion.pick(this.data, this.selectedHint);\n\t    },\n\t\n\t    changeActive: function(i, avoidWrap) {\n\t      if (i >= this.data.list.length)\n\t        i = avoidWrap ? this.data.list.length - 1 : 0;\n\t      else if (i < 0)\n\t        i = avoidWrap ? 0  : this.data.list.length - 1;\n\t      if (this.selectedHint == i) return;\n\t      var node = this.hints.childNodes[this.selectedHint];\n\t      node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n\t      node = this.hints.childNodes[this.selectedHint = i];\n\t      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n\t      if (node.offsetTop < this.hints.scrollTop)\n\t        this.hints.scrollTop = node.offsetTop - 3;\n\t      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n\t        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;\n\t      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n\t    },\n\t\n\t    screenAmount: function() {\n\t      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n\t    }\n\t  };\n\t\n\t  function applicableHelpers(cm, helpers) {\n\t    if (!cm.somethingSelected()) return helpers\n\t    var result = []\n\t    for (var i = 0; i < helpers.length; i++)\n\t      if (helpers[i].supportsSelection) result.push(helpers[i])\n\t    return result\n\t  }\n\t\n\t  function resolveAutoHints(cm, pos) {\n\t    var helpers = cm.getHelpers(pos, \"hint\"), words\n\t    if (helpers.length) {\n\t      var async = false, resolved\n\t      for (var i = 0; i < helpers.length; i++) if (helpers[i].async) async = true\n\t      if (async) {\n\t        resolved = function(cm, callback, options) {\n\t          var app = applicableHelpers(cm, helpers)\n\t          function run(i, result) {\n\t            if (i == app.length) return callback(null)\n\t            var helper = app[i]\n\t            if (helper.async) {\n\t              helper(cm, function(result) {\n\t                if (result) callback(result)\n\t                else run(i + 1)\n\t              }, options)\n\t            } else {\n\t              var result = helper(cm, options)\n\t              if (result) callback(result)\n\t              else run(i + 1)\n\t            }\n\t          }\n\t          run(0)\n\t        }\n\t        resolved.async = true\n\t      } else {\n\t        resolved = function(cm, options) {\n\t          var app = applicableHelpers(cm, helpers)\n\t          for (var i = 0; i < app.length; i++) {\n\t            var cur = app[i](cm, options)\n\t            if (cur && cur.list.length) return cur\n\t          }\n\t        }\n\t      }\n\t      resolved.supportsSelection = true\n\t      return resolved\n\t    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n\t      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n\t    } else if (CodeMirror.hint.anyword) {\n\t      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n\t    } else {\n\t      return function() {}\n\t    }\n\t  }\n\t\n\t  CodeMirror.registerHelper(\"hint\", \"auto\", {\n\t    resolve: resolveAutoHints\n\t  });\n\t\n\t  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n\t    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n\t    var to = CodeMirror.Pos(cur.line, token.end);\n\t    if (token.string && /\\w/.test(token.string[token.string.length - 1])) {\n\t      var term = token.string, from = CodeMirror.Pos(cur.line, token.start);\n\t    } else {\n\t      var term = \"\", from = to;\n\t    }\n\t    var found = [];\n\t    for (var i = 0; i < options.words.length; i++) {\n\t      var word = options.words[i];\n\t      if (word.slice(0, term.length) == term)\n\t        found.push(word);\n\t    }\n\t\n\t    if (found.length) return {list: found, from: from, to: to};\n\t  });\n\t\n\t  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\t\n\t  var defaultOptions = {\n\t    hint: CodeMirror.hint.auto,\n\t    completeSingle: true,\n\t    alignWithWord: true,\n\t    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n\t    closeOnUnfocus: true,\n\t    completeOnSingleClick: true,\n\t    container: null,\n\t    customKeys: null,\n\t    extraKeys: null\n\t  };\n\t\n\t  CodeMirror.defineOption(\"hintOptions\", null);\n\t});\n\n\n/***/ },\n/* 426 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  var noOptions = {};\n\t  var nonWS = /[^\\s\\u00a0]/;\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  function firstNonWS(str) {\n\t    var found = str.search(nonWS);\n\t    return found == -1 ? 0 : found;\n\t  }\n\t\n\t  CodeMirror.commands.toggleComment = function(cm) {\n\t    cm.toggleComment();\n\t  };\n\t\n\t  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n\t    if (!options) options = noOptions;\n\t    var cm = this;\n\t    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n\t    for (var i = ranges.length - 1; i >= 0; i--) {\n\t      var from = ranges[i].from(), to = ranges[i].to();\n\t      if (from.line >= minLine) continue;\n\t      if (to.line >= minLine) to = Pos(minLine, 0);\n\t      minLine = from.line;\n\t      if (mode == null) {\n\t        if (cm.uncomment(from, to, options)) mode = \"un\";\n\t        else { cm.lineComment(from, to, options); mode = \"line\"; }\n\t      } else if (mode == \"un\") {\n\t        cm.uncomment(from, to, options);\n\t      } else {\n\t        cm.lineComment(from, to, options);\n\t      }\n\t    }\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n\t    if (!options) options = noOptions;\n\t    var self = this, mode = self.getModeAt(from);\n\t    var commentString = options.lineComment || mode.lineComment;\n\t    if (!commentString) {\n\t      if (options.blockCommentStart || mode.blockCommentStart) {\n\t        options.fullLines = true;\n\t        self.blockComment(from, to, options);\n\t      }\n\t      return;\n\t    }\n\t    var firstLine = self.getLine(from.line);\n\t    if (firstLine == null) return;\n\t    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n\t    var pad = options.padding == null ? \" \" : options.padding;\n\t    var blankLines = options.commentBlankLines || from.line == to.line;\n\t\n\t    self.operation(function() {\n\t      if (options.indent) {\n\t        var baseString = null;\n\t        for (var i = from.line; i < end; ++i) {\n\t          var line = self.getLine(i);\n\t          var whitespace = line.slice(0, firstNonWS(line));\n\t          if (baseString == null || baseString.length > whitespace.length) {\n\t            baseString = whitespace;\n\t          }\n\t        }\n\t        for (var i = from.line; i < end; ++i) {\n\t          var line = self.getLine(i), cut = baseString.length;\n\t          if (!blankLines && !nonWS.test(line)) continue;\n\t          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n\t          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n\t        }\n\t      } else {\n\t        for (var i = from.line; i < end; ++i) {\n\t          if (blankLines || nonWS.test(self.getLine(i)))\n\t            self.replaceRange(commentString + pad, Pos(i, 0));\n\t        }\n\t      }\n\t    });\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n\t    if (!options) options = noOptions;\n\t    var self = this, mode = self.getModeAt(from);\n\t    var startString = options.blockCommentStart || mode.blockCommentStart;\n\t    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n\t    if (!startString || !endString) {\n\t      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n\t        self.lineComment(from, to, options);\n\t      return;\n\t    }\n\t\n\t    var end = Math.min(to.line, self.lastLine());\n\t    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\t\n\t    var pad = options.padding == null ? \" \" : options.padding;\n\t    if (from.line > end) return;\n\t\n\t    self.operation(function() {\n\t      if (options.fullLines != false) {\n\t        var lastLineHasText = nonWS.test(self.getLine(end));\n\t        self.replaceRange(pad + endString, Pos(end));\n\t        self.replaceRange(startString + pad, Pos(from.line, 0));\n\t        var lead = options.blockCommentLead || mode.blockCommentLead;\n\t        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n\t          if (i != end || lastLineHasText)\n\t            self.replaceRange(lead + pad, Pos(i, 0));\n\t      } else {\n\t        self.replaceRange(endString, to);\n\t        self.replaceRange(startString, from);\n\t      }\n\t    });\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n\t    if (!options) options = noOptions;\n\t    var self = this, mode = self.getModeAt(from);\n\t    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\t\n\t    // Try finding line comments\n\t    var lineString = options.lineComment || mode.lineComment, lines = [];\n\t    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n\t    lineComment: {\n\t      if (!lineString) break lineComment;\n\t      for (var i = start; i <= end; ++i) {\n\t        var line = self.getLine(i);\n\t        var found = line.indexOf(lineString);\n\t        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n\t        if (found == -1 && (i != end || i == start) && nonWS.test(line)) break lineComment;\n\t        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n\t        lines.push(line);\n\t      }\n\t      self.operation(function() {\n\t        for (var i = start; i <= end; ++i) {\n\t          var line = lines[i - start];\n\t          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n\t          if (pos < 0) continue;\n\t          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n\t          didSomething = true;\n\t          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n\t        }\n\t      });\n\t      if (didSomething) return true;\n\t    }\n\t\n\t    // Try block comments\n\t    var startString = options.blockCommentStart || mode.blockCommentStart;\n\t    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n\t    if (!startString || !endString) return false;\n\t    var lead = options.blockCommentLead || mode.blockCommentLead;\n\t    var startLine = self.getLine(start), endLine = end == start ? startLine : self.getLine(end);\n\t    var open = startLine.indexOf(startString), close = endLine.lastIndexOf(endString);\n\t    if (close == -1 && start != end) {\n\t      endLine = self.getLine(--end);\n\t      close = endLine.lastIndexOf(endString);\n\t    }\n\t    if (open == -1 || close == -1 ||\n\t        !/comment/.test(self.getTokenTypeAt(Pos(start, open + 1))) ||\n\t        !/comment/.test(self.getTokenTypeAt(Pos(end, close + 1))))\n\t      return false;\n\t\n\t    // Avoid killing block comments completely outside the selection.\n\t    // Positions of the last startString before the start of the selection, and the first endString after it.\n\t    var lastStart = startLine.lastIndexOf(startString, from.ch);\n\t    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n\t    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n\t    // Positions of the first endString after the end of the selection, and the last startString before it.\n\t    firstEnd = endLine.indexOf(endString, to.ch);\n\t    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n\t    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n\t    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\t\n\t    self.operation(function() {\n\t      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n\t                        Pos(end, close + endString.length));\n\t      var openEnd = open + startString.length;\n\t      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n\t      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n\t      if (lead) for (var i = start + 1; i <= end; ++i) {\n\t        var line = self.getLine(i), found = line.indexOf(lead);\n\t        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n\t        var foundEnd = found + lead.length;\n\t        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n\t        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n\t      }\n\t    });\n\t    return true;\n\t  });\n\t});\n\n\n/***/ },\n/* 427 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n\t    (document.documentMode == null || document.documentMode < 8);\n\t\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\t\n\t  function findMatchingBracket(cm, where, strict, config) {\n\t    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n\t    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n\t    if (!match) return null;\n\t    var dir = match.charAt(1) == \">\" ? 1 : -1;\n\t    if (strict && (dir > 0) != (pos == where.ch)) return null;\n\t    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\t\n\t    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n\t    if (found == null) return null;\n\t    return {from: Pos(where.line, pos), to: found && found.pos,\n\t            match: found && found.ch == match.charAt(0), forward: dir > 0};\n\t  }\n\t\n\t  // bracketRegex is used to specify which type of bracket to scan\n\t  // should be a regexp, e.g. /[[\\]]/\n\t  //\n\t  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n\t  //\n\t  // Returns false when no bracket was found, null when it reached\n\t  // maxScanLines and gave up\n\t  function scanForBracket(cm, where, dir, style, config) {\n\t    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n\t    var maxScanLines = (config && config.maxScanLines) || 1000;\n\t\n\t    var stack = [];\n\t    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n\t    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n\t                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n\t    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n\t      var line = cm.getLine(lineNo);\n\t      if (!line) continue;\n\t      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n\t      if (line.length > maxScanLen) continue;\n\t      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n\t      for (; pos != end; pos += dir) {\n\t        var ch = line.charAt(pos);\n\t        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n\t          var match = matching[ch];\n\t          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n\t          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n\t          else stack.pop();\n\t        }\n\t      }\n\t    }\n\t    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n\t  }\n\t\n\t  function matchBrackets(cm, autoclear, config) {\n\t    // Disable brace matching in long lines, since it'll cause hugely slow updates\n\t    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n\t    var marks = [], ranges = cm.listSelections();\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\n\t      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n\t        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n\t        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n\t        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n\t          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n\t      }\n\t    }\n\t\n\t    if (marks.length) {\n\t      // Kludge to work around the IE bug from issue #1193, where text\n\t      // input stops going to the textare whever this fires.\n\t      if (ie_lt8 && cm.state.focused) cm.focus();\n\t\n\t      var clear = function() {\n\t        cm.operation(function() {\n\t          for (var i = 0; i < marks.length; i++) marks[i].clear();\n\t        });\n\t      };\n\t      if (autoclear) setTimeout(clear, 800);\n\t      else return clear;\n\t    }\n\t  }\n\t\n\t  var currentlyHighlighted = null;\n\t  function doMatchBrackets(cm) {\n\t    cm.operation(function() {\n\t      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n\t      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n\t    });\n\t  }\n\t\n\t  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n\t    if (old && old != CodeMirror.Init)\n\t      cm.off(\"cursorActivity\", doMatchBrackets);\n\t    if (val) {\n\t      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n\t      cm.on(\"cursorActivity\", doMatchBrackets);\n\t    }\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n\t  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict, config){\n\t    return findMatchingBracket(this, pos, strict, config);\n\t  });\n\t  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n\t    return scanForBracket(this, pos, dir, style, config);\n\t  });\n\t});\n\n\n/***/ },\n/* 428 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  var defaults = {\n\t    pairs: \"()[]{}''\\\"\\\"\",\n\t    triples: \"\",\n\t    explode: \"[]{}\"\n\t  };\n\t\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n\t    if (old && old != CodeMirror.Init) {\n\t      cm.removeKeyMap(keyMap);\n\t      cm.state.closeBrackets = null;\n\t    }\n\t    if (val) {\n\t      cm.state.closeBrackets = val;\n\t      cm.addKeyMap(keyMap);\n\t    }\n\t  });\n\t\n\t  function getOption(conf, name) {\n\t    if (name == \"pairs\" && typeof conf == \"string\") return conf;\n\t    if (typeof conf == \"object\" && conf[name] != null) return conf[name];\n\t    return defaults[name];\n\t  }\n\t\n\t  var bind = defaults.pairs + \"`\";\n\t  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};\n\t  for (var i = 0; i < bind.length; i++)\n\t    keyMap[\"'\" + bind.charAt(i) + \"'\"] = handler(bind.charAt(i));\n\t\n\t  function handler(ch) {\n\t    return function(cm) { return handleChar(cm, ch); };\n\t  }\n\t\n\t  function getConfig(cm) {\n\t    var deflt = cm.state.closeBrackets;\n\t    if (!deflt) return null;\n\t    var mode = cm.getModeAt(cm.getCursor());\n\t    return mode.closeBrackets || deflt;\n\t  }\n\t\n\t  function handleBackspace(cm) {\n\t    var conf = getConfig(cm);\n\t    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\t\n\t    var pairs = getOption(conf, \"pairs\");\n\t    var ranges = cm.listSelections();\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      if (!ranges[i].empty()) return CodeMirror.Pass;\n\t      var around = charsAround(cm, ranges[i].head);\n\t      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n\t    }\n\t    for (var i = ranges.length - 1; i >= 0; i--) {\n\t      var cur = ranges[i].head;\n\t      cm.replaceRange(\"\", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n\t    }\n\t  }\n\t\n\t  function handleEnter(cm) {\n\t    var conf = getConfig(cm);\n\t    var explode = conf && getOption(conf, \"explode\");\n\t    if (!explode || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\t\n\t    var ranges = cm.listSelections();\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      if (!ranges[i].empty()) return CodeMirror.Pass;\n\t      var around = charsAround(cm, ranges[i].head);\n\t      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n\t    }\n\t    cm.operation(function() {\n\t      cm.replaceSelection(\"\\n\\n\", null);\n\t      cm.execCommand(\"goCharLeft\");\n\t      ranges = cm.listSelections();\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var line = ranges[i].head.line;\n\t        cm.indentLine(line, null, true);\n\t        cm.indentLine(line + 1, null, true);\n\t      }\n\t    });\n\t  }\n\t\n\t  function contractSelection(sel) {\n\t    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n\t    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n\t            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};\n\t  }\n\t\n\t  function handleChar(cm, ch) {\n\t    var conf = getConfig(cm);\n\t    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\t\n\t    var pairs = getOption(conf, \"pairs\");\n\t    var pos = pairs.indexOf(ch);\n\t    if (pos == -1) return CodeMirror.Pass;\n\t    var triples = getOption(conf, \"triples\");\n\t\n\t    var identical = pairs.charAt(pos + 1) == ch;\n\t    var ranges = cm.listSelections();\n\t    var opening = pos % 2 == 0;\n\t\n\t    var type, next;\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i], cur = range.head, curType;\n\t      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n\t      if (opening && !range.empty()) {\n\t        curType = \"surround\";\n\t      } else if ((identical || !opening) && next == ch) {\n\t        if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n\t          curType = \"skipThree\";\n\t        else\n\t          curType = \"skip\";\n\t      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&\n\t                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch &&\n\t                 (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != ch)) {\n\t        curType = \"addFour\";\n\t      } else if (identical) {\n\t        if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, ch)) curType = \"both\";\n\t        else return CodeMirror.Pass;\n\t      } else if (opening && (cm.getLine(cur.line).length == cur.ch ||\n\t                             isClosingBracket(next, pairs) ||\n\t                             /\\s/.test(next))) {\n\t        curType = \"both\";\n\t      } else {\n\t        return CodeMirror.Pass;\n\t      }\n\t      if (!type) type = curType;\n\t      else if (type != curType) return CodeMirror.Pass;\n\t    }\n\t\n\t    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n\t    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n\t    cm.operation(function() {\n\t      if (type == \"skip\") {\n\t        cm.execCommand(\"goCharRight\");\n\t      } else if (type == \"skipThree\") {\n\t        for (var i = 0; i < 3; i++)\n\t          cm.execCommand(\"goCharRight\");\n\t      } else if (type == \"surround\") {\n\t        var sels = cm.getSelections();\n\t        for (var i = 0; i < sels.length; i++)\n\t          sels[i] = left + sels[i] + right;\n\t        cm.replaceSelections(sels, \"around\");\n\t        sels = cm.listSelections().slice();\n\t        for (var i = 0; i < sels.length; i++)\n\t          sels[i] = contractSelection(sels[i]);\n\t        cm.setSelections(sels);\n\t      } else if (type == \"both\") {\n\t        cm.replaceSelection(left + right, null);\n\t        cm.triggerElectric(left + right);\n\t        cm.execCommand(\"goCharLeft\");\n\t      } else if (type == \"addFour\") {\n\t        cm.replaceSelection(left + left + left + left, \"before\");\n\t        cm.execCommand(\"goCharRight\");\n\t      }\n\t    });\n\t  }\n\t\n\t  function isClosingBracket(ch, pairs) {\n\t    var pos = pairs.lastIndexOf(ch);\n\t    return pos > -1 && pos % 2 == 1;\n\t  }\n\t\n\t  function charsAround(cm, pos) {\n\t    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\n\t                          Pos(pos.line, pos.ch + 1));\n\t    return str.length == 2 ? str : null;\n\t  }\n\t\n\t  // Project the token type that will exists after the given char is\n\t  // typed, and use it to determine whether it would cause the start\n\t  // of a string token.\n\t  function enteringString(cm, pos, ch) {\n\t    var line = cm.getLine(pos.line);\n\t    var token = cm.getTokenAt(pos);\n\t    if (/\\bstring2?\\b/.test(token.type)) return false;\n\t    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);\n\t    stream.pos = stream.start = token.start;\n\t    for (;;) {\n\t      var type1 = cm.getMode().token(stream, token.state);\n\t      if (stream.pos >= pos.ch + 1) return /\\bstring2?\\b/.test(type1);\n\t      stream.start = stream.pos;\n\t    }\n\t  }\n\t});\n\n\n/***/ },\n/* 429 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351), __webpack_require__(430));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n\t    if (old && old != CodeMirror.Init) {\n\t      cm.clearGutter(cm.state.foldGutter.options.gutter);\n\t      cm.state.foldGutter = null;\n\t      cm.off(\"gutterClick\", onGutterClick);\n\t      cm.off(\"change\", onChange);\n\t      cm.off(\"viewportChange\", onViewportChange);\n\t      cm.off(\"fold\", onFold);\n\t      cm.off(\"unfold\", onFold);\n\t      cm.off(\"swapDoc\", updateInViewport);\n\t    }\n\t    if (val) {\n\t      cm.state.foldGutter = new State(parseOptions(val));\n\t      updateInViewport(cm);\n\t      cm.on(\"gutterClick\", onGutterClick);\n\t      cm.on(\"change\", onChange);\n\t      cm.on(\"viewportChange\", onViewportChange);\n\t      cm.on(\"fold\", onFold);\n\t      cm.on(\"unfold\", onFold);\n\t      cm.on(\"swapDoc\", updateInViewport);\n\t    }\n\t  });\n\t\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  function State(options) {\n\t    this.options = options;\n\t    this.from = this.to = 0;\n\t  }\n\t\n\t  function parseOptions(opts) {\n\t    if (opts === true) opts = {};\n\t    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n\t    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n\t    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n\t    return opts;\n\t  }\n\t\n\t  function isFolded(cm, line) {\n\t    var marks = cm.findMarksAt(Pos(line));\n\t    for (var i = 0; i < marks.length; ++i)\n\t      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];\n\t  }\n\t\n\t  function marker(spec) {\n\t    if (typeof spec == \"string\") {\n\t      var elt = document.createElement(\"div\");\n\t      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n\t      return elt;\n\t    } else {\n\t      return spec.cloneNode(true);\n\t    }\n\t  }\n\t\n\t  function updateFoldInfo(cm, from, to) {\n\t    var opts = cm.state.foldGutter.options, cur = from;\n\t    var minSize = cm.foldOption(opts, \"minFoldSize\");\n\t    var func = cm.foldOption(opts, \"rangeFinder\");\n\t    cm.eachLine(from, to, function(line) {\n\t      var mark = null;\n\t      if (isFolded(cm, cur)) {\n\t        mark = marker(opts.indicatorFolded);\n\t      } else {\n\t        var pos = Pos(cur, 0);\n\t        var range = func && func(cm, pos);\n\t        if (range && range.to.line - range.from.line >= minSize)\n\t          mark = marker(opts.indicatorOpen);\n\t      }\n\t      cm.setGutterMarker(line, opts.gutter, mark);\n\t      ++cur;\n\t    });\n\t  }\n\t\n\t  function updateInViewport(cm) {\n\t    var vp = cm.getViewport(), state = cm.state.foldGutter;\n\t    if (!state) return;\n\t    cm.operation(function() {\n\t      updateFoldInfo(cm, vp.from, vp.to);\n\t    });\n\t    state.from = vp.from; state.to = vp.to;\n\t  }\n\t\n\t  function onGutterClick(cm, line, gutter) {\n\t    var state = cm.state.foldGutter;\n\t    if (!state) return;\n\t    var opts = state.options;\n\t    if (gutter != opts.gutter) return;\n\t    var folded = isFolded(cm, line);\n\t    if (folded) folded.clear();\n\t    else cm.foldCode(Pos(line, 0), opts.rangeFinder);\n\t  }\n\t\n\t  function onChange(cm) {\n\t    var state = cm.state.foldGutter;\n\t    if (!state) return;\n\t    var opts = state.options;\n\t    state.from = state.to = 0;\n\t    clearTimeout(state.changeUpdate);\n\t    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n\t  }\n\t\n\t  function onViewportChange(cm) {\n\t    var state = cm.state.foldGutter;\n\t    if (!state) return;\n\t    var opts = state.options;\n\t    clearTimeout(state.changeUpdate);\n\t    state.changeUpdate = setTimeout(function() {\n\t      var vp = cm.getViewport();\n\t      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n\t        updateInViewport(cm);\n\t      } else {\n\t        cm.operation(function() {\n\t          if (vp.from < state.from) {\n\t            updateFoldInfo(cm, vp.from, state.from);\n\t            state.from = vp.from;\n\t          }\n\t          if (vp.to > state.to) {\n\t            updateFoldInfo(cm, state.to, vp.to);\n\t            state.to = vp.to;\n\t          }\n\t        });\n\t      }\n\t    }, opts.updateViewportTimeSpan || 400);\n\t  }\n\t\n\t  function onFold(cm, from) {\n\t    var state = cm.state.foldGutter;\n\t    if (!state) return;\n\t    var line = from.line;\n\t    if (line >= state.from && line < state.to)\n\t      updateFoldInfo(cm, line, line + 1);\n\t  }\n\t});\n\n\n/***/ },\n/* 430 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  function doFold(cm, pos, options, force) {\n\t    if (options && options.call) {\n\t      var finder = options;\n\t      options = null;\n\t    } else {\n\t      var finder = getOption(cm, options, \"rangeFinder\");\n\t    }\n\t    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n\t    var minSize = getOption(cm, options, \"minFoldSize\");\n\t\n\t    function getRange(allowFolded) {\n\t      var range = finder(cm, pos);\n\t      if (!range || range.to.line - range.from.line < minSize) return null;\n\t      var marks = cm.findMarksAt(range.from);\n\t      for (var i = 0; i < marks.length; ++i) {\n\t        if (marks[i].__isFold && force !== \"fold\") {\n\t          if (!allowFolded) return null;\n\t          range.cleared = true;\n\t          marks[i].clear();\n\t        }\n\t      }\n\t      return range;\n\t    }\n\t\n\t    var range = getRange(true);\n\t    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n\t      pos = CodeMirror.Pos(pos.line - 1, 0);\n\t      range = getRange(false);\n\t    }\n\t    if (!range || range.cleared || force === \"unfold\") return;\n\t\n\t    var myWidget = makeWidget(cm, options);\n\t    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n\t      myRange.clear();\n\t      CodeMirror.e_preventDefault(e);\n\t    });\n\t    var myRange = cm.markText(range.from, range.to, {\n\t      replacedWith: myWidget,\n\t      clearOnEnter: true,\n\t      __isFold: true\n\t    });\n\t    myRange.on(\"clear\", function(from, to) {\n\t      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n\t    });\n\t    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n\t  }\n\t\n\t  function makeWidget(cm, options) {\n\t    var widget = getOption(cm, options, \"widget\");\n\t    if (typeof widget == \"string\") {\n\t      var text = document.createTextNode(widget);\n\t      widget = document.createElement(\"span\");\n\t      widget.appendChild(text);\n\t      widget.className = \"CodeMirror-foldmarker\";\n\t    }\n\t    return widget;\n\t  }\n\t\n\t  // Clumsy backwards-compatible interface\n\t  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n\t    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n\t  };\n\t\n\t  // New-style interface\n\t  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n\t    doFold(this, pos, options, force);\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n\t    var marks = this.findMarksAt(pos);\n\t    for (var i = 0; i < marks.length; ++i)\n\t      if (marks[i].__isFold) return true;\n\t  });\n\t\n\t  CodeMirror.commands.toggleFold = function(cm) {\n\t    cm.foldCode(cm.getCursor());\n\t  };\n\t  CodeMirror.commands.fold = function(cm) {\n\t    cm.foldCode(cm.getCursor(), null, \"fold\");\n\t  };\n\t  CodeMirror.commands.unfold = function(cm) {\n\t    cm.foldCode(cm.getCursor(), null, \"unfold\");\n\t  };\n\t  CodeMirror.commands.foldAll = function(cm) {\n\t    cm.operation(function() {\n\t      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n\t        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n\t    });\n\t  };\n\t  CodeMirror.commands.unfoldAll = function(cm) {\n\t    cm.operation(function() {\n\t      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n\t        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\n\t    });\n\t  };\n\t\n\t  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n\t    var funcs = Array.prototype.slice.call(arguments, 0);\n\t    return function(cm, start) {\n\t      for (var i = 0; i < funcs.length; ++i) {\n\t        var found = funcs[i](cm, start);\n\t        if (found) return found;\n\t      }\n\t    };\n\t  });\n\t\n\t  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n\t    var helpers = cm.getHelpers(start, \"fold\");\n\t    for (var i = 0; i < helpers.length; i++) {\n\t      var cur = helpers[i](cm, start);\n\t      if (cur) return cur;\n\t    }\n\t  });\n\t\n\t  var defaultOptions = {\n\t    rangeFinder: CodeMirror.fold.auto,\n\t    widget: \"\\u2194\",\n\t    minFoldSize: 0,\n\t    scanUp: false\n\t  };\n\t\n\t  CodeMirror.defineOption(\"foldOptions\", null);\n\t\n\t  function getOption(cm, options, name) {\n\t    if (options && options[name] !== undefined)\n\t      return options[name];\n\t    var editorOptions = cm.options.foldOptions;\n\t    if (editorOptions && editorOptions[name] !== undefined)\n\t      return editorOptions[name];\n\t    return defaultOptions[name];\n\t  }\n\t\n\t  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n\t    return getOption(this, options, name);\n\t  });\n\t});\n\n\n/***/ },\n/* 431 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n\t  var line = start.line, lineText = cm.getLine(line);\n\t  var startCh, tokenType;\n\t\n\t  function findOpening(openCh) {\n\t    for (var at = start.ch, pass = 0;;) {\n\t      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n\t      if (found == -1) {\n\t        if (pass == 1) break;\n\t        pass = 1;\n\t        at = lineText.length;\n\t        continue;\n\t      }\n\t      if (pass == 1 && found < start.ch) break;\n\t      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n\t      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n\t      at = found - 1;\n\t    }\n\t  }\n\t\n\t  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\n\t  if (startCh == null) {\n\t    startToken = \"[\", endToken = \"]\";\n\t    startCh = findOpening(\"[\");\n\t  }\n\t\n\t  if (startCh == null) return;\n\t  var count = 1, lastLine = cm.lastLine(), end, endCh;\n\t  outer: for (var i = line; i <= lastLine; ++i) {\n\t    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n\t    for (;;) {\n\t      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n\t      if (nextOpen < 0) nextOpen = text.length;\n\t      if (nextClose < 0) nextClose = text.length;\n\t      pos = Math.min(nextOpen, nextClose);\n\t      if (pos == text.length) break;\n\t      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n\t        if (pos == nextOpen) ++count;\n\t        else if (!--count) { end = i; endCh = pos; break outer; }\n\t      }\n\t      ++pos;\n\t    }\n\t  }\n\t  if (end == null || line == end && endCh == startCh) return;\n\t  return {from: CodeMirror.Pos(line, startCh),\n\t          to: CodeMirror.Pos(end, endCh)};\n\t});\n\t\n\tCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n\t  function hasImport(line) {\n\t    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n\t    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n\t    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n\t    if (start.type != \"keyword\" || start.string != \"import\") return null;\n\t    // Now find closing semicolon, return its position\n\t    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n\t      var text = cm.getLine(i), semi = text.indexOf(\";\");\n\t      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n\t    }\n\t  }\n\t\n\t  var start = start.line, has = hasImport(start), prev;\n\t  if (!has || hasImport(start - 1) || ((prev = hasImport(start - 2)) && prev.end.line == start - 1))\n\t    return null;\n\t  for (var end = has.end;;) {\n\t    var next = hasImport(end.line + 1);\n\t    if (next == null) break;\n\t    end = next.end;\n\t  }\n\t  return {from: cm.clipPos(CodeMirror.Pos(start, has.startCh + 1)), to: end};\n\t});\n\t\n\tCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n\t  function hasInclude(line) {\n\t    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n\t    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n\t    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n\t    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n\t  }\n\t\n\t  var start = start.line, has = hasInclude(start);\n\t  if (has == null || hasInclude(start - 1) != null) return null;\n\t  for (var end = start;;) {\n\t    var next = hasInclude(end + 1);\n\t    if (next == null) break;\n\t    ++end;\n\t  }\n\t  return {from: CodeMirror.Pos(start, has + 1),\n\t          to: cm.clipPos(CodeMirror.Pos(end))};\n\t});\n\t\n\t});\n\n\n/***/ },\n/* 432 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t  var GUTTER_ID = \"CodeMirror-lint-markers\";\n\t\n\t  function showTooltip(e, content) {\n\t    var tt = document.createElement(\"div\");\n\t    tt.className = \"CodeMirror-lint-tooltip\";\n\t    tt.appendChild(content.cloneNode(true));\n\t    document.body.appendChild(tt);\n\t\n\t    function position(e) {\n\t      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n\t      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n\t      tt.style.left = (e.clientX + 5) + \"px\";\n\t    }\n\t    CodeMirror.on(document, \"mousemove\", position);\n\t    position(e);\n\t    if (tt.style.opacity != null) tt.style.opacity = 1;\n\t    return tt;\n\t  }\n\t  function rm(elt) {\n\t    if (elt.parentNode) elt.parentNode.removeChild(elt);\n\t  }\n\t  function hideTooltip(tt) {\n\t    if (!tt.parentNode) return;\n\t    if (tt.style.opacity == null) rm(tt);\n\t    tt.style.opacity = 0;\n\t    setTimeout(function() { rm(tt); }, 600);\n\t  }\n\t\n\t  function showTooltipFor(e, content, node) {\n\t    var tooltip = showTooltip(e, content);\n\t    function hide() {\n\t      CodeMirror.off(node, \"mouseout\", hide);\n\t      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n\t    }\n\t    var poll = setInterval(function() {\n\t      if (tooltip) for (var n = node;; n = n.parentNode) {\n\t        if (n && n.nodeType == 11) n = n.host;\n\t        if (n == document.body) return;\n\t        if (!n) { hide(); break; }\n\t      }\n\t      if (!tooltip) return clearInterval(poll);\n\t    }, 400);\n\t    CodeMirror.on(node, \"mouseout\", hide);\n\t  }\n\t\n\t  function LintState(cm, options, hasGutter) {\n\t    this.marked = [];\n\t    this.options = options;\n\t    this.timeout = null;\n\t    this.hasGutter = hasGutter;\n\t    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n\t    this.waitingFor = 0\n\t  }\n\t\n\t  function parseOptions(_cm, options) {\n\t    if (options instanceof Function) return {getAnnotations: options};\n\t    if (!options || options === true) options = {};\n\t    return options;\n\t  }\n\t\n\t  function clearMarks(cm) {\n\t    var state = cm.state.lint;\n\t    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n\t    for (var i = 0; i < state.marked.length; ++i)\n\t      state.marked[i].clear();\n\t    state.marked.length = 0;\n\t  }\n\t\n\t  function makeMarker(labels, severity, multiple, tooltips) {\n\t    var marker = document.createElement(\"div\"), inner = marker;\n\t    marker.className = \"CodeMirror-lint-marker-\" + severity;\n\t    if (multiple) {\n\t      inner = marker.appendChild(document.createElement(\"div\"));\n\t      inner.className = \"CodeMirror-lint-marker-multiple\";\n\t    }\n\t\n\t    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n\t      showTooltipFor(e, labels, inner);\n\t    });\n\t\n\t    return marker;\n\t  }\n\t\n\t  function getMaxSeverity(a, b) {\n\t    if (a == \"error\") return a;\n\t    else return b;\n\t  }\n\t\n\t  function groupByLine(annotations) {\n\t    var lines = [];\n\t    for (var i = 0; i < annotations.length; ++i) {\n\t      var ann = annotations[i], line = ann.from.line;\n\t      (lines[line] || (lines[line] = [])).push(ann);\n\t    }\n\t    return lines;\n\t  }\n\t\n\t  function annotationTooltip(ann) {\n\t    var severity = ann.severity;\n\t    if (!severity) severity = \"error\";\n\t    var tip = document.createElement(\"div\");\n\t    tip.className = \"CodeMirror-lint-message-\" + severity;\n\t    tip.appendChild(document.createTextNode(ann.message));\n\t    return tip;\n\t  }\n\t\n\t  function lintAsync(cm, getAnnotations, passOptions) {\n\t    var state = cm.state.lint\n\t    var id = ++state.waitingFor\n\t    function abort() {\n\t      id = -1\n\t      cm.off(\"change\", abort)\n\t    }\n\t    cm.on(\"change\", abort)\n\t    getAnnotations(cm.getValue(), function(annotations, arg2) {\n\t      cm.off(\"change\", abort)\n\t      if (state.waitingFor != id) return\n\t      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n\t      updateLinting(cm, annotations)\n\t    }, passOptions, cm);\n\t  }\n\t\n\t  function startLinting(cm) {\n\t    var state = cm.state.lint, options = state.options;\n\t    var passOptions = options.options || options; // Support deprecated passing of `options` property in options\n\t    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n\t    if (!getAnnotations) return;\n\t    if (options.async || getAnnotations.async) {\n\t      lintAsync(cm, getAnnotations, passOptions)\n\t    } else {\n\t      updateLinting(cm, getAnnotations(cm.getValue(), passOptions, cm));\n\t    }\n\t  }\n\t\n\t  function updateLinting(cm, annotationsNotSorted) {\n\t    clearMarks(cm);\n\t    var state = cm.state.lint, options = state.options;\n\t\n\t    var annotations = groupByLine(annotationsNotSorted);\n\t\n\t    for (var line = 0; line < annotations.length; ++line) {\n\t      var anns = annotations[line];\n\t      if (!anns) continue;\n\t\n\t      var maxSeverity = null;\n\t      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\t\n\t      for (var i = 0; i < anns.length; ++i) {\n\t        var ann = anns[i];\n\t        var severity = ann.severity;\n\t        if (!severity) severity = \"error\";\n\t        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\t\n\t        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n\t        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\t\n\t        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n\t          className: \"CodeMirror-lint-mark-\" + severity,\n\t          __annotation: ann\n\t        }));\n\t      }\n\t\n\t      if (state.hasGutter)\n\t        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,\n\t                                                       state.options.tooltips));\n\t    }\n\t    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n\t  }\n\t\n\t  function onChange(cm) {\n\t    var state = cm.state.lint;\n\t    if (!state) return;\n\t    clearTimeout(state.timeout);\n\t    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);\n\t  }\n\t\n\t  function popupSpanTooltip(ann, e) {\n\t    var target = e.target || e.srcElement;\n\t    showTooltipFor(e, annotationTooltip(ann), target);\n\t  }\n\t\n\t  function onMouseOver(cm, e) {\n\t    var target = e.target || e.srcElement;\n\t    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n\t    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n\t    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n\t    for (var i = 0; i < spans.length; ++i) {\n\t      var ann = spans[i].__annotation;\n\t      if (ann) return popupSpanTooltip(ann, e);\n\t    }\n\t  }\n\t\n\t  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n\t    if (old && old != CodeMirror.Init) {\n\t      clearMarks(cm);\n\t      if (cm.state.lint.options.lintOnChange !== false)\n\t        cm.off(\"change\", onChange);\n\t      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n\t      clearTimeout(cm.state.lint.timeout);\n\t      delete cm.state.lint;\n\t    }\n\t\n\t    if (val) {\n\t      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n\t      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n\t      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);\n\t      if (state.options.lintOnChange !== false)\n\t        cm.on(\"change\", onChange);\n\t      if (state.options.tooltips != false)\n\t        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\t\n\t      startLinting(cm);\n\t    }\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"performLint\", function() {\n\t    if (this.state.lint) startLinting(this);\n\t  });\n\t});\n\n\n/***/ },\n/* 433 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// A rough approximation of Sublime Text's keybindings\n\t// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351), __webpack_require__(434), __webpack_require__(427));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n\t  var cmds = CodeMirror.commands;\n\t  var Pos = CodeMirror.Pos;\n\t  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n\t  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\t\n\t  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n\t  function findPosSubword(doc, start, dir) {\n\t    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n\t    var line = doc.getLine(start.line);\n\t    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n\t    var state = \"start\", type;\n\t    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n\t      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n\t      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n\t      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n\t      if (state == \"start\") {\n\t        if (cat != \"o\") { state = \"in\"; type = cat; }\n\t      } else if (state == \"in\") {\n\t        if (type != cat) {\n\t          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n\t          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    return Pos(start.line, pos);\n\t  }\n\t\n\t  function moveSubword(cm, dir) {\n\t    cm.extendSelectionsBy(function(range) {\n\t      if (cm.display.shift || cm.doc.extend || range.empty())\n\t        return findPosSubword(cm.doc, range.head, dir);\n\t      else\n\t        return dir < 0 ? range.from() : range.to();\n\t    });\n\t  }\n\t\n\t  cmds[map[\"Alt-Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n\t  cmds[map[\"Alt-Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\t\n\t  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\t\n\t  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n\t    var info = cm.getScrollInfo();\n\t    if (!cm.somethingSelected()) {\n\t      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n\t      if (cm.getCursor().line >= visibleBottomLine)\n\t        cm.execCommand(\"goLineUp\");\n\t    }\n\t    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n\t  };\n\t  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n\t    var info = cm.getScrollInfo();\n\t    if (!cm.somethingSelected()) {\n\t      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n\t      if (cm.getCursor().line <= visibleTopLine)\n\t        cm.execCommand(\"goLineDown\");\n\t    }\n\t    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n\t  };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n\t    var ranges = cm.listSelections(), lineRanges = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var from = ranges[i].from(), to = ranges[i].to();\n\t      for (var line = from.line; line <= to.line; ++line)\n\t        if (!(to.line > from.line && line == to.line && to.ch == 0))\n\t          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n\t                           head: line == to.line ? to : Pos(line)});\n\t    }\n\t    cm.setSelections(lineRanges, 0);\n\t  };\n\t\n\t  map[\"Shift-Tab\"] = \"indentLess\";\n\t\n\t  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n\t    var range = cm.listSelections()[0];\n\t    cm.setSelection(range.anchor, range.head, {scroll: false});\n\t  };\n\t\n\t  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n\t    var ranges = cm.listSelections(), extended = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i];\n\t      extended.push({anchor: Pos(range.from().line, 0),\n\t                     head: Pos(range.to().line + 1, 0)});\n\t    }\n\t    cm.setSelections(extended);\n\t  };\n\t\n\t  map[\"Shift-\" + ctrl + \"K\"] = \"deleteLine\";\n\t\n\t  function insertLine(cm, above) {\n\t    cm.operation(function() {\n\t      var len = cm.listSelections().length, newSelection = [], last = -1;\n\t      for (var i = 0; i < len; i++) {\n\t        var head = cm.listSelections()[i].head;\n\t        if (head.line <= last) continue;\n\t        var at = Pos(head.line + (above ? 0 : 1), 0);\n\t        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n\t        cm.indentLine(at.line, null, true);\n\t        newSelection.push({head: at, anchor: at});\n\t        last = head.line + 1;\n\t      }\n\t      cm.setSelections(newSelection);\n\t    });\n\t  }\n\t\n\t  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { insertLine(cm, false); };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { insertLine(cm, true); };\n\t\n\t  function wordAt(cm, pos) {\n\t    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n\t    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n\t    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n\t    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n\t  }\n\t\n\t  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n\t    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n\t    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n\t    if (CodeMirror.cmpPos(from, to) == 0) {\n\t      var word = wordAt(cm, from);\n\t      if (!word.word) return;\n\t      cm.setSelection(word.from, word.to);\n\t      fullWord = true;\n\t    } else {\n\t      var text = cm.getRange(from, to);\n\t      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n\t      var cur = cm.getSearchCursor(query, to);\n\t      if (cur.findNext()) {\n\t        cm.addSelection(cur.from(), cur.to());\n\t      } else {\n\t        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n\t        if (cur.findNext())\n\t          cm.addSelection(cur.from(), cur.to());\n\t      }\n\t    }\n\t    if (fullWord)\n\t      cm.state.sublimeFindFullWord = cm.doc.sel;\n\t  };\n\t\n\t  var mirror = \"(){}[]\";\n\t  function selectBetweenBrackets(cm) {\n\t    var pos = cm.getCursor(), opening = cm.scanForBracket(pos, -1);\n\t    if (!opening) return;\n\t    for (;;) {\n\t      var closing = cm.scanForBracket(pos, 1);\n\t      if (!closing) return;\n\t      if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n\t        cm.setSelection(Pos(opening.pos.line, opening.pos.ch + 1), closing.pos, false);\n\t        return true;\n\t      }\n\t      pos = Pos(closing.pos.line, closing.pos.ch + 1);\n\t    }\n\t  }\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n\t    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n\t  };\n\t  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n\t    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n\t  };\n\t\n\t  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n\t    cm.extendSelectionsBy(function(range) {\n\t      var next = cm.scanForBracket(range.head, 1);\n\t      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n\t      var prev = cm.scanForBracket(range.head, -1);\n\t      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n\t    });\n\t  };\n\t\n\t  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\t\n\t  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n\t    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n\t      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n\t                    head: Pos(range.head.line - 1, range.head.ch)});\n\t      if (range.to().ch == 0 && !range.empty()) --to;\n\t      if (from > at) linesToMove.push(from, to);\n\t      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n\t      at = to;\n\t    }\n\t    cm.operation(function() {\n\t      for (var i = 0; i < linesToMove.length; i += 2) {\n\t        var from = linesToMove[i], to = linesToMove[i + 1];\n\t        var line = cm.getLine(from);\n\t        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n\t        if (to > cm.lastLine())\n\t          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n\t        else\n\t          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n\t      }\n\t      cm.setSelections(newSels);\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n\t    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n\t    for (var i = ranges.length - 1; i >= 0; i--) {\n\t      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n\t      if (range.to().ch == 0 && !range.empty()) from--;\n\t      if (from < at) linesToMove.push(from, to);\n\t      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n\t      at = to;\n\t    }\n\t    cm.operation(function() {\n\t      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n\t        var from = linesToMove[i], to = linesToMove[i + 1];\n\t        var line = cm.getLine(from);\n\t        if (from == cm.lastLine())\n\t          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n\t        else\n\t          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n\t        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n\t      }\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  map[ctrl + \"/\"] = function(cm) {\n\t    cm.toggleComment({ indent: true });\n\t  }\n\t\n\t  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n\t    var ranges = cm.listSelections(), joined = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i], from = range.from();\n\t      var start = from.line, end = range.to().line;\n\t      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n\t        end = ranges[++i].to().line;\n\t      joined.push({start: start, end: end, anchor: !range.empty() && from});\n\t    }\n\t    cm.operation(function() {\n\t      var offset = 0, ranges = [];\n\t      for (var i = 0; i < joined.length; i++) {\n\t        var obj = joined[i];\n\t        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n\t        for (var line = obj.start; line <= obj.end; line++) {\n\t          var actual = line - offset;\n\t          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n\t          if (actual < cm.lastLine()) {\n\t            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n\t            ++offset;\n\t          }\n\t        }\n\t        ranges.push({anchor: anchor || head, head: head});\n\t      }\n\t      cm.setSelections(ranges, 0);\n\t    });\n\t  };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var rangeCount = cm.listSelections().length;\n\t      for (var i = 0; i < rangeCount; i++) {\n\t        var range = cm.listSelections()[i];\n\t        if (range.empty())\n\t          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n\t        else\n\t          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n\t      }\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  map[ctrl + \"T\"] = \"transposeChars\";\n\t\n\t  function sortLines(cm, caseSensitive) {\n\t    var ranges = cm.listSelections(), toSort = [], selected;\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i];\n\t      if (range.empty()) continue;\n\t      var from = range.from().line, to = range.to().line;\n\t      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n\t        to = range[++i].to().line;\n\t      toSort.push(from, to);\n\t    }\n\t    if (toSort.length) selected = true;\n\t    else toSort.push(cm.firstLine(), cm.lastLine());\n\t\n\t    cm.operation(function() {\n\t      var ranges = [];\n\t      for (var i = 0; i < toSort.length; i += 2) {\n\t        var from = toSort[i], to = toSort[i + 1];\n\t        var start = Pos(from, 0), end = Pos(to);\n\t        var lines = cm.getRange(start, end, false);\n\t        if (caseSensitive)\n\t          lines.sort();\n\t        else\n\t          lines.sort(function(a, b) {\n\t            var au = a.toUpperCase(), bu = b.toUpperCase();\n\t            if (au != bu) { a = au; b = bu; }\n\t            return a < b ? -1 : a == b ? 0 : 1;\n\t          });\n\t        cm.replaceRange(lines, start, end);\n\t        if (selected) ranges.push({anchor: start, head: end});\n\t      }\n\t      if (selected) cm.setSelections(ranges, 0);\n\t    });\n\t  }\n\t\n\t  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n\t  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\t\n\t  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks;\n\t    if (marks) while (marks.length) {\n\t      var current = marks.shift();\n\t      var found = current.find();\n\t      if (found) {\n\t        marks.push(current);\n\t        return cm.setSelection(found.from, found.to);\n\t      }\n\t    }\n\t  };\n\t\n\t  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks;\n\t    if (marks) while (marks.length) {\n\t      marks.unshift(marks.pop());\n\t      var found = marks[marks.length - 1].find();\n\t      if (!found)\n\t        marks.pop();\n\t      else\n\t        return cm.setSelection(found.from, found.to);\n\t    }\n\t  };\n\t\n\t  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n\t    var ranges = cm.listSelections();\n\t    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var from = ranges[i].from(), to = ranges[i].to();\n\t      var found = cm.findMarks(from, to);\n\t      for (var j = 0; j < found.length; j++) {\n\t        if (found[j].sublimeBookmark) {\n\t          found[j].clear();\n\t          for (var k = 0; k < marks.length; k++)\n\t            if (marks[k] == found[j])\n\t              marks.splice(k--, 1);\n\t          break;\n\t        }\n\t      }\n\t      if (j == found.length)\n\t        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n\t    }\n\t  };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks;\n\t    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n\t    marks.length = 0;\n\t  };\n\t\n\t  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks, ranges = [];\n\t    if (marks) for (var i = 0; i < marks.length; i++) {\n\t      var found = marks[i].find();\n\t      if (!found)\n\t        marks.splice(i--, 0);\n\t      else\n\t        ranges.push({anchor: found.from, head: found.to});\n\t    }\n\t    if (ranges.length)\n\t      cm.setSelections(ranges, 0);\n\t  };\n\t\n\t  map[\"Alt-Q\"] = \"wrapLines\";\n\t\n\t  var cK = ctrl + \"K \";\n\t\n\t  function modifyWordOrSelection(cm, mod) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections(), indices = [], replacements = [];\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n\t        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n\t      }\n\t      cm.replaceSelections(replacements, \"around\", \"case\");\n\t      for (var i = indices.length - 1, at; i >= 0; i--) {\n\t        var range = ranges[indices[i]];\n\t        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n\t        var word = wordAt(cm, range.head);\n\t        at = word.from;\n\t        cm.replaceRange(mod(word.word), word.from, word.to);\n\t      }\n\t    });\n\t  }\n\t\n\t  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\t\n\t  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n\t    if (cm.somethingSelected()) return CodeMirror.Pass;\n\t\n\t    var cursor = cm.getCursor();\n\t    var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n\t    var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\t    var indentUnit = cm.getOption(\"indentUnit\");\n\t\n\t    if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n\t      var prevIndent = new Pos(cursor.line,\n\t        CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\t\n\t      // If no smart delete is happening (due to tab sizing) just do a regular delete\n\t      if (prevIndent.ch == cursor.ch) return CodeMirror.Pass;\n\t\n\t      return cm.replaceRange(\"\", prevIndent, cursor, \"+delete\");\n\t    } else {\n\t      return CodeMirror.Pass;\n\t    }\n\t  };\n\t\n\t  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections();\n\t      for (var i = ranges.length - 1; i >= 0; i--)\n\t        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n\t    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n\t  };\n\t  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n\t    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n\t  };\n\t\n\t  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n\t    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n\t    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n\t  };\n\t  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n\t    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\t    if (found) cm.setSelection(cm.getCursor(), found);\n\t  };\n\t  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n\t    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\t    if (found) {\n\t      var from = cm.getCursor(), to = found;\n\t      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n\t      cm.state.sublimeKilled = cm.getRange(from, to);\n\t      cm.replaceRange(\"\", from, to);\n\t    }\n\t  };\n\t  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n\t    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\t    if (found) {\n\t      cm.state.sublimeMark.clear();\n\t      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n\t      cm.setCursor(found);\n\t    }\n\t  };\n\t  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n\t    if (cm.state.sublimeKilled != null)\n\t      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n\t  };\n\t\n\t  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n\t  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n\t    var pos = cm.cursorCoords(null, \"local\");\n\t    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n\t  };\n\t\n\t  cmds[map[\"Shift-Alt-Up\"] = \"selectLinesUpward\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections();\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (range.head.line > cm.firstLine())\n\t          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n\t      }\n\t    });\n\t  };\n\t  cmds[map[\"Shift-Alt-Down\"] = \"selectLinesDownward\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections();\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (range.head.line < cm.lastLine())\n\t          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n\t      }\n\t    });\n\t  };\n\t\n\t  function getTarget(cm) {\n\t    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n\t    if (CodeMirror.cmpPos(from, to) == 0) {\n\t      var word = wordAt(cm, from);\n\t      if (!word.word) return;\n\t      from = word.from;\n\t      to = word.to;\n\t    }\n\t    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n\t  }\n\t\n\t  function findAndGoTo(cm, forward) {\n\t    var target = getTarget(cm);\n\t    if (!target) return;\n\t    var query = target.query;\n\t    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\t\n\t    if (forward ? cur.findNext() : cur.findPrevious()) {\n\t      cm.setSelection(cur.from(), cur.to());\n\t    } else {\n\t      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n\t                                              : cm.clipPos(Pos(cm.lastLine())));\n\t      if (forward ? cur.findNext() : cur.findPrevious())\n\t        cm.setSelection(cur.from(), cur.to());\n\t      else if (target.word)\n\t        cm.setSelection(target.from, target.to);\n\t    }\n\t  };\n\t  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n\t  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n\t  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n\t    var target = getTarget(cm);\n\t    if (!target) return;\n\t    var cur = cm.getSearchCursor(target.query);\n\t    var matches = [];\n\t    var primaryIndex = -1;\n\t    while (cur.findNext()) {\n\t      matches.push({anchor: cur.from(), head: cur.to()});\n\t      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n\t        primaryIndex++;\n\t    }\n\t    cm.setSelections(matches, primaryIndex);\n\t  };\n\t\n\t  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n\t  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n\t  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"j\"] = \"unfoldAll\";\n\t\n\t  map[ctrl + \"I\"] = \"findIncremental\";\n\t  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n\t  map[ctrl + \"H\"] = \"replace\";\n\t  map[\"F3\"] = \"findNext\";\n\t  map[\"Shift-F3\"] = \"findPrev\";\n\t\n\t  CodeMirror.normalizeKeyMap(map);\n\t});\n\n\n/***/ },\n/* 434 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  function SearchCursor(doc, query, pos, caseFold) {\n\t    this.atOccurrence = false; this.doc = doc;\n\t    if (caseFold == null && typeof query == \"string\") caseFold = false;\n\t\n\t    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n\t    this.pos = {from: pos, to: pos};\n\t\n\t    // The matches method is filled in based on the type of query.\n\t    // It takes a position and a direction, and returns an object\n\t    // describing the next occurrence of the query, or null if no\n\t    // more matches were found.\n\t    if (typeof query != \"string\") { // Regexp match\n\t      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? \"ig\" : \"g\");\n\t      this.matches = function(reverse, pos) {\n\t        if (reverse) {\n\t          query.lastIndex = 0;\n\t          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;\n\t          for (;;) {\n\t            query.lastIndex = cutOff;\n\t            var newMatch = query.exec(line);\n\t            if (!newMatch) break;\n\t            match = newMatch;\n\t            start = match.index;\n\t            cutOff = match.index + (match[0].length || 1);\n\t            if (cutOff == line.length) break;\n\t          }\n\t          var matchLen = (match && match[0].length) || 0;\n\t          if (!matchLen) {\n\t            if (start == 0 && line.length == 0) {match = undefined;}\n\t            else if (start != doc.getLine(pos.line).length) {\n\t              matchLen++;\n\t            }\n\t          }\n\t        } else {\n\t          query.lastIndex = pos.ch;\n\t          var line = doc.getLine(pos.line), match = query.exec(line);\n\t          var matchLen = (match && match[0].length) || 0;\n\t          var start = match && match.index;\n\t          if (start + matchLen != line.length && !matchLen) matchLen = 1;\n\t        }\n\t        if (match && matchLen)\n\t          return {from: Pos(pos.line, start),\n\t                  to: Pos(pos.line, start + matchLen),\n\t                  match: match};\n\t      };\n\t    } else { // String query\n\t      var origQuery = query;\n\t      if (caseFold) query = query.toLowerCase();\n\t      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n\t      var target = query.split(\"\\n\");\n\t      // Different methods for single-line and multi-line queries\n\t      if (target.length == 1) {\n\t        if (!query.length) {\n\t          // Empty string would match anything and never progress, so\n\t          // we define it to match nothing instead.\n\t          this.matches = function() {};\n\t        } else {\n\t          this.matches = function(reverse, pos) {\n\t            if (reverse) {\n\t              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);\n\t              var match = line.lastIndexOf(query);\n\t              if (match > -1) {\n\t                match = adjustPos(orig, line, match);\n\t                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n\t              }\n\t             } else {\n\t               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);\n\t               var match = line.indexOf(query);\n\t               if (match > -1) {\n\t                 match = adjustPos(orig, line, match) + pos.ch;\n\t                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n\t               }\n\t            }\n\t          };\n\t        }\n\t      } else {\n\t        var origTarget = origQuery.split(\"\\n\");\n\t        this.matches = function(reverse, pos) {\n\t          var last = target.length - 1;\n\t          if (reverse) {\n\t            if (pos.line - (target.length - 1) < doc.firstLine()) return;\n\t            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;\n\t            var to = Pos(pos.line, origTarget[last].length);\n\t            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)\n\t              if (target[i] != fold(doc.getLine(ln))) return;\n\t            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;\n\t            if (fold(line.slice(cut)) != target[0]) return;\n\t            return {from: Pos(ln, cut), to: to};\n\t          } else {\n\t            if (pos.line + (target.length - 1) > doc.lastLine()) return;\n\t            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;\n\t            if (fold(line.slice(cut)) != target[0]) return;\n\t            var from = Pos(pos.line, cut);\n\t            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)\n\t              if (target[i] != fold(doc.getLine(ln))) return;\n\t            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;\n\t            return {from: from, to: Pos(ln, origTarget[last].length)};\n\t          }\n\t        };\n\t      }\n\t    }\n\t  }\n\t\n\t  SearchCursor.prototype = {\n\t    findNext: function() {return this.find(false);},\n\t    findPrevious: function() {return this.find(true);},\n\t\n\t    find: function(reverse) {\n\t      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n\t      function savePosAndFail(line) {\n\t        var pos = Pos(line, 0);\n\t        self.pos = {from: pos, to: pos};\n\t        self.atOccurrence = false;\n\t        return false;\n\t      }\n\t\n\t      for (;;) {\n\t        if (this.pos = this.matches(reverse, pos)) {\n\t          this.atOccurrence = true;\n\t          return this.pos.match || true;\n\t        }\n\t        if (reverse) {\n\t          if (!pos.line) return savePosAndFail(0);\n\t          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);\n\t        }\n\t        else {\n\t          var maxLine = this.doc.lineCount();\n\t          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n\t          pos = Pos(pos.line + 1, 0);\n\t        }\n\t      }\n\t    },\n\t\n\t    from: function() {if (this.atOccurrence) return this.pos.from;},\n\t    to: function() {if (this.atOccurrence) return this.pos.to;},\n\t\n\t    replace: function(newText, origin) {\n\t      if (!this.atOccurrence) return;\n\t      var lines = CodeMirror.splitLines(newText);\n\t      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n\t      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n\t                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n\t    }\n\t  };\n\t\n\t  // Maps a position in a case-folded line back to a position in the original line\n\t  // (compensating for codepoints increasing in number during folding)\n\t  function adjustPos(orig, folded, pos) {\n\t    if (orig.length == folded.length) return pos;\n\t    for (var pos1 = Math.min(pos, orig.length);;) {\n\t      var len1 = orig.slice(0, pos1).toLowerCase().length;\n\t      if (len1 < pos) ++pos1;\n\t      else if (len1 > pos) --pos1;\n\t      else return pos1;\n\t    }\n\t  }\n\t\n\t  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n\t    return new SearchCursor(this.doc, query, pos, caseFold);\n\t  });\n\t  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n\t    return new SearchCursor(this, query, pos, caseFold);\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n\t    var ranges = [];\n\t    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n\t    while (cur.findNext()) {\n\t      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n\t      ranges.push({anchor: cur.from(), head: cur.to()});\n\t    }\n\t    if (ranges.length)\n\t      this.setSelections(ranges, 0);\n\t  });\n\t});\n\n\n/***/ },\n/* 435 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _codemirror = __webpack_require__(351);\n\t\n\tvar _codemirror2 = _interopRequireDefault(_codemirror);\n\t\n\tvar _graphqlType = __webpack_require__(412);\n\t\n\tvar _graphqlTypeIntrospection = __webpack_require__(375);\n\t\n\t/**\n\t * Registers a \"hint\" helper for CodeMirror.\n\t *\n\t * Using CodeMirror's \"hint\" addon: https://codemirror.net/demo/complete.html\n\t * Given an editor, this helper will take the token at the cursor and return a\n\t * list of suggested tokens.\n\t *\n\t * Options:\n\t *\n\t *   - schema: GraphQLSchema provides the hinter with positionally relevant info\n\t *\n\t * Additional Events:\n\t *\n\t *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a\n\t *     new list of completion suggestions.\n\t *\n\t */\n\t_codemirror2['default'].registerHelper('hint', 'graphql', function (editor, options) {\n\t  var schema = options.schema;\n\t  if (!schema) {\n\t    return;\n\t  }\n\t\n\t  var cur = editor.getCursor();\n\t  var token = editor.getTokenAt(cur);\n\t  var typeInfo = getTypeInfo(schema, token.state);\n\t\n\t  var state = token.state;\n\t  var kind = state.kind;\n\t  var step = state.step;\n\t\n\t  if (token.type === 'comment') {\n\t    return;\n\t  }\n\t\n\t  // Definition kinds\n\t  if (kind === 'Document') {\n\t    return hintList(editor, options, cur, token, [{ text: 'query' }, { text: 'mutation' }, { text: 'subscription' }, { text: 'fragment' }, { text: '{' }]);\n\t  }\n\t\n\t  // Field names\n\t  if (kind === 'SelectionSet' || kind === 'Field' || kind === 'AliasedField') {\n\t    if (typeInfo.parentType) {\n\t      var fields;\n\t      if (typeInfo.parentType.getFields) {\n\t        var fieldObj = typeInfo.parentType.getFields();\n\t        fields = Object.keys(fieldObj).map(function (fieldName) {\n\t          return fieldObj[fieldName];\n\t        });\n\t      } else {\n\t        fields = [];\n\t      }\n\t      if (_graphqlType.isAbstractType(typeInfo.parentType)) {\n\t        fields.push(_graphqlTypeIntrospection.TypeNameMetaFieldDef);\n\t      }\n\t      if (typeInfo.parentType === schema.getQueryType()) {\n\t        fields.push(_graphqlTypeIntrospection.SchemaMetaFieldDef, _graphqlTypeIntrospection.TypeMetaFieldDef);\n\t      }\n\t      return hintList(editor, options, cur, token, fields.map(function (field) {\n\t        return {\n\t          text: field.name,\n\t          type: field.type,\n\t          description: field.description\n\t        };\n\t      }));\n\t    }\n\t  }\n\t\n\t  // Argument names\n\t  if (kind === 'Arguments' || kind === 'Argument' && step === 0) {\n\t    var argDefs = typeInfo.argDefs;\n\t    if (argDefs) {\n\t      return hintList(editor, options, cur, token, argDefs.map(function (argDef) {\n\t        return {\n\t          text: argDef.name,\n\t          type: argDef.type,\n\t          description: argDef.description\n\t        };\n\t      }));\n\t    }\n\t  }\n\t\n\t  // Input Object fields\n\t  if (kind === 'ObjectValue' || kind === 'ObjectField' && step === 0) {\n\t    if (typeInfo.objectFieldDefs) {\n\t      var objectFields = Object.keys(typeInfo.objectFieldDefs).map(function (fieldName) {\n\t        return typeInfo.objectFieldDefs[fieldName];\n\t      });\n\t      return hintList(editor, options, cur, token, objectFields.map(function (field) {\n\t        return {\n\t          text: field.name,\n\t          type: field.type,\n\t          description: field.description\n\t        };\n\t      }));\n\t    }\n\t  }\n\t\n\t  // Input values: Enum and Boolean\n\t  if (kind === 'EnumValue' || kind === 'ListValue' && step === 1 || kind === 'ObjectField' && step === 2 || kind === 'Argument' && step === 2) {\n\t    var namedInputType = _graphqlType.getNamedType(typeInfo.inputType);\n\t    if (namedInputType instanceof _graphqlType.GraphQLEnumType) {\n\t      var valueMap = namedInputType.getValues();\n\t      var values = Object.keys(valueMap).map(function (valueName) {\n\t        return valueMap[valueName];\n\t      });\n\t      return hintList(editor, options, cur, token, values.map(function (value) {\n\t        return {\n\t          text: value.name,\n\t          type: namedInputType,\n\t          description: value.description\n\t        };\n\t      }));\n\t    } else if (namedInputType === _graphqlType.GraphQLBoolean) {\n\t      return hintList(editor, options, cur, token, [{ text: 'true', type: _graphqlType.GraphQLBoolean, description: 'Not false.' }, { text: 'false', type: _graphqlType.GraphQLBoolean, description: 'Not true.' }]);\n\t    }\n\t  }\n\t\n\t  // Fragment type conditions\n\t  if (kind === 'TypeCondition' && step === 1 || kind === 'NamedType' && state.prevState.kind === 'TypeCondition') {\n\t    var possibleTypes;\n\t    if (typeInfo.parentType) {\n\t      possibleTypes = _graphqlType.isAbstractType(typeInfo.parentType) ? typeInfo.parentType.getPossibleTypes() : [typeInfo.parentType];\n\t    } else {\n\t      var typeMap = schema.getTypeMap();\n\t      possibleTypes = Object.keys(typeMap).map(function (typeName) {\n\t        return typeMap[typeName];\n\t      }).filter(_graphqlType.isCompositeType);\n\t    }\n\t    return hintList(editor, options, cur, token, possibleTypes.map(function (type) {\n\t      return {\n\t        text: type.name,\n\t        description: type.description\n\t      };\n\t    }));\n\t  }\n\t\n\t  // Variable definition types\n\t  if (kind === 'VariableDefinition' && step === 2 || kind === 'ListType' && step === 1 || kind === 'NamedType' && (state.prevState.kind === 'VariableDefinition' || state.prevState.kind === 'ListType')) {\n\t    var inputTypeMap = schema.getTypeMap();\n\t    var inputTypes = Object.keys(inputTypeMap).map(function (typeName) {\n\t      return inputTypeMap[typeName];\n\t    }).filter(_graphqlType.isInputType);\n\t    return hintList(editor, options, cur, token, inputTypes.map(function (type) {\n\t      return {\n\t        text: type.name,\n\t        description: type.description\n\t      };\n\t    }));\n\t  }\n\t\n\t  // Directive names\n\t  if (kind === 'Directive') {\n\t    var directives = schema.getDirectives().filter(function (directive) {\n\t      return directive.onField && state.prevState.kind === 'Field' || directive.onFragment && (state.prevState.kind === 'FragmentDefinition' || state.prevState.kind === 'InlineFragment' || state.prevState.kind === 'FragmentSpread') || directive.onOperation && (state.prevState.kind === 'Query' || state.prevState.kind === 'Mutation' || state.prevState.kind === 'Subscription');\n\t    });\n\t    return hintList(editor, options, cur, token, directives.map(function (directive) {\n\t      return {\n\t        text: directive.name,\n\t        description: directive.description\n\t      };\n\t    }));\n\t  }\n\t});\n\t\n\t// Utility for collecting rich type information given any token's state\n\t// from the graphql-mode parser.\n\tfunction getTypeInfo(schema, tokenState) {\n\t  var info = {\n\t    type: null,\n\t    parentType: null,\n\t    inputType: null,\n\t    directiveDef: null,\n\t    fieldDef: null,\n\t    argDef: null,\n\t    argDefs: null,\n\t    objectFieldDefs: null\n\t  };\n\t\n\t  forEachState(tokenState, function (state) {\n\t    switch (state.kind) {\n\t      case 'Query':case 'ShortQuery':\n\t        info.type = schema.getQueryType();\n\t        break;\n\t      case 'Mutation':\n\t        info.type = schema.getMutationType();\n\t        break;\n\t      case 'Subscription':\n\t        info.type = schema.getSubscriptionType();\n\t        break;\n\t      case 'InlineFragment':\n\t      case 'FragmentDefinition':\n\t        info.type = state.type && schema.getType(state.type);\n\t        break;\n\t      case 'Field':\n\t        info.fieldDef = info.type && state.name ? getFieldDef(schema, info.parentType, state.name) : null;\n\t        info.type = info.fieldDef && info.fieldDef.type;\n\t        break;\n\t      case 'SelectionSet':\n\t        info.parentType = _graphqlType.getNamedType(info.type);\n\t        break;\n\t      case 'Directive':\n\t        info.directiveDef = state.name && schema.getDirective(state.name);\n\t        break;\n\t      case 'Arguments':\n\t        info.argDefs = state.prevState.kind === 'Field' ? info.fieldDef && info.fieldDef.args : state.prevState.kind === 'Directive' ? info.directiveDef && info.directiveDef.args : null;\n\t        break;\n\t      case 'Argument':\n\t        info.argDef = null;\n\t        if (info.argDefs) {\n\t          for (var i = 0; i < info.argDefs.length; i++) {\n\t            if (info.argDefs[i].name === state.name) {\n\t              info.argDef = info.argDefs[i];\n\t              break;\n\t            }\n\t          }\n\t        }\n\t        info.inputType = info.argDef && info.argDef.type;\n\t        break;\n\t      case 'ListValue':\n\t        var nullableType = _graphqlType.getNullableType(info.inputType);\n\t        info.inputType = nullableType instanceof _graphqlType.GraphQLList ? nullableType.ofType : null;\n\t        break;\n\t      case 'ObjectValue':\n\t        var objectType = _graphqlType.getNamedType(info.inputType);\n\t        info.objectFieldDefs = objectType instanceof _graphqlType.GraphQLInputObjectType ? objectType.getFields() : null;\n\t        break;\n\t      case 'ObjectField':\n\t        var objectField = state.name && info.objectFieldDefs ? info.objectFieldDefs[state.name] : null;\n\t        info.inputType = objectField && objectField.type;\n\t        break;\n\t    }\n\t  });\n\t\n\t  return info;\n\t}\n\t\n\t// Utility for iterating through a state stack bottom-up.\n\tfunction forEachState(stack, fn) {\n\t  var reverseStateStack = [];\n\t  var state = stack;\n\t  while (state && state.kind) {\n\t    reverseStateStack.push(state);\n\t    state = state.prevState;\n\t  }\n\t  for (var i = reverseStateStack.length - 1; i >= 0; i--) {\n\t    fn(reverseStateStack[i]);\n\t  }\n\t}\n\t\n\t// Gets the field definition given a type and field name\n\tfunction getFieldDef(schema, type, fieldName) {\n\t  if (fieldName === _graphqlTypeIntrospection.SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n\t    return _graphqlTypeIntrospection.SchemaMetaFieldDef;\n\t  }\n\t  if (fieldName === _graphqlTypeIntrospection.TypeMetaFieldDef.name && schema.getQueryType() === type) {\n\t    return _graphqlTypeIntrospection.TypeMetaFieldDef;\n\t  }\n\t  if (fieldName === _graphqlTypeIntrospection.TypeNameMetaFieldDef.name && _graphqlType.isCompositeType(type)) {\n\t    return _graphqlTypeIntrospection.TypeNameMetaFieldDef;\n\t  }\n\t  if (type.getFields) {\n\t    return type.getFields()[fieldName];\n\t  }\n\t}\n\t\n\t// Create the expected hint response given a possible list and a token\n\tfunction hintList(editor, options, cursor, token, list) {\n\t  var hints = filterAndSortList(list, normalizeText(token.string));\n\t  if (!hints) {\n\t    return;\n\t  }\n\t\n\t  var tokenStart = token.type === null ? token.end : /\\w/.test(token.string[0]) ? token.start : token.start + 1;\n\t\n\t  var results = {\n\t    list: hints,\n\t    from: _codemirror2['default'].Pos(cursor.line, tokenStart),\n\t    to: _codemirror2['default'].Pos(cursor.line, token.end)\n\t  };\n\t\n\t  _codemirror2['default'].signal(editor, 'hasCompletion', editor, results, token);\n\t\n\t  return results;\n\t}\n\t\n\t// Given a list of hint entries and currently typed text, sort and filter to\n\t// provide a concise list.\n\tfunction filterAndSortList(list, text) {\n\t  var sorted = !text ? list : list.map(function (entry) {\n\t    return {\n\t      proximity: getProximity(normalizeText(entry.text), text),\n\t      entry: entry\n\t    };\n\t  }).filter(function (pair) {\n\t    return pair.proximity <= 2;\n\t  }).sort(function (a, b) {\n\t    return a.proximity - b.proximity || a.entry.text.length - b.entry.text.length;\n\t  }).map(function (pair) {\n\t    return pair.entry;\n\t  });\n\t\n\t  return sorted.length > 0 ? sorted : list;\n\t}\n\t\n\tfunction normalizeText(text) {\n\t  return text.toLowerCase().replace(/\\W/g, '');\n\t}\n\t\n\t// Determine a numeric proximity for a suggestion based on current text.\n\tfunction getProximity(suggestion, text) {\n\t  // start with lexical distance\n\t  var proximity = lexicalDistance(text, suggestion);\n\t  if (suggestion.length > text.length) {\n\t    // do not penalize long suggestions.\n\t    proximity -= suggestion.length - text.length - 1;\n\t    // penalize suggestions not starting with this phrase\n\t    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n\t  }\n\t  return proximity;\n\t}\n\t\n\t/**\n\t * Computes the lexical distance between strings A and B.\n\t *\n\t * The \"distance\" between two strings is given by counting the minimum number\n\t * of edits needed to transform string A into string B. An edit can be an\n\t * insertion, deletion, or substitution of a single character, or a swap of two\n\t * adjacent characters.\n\t *\n\t * This distance can be useful for detecting typos in input or sorting\n\t *\n\t * @param {string} a\n\t * @param {string} b\n\t * @return {int} distance in number of edits\n\t */\n\tfunction lexicalDistance(a, b) {\n\t  var i;\n\t  var j;\n\t  var d = [];\n\t  var aLength = a.length;\n\t  var bLength = b.length;\n\t\n\t  for (i = 0; i <= aLength; i++) {\n\t    d[i] = [i];\n\t  }\n\t\n\t  for (j = 1; j <= bLength; j++) {\n\t    d[0][j] = j;\n\t  }\n\t\n\t  for (i = 1; i <= aLength; i++) {\n\t    for (j = 1; j <= bLength; j++) {\n\t      var cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\t\n\t      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n\t\n\t      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n\t        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n\t      }\n\t    }\n\t  }\n\t\n\t  return d[aLength][bLength];\n\t}\n\n/***/ },\n/* 436 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _codemirror = __webpack_require__(351);\n\t\n\tvar _codemirror2 = _interopRequireDefault(_codemirror);\n\t\n\tvar _graphqlLanguage = __webpack_require__(358);\n\t\n\tvar _graphqlValidation = __webpack_require__(437);\n\t\n\t/**\n\t * Registers a \"lint\" helper for CodeMirror.\n\t *\n\t * Using CodeMirror's \"lint\" addon: https://codemirror.net/demo/lint.html\n\t * Given the text within an editor, this helper will take that text and return\n\t * a list of linter issues, derived from GraphQL's parse and validate steps.\n\t *\n\t * Options:\n\t *\n\t *   - schema: GraphQLSchema provides the linter with positionally relevant info\n\t *\n\t */\n\t_codemirror2['default'].registerHelper('lint', 'graphql', function (text, options, editor) {\n\t  var schema = options.schema;\n\t  try {\n\t    var ast = _graphqlLanguage.parse(text);\n\t  } catch (error) {\n\t    var location = error.locations[0];\n\t    var pos = _codemirror2['default'].Pos(location.line - 1, location.column);\n\t    var token = editor.getTokenAt(pos);\n\t    return [{\n\t      message: error.message,\n\t      severity: 'error',\n\t      type: 'syntax',\n\t      from: _codemirror2['default'].Pos(location.line - 1, token.start),\n\t      to: _codemirror2['default'].Pos(location.line - 1, token.end)\n\t    }];\n\t  }\n\t  var errors = schema ? _graphqlValidation.validate(schema, ast) : [];\n\t  return mapCat(errors, function (error) {\n\t    return errorAnnotations(editor, error);\n\t  });\n\t});\n\t\n\tfunction errorAnnotations(editor, error) {\n\t  return error.nodes.map(function (node) {\n\t    var highlightNode = node.kind !== 'Variable' && node.name ? node.name : node.variable ? node.variable : node;\n\t    return {\n\t      message: error.message,\n\t      severity: 'error',\n\t      type: 'validation',\n\t      from: editor.posFromIndex(highlightNode.loc.start),\n\t      to: editor.posFromIndex(highlightNode.loc.end)\n\t    };\n\t  });\n\t}\n\t\n\t// General utility for map-cating (aka flat-mapping).\n\tfunction mapCat(array, mapper) {\n\t  return Array.prototype.concat.apply([], array.map(mapper));\n\t}\n\n/***/ },\n/* 437 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _validate = __webpack_require__(368);\n\t\n\tObject.defineProperty(exports, 'validate', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _validate.validate;\n\t  }\n\t});\n\t\n\tvar _specifiedRules = __webpack_require__(381);\n\t\n\tObject.defineProperty(exports, 'specifiedRules', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _specifiedRules.specifiedRules;\n\t  }\n\t});\n\n/***/ },\n/* 438 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _codemirror = __webpack_require__(351);\n\t\n\tvar _codemirror2 = _interopRequireDefault(_codemirror);\n\t\n\t/**\n\t * The GraphQL mode is defined as a tokenizer along with a list of rules, each\n\t * of which is either a function or an array.\n\t *\n\t *   * Function: Provided a token and the stream, returns an expected next step.\n\t *   * Array: A list of steps to take in order.\n\t *\n\t * A step is either another rule, or a terminal description of a token. If it\n\t * is a rule, that rule is pushed onto the stack and the parsing continues from\n\t * that point.\n\t *\n\t * If it is a terminal description, the token is checked against it using a\n\t * `match` function. If the match is successful, the token is colored and the\n\t * rule is stepped forward. If the match is unsuccessful, the remainder of the\n\t * rule is skipped and the previous rule is advanced.\n\t *\n\t * This parsing algorithm allows for incremental online parsing within various\n\t * levels of the syntax tree and results in a structured `state` linked-list\n\t * which contains the relevant information to produce valuable typeaheads.\n\t */\n\t_codemirror2['default'].defineMode('graphql', function (config) {\n\t  return {\n\t    config: config,\n\t    token: getToken,\n\t    indent: indent,\n\t    startState: function startState() {\n\t      var initialState = { level: 0 };\n\t      pushRule(initialState, 'Document');\n\t      return initialState;\n\t    },\n\t    electricInput: /^\\s*[})\\]]/,\n\t    fold: 'brace',\n\t    lineComment: '#',\n\t    closeBrackets: {\n\t      pairs: '()[]{}\"\"',\n\t      explode: '()[]{}'\n\t    }\n\t  };\n\t});\n\t\n\tfunction getToken(stream, state) {\n\t  if (state.needsAdvance) {\n\t    state.needsAdvance = false;\n\t    advanceRule(state);\n\t  }\n\t\n\t  // Remember initial indentation\n\t  if (stream.sol()) {\n\t    state.indentLevel = Math.floor(stream.indentation() / this.config.tabSize);\n\t  }\n\t\n\t  // Consume spaces and ignored characters\n\t  if (stream.eatSpace() || stream.eatWhile(',')) {\n\t    return null;\n\t  }\n\t\n\t  // Tokenize line comment\n\t  if (stream.match(this.lineComment)) {\n\t    stream.skipToEnd();\n\t    return 'comment';\n\t  }\n\t\n\t  // Lex a token from the stream\n\t  var token = lex(stream);\n\t\n\t  // If there's no matching token, skip ahead.\n\t  if (!token) {\n\t    stream.match(/\\w+|./);\n\t    return 'invalidchar';\n\t  }\n\t\n\t  // Save state before continuing.\n\t  saveState(state);\n\t\n\t  // Handle changes in expected indentation level\n\t  if (token.kind === 'Punctuation') {\n\t    if (/^[{([]/.test(token.value)) {\n\t      // Push on the stack of levels one level deeper than the current level.\n\t      state.levels = (state.levels || []).concat(state.indentLevel + 1);\n\t    } else if (/^[})\\]]/.test(token.value)) {\n\t      // Pop from the stack of levels.\n\t      // If the top of the stack is lower than the current level, lower the\n\t      // current level to match.\n\t      var levels = state.levels = (state.levels || []).slice(0, -1);\n\t      if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n\t        state.indentLevel = levels[levels.length - 1];\n\t      }\n\t    }\n\t  }\n\t\n\t  while (state.rule) {\n\t    // If this is a forking rule, determine what rule to use based on\n\t    // the current token, otherwise expect based on the current step.\n\t    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n\t\n\t    if (expected) {\n\t      // Un-wrap optional/list ParseRules.\n\t      if (expected.ofRule) {\n\t        expected = expected.ofRule;\n\t      }\n\t\n\t      // A string represents a Rule\n\t      if (typeof expected === 'string') {\n\t        pushRule(state, expected);\n\t        continue;\n\t      }\n\t\n\t      // Otherwise, match a Terminal.\n\t      if (expected.match && expected.match(token)) {\n\t        if (expected.update) {\n\t          expected.update(state, token);\n\t        }\n\t        // If this token was a punctuator, advance the parse rule, otherwise\n\t        // mark the state to be advanced before the next token. This ensures\n\t        // that tokens which can be appended to keep the appropriate state.\n\t        if (token.kind === 'Punctuation') {\n\t          advanceRule(state);\n\t        } else {\n\t          state.needsAdvance = true;\n\t        }\n\t        return expected.style;\n\t      }\n\t    }\n\t\n\t    unsuccessful(state);\n\t  }\n\t\n\t  // The parser does not know how to interpret this token, do not affect state.\n\t  restoreState(state);\n\t  return 'invalidchar';\n\t}\n\t\n\tfunction indent(state, textAfter) {\n\t  var levels = state.levels;\n\t  // If there is no stack of levels, use the current level.\n\t  // Otherwise, use the top level, pre-emptively dedenting for close braces.\n\t  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (this.electricInput.test(textAfter) ? 1 : 0);\n\t  return level * this.config.indentUnit;\n\t}\n\t\n\tfunction assign(to, from) {\n\t  var keys = Object.keys(from);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    to[keys[i]] = from[keys[i]];\n\t  }\n\t  return to;\n\t}\n\t\n\tvar stateCache = {};\n\t\n\t// Save the current state in the cache.\n\tfunction saveState(state) {\n\t  assign(stateCache, state);\n\t}\n\t\n\t// Restore from the state cache.\n\tfunction restoreState(state) {\n\t  assign(state, stateCache);\n\t}\n\t\n\t// Push a new rule onto the state.\n\tfunction pushRule(state, ruleKind) {\n\t  state.prevState = assign({}, state);\n\t  state.kind = ruleKind;\n\t  state.name = null;\n\t  state.type = null;\n\t  state.rule = ParseRules[ruleKind];\n\t  state.step = 0;\n\t}\n\t\n\t// Pop the current rule from the state.\n\tfunction popRule(state) {\n\t  state.kind = state.prevState.kind;\n\t  state.name = state.prevState.name;\n\t  state.type = state.prevState.type;\n\t  state.rule = state.prevState.rule;\n\t  state.step = state.prevState.step;\n\t  state.prevState = state.prevState.prevState;\n\t}\n\t\n\t// Advance the step of the current rule.\n\tfunction advanceRule(state) {\n\t  // Advance the step in the rule. If the rule is completed, pop\n\t  // the rule and advance the parent rule as well (recursively).\n\t  state.step++;\n\t  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n\t    popRule(state);\n\t    // Do not advance a List step so it has the opportunity to repeat itself.\n\t    if (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].isList)) {\n\t      state.step++;\n\t    }\n\t  }\n\t}\n\t\n\t// Unwind the state after an unsuccessful match.\n\tfunction unsuccessful(state) {\n\t  // Fall back to the parent rule until you get to an optional or list rule or\n\t  // until the entire stack of rules is empty.\n\t  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n\t    popRule(state);\n\t  }\n\t\n\t  // If there is still a rule, it must be an optional or list rule.\n\t  // Consider this rule a success so that we may move past it.\n\t  if (state.rule) {\n\t    advanceRule(state);\n\t  }\n\t}\n\t\n\t// Given a stream, returns a { kind, value } pair, or null.\n\tfunction lex(stream) {\n\t  var kinds = Object.keys(LexRules);\n\t  for (var i = 0; i < kinds.length; i++) {\n\t    var match = stream.match(LexRules[kinds[i]]);\n\t    if (match) {\n\t      return { kind: kinds[i], value: match[0] };\n\t    }\n\t  }\n\t}\n\t\n\t// An optional rule.\n\tfunction opt(ofRule) {\n\t  return { ofRule: ofRule };\n\t}\n\t\n\t// A list of another rule.\n\tfunction list(ofRule) {\n\t  return { ofRule: ofRule, isList: true };\n\t}\n\t\n\t// Token of a kind\n\tfunction t(kind, style) {\n\t  return { style: style, match: function match(token) {\n\t      return token.kind === kind;\n\t    } };\n\t}\n\t\n\t// Punctuator\n\tfunction p(value, style) {\n\t  return {\n\t    style: style || 'punctuation',\n\t    match: function match(token) {\n\t      return token.kind === 'Punctuation' && token.value === value;\n\t    }\n\t  };\n\t}\n\t\n\t// A keyword Token\n\tfunction word(value) {\n\t  return {\n\t    style: 'keyword',\n\t    match: function match(token) {\n\t      return token.kind === 'Name' && token.value === value;\n\t    }\n\t  };\n\t}\n\t\n\t// A Name Token which will decorate the state with a `name`\n\tfunction name(style) {\n\t  return {\n\t    style: style,\n\t    match: function match(token) {\n\t      return token.kind === 'Name';\n\t    },\n\t    update: function update(state, token) {\n\t      state.name = token.value;\n\t    }\n\t  };\n\t}\n\t\n\t// A Name Token which will decorate the previous state with a `type`\n\tfunction type(style) {\n\t  return {\n\t    style: style,\n\t    match: function match(token) {\n\t      return token.kind === 'Name';\n\t    },\n\t    update: function update(state, token) {\n\t      state.prevState.type = token.value;\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * The lexer rules. These are exactly as described by the spec.\n\t */\n\tvar LexRules = {\n\t  // The Name token.\n\t  Name: /^[_A-Za-z][_0-9A-Za-z]*/,\n\t\n\t  // All Punctuation used in GraphQL\n\t  Punctuation: /^(?:!|\\$|\\(|\\)|\\.\\.\\.|:|=|@|\\[|\\]|\\{|\\})/,\n\t\n\t  // Combines the IntValue and FloatValue tokens.\n\t  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n\t\n\t  // Note the closing quote is made optional as an IDE experience improvment.\n\t  String: /^\"(?:[^\"\\\\]|\\\\(?:b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?/\n\t};\n\t\n\t/**\n\t * The parser rules. These are very close to, but not exactly the same as the\n\t * spec. Minor deviations allow for a simpler implementation. The resulting\n\t * parser can parse everything the spec declares possible.\n\t */\n\tvar ParseRules = {\n\t  Document: [list('Definition')],\n\t  Definition: function Definition(token) {\n\t    switch (token.value) {\n\t      case 'query':\n\t        return 'Query';\n\t      case 'mutation':\n\t        return 'Mutation';\n\t      case 'subscription':\n\t        return 'Subscription';\n\t      case 'fragment':\n\t        return 'FragmentDefinition';\n\t      case '{':\n\t        return 'ShortQuery';\n\t    }\n\t  },\n\t  // Note: instead of \"Operation\", these rules have been separated out.\n\t  Query: [word('query'), opt(name('def')), opt('VariableDefinitions'), list('Directive'), 'SelectionSet'],\n\t  ShortQuery: ['SelectionSet'],\n\t  Mutation: [word('mutation'), opt(name('def')), opt('VariableDefinitions'), list('Directive'), 'SelectionSet'],\n\t  Subscription: [word('subscription'), opt(name('def')), opt('VariableDefinitions'), list('Directive'), 'SelectionSet'],\n\t  VariableDefinitions: [p('('), list('VariableDefinition'), p(')')],\n\t  VariableDefinition: ['Variable', p(':'), 'Type', opt('DefaultValue')],\n\t  Variable: [p('$', 'variable'), name('variable')],\n\t  DefaultValue: [p('='), 'Value'],\n\t  SelectionSet: [p('{'), list('Selection'), p('}')],\n\t  Selection: function Selection(token, stream) {\n\t    return token.value === '...' ? stream.match(/[\\s\\u00a0,]*on\\b/, false) ? 'InlineFragment' : 'FragmentSpread' : stream.match(/[\\s\\u00a0,]*:/, false) ? 'AliasedField' : 'Field';\n\t  },\n\t  // Note: this minor deviation of \"AliasedField\" simplifies the lookahead.\n\t  AliasedField: [name('qualifier'), p(':'), 'Field'],\n\t  Field: [name('property'), opt('Arguments'), list('Directive'), opt('SelectionSet')],\n\t  Arguments: [p('('), list('Argument'), p(')')],\n\t  Argument: [name('attribute'), p(':'), 'Value'],\n\t  FragmentSpread: [p('...'), name('def'), list('Directive')],\n\t  InlineFragment: [p('...'), opt('TypeCondition'), list('Directive'), 'SelectionSet'],\n\t  FragmentDefinition: [word('fragment'), name('def'), 'TypeCondition', list('Directive'), 'SelectionSet'],\n\t  TypeCondition: [word('on'), type('atom')],\n\t  // Variables could be parsed in cases where only Const is expected by spec.\n\t  Value: function Value(token) {\n\t    switch (token.kind) {\n\t      case 'Number':\n\t        return 'NumberValue';\n\t      case 'String':\n\t        return 'StringValue';\n\t      case 'Punctuation':\n\t        switch (token.value) {\n\t          case '[':\n\t            return 'ListValue';\n\t          case '{':\n\t            return 'ObjectValue';\n\t          case '$':\n\t            return 'Variable';\n\t        }\n\t        return null;\n\t      case 'Name':\n\t        switch (token.value) {\n\t          case 'true':case 'false':\n\t            return 'BooleanValue';\n\t        }\n\t        return 'EnumValue';\n\t    }\n\t  },\n\t  NumberValue: [t('Number', 'number')],\n\t  StringValue: [t('String', 'string')],\n\t  BooleanValue: [t('Name', 'builtin')],\n\t  EnumValue: [name('string-2')],\n\t  ListValue: [p('['), list('Value'), p(']')],\n\t  ObjectValue: [p('{'), list('ObjectField'), p('}')],\n\t  ObjectField: [name('attribute'), p(':'), 'Value'],\n\t  Type: function Type(token) {\n\t    return token.value === '[' ? 'ListType' : 'NamedType';\n\t  },\n\t  // NonNullType has been merged into ListType and NamedType to simplify.\n\t  ListType: [p('['), 'NamedType', p(']'), opt(p('!'))],\n\t  NamedType: [name('atom'), opt(p('!'))],\n\t  Directive: [p('@', 'meta'), name('meta'), opt('Arguments')]\n\t};\n\n/***/ },\n/* 439 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _reactDom = __webpack_require__(155);\n\t\n\tvar _reactDom2 = _interopRequireDefault(_reactDom);\n\t\n\tvar _codemirror = __webpack_require__(351);\n\t\n\tvar _codemirror2 = _interopRequireDefault(_codemirror);\n\t\n\t__webpack_require__(431);\n\t\n\t__webpack_require__(429);\n\t\n\t__webpack_require__(432);\n\t\n\t__webpack_require__(433);\n\t\n\t__webpack_require__(440);\n\t\n\t__webpack_require__(441);\n\t\n\t/**\n\t * VariableEditor\n\t *\n\t * An instance of CodeMirror for editing variables defined in QueryEditor.\n\t *\n\t * Props:\n\t *\n\t *   - value: The text of the editor.\n\t *   - onEdit: A function called when the editor changes, given the edited text.\n\t *\n\t */\n\t\n\tvar VariableEditor = (function (_React$Component) {\n\t  _inherits(VariableEditor, _React$Component);\n\t\n\t  _createClass(VariableEditor, null, [{\n\t    key: 'propTypes',\n\t    value: {\n\t      value: _react.PropTypes.string,\n\t      onEdit: _react.PropTypes.func\n\t    },\n\t    enumerable: true\n\t  }]);\n\t\n\t  function VariableEditor(props) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, VariableEditor);\n\t\n\t    _React$Component.call(this);\n\t\n\t    // Keep a cached version of the value, this cache will be updated when the\n\t    // editor is updated, which can later be used to protect the editor from\n\t    // unnecessary updates during the update lifecycle.\n\t\n\t    this._onEdit = function () {\n\t      if (!_this.ignoreChangeEvent) {\n\t        _this.cachedValue = _this.editor.getValue();\n\t        if (_this.props.onEdit) {\n\t          _this.props.onEdit(_this.cachedValue);\n\t        }\n\t      }\n\t    };\n\t\n\t    this.cachedValue = props.value || '';\n\t  }\n\t\n\t  VariableEditor.prototype.componentDidMount = function componentDidMount() {\n\t    this.editor = _codemirror2['default'](_reactDom2['default'].findDOMNode(this), {\n\t      value: this.props.value || '',\n\t      lineNumbers: true,\n\t      theme: 'graphiql',\n\t      mode: {\n\t        name: 'javascript',\n\t        json: true\n\t      },\n\t      lint: true,\n\t      autoCloseBrackets: true,\n\t      matchBrackets: true,\n\t      showCursorWhenSelecting: true,\n\t      keyMap: 'sublime',\n\t      foldGutter: {\n\t        minFoldSize: 4\n\t      },\n\t      gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n\t      extraKeys: {\n\t        // Editor improvements\n\t        'Ctrl-Left': 'goSubwordLeft',\n\t        'Ctrl-Right': 'goSubwordRight',\n\t        'Alt-Left': 'goGroupLeft',\n\t        'Alt-Right': 'goGroupRight'\n\t      }\n\t    });\n\t\n\t    this.editor.on('change', this._onEdit);\n\t  };\n\t\n\t  VariableEditor.prototype.componentWillUnmount = function componentWillUnmount() {\n\t    this.editor.off('change', this._onEdit);\n\t    this.editor = null;\n\t  };\n\t\n\t  VariableEditor.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n\t    // Ensure the changes caused by this update are not interpretted as\n\t    // user-input changes which could otherwise result in an infinite\n\t    // event loop.\n\t    this.ignoreChangeEvent = true;\n\t    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {\n\t      this.cachedValue = this.props.value;\n\t      this.editor.setValue(this.props.value);\n\t    }\n\t    this.ignoreChangeEvent = false;\n\t  };\n\t\n\t  VariableEditor.prototype.render = function render() {\n\t    return _react2['default'].createElement('div', { className: 'codemirrorWrap', ref: 'codemirror' });\n\t  };\n\t\n\t  return VariableEditor;\n\t})(_react2['default'].Component);\n\t\n\texports.VariableEditor = VariableEditor;\n\n/***/ },\n/* 440 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// TODO actually recognize syntax of TypeScript constructs\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n\t  var indentUnit = config.indentUnit;\n\t  var statementIndent = parserConfig.statementIndent;\n\t  var jsonldMode = parserConfig.jsonld;\n\t  var jsonMode = parserConfig.json || jsonldMode;\n\t  var isTS = parserConfig.typescript;\n\t  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\t\n\t  // Tokenizer\n\t\n\t  var keywords = function(){\n\t    function kw(type) {return {type: type, style: \"keyword\"};}\n\t    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n\t    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\t\n\t    var jsKeywords = {\n\t      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n\t      \"return\": C, \"break\": C, \"continue\": C, \"new\": kw(\"new\"), \"delete\": C, \"throw\": C, \"debugger\": C,\n\t      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n\t      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n\t      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n\t      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n\t      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n\t      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n\t      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C\n\t    };\n\t\n\t    // Extend the 'normal' keywords with the TypeScript language extensions\n\t    if (isTS) {\n\t      var type = {type: \"variable\", style: \"variable-3\"};\n\t      var tsKeywords = {\n\t        // object-like things\n\t        \"interface\": kw(\"interface\"),\n\t        \"extends\": kw(\"extends\"),\n\t        \"constructor\": kw(\"constructor\"),\n\t\n\t        // scope modifiers\n\t        \"public\": kw(\"public\"),\n\t        \"private\": kw(\"private\"),\n\t        \"protected\": kw(\"protected\"),\n\t        \"static\": kw(\"static\"),\n\t\n\t        // types\n\t        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\n\t      };\n\t\n\t      for (var attr in tsKeywords) {\n\t        jsKeywords[attr] = tsKeywords[attr];\n\t      }\n\t    }\n\t\n\t    return jsKeywords;\n\t  }();\n\t\n\t  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n\t  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\t\n\t  function readRegexp(stream) {\n\t    var escaped = false, next, inSet = false;\n\t    while ((next = stream.next()) != null) {\n\t      if (!escaped) {\n\t        if (next == \"/\" && !inSet) return;\n\t        if (next == \"[\") inSet = true;\n\t        else if (inSet && next == \"]\") inSet = false;\n\t      }\n\t      escaped = !escaped && next == \"\\\\\";\n\t    }\n\t  }\n\t\n\t  // Used as scratch variables to communicate multiple values without\n\t  // consing up tons of objects.\n\t  var type, content;\n\t  function ret(tp, style, cont) {\n\t    type = tp; content = cont;\n\t    return style;\n\t  }\n\t  function tokenBase(stream, state) {\n\t    var ch = stream.next();\n\t    if (ch == '\"' || ch == \"'\") {\n\t      state.tokenize = tokenString(ch);\n\t      return state.tokenize(stream, state);\n\t    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \".\" && stream.match(\"..\")) {\n\t      return ret(\"spread\", \"meta\");\n\t    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n\t      return ret(ch);\n\t    } else if (ch == \"=\" && stream.eat(\">\")) {\n\t      return ret(\"=>\", \"operator\");\n\t    } else if (ch == \"0\" && stream.eat(/x/i)) {\n\t      stream.eatWhile(/[\\da-f]/i);\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \"0\" && stream.eat(/o/i)) {\n\t      stream.eatWhile(/[0-7]/i);\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \"0\" && stream.eat(/b/i)) {\n\t      stream.eatWhile(/[01]/i);\n\t      return ret(\"number\", \"number\");\n\t    } else if (/\\d/.test(ch)) {\n\t      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \"/\") {\n\t      if (stream.eat(\"*\")) {\n\t        state.tokenize = tokenComment;\n\t        return tokenComment(stream, state);\n\t      } else if (stream.eat(\"/\")) {\n\t        stream.skipToEnd();\n\t        return ret(\"comment\", \"comment\");\n\t      } else if (/^(?:operator|sof|keyword c|case|new|[\\[{}\\(,;:])$/.test(state.lastType)) {\n\t        readRegexp(stream);\n\t        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n\t        return ret(\"regexp\", \"string-2\");\n\t      } else {\n\t        stream.eatWhile(isOperatorChar);\n\t        return ret(\"operator\", \"operator\", stream.current());\n\t      }\n\t    } else if (ch == \"`\") {\n\t      state.tokenize = tokenQuasi;\n\t      return tokenQuasi(stream, state);\n\t    } else if (ch == \"#\") {\n\t      stream.skipToEnd();\n\t      return ret(\"error\", \"error\");\n\t    } else if (isOperatorChar.test(ch)) {\n\t      stream.eatWhile(isOperatorChar);\n\t      return ret(\"operator\", \"operator\", stream.current());\n\t    } else if (wordRE.test(ch)) {\n\t      stream.eatWhile(wordRE);\n\t      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n\t      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n\t                     ret(\"variable\", \"variable\", word);\n\t    }\n\t  }\n\t\n\t  function tokenString(quote) {\n\t    return function(stream, state) {\n\t      var escaped = false, next;\n\t      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n\t        state.tokenize = tokenBase;\n\t        return ret(\"jsonld-keyword\", \"meta\");\n\t      }\n\t      while ((next = stream.next()) != null) {\n\t        if (next == quote && !escaped) break;\n\t        escaped = !escaped && next == \"\\\\\";\n\t      }\n\t      if (!escaped) state.tokenize = tokenBase;\n\t      return ret(\"string\", \"string\");\n\t    };\n\t  }\n\t\n\t  function tokenComment(stream, state) {\n\t    var maybeEnd = false, ch;\n\t    while (ch = stream.next()) {\n\t      if (ch == \"/\" && maybeEnd) {\n\t        state.tokenize = tokenBase;\n\t        break;\n\t      }\n\t      maybeEnd = (ch == \"*\");\n\t    }\n\t    return ret(\"comment\", \"comment\");\n\t  }\n\t\n\t  function tokenQuasi(stream, state) {\n\t    var escaped = false, next;\n\t    while ((next = stream.next()) != null) {\n\t      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n\t        state.tokenize = tokenBase;\n\t        break;\n\t      }\n\t      escaped = !escaped && next == \"\\\\\";\n\t    }\n\t    return ret(\"quasi\", \"string-2\", stream.current());\n\t  }\n\t\n\t  var brackets = \"([{}])\";\n\t  // This is a crude lookahead trick to try and notice that we're\n\t  // parsing the argument patterns for a fat-arrow function before we\n\t  // actually hit the arrow token. It only works if the arrow is on\n\t  // the same line as the arguments and there's no strange noise\n\t  // (comments) in between. Fallback is to only notice when we hit the\n\t  // arrow, and not declare the arguments as locals for the arrow\n\t  // body.\n\t  function findFatArrow(stream, state) {\n\t    if (state.fatArrowAt) state.fatArrowAt = null;\n\t    var arrow = stream.string.indexOf(\"=>\", stream.start);\n\t    if (arrow < 0) return;\n\t\n\t    var depth = 0, sawSomething = false;\n\t    for (var pos = arrow - 1; pos >= 0; --pos) {\n\t      var ch = stream.string.charAt(pos);\n\t      var bracket = brackets.indexOf(ch);\n\t      if (bracket >= 0 && bracket < 3) {\n\t        if (!depth) { ++pos; break; }\n\t        if (--depth == 0) break;\n\t      } else if (bracket >= 3 && bracket < 6) {\n\t        ++depth;\n\t      } else if (wordRE.test(ch)) {\n\t        sawSomething = true;\n\t      } else if (/[\"'\\/]/.test(ch)) {\n\t        return;\n\t      } else if (sawSomething && !depth) {\n\t        ++pos;\n\t        break;\n\t      }\n\t    }\n\t    if (sawSomething && !depth) state.fatArrowAt = pos;\n\t  }\n\t\n\t  // Parser\n\t\n\t  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\t\n\t  function JSLexical(indented, column, type, align, prev, info) {\n\t    this.indented = indented;\n\t    this.column = column;\n\t    this.type = type;\n\t    this.prev = prev;\n\t    this.info = info;\n\t    if (align != null) this.align = align;\n\t  }\n\t\n\t  function inScope(state, varname) {\n\t    for (var v = state.localVars; v; v = v.next)\n\t      if (v.name == varname) return true;\n\t    for (var cx = state.context; cx; cx = cx.prev) {\n\t      for (var v = cx.vars; v; v = v.next)\n\t        if (v.name == varname) return true;\n\t    }\n\t  }\n\t\n\t  function parseJS(state, style, type, content, stream) {\n\t    var cc = state.cc;\n\t    // Communicate our context to the combinators.\n\t    // (Less wasteful than consing up a hundred closures on every call.)\n\t    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\t\n\t    if (!state.lexical.hasOwnProperty(\"align\"))\n\t      state.lexical.align = true;\n\t\n\t    while(true) {\n\t      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n\t      if (combinator(type, content)) {\n\t        while(cc.length && cc[cc.length - 1].lex)\n\t          cc.pop()();\n\t        if (cx.marked) return cx.marked;\n\t        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n\t        return style;\n\t      }\n\t    }\n\t  }\n\t\n\t  // Combinator utils\n\t\n\t  var cx = {state: null, column: null, marked: null, cc: null};\n\t  function pass() {\n\t    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n\t  }\n\t  function cont() {\n\t    pass.apply(null, arguments);\n\t    return true;\n\t  }\n\t  function register(varname) {\n\t    function inList(list) {\n\t      for (var v = list; v; v = v.next)\n\t        if (v.name == varname) return true;\n\t      return false;\n\t    }\n\t    var state = cx.state;\n\t    cx.marked = \"def\";\n\t    if (state.context) {\n\t      if (inList(state.localVars)) return;\n\t      state.localVars = {name: varname, next: state.localVars};\n\t    } else {\n\t      if (inList(state.globalVars)) return;\n\t      if (parserConfig.globalVars)\n\t        state.globalVars = {name: varname, next: state.globalVars};\n\t    }\n\t  }\n\t\n\t  // Combinators\n\t\n\t  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n\t  function pushcontext() {\n\t    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n\t    cx.state.localVars = defaultVars;\n\t  }\n\t  function popcontext() {\n\t    cx.state.localVars = cx.state.context.vars;\n\t    cx.state.context = cx.state.context.prev;\n\t  }\n\t  function pushlex(type, info) {\n\t    var result = function() {\n\t      var state = cx.state, indent = state.indented;\n\t      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n\t      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n\t        indent = outer.indented;\n\t      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n\t    };\n\t    result.lex = true;\n\t    return result;\n\t  }\n\t  function poplex() {\n\t    var state = cx.state;\n\t    if (state.lexical.prev) {\n\t      if (state.lexical.type == \")\")\n\t        state.indented = state.lexical.indented;\n\t      state.lexical = state.lexical.prev;\n\t    }\n\t  }\n\t  poplex.lex = true;\n\t\n\t  function expect(wanted) {\n\t    function exp(type) {\n\t      if (type == wanted) return cont();\n\t      else if (wanted == \";\") return pass();\n\t      else return cont(exp);\n\t    };\n\t    return exp;\n\t  }\n\t\n\t  function statement(type, value) {\n\t    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n\t    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n\t    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n\t    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n\t    if (type == \";\") return cont();\n\t    if (type == \"if\") {\n\t      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n\t        cx.state.cc.pop()();\n\t      return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n\t    }\n\t    if (type == \"function\") return cont(functiondef);\n\t    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n\t    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n\t    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n\t                                      block, poplex, poplex);\n\t    if (type == \"case\") return cont(expression, expect(\":\"));\n\t    if (type == \"default\") return cont(expect(\":\"));\n\t    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n\t                                     statement, poplex, popcontext);\n\t    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n\t    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n\t    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n\t    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n\t  }\n\t  function expression(type) {\n\t    return expressionInner(type, false);\n\t  }\n\t  function expressionNoComma(type) {\n\t    return expressionInner(type, true);\n\t  }\n\t  function expressionInner(type, noComma) {\n\t    if (cx.state.fatArrowAt == cx.stream.start) {\n\t      var body = noComma ? arrowBodyNoComma : arrowBody;\n\t      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n\t      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n\t    }\n\t\n\t    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n\t    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n\t    if (type == \"function\") return cont(functiondef, maybeop);\n\t    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n\t    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, comprehension, expect(\")\"), poplex, maybeop);\n\t    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n\t    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n\t    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n\t    if (type == \"quasi\") return pass(quasi, maybeop);\n\t    if (type == \"new\") return cont(maybeTarget(noComma));\n\t    return cont();\n\t  }\n\t  function maybeexpression(type) {\n\t    if (type.match(/[;\\}\\)\\],]/)) return pass();\n\t    return pass(expression);\n\t  }\n\t  function maybeexpressionNoComma(type) {\n\t    if (type.match(/[;\\}\\)\\],]/)) return pass();\n\t    return pass(expressionNoComma);\n\t  }\n\t\n\t  function maybeoperatorComma(type, value) {\n\t    if (type == \",\") return cont(expression);\n\t    return maybeoperatorNoComma(type, value, false);\n\t  }\n\t  function maybeoperatorNoComma(type, value, noComma) {\n\t    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n\t    var expr = noComma == false ? expression : expressionNoComma;\n\t    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n\t    if (type == \"operator\") {\n\t      if (/\\+\\+|--/.test(value)) return cont(me);\n\t      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n\t      return cont(expr);\n\t    }\n\t    if (type == \"quasi\") { return pass(quasi, me); }\n\t    if (type == \";\") return;\n\t    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n\t    if (type == \".\") return cont(property, me);\n\t    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n\t  }\n\t  function quasi(type, value) {\n\t    if (type != \"quasi\") return pass();\n\t    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n\t    return cont(expression, continueQuasi);\n\t  }\n\t  function continueQuasi(type) {\n\t    if (type == \"}\") {\n\t      cx.marked = \"string-2\";\n\t      cx.state.tokenize = tokenQuasi;\n\t      return cont(quasi);\n\t    }\n\t  }\n\t  function arrowBody(type) {\n\t    findFatArrow(cx.stream, cx.state);\n\t    return pass(type == \"{\" ? statement : expression);\n\t  }\n\t  function arrowBodyNoComma(type) {\n\t    findFatArrow(cx.stream, cx.state);\n\t    return pass(type == \"{\" ? statement : expressionNoComma);\n\t  }\n\t  function maybeTarget(noComma) {\n\t    return function(type) {\n\t      if (type == \".\") return cont(noComma ? targetNoComma : target);\n\t      else return pass(noComma ? expressionNoComma : expression);\n\t    };\n\t  }\n\t  function target(_, value) {\n\t    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n\t  }\n\t  function targetNoComma(_, value) {\n\t    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n\t  }\n\t  function maybelabel(type) {\n\t    if (type == \":\") return cont(poplex, statement);\n\t    return pass(maybeoperatorComma, expect(\";\"), poplex);\n\t  }\n\t  function property(type) {\n\t    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n\t  }\n\t  function objprop(type, value) {\n\t    if (type == \"variable\" || cx.style == \"keyword\") {\n\t      cx.marked = \"property\";\n\t      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n\t      return cont(afterprop);\n\t    } else if (type == \"number\" || type == \"string\") {\n\t      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n\t      return cont(afterprop);\n\t    } else if (type == \"jsonld-keyword\") {\n\t      return cont(afterprop);\n\t    } else if (type == \"[\") {\n\t      return cont(expression, expect(\"]\"), afterprop);\n\t    } else if (type == \"spread\") {\n\t      return cont(expression);\n\t    }\n\t  }\n\t  function getterSetter(type) {\n\t    if (type != \"variable\") return pass(afterprop);\n\t    cx.marked = \"property\";\n\t    return cont(functiondef);\n\t  }\n\t  function afterprop(type) {\n\t    if (type == \":\") return cont(expressionNoComma);\n\t    if (type == \"(\") return pass(functiondef);\n\t  }\n\t  function commasep(what, end) {\n\t    function proceed(type) {\n\t      if (type == \",\") {\n\t        var lex = cx.state.lexical;\n\t        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n\t        return cont(what, proceed);\n\t      }\n\t      if (type == end) return cont();\n\t      return cont(expect(end));\n\t    }\n\t    return function(type) {\n\t      if (type == end) return cont();\n\t      return pass(what, proceed);\n\t    };\n\t  }\n\t  function contCommasep(what, end, info) {\n\t    for (var i = 3; i < arguments.length; i++)\n\t      cx.cc.push(arguments[i]);\n\t    return cont(pushlex(end, info), commasep(what, end), poplex);\n\t  }\n\t  function block(type) {\n\t    if (type == \"}\") return cont();\n\t    return pass(statement, block);\n\t  }\n\t  function maybetype(type) {\n\t    if (isTS && type == \":\") return cont(typedef);\n\t  }\n\t  function maybedefault(_, value) {\n\t    if (value == \"=\") return cont(expressionNoComma);\n\t  }\n\t  function typedef(type) {\n\t    if (type == \"variable\") {cx.marked = \"variable-3\"; return cont();}\n\t  }\n\t  function vardef() {\n\t    return pass(pattern, maybetype, maybeAssign, vardefCont);\n\t  }\n\t  function pattern(type, value) {\n\t    if (type == \"variable\") { register(value); return cont(); }\n\t    if (type == \"spread\") return cont(pattern);\n\t    if (type == \"[\") return contCommasep(pattern, \"]\");\n\t    if (type == \"{\") return contCommasep(proppattern, \"}\");\n\t  }\n\t  function proppattern(type, value) {\n\t    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n\t      register(value);\n\t      return cont(maybeAssign);\n\t    }\n\t    if (type == \"variable\") cx.marked = \"property\";\n\t    if (type == \"spread\") return cont(pattern);\n\t    return cont(expect(\":\"), pattern, maybeAssign);\n\t  }\n\t  function maybeAssign(_type, value) {\n\t    if (value == \"=\") return cont(expressionNoComma);\n\t  }\n\t  function vardefCont(type) {\n\t    if (type == \",\") return cont(vardef);\n\t  }\n\t  function maybeelse(type, value) {\n\t    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n\t  }\n\t  function forspec(type) {\n\t    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n\t  }\n\t  function forspec1(type) {\n\t    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n\t    if (type == \";\") return cont(forspec2);\n\t    if (type == \"variable\") return cont(formaybeinof);\n\t    return pass(expression, expect(\";\"), forspec2);\n\t  }\n\t  function formaybeinof(_type, value) {\n\t    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n\t    return cont(maybeoperatorComma, forspec2);\n\t  }\n\t  function forspec2(type, value) {\n\t    if (type == \";\") return cont(forspec3);\n\t    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n\t    return pass(expression, expect(\";\"), forspec3);\n\t  }\n\t  function forspec3(type) {\n\t    if (type != \")\") cont(expression);\n\t  }\n\t  function functiondef(type, value) {\n\t    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n\t    if (type == \"variable\") {register(value); return cont(functiondef);}\n\t    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, statement, popcontext);\n\t  }\n\t  function funarg(type) {\n\t    if (type == \"spread\") return cont(funarg);\n\t    return pass(pattern, maybetype, maybedefault);\n\t  }\n\t  function className(type, value) {\n\t    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n\t  }\n\t  function classNameAfter(type, value) {\n\t    if (value == \"extends\") return cont(expression, classNameAfter);\n\t    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n\t  }\n\t  function classBody(type, value) {\n\t    if (type == \"variable\" || cx.style == \"keyword\") {\n\t      if (value == \"static\") {\n\t        cx.marked = \"keyword\";\n\t        return cont(classBody);\n\t      }\n\t      cx.marked = \"property\";\n\t      if (value == \"get\" || value == \"set\") return cont(classGetterSetter, functiondef, classBody);\n\t      return cont(functiondef, classBody);\n\t    }\n\t    if (value == \"*\") {\n\t      cx.marked = \"keyword\";\n\t      return cont(classBody);\n\t    }\n\t    if (type == \";\") return cont(classBody);\n\t    if (type == \"}\") return cont();\n\t  }\n\t  function classGetterSetter(type) {\n\t    if (type != \"variable\") return pass();\n\t    cx.marked = \"property\";\n\t    return cont();\n\t  }\n\t  function afterExport(_type, value) {\n\t    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n\t    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n\t    return pass(statement);\n\t  }\n\t  function afterImport(type) {\n\t    if (type == \"string\") return cont();\n\t    return pass(importSpec, maybeFrom);\n\t  }\n\t  function importSpec(type, value) {\n\t    if (type == \"{\") return contCommasep(importSpec, \"}\");\n\t    if (type == \"variable\") register(value);\n\t    if (value == \"*\") cx.marked = \"keyword\";\n\t    return cont(maybeAs);\n\t  }\n\t  function maybeAs(_type, value) {\n\t    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n\t  }\n\t  function maybeFrom(_type, value) {\n\t    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n\t  }\n\t  function arrayLiteral(type) {\n\t    if (type == \"]\") return cont();\n\t    return pass(expressionNoComma, maybeArrayComprehension);\n\t  }\n\t  function maybeArrayComprehension(type) {\n\t    if (type == \"for\") return pass(comprehension, expect(\"]\"));\n\t    if (type == \",\") return cont(commasep(maybeexpressionNoComma, \"]\"));\n\t    return pass(commasep(expressionNoComma, \"]\"));\n\t  }\n\t  function comprehension(type) {\n\t    if (type == \"for\") return cont(forspec, comprehension);\n\t    if (type == \"if\") return cont(expression, comprehension);\n\t  }\n\t\n\t  function isContinuedStatement(state, textAfter) {\n\t    return state.lastType == \"operator\" || state.lastType == \",\" ||\n\t      isOperatorChar.test(textAfter.charAt(0)) ||\n\t      /[,.]/.test(textAfter.charAt(0));\n\t  }\n\t\n\t  // Interface\n\t\n\t  return {\n\t    startState: function(basecolumn) {\n\t      var state = {\n\t        tokenize: tokenBase,\n\t        lastType: \"sof\",\n\t        cc: [],\n\t        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n\t        localVars: parserConfig.localVars,\n\t        context: parserConfig.localVars && {vars: parserConfig.localVars},\n\t        indented: 0\n\t      };\n\t      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n\t        state.globalVars = parserConfig.globalVars;\n\t      return state;\n\t    },\n\t\n\t    token: function(stream, state) {\n\t      if (stream.sol()) {\n\t        if (!state.lexical.hasOwnProperty(\"align\"))\n\t          state.lexical.align = false;\n\t        state.indented = stream.indentation();\n\t        findFatArrow(stream, state);\n\t      }\n\t      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n\t      var style = state.tokenize(stream, state);\n\t      if (type == \"comment\") return style;\n\t      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n\t      return parseJS(state, style, type, content, stream);\n\t    },\n\t\n\t    indent: function(state, textAfter) {\n\t      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n\t      if (state.tokenize != tokenBase) return 0;\n\t      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n\t      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n\t      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n\t        var c = state.cc[i];\n\t        if (c == poplex) lexical = lexical.prev;\n\t        else if (c != maybeelse) break;\n\t      }\n\t      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n\t      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n\t        lexical = lexical.prev;\n\t      var type = lexical.type, closing = firstChar == type;\n\t\n\t      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n\t      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n\t      else if (type == \"form\") return lexical.indented + indentUnit;\n\t      else if (type == \"stat\")\n\t        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n\t      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n\t        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n\t      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n\t      else return lexical.indented + (closing ? 0 : indentUnit);\n\t    },\n\t\n\t    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n\t    blockCommentStart: jsonMode ? null : \"/*\",\n\t    blockCommentEnd: jsonMode ? null : \"*/\",\n\t    lineComment: jsonMode ? null : \"//\",\n\t    fold: \"brace\",\n\t    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\t\n\t    helperType: jsonMode ? \"json\" : \"javascript\",\n\t    jsonldMode: jsonldMode,\n\t    jsonMode: jsonMode\n\t  };\n\t});\n\t\n\tCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\t\n\tCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\n\tCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\n\tCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\n\tCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\n\tCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\t\n\t});\n\n\n/***/ },\n/* 441 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _codemirror = __webpack_require__(351);\n\t\n\tvar _codemirror2 = _interopRequireDefault(_codemirror);\n\t\n\tvar _jsonLint = __webpack_require__(442);\n\t\n\t_codemirror2['default'].registerHelper('lint', 'json', function (text) {\n\t  var err = _jsonLint.jsonLint(text);\n\t  if (err) {\n\t    return [{\n\t      message: err.message,\n\t      severity: 'error',\n\t      from: getLocation(text, err.start),\n\t      to: getLocation(text, err.end)\n\t    }];\n\t  }\n\t  return [];\n\t});\n\t\n\tfunction getLocation(source, position) {\n\t  var line = 0;\n\t  var column = position;\n\t  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n\t  var match;\n\t  while ((match = lineRegexp.exec(source)) && match.index < position) {\n\t    line += 1;\n\t    column = position - (match.index + match[0].length);\n\t  }\n\t  return _codemirror2['default'].Pos(line, column);\n\t}\n\n/***/ },\n/* 442 */\n/***/ function(module, exports) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t/**\n\t * This JSON parser simply walks the input, but does not generate an AST\n\t * or Value. Instead it returns either an syntax error object, or null.\n\t *\n\t * The returned syntax error object:\n\t *\n\t *   - message: string\n\t *   - start: int - the start inclusive offset of the syntax error\n\t *   - end: int - the end exclusive offset of the syntax error\n\t *\n\t */\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.jsonLint = jsonLint;\n\t\n\tfunction jsonLint(str, looseMode) {\n\t  string = str;\n\t  strLen = str.length;\n\t  end = -1;\n\t  try {\n\t    ch();\n\t    lex();\n\t    if (looseMode) {\n\t      readVal();\n\t    } else {\n\t      readObj();\n\t    }\n\t    expect('EOF');\n\t  } catch (err) {\n\t    return err;\n\t  }\n\t}\n\t\n\tvar string;\n\tvar strLen;\n\tvar start;\n\tvar end;\n\tvar code;\n\tvar kind;\n\t\n\tfunction readObj() {\n\t  expect('{');\n\t  if (!skip('}')) {\n\t    do {\n\t      expect('String');\n\t      expect(':');\n\t      readVal();\n\t    } while (skip(','));\n\t    expect('}');\n\t  }\n\t}\n\t\n\tfunction readArr() {\n\t  expect('[');\n\t  if (!skip(']')) {\n\t    do {\n\t      readVal();\n\t    } while (skip(','));\n\t    expect(']');\n\t  }\n\t}\n\t\n\tfunction readVal() {\n\t  switch (kind) {\n\t    case '[':\n\t      return readArr();\n\t    case '{':\n\t      return readObj();\n\t    case 'String':\n\t      return lex();\n\t    default:\n\t      return expect('Value');\n\t  }\n\t}\n\t\n\tfunction syntaxError(message) {\n\t  return { message: message, start: start, end: end };\n\t}\n\t\n\tfunction expect(str) {\n\t  if (kind === str) {\n\t    return lex();\n\t  }\n\t  throw syntaxError('Expected ' + str + ' but got ' + string.slice(start, end) + '.');\n\t}\n\t\n\tfunction skip(k) {\n\t  if (kind === k) {\n\t    lex();\n\t    return true;\n\t  }\n\t}\n\t\n\tfunction ch() {\n\t  if (end < strLen) {\n\t    end++;\n\t    code = end === strLen ? 0 : string.charCodeAt(end);\n\t  }\n\t}\n\t\n\tfunction lex() {\n\t  while (code === 9 || code === 10 || code === 13 || code === 32) {\n\t    ch();\n\t  }\n\t\n\t  if (code === 0) {\n\t    kind = 'EOF';\n\t    return;\n\t  }\n\t\n\t  start = end;\n\t\n\t  switch (code) {\n\t    // \"\n\t    case 34:\n\t      kind = 'String';\n\t      return readString();\n\t    // -\n\t    case 45:\n\t    // 0-9\n\t    case 48:case 49:case 50:case 51:case 52:\n\t    case 53:case 54:case 55:case 56:case 57:\n\t      kind = 'Value';\n\t      return readNumber();\n\t    // f\n\t    case 102:\n\t      if (string.slice(start, start + 5) !== 'false') {\n\t        break;\n\t      }\n\t      end += 4;ch();\n\t\n\t      kind = 'Value';\n\t      return;\n\t    // n\n\t    case 110:\n\t      if (string.slice(start, start + 4) !== 'null') {\n\t        break;\n\t      }\n\t      end += 3;ch();\n\t\n\t      kind = 'Value';\n\t      return;\n\t    // t\n\t    case 116:\n\t      if (string.slice(start, start + 4) !== 'true') {\n\t        break;\n\t      }\n\t      end += 3;ch();\n\t\n\t      kind = 'Value';\n\t      return;\n\t  }\n\t\n\t  kind = string[start];\n\t  ch();\n\t}\n\t\n\tfunction readString() {\n\t  ch();\n\t  while (code !== 34) {\n\t    ch();\n\t    if (code === 92) {\n\t      // \\\n\t      ch();\n\t      switch (code) {\n\t        case 34: // '\n\t        case 47: // /\n\t        case 92: // \\\n\t        case 98: // b\n\t        case 102: // f\n\t        case 110: // n\n\t        case 114: // r\n\t        case 116:\n\t          // t\n\t          ch();\n\t          break;\n\t        case 117:\n\t          // u\n\t          ch();\n\t          readHex();\n\t          readHex();\n\t          readHex();\n\t          readHex();\n\t          break;\n\t        default:\n\t          throw syntaxError('Bad character escape sequence.');\n\t      }\n\t    } else if (end === strLen) {\n\t      throw syntaxError('Unterminated string.');\n\t    }\n\t  }\n\t\n\t  if (code === 34) {\n\t    ch();\n\t    return;\n\t  }\n\t\n\t  throw syntaxError('Unterminated string.');\n\t}\n\t\n\tfunction readHex() {\n\t  if (code >= 48 && code <= 57 || // 0-9\n\t  code >= 65 && code <= 70 || // A-F\n\t  code >= 97 && code <= 102 // a-f\n\t  ) {\n\t      return ch();\n\t    }\n\t  throw syntaxError('Expected hexadecimal digit.');\n\t}\n\t\n\tfunction readNumber() {\n\t  if (code === 45) {\n\t    // -\n\t    ch();\n\t  }\n\t\n\t  if (code === 48) {\n\t    // 0\n\t    ch();\n\t  } else {\n\t    readDigits();\n\t  }\n\t\n\t  if (code === 46) {\n\t    // .\n\t    ch();\n\t    readDigits();\n\t  }\n\t\n\t  if (code === 69 || code === 101) {\n\t    // E e\n\t    ch();\n\t    if (code === 43 || code === 45) {\n\t      // + -\n\t      ch();\n\t    }\n\t    readDigits();\n\t  }\n\t}\n\t\n\tfunction readDigits() {\n\t  if (code < 48 || code > 57) {\n\t    // 0 - 9\n\t    throw syntaxError('Expected decimal digit.');\n\t  }\n\t  do {\n\t    ch();\n\t  } while (code >= 48 && code <= 57); // 0 - 9\n\t}\n\n/***/ },\n/* 443 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _reactDom = __webpack_require__(155);\n\t\n\tvar _reactDom2 = _interopRequireDefault(_reactDom);\n\t\n\tvar _codemirror = __webpack_require__(351);\n\t\n\tvar _codemirror2 = _interopRequireDefault(_codemirror);\n\t\n\t__webpack_require__(429);\n\t\n\t__webpack_require__(431);\n\t\n\t__webpack_require__(433);\n\t\n\t__webpack_require__(440);\n\t\n\t/**\n\t * ResultViewer\n\t *\n\t * Maintains an instance of CodeMirror for viewing a GraphQL response.\n\t *\n\t * Props:\n\t *\n\t *   - value: The text of the editor.\n\t *\n\t */\n\t\n\tvar ResultViewer = (function (_React$Component) {\n\t  _inherits(ResultViewer, _React$Component);\n\t\n\t  function ResultViewer() {\n\t    _classCallCheck(this, ResultViewer);\n\t\n\t    _React$Component.apply(this, arguments);\n\t  }\n\t\n\t  ResultViewer.prototype.componentDidMount = function componentDidMount() {\n\t    this.viewer = _codemirror2['default'](_reactDom2['default'].findDOMNode(this), {\n\t      value: this.props.value || '',\n\t      readOnly: true,\n\t      theme: 'graphiql',\n\t      mode: {\n\t        name: 'javascript',\n\t        json: true\n\t      },\n\t      keyMap: 'sublime',\n\t      foldGutter: {\n\t        minFoldSize: 4\n\t      },\n\t      gutters: ['CodeMirror-foldgutter'],\n\t      extraKeys: {\n\t        // Editor improvements\n\t        'Ctrl-Left': 'goSubwordLeft',\n\t        'Ctrl-Right': 'goSubwordRight',\n\t        'Alt-Left': 'goGroupLeft',\n\t        'Alt-Right': 'goGroupRight'\n\t      }\n\t    });\n\t  };\n\t\n\t  ResultViewer.prototype.componentWillUnmount = function componentWillUnmount() {\n\t    this.viewer = null;\n\t  };\n\t\n\t  ResultViewer.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n\t    return this.props.value !== nextProps.value;\n\t  };\n\t\n\t  ResultViewer.prototype.componentDidUpdate = function componentDidUpdate() {\n\t    this.viewer.setValue(this.props.value || '');\n\t  };\n\t\n\t  ResultViewer.prototype.render = function render() {\n\t    return _react2['default'].createElement('div', { className: 'result-window' });\n\t  };\n\t\n\t  _createClass(ResultViewer, null, [{\n\t    key: 'propTypes',\n\t    value: {\n\t      value: _react.PropTypes.string\n\t    },\n\t    enumerable: true\n\t  }]);\n\t\n\t  return ResultViewer;\n\t})(_react2['default'].Component);\n\t\n\texports.ResultViewer = ResultViewer;\n\n/***/ },\n/* 444 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _marked = __webpack_require__(424);\n\t\n\tvar _marked2 = _interopRequireDefault(_marked);\n\t\n\tvar _graphqlType = __webpack_require__(412);\n\t\n\t/**\n\t * DocExplorer\n\t *\n\t * Shows documentations for GraphQL definitions from the schema.\n\t *\n\t * Props:\n\t *\n\t *   - schema: A required GraphQLSchema instance that provides GraphQL document\n\t *     definitions.\n\t *\n\t * Children:\n\t *\n\t *   - Any provided children will be positioned in the right-hand-side of the\n\t *     top bar. Typically this will be a \"close\" button for temporary explorer.\n\t *\n\t */\n\t\n\tvar DocExplorer = (function (_React$Component) {\n\t  _inherits(DocExplorer, _React$Component);\n\t\n\t  // Public API\n\t\n\t  DocExplorer.prototype.showDoc = function showDoc(typeOrField) {\n\t    var navStack = this.state.navStack;\n\t    var isCurrentlyShown = navStack.length > 0 && navStack[navStack.length - 1] === typeOrField;\n\t    if (!isCurrentlyShown) {\n\t      navStack = navStack.concat([typeOrField]);\n\t    }\n\t    this.setState({ navStack: navStack });\n\t  };\n\t\n\t  _createClass(DocExplorer, null, [{\n\t    key: 'propTypes',\n\t    value: {\n\t      schema: _react.PropTypes.instanceOf(_graphqlType.GraphQLSchema)\n\t    },\n\t    enumerable: true\n\t  }]);\n\t\n\t  function DocExplorer() {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, DocExplorer);\n\t\n\t    _React$Component.call(this);\n\t\n\t    this._onToggleBtnClick = function () {\n\t      _this.setState({ expanded: !_this.state.expanded });\n\t    };\n\t\n\t    this._onNavBackClick = function () {\n\t      _this.setState({ navStack: _this.state.navStack.slice(0, -1) });\n\t    };\n\t\n\t    this._onClickTypeOrField = function (typeOrField) {\n\t      _this.showDoc(typeOrField);\n\t    };\n\t\n\t    this.state = { navStack: [] };\n\t  }\n\t\n\t  // Render the top level Schema\n\t\n\t  DocExplorer.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n\t    return this.props.schema !== nextProps.schema || this.state.navStack !== nextState.navStack;\n\t  };\n\t\n\t  DocExplorer.prototype.render = function render() {\n\t    var schema = this.props.schema;\n\t    var navStack = this.state.navStack;\n\t\n\t    var typeOrField;\n\t    if (navStack.length > 0) {\n\t      typeOrField = navStack[navStack.length - 1];\n\t    }\n\t\n\t    var title;\n\t    var content;\n\t    if (typeOrField) {\n\t      title = typeOrField.name;\n\t      content = _graphqlType.isType(typeOrField) ? _react2['default'].createElement(TypeDoc, {\n\t        key: typeOrField.name,\n\t        type: typeOrField,\n\t        onClickType: this._onClickTypeOrField,\n\t        onClickField: this._onClickTypeOrField\n\t      }) : _react2['default'].createElement(FieldDoc, {\n\t        key: typeOrField.name,\n\t        field: typeOrField,\n\t        onClickType: this._onClickTypeOrField\n\t      });\n\t    } else if (schema) {\n\t      title = 'Documentation Explorer';\n\t      content = _react2['default'].createElement(SchemaDoc, {\n\t        schema: schema,\n\t        onClickType: this._onClickTypeOrField\n\t      });\n\t    }\n\t\n\t    var prevName;\n\t    if (navStack.length === 1) {\n\t      prevName = 'Schema';\n\t    } else if (navStack.length > 1) {\n\t      prevName = navStack[navStack.length - 2].name;\n\t    }\n\t\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      { className: 'doc-explorer' },\n\t      _react2['default'].createElement(\n\t        'div',\n\t        { className: 'doc-explorer-title-bar' },\n\t        prevName && _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-explorer-back', onClick: this._onNavBackClick },\n\t          prevName\n\t        ),\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-explorer-title' },\n\t          title\n\t        ),\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-explorer-rhs' },\n\t          this.props.children\n\t        )\n\t      ),\n\t      _react2['default'].createElement(\n\t        'div',\n\t        { className: 'doc-explorer-contents' },\n\t        content\n\t      )\n\t    );\n\t  };\n\t\n\t  return DocExplorer;\n\t})(_react2['default'].Component);\n\t\n\texports.DocExplorer = DocExplorer;\n\t\n\tvar SchemaDoc = (function (_React$Component2) {\n\t  _inherits(SchemaDoc, _React$Component2);\n\t\n\t  function SchemaDoc() {\n\t    _classCallCheck(this, SchemaDoc);\n\t\n\t    _React$Component2.apply(this, arguments);\n\t  }\n\t\n\t  // Documentation for a Type\n\t\n\t  SchemaDoc.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n\t    return this.props.schema !== nextProps.schema;\n\t  };\n\t\n\t  SchemaDoc.prototype.render = function render() {\n\t    var schema = this.props.schema;\n\t    var queryType = schema.getQueryType();\n\t    var mutationType = schema.getMutationType();\n\t    var subscriptionType = schema.getSubscriptionType();\n\t\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      null,\n\t      _react2['default'].createElement(Description, {\n\t        className: 'doc-type-description',\n\t        markdown: 'A GraphQL schema provides a root type for each kind of operation.'\n\t      }),\n\t      _react2['default'].createElement(\n\t        'div',\n\t        { className: 'doc-category' },\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-category-title' },\n\t          'root types'\n\t        ),\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-category-item' },\n\t          _react2['default'].createElement(\n\t            'span',\n\t            { className: 'keyword' },\n\t            'query'\n\t          ),\n\t          ': ',\n\t          _react2['default'].createElement(TypeLink, { type: queryType, onClick: this.props.onClickType })\n\t        ),\n\t        mutationType && _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-category-item' },\n\t          _react2['default'].createElement(\n\t            'span',\n\t            { className: 'keyword' },\n\t            'mutation'\n\t          ),\n\t          ': ',\n\t          _react2['default'].createElement(TypeLink, { type: mutationType, onClick: this.props.onClickType })\n\t        ),\n\t        subscriptionType && _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-category-item' },\n\t          _react2['default'].createElement(\n\t            'span',\n\t            { className: 'keyword' },\n\t            'subscription'\n\t          ),\n\t          ': ',\n\t          _react2['default'].createElement(TypeLink, {\n\t            type: subscriptionType,\n\t            onClick: this.props.onClickType\n\t          })\n\t        )\n\t      )\n\t    );\n\t  };\n\t\n\t  return SchemaDoc;\n\t})(_react2['default'].Component);\n\t\n\tvar TypeDoc = (function (_React$Component3) {\n\t  _inherits(TypeDoc, _React$Component3);\n\t\n\t  function TypeDoc() {\n\t    _classCallCheck(this, TypeDoc);\n\t\n\t    _React$Component3.apply(this, arguments);\n\t  }\n\t\n\t  // Documentation for a field\n\t\n\t  TypeDoc.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n\t    return this.props.type !== nextProps.type;\n\t  };\n\t\n\t  TypeDoc.prototype.render = function render() {\n\t    var type = this.props.type;\n\t    var onClickType = this.props.onClickType || function () {};\n\t    var onClickField = this.props.onClickField || function () {};\n\t\n\t    var typesTitle;\n\t    var types;\n\t    if (type instanceof _graphqlType.GraphQLUnionType) {\n\t      typesTitle = 'possible types';\n\t      types = type.getPossibleTypes();\n\t    } else if (type instanceof _graphqlType.GraphQLInterfaceType) {\n\t      typesTitle = 'implementations';\n\t      types = type.getPossibleTypes();\n\t    } else if (type instanceof _graphqlType.GraphQLObjectType) {\n\t      typesTitle = 'implements';\n\t      types = type.getInterfaces();\n\t    }\n\t\n\t    var typesDef;\n\t    if (types && types.length > 0) {\n\t      typesDef = _react2['default'].createElement(\n\t        'div',\n\t        { className: 'doc-category' },\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-category-title' },\n\t          typesTitle\n\t        ),\n\t        types.map(function (subtype) {\n\t          return _react2['default'].createElement(\n\t            'div',\n\t            { key: subtype.name, className: 'doc-category-item' },\n\t            _react2['default'].createElement(TypeLink, { type: subtype, onClick: onClickType })\n\t          );\n\t        })\n\t      );\n\t    }\n\t\n\t    // InputObject and Object\n\t    var fieldsDef;\n\t    if (type.getFields) {\n\t      var fieldMap = type.getFields();\n\t      var fields = Object.keys(fieldMap).map(function (name) {\n\t        return fieldMap[name];\n\t      });\n\t      fieldsDef = _react2['default'].createElement(\n\t        'div',\n\t        { className: 'doc-category' },\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-category-title' },\n\t          'fields'\n\t        ),\n\t        fields.map(function (field) {\n\t\n\t          // Field arguments\n\t          var argsDef;\n\t          if (field.args && field.args.length > 0) {\n\t            argsDef = field.args.map(function (arg) {\n\t              return _react2['default'].createElement(\n\t                'span',\n\t                { className: 'arg', key: arg.name },\n\t                _react2['default'].createElement(\n\t                  'span',\n\t                  { className: 'arg-name' },\n\t                  arg.name\n\t                ),\n\t                ': ',\n\t                _react2['default'].createElement(TypeLink, { type: arg.type, onClick: onClickType })\n\t              );\n\t            });\n\t          }\n\t\n\t          return _react2['default'].createElement(\n\t            'div',\n\t            { key: field.name, className: 'doc-category-item' },\n\t            _react2['default'].createElement(\n\t              'a',\n\t              {\n\t                className: 'field-name',\n\t                onClick: function (event) {\n\t                  return onClickField(field, type, event);\n\t                } },\n\t              field.name\n\t            ),\n\t            argsDef && ['(', _react2['default'].createElement(\n\t              'span',\n\t              null,\n\t              argsDef\n\t            ), ')'],\n\t            ': ',\n\t            _react2['default'].createElement(TypeLink, { type: field.type, onClick: onClickType })\n\t          );\n\t        })\n\t      );\n\t    }\n\t\n\t    var valuesDef;\n\t    if (type instanceof _graphqlType.GraphQLEnumType) {\n\t      valuesDef = _react2['default'].createElement(\n\t        'div',\n\t        { className: 'doc-category' },\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-category-title' },\n\t          'values'\n\t        ),\n\t        type.getValues().map(function (value) {\n\t          return _react2['default'].createElement(\n\t            'div',\n\t            { key: value.name, className: 'doc-category-item' },\n\t            _react2['default'].createElement(\n\t              'div',\n\t              { className: 'enum-value' },\n\t              value.name\n\t            ),\n\t            _react2['default'].createElement(Description, {\n\t              className: 'doc-value-description',\n\t              markdown: type.description\n\t            })\n\t          );\n\t        })\n\t      );\n\t    }\n\t\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      null,\n\t      _react2['default'].createElement(Description, {\n\t        className: 'doc-type-description',\n\t        markdown: type.description || 'No Description'\n\t      }),\n\t      type instanceof _graphqlType.GraphQLObjectType && typesDef,\n\t      fieldsDef,\n\t      valuesDef,\n\t      !(type instanceof _graphqlType.GraphQLObjectType) && typesDef\n\t    );\n\t  };\n\t\n\t  return TypeDoc;\n\t})(_react2['default'].Component);\n\t\n\tvar FieldDoc = (function (_React$Component4) {\n\t  _inherits(FieldDoc, _React$Component4);\n\t\n\t  function FieldDoc() {\n\t    _classCallCheck(this, FieldDoc);\n\t\n\t    _React$Component4.apply(this, arguments);\n\t  }\n\t\n\t  // Renders a type link\n\t\n\t  FieldDoc.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n\t    return this.props.field !== nextProps.field;\n\t  };\n\t\n\t  FieldDoc.prototype.render = function render() {\n\t    var _this2 = this;\n\t\n\t    var field = this.props.field;\n\t\n\t    var argsDef;\n\t    if (field.args && field.args.length > 0) {\n\t      argsDef = _react2['default'].createElement(\n\t        'div',\n\t        { className: 'doc-category' },\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-category-title' },\n\t          'arguments'\n\t        ),\n\t        field.args.map(function (arg) {\n\t          return _react2['default'].createElement(\n\t            'div',\n\t            { key: arg.name, className: 'doc-category-item' },\n\t            _react2['default'].createElement(\n\t              'div',\n\t              null,\n\t              _react2['default'].createElement(\n\t                'span',\n\t                { className: 'arg-name' },\n\t                arg.name\n\t              ),\n\t              ': ',\n\t              _react2['default'].createElement(TypeLink, { type: arg.type, onClick: _this2.props.onClickType })\n\t            ),\n\t            _react2['default'].createElement(Description, {\n\t              className: 'doc-value-description',\n\t              markdown: arg.description\n\t            })\n\t          );\n\t        })\n\t      );\n\t    }\n\t\n\t    return _react2['default'].createElement(\n\t      'div',\n\t      null,\n\t      _react2['default'].createElement(Description, {\n\t        className: 'doc-type-description',\n\t        markdown: field.description || 'No Description'\n\t      }),\n\t      _react2['default'].createElement(\n\t        'div',\n\t        { className: 'doc-category' },\n\t        _react2['default'].createElement(\n\t          'div',\n\t          { className: 'doc-category-title' },\n\t          'type'\n\t        ),\n\t        _react2['default'].createElement(TypeLink, { type: field.type, onClick: this.props.onClickType })\n\t      ),\n\t      argsDef\n\t    );\n\t  };\n\t\n\t  return FieldDoc;\n\t})(_react2['default'].Component);\n\t\n\tvar TypeLink = (function (_React$Component5) {\n\t  _inherits(TypeLink, _React$Component5);\n\t\n\t  function TypeLink() {\n\t    _classCallCheck(this, TypeLink);\n\t\n\t    _React$Component5.apply(this, arguments);\n\t  }\n\t\n\t  TypeLink.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n\t    return this.props.type !== nextProps.type;\n\t  };\n\t\n\t  TypeLink.prototype.render = function render() {\n\t    return renderType(this.props.type, this.props.onClick);\n\t  };\n\t\n\t  return TypeLink;\n\t})(_react2['default'].Component);\n\t\n\tfunction renderType(type, onClick) {\n\t  if (type instanceof _graphqlType.GraphQLNonNull) {\n\t    return _react2['default'].createElement(\n\t      'span',\n\t      null,\n\t      renderType(type.ofType, onClick),\n\t      '!'\n\t    );\n\t  }\n\t  if (type instanceof _graphqlType.GraphQLList) {\n\t    return _react2['default'].createElement(\n\t      'span',\n\t      null,\n\t      '[',\n\t      renderType(type.ofType, onClick),\n\t      ']'\n\t    );\n\t  }\n\t  return _react2['default'].createElement(\n\t    'a',\n\t    { className: 'type-name', onClick: function (event) {\n\t        return onClick(type, event);\n\t      } },\n\t    type.name\n\t  );\n\t}\n\t\n\t// Renders a description\n\t\n\tvar Description = (function (_React$Component6) {\n\t  _inherits(Description, _React$Component6);\n\t\n\t  function Description() {\n\t    _classCallCheck(this, Description);\n\t\n\t    _React$Component6.apply(this, arguments);\n\t  }\n\t\n\t  Description.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n\t    return this.props.markdown !== nextProps.markdown;\n\t  };\n\t\n\t  Description.prototype.render = function render() {\n\t    var markdown = this.props.markdown;\n\t    if (!markdown) {\n\t      return _react2['default'].createElement('div', null);\n\t    }\n\t\n\t    var html = _marked2['default'](markdown);\n\t    return _react2['default'].createElement('div', {\n\t      className: this.props.className,\n\t      dangerouslySetInnerHTML: { __html: html }\n\t    });\n\t  };\n\t\n\t  return Description;\n\t})(_react2['default'].Component);\n\n/***/ },\n/* 445 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.fillLeafs = fillLeafs;\n\t\n\tvar _graphqlUtilities = __webpack_require__(413);\n\t\n\tvar _graphqlLanguage = __webpack_require__(358);\n\t\n\tvar _graphqlType = __webpack_require__(412);\n\t\n\t/**\n\t * Given a document string which may not be valid due to terminal fields not\n\t * representing leaf values (Spec Section: \"Leaf Field Selections\"), and a\n\t * function which provides reasonable default field names for a given type,\n\t * this function will attempt to produce a schema which is valid after filling\n\t * in selection sets for the invalid fields.\n\t *\n\t * Note that there is no guarantee that the result will be a valid query, this\n\t * utility represents a \"best effort\" which may be useful within IDE tools.\n\t */\n\t\n\tfunction fillLeafs(schema, docString, getDefaultFieldNames) {\n\t  var insertions = [];\n\t\n\t  if (!schema) {\n\t    return { insertions: insertions, result: docString };\n\t  }\n\t\n\t  var ast = undefined;\n\t  try {\n\t    ast = _graphqlLanguage.parse(docString);\n\t  } catch (error) {\n\t    return { insertions: insertions, result: docString };\n\t  }\n\t\n\t  var fieldNameFn = getDefaultFieldNames || defaultGetDefaultFieldNames;\n\t  var typeInfo = new _graphqlUtilities.TypeInfo(schema);\n\t  _graphqlLanguage.visit(ast, {\n\t    leave: function leave(node) {\n\t      typeInfo.leave(node);\n\t    },\n\t    enter: function enter(node) {\n\t      typeInfo.enter(node);\n\t      if (node.kind === 'Field' && !node.selectionSet) {\n\t        var fieldType = typeInfo.getType();\n\t        var selectionSet = buildSelectionSet(fieldType, fieldNameFn);\n\t        if (selectionSet) {\n\t          var indent = getIndentation(docString, node.loc.start);\n\t          insertions.push({\n\t            index: node.loc.end,\n\t            string: ' ' + _graphqlLanguage.print(selectionSet).replace(/\\n/g, '\\n' + indent)\n\t          });\n\t        }\n\t      }\n\t    }\n\t  });\n\t\n\t  // Apply the insertions, but also return the insertions metadata.\n\t  return {\n\t    insertions: insertions,\n\t    result: withInsertions(docString, insertions)\n\t  };\n\t}\n\t\n\t// The default function to use for producing the default fields from a type.\n\t// This function first looks for some common patterns, and falls back to\n\t// including all leaf-type fields.\n\tfunction defaultGetDefaultFieldNames(type) {\n\t  var fields = type.getFields();\n\t\n\t  // Is there an `id` field?\n\t  if (fields['id']) {\n\t    return ['id'];\n\t  }\n\t\n\t  // Is there an `edges` field?\n\t  if (fields['edges']) {\n\t    return ['edges'];\n\t  }\n\t\n\t  // Is there an `node` field?\n\t  if (fields['node']) {\n\t    return ['node'];\n\t  }\n\t\n\t  // Include all leaf-type fields.\n\t  var leafFieldNames = [];\n\t  Object.keys(fields).forEach(function (fieldName) {\n\t    if (_graphqlType.isLeafType(fields[fieldName].type)) {\n\t      leafFieldNames.push(fieldName);\n\t    }\n\t  });\n\t  return leafFieldNames;\n\t}\n\t\n\t// Given a GraphQL type, and a function which produces field names, recursively\n\t// generate a SelectionSet which includes default fields.\n\tfunction buildSelectionSet(type, getDefaultFieldNames) {\n\t  // Unwrap any non-null or list types.\n\t  var namedType = _graphqlType.getNamedType(type);\n\t\n\t  // Unknown types and leaf types do not have selection sets.\n\t  if (!type || _graphqlType.isLeafType(type)) {\n\t    return;\n\t  }\n\t\n\t  // Get an array of field names to use.\n\t  var fieldNames = getDefaultFieldNames(namedType);\n\t\n\t  // If there are no field names to use, return no selection set.\n\t  if (!Array.isArray(fieldNames) || fieldNames.length === 0) {\n\t    return;\n\t  }\n\t\n\t  // Build a selection set of each field, calling buildSelectionSet recursively.\n\t  return {\n\t    kind: 'SelectionSet',\n\t    selections: fieldNames.map(function (fieldName) {\n\t      var fieldDef = namedType.getFields()[fieldName];\n\t      var fieldType = fieldDef ? fieldDef.type : null;\n\t      return {\n\t        kind: 'Field',\n\t        name: {\n\t          kind: 'Name',\n\t          value: fieldName\n\t        },\n\t        selectionSet: buildSelectionSet(fieldType, getDefaultFieldNames)\n\t      };\n\t    })\n\t  };\n\t}\n\t\n\t// Given an initial string, and a list of \"insertion\" { index, string } objects,\n\t// return a new string with these insertions applied.\n\tfunction withInsertions(initial, insertions) {\n\t  if (insertions.length === 0) {\n\t    return initial;\n\t  }\n\t  var edited = '';\n\t  var prevIndex = 0;\n\t  insertions.forEach(function (_ref) {\n\t    var index = _ref.index;\n\t    var string = _ref.string;\n\t\n\t    edited += initial.slice(prevIndex, index) + string;\n\t    prevIndex = index;\n\t  });\n\t  edited += initial.slice(prevIndex);\n\t  return edited;\n\t}\n\t\n\t// Given a string and an index, look backwards to find the string of whitespace\n\t// following the next previous line break.\n\tfunction getIndentation(str, index) {\n\t  var indentStart = index;\n\t  var indentEnd = index;\n\t  while (indentStart) {\n\t    var c = str.charCodeAt(indentStart - 1);\n\t    // line break\n\t    if (c === 10 || c === 13 || c === 0x2028 || c === 0x2029) {\n\t      break;\n\t    }\n\t    indentStart--;\n\t    // not white space\n\t    if (c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160) {\n\t      indentEnd = indentStart;\n\t    }\n\t  }\n\t  return str.substring(indentStart, indentEnd);\n\t}\n\n/***/ },\n/* 446 */\n/***/ function(module, exports) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the license found in the\n\t *  LICENSE-examples file in the root directory of this source tree.\n\t */\n\t\n\t/**\n\t * Utility functions to get a pixel distance from left/top of the window.\n\t */\n\t\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.getLeft = getLeft;\n\texports.getTop = getTop;\n\t\n\tfunction getLeft(initialElem) {\n\t  var pt = 0;\n\t  var elem = initialElem;\n\t  while (elem.offsetParent) {\n\t    pt += elem.offsetLeft;\n\t    elem = elem.offsetParent;\n\t  }\n\t  return pt;\n\t}\n\t\n\tfunction getTop(initialElem) {\n\t  var pt = 0;\n\t  var elem = initialElem;\n\t  while (elem.offsetParent) {\n\t    pt += elem.offsetTop;\n\t    elem = elem.offsetParent;\n\t  }\n\t  return pt;\n\t}\n\n/***/ },\n/* 447 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _graphqlUtilities = __webpack_require__(413);\n\t\n\texports.introspectionQuery = _graphqlUtilities.introspectionQuery;\n\t\n\t// Some GraphQL services do not support subscriptions and fail an introspection\n\t// query which includes the `subscriptionType` field as the stock introspection\n\t// query does. This backup query removes that field.\n\tvar introspectionQuerySansSubscriptions = '\\n  query IntrospectionQuery {\\n    __schema {\\n      queryType { name }\\n      mutationType { name }\\n      types {\\n        ...FullType\\n      }\\n      directives {\\n        name\\n        description\\n        args {\\n          ...InputValue\\n        }\\n        onOperation\\n        onFragment\\n        onField\\n      }\\n    }\\n  }\\n\\n  fragment FullType on __Type {\\n    kind\\n    name\\n    description\\n    fields(includeDeprecated: true) {\\n      name\\n      description\\n      args {\\n        ...InputValue\\n      }\\n      type {\\n        ...TypeRef\\n      }\\n      isDeprecated\\n      deprecationReason\\n    }\\n    inputFields {\\n      ...InputValue\\n    }\\n    interfaces {\\n      ...TypeRef\\n    }\\n    enumValues(includeDeprecated: true) {\\n      name\\n      description\\n      isDeprecated\\n      deprecationReason\\n    }\\n    possibleTypes {\\n      ...TypeRef\\n    }\\n  }\\n\\n  fragment InputValue on __InputValue {\\n    name\\n    description\\n    type { ...TypeRef }\\n    defaultValue\\n  }\\n\\n  fragment TypeRef on __Type {\\n    kind\\n    name\\n    ofType {\\n      kind\\n      name\\n      ofType {\\n        kind\\n        name\\n        ofType {\\n          kind\\n          name\\n        }\\n      }\\n    }\\n  }\\n';\n\texports.introspectionQuerySansSubscriptions = introspectionQuerySansSubscriptions;\n\n/***/ },\n/* 448 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _graphql = __webpack_require__(352);\n\t\n\texports['default'] = new _graphql.GraphQLSchema({\n\t  query: new _graphql.GraphQLObjectType({\n\t    name: 'Query',\n\t    fields: function fields() {\n\t      return {\n\t        __emptyField: { type: _graphql.GraphQLString }\n\t      };\n\t    }\n\t  })\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 449 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {//\n\t//  pypyjs:  an experimental in-browser python environment.\n\t//\n\t\n\t\"use strict\";\n\t\n\t(function () {\n\t\n\t  // Expose the main pypyjs function at global scope for this file,\n\t  // as well as in any module exports or 'window' object we can find.\n\t  if (this) {\n\t    this.pypyjs = pypyjs;\n\t  }\n\t  if (typeof window !== \"undefined\") {\n\t    window.pypyjs = pypyjs;\n\t  }\n\t  if (true) {\n\t    if (typeof module.exports !== \"undefined\") {\n\t      module.exports = pypyjs;\n\t    }\n\t  }\n\t\n\t  // Generic debugging printf.\n\t  var debug = function debug() {};\n\t  if (typeof console !== \"undefined\") {\n\t    debug = console.log.bind(console);\n\t  } else if (typeof print !== \"undefined\" && typeof window === \"undefined\") {\n\t    debug = print;\n\t  }\n\t\n\t  // Find the directory containing this very file.\n\t  // It can be quite difficult depending on execution environment...\n\t  if (true) {\n\t    var __dirname = \"./\";\n\t    // A little hackery to find the URL of this very file.\n\t    // Throw an error, then parse the stack trace looking for filenames.\n\t    var errlines = new Error().stack.split(\"\\n\");\n\t    for (var i = 0; i < errlines.length; i++) {\n\t      var match = /(at Anonymous function \\(|at |@)(.+\\/)pypyjs.js/.exec(errlines[i]);\n\t      if (match) {\n\t        __dirname = match[2];\n\t        break;\n\t      }\n\t    }\n\t  }\n\t  if (__dirname.charAt(__dirname.length - 1) !== \"/\") {\n\t    __dirname += \"/\";\n\t  }\n\t\n\t  if (typeof Promise === \"undefined\") {\n\t    var Promise = __webpack_require__(451).Promise;\n\t  }\n\t\n\t  // Ensure we have reference to a 'FunctionPromise' constructor.\n\t  var FunctionPromise = __webpack_require__(454);\n\t\n\t  if (typeof FunctionPromise === \"undefined\") {\n\t    throw \"FunctionPromise object not found\";\n\t  }\n\t\n\t  // Some extra goodies for nodejs.\n\t  if (typeof process !== 'undefined') {\n\t    if (Object.prototype.toString.call(process) === '[object process]') {\n\t      var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"fs\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t      var path = __webpack_require__(455);\n\t    }\n\t  }\n\t\n\t  // Create functions for handling default stdio streams.\n\t  // These will be shared by all VM instances by default.\n\t  //\n\t  // We default stdout and stderr to process outputs if available,\n\t  // printing/logging functions otherwise, and /dev/null if nothing\n\t  // else is available.  Unfortunately there's no good way to read\n\t  // synchronously from stdin in javascript, so that's always /dev/null.\n\t\n\t  var devNull = {\n\t    stdin: function stdin() {\n\t      return null;\n\t    },\n\t    stdout: function stdout() {},\n\t    stderr: function stderr() {}\n\t  };\n\t\n\t  var stdio = {\n\t    stdin: null,\n\t    stdout: null,\n\t    stderr: null\n\t  };\n\t\n\t  stdio.stdin = devNull.stdin;\n\t\n\t  if (typeof process !== \"undefined\") {\n\t    if (typeof process.stdout !== \"undefined\") {\n\t      stdio.stdout = function (x) {\n\t        process.stdout.write(x);\n\t      };\n\t    }\n\t    if (typeof process.stderr !== \"undefined\") {\n\t      stdio.stderr = function (x) {\n\t        process.stderr.write(x);\n\t      };\n\t    }\n\t  }\n\t\n\t  var _print, _printErr;\n\t  if (typeof window === \"undefined\") {\n\t    // print, printErr from v8, spidermonkey\n\t    if (typeof print !== \"undefined\") {\n\t      _print = print;\n\t    }\n\t    if (typeof printErr !== \"undefined\") {\n\t      _printErr = printErr;\n\t    }\n\t  }\n\t  if (typeof console !== \"undefined\") {\n\t    if (typeof _print === \"undefined\") {\n\t      _print = console.log.bind(console);\n\t    }\n\t    if (typeof _printErr === \"undefined\") {\n\t      _printErr = console.error.bind(console);\n\t    }\n\t  }\n\t\n\t  if (stdio.stdout == null && typeof _print !== \"undefined\") {\n\t    // print()/console.log() will add a newline, so we buffer until we\n\t    // receive one and then let it add it for us.\n\t    stdio.stdout = (function () {\n\t      var buffer = [];\n\t      return function (data) {\n\t        for (var i = 0; i < data.length; i++) {\n\t          var x = data.charAt(i);\n\t          if (x !== \"\\n\") {\n\t            buffer.push(x);\n\t          } else {\n\t            _print(buffer.join(\"\"));\n\t            buffer.splice(undefined, buffer.length);\n\t          }\n\t        }\n\t      };\n\t    })();\n\t  }\n\t\n\t  if (stdio.stderr == null && typeof _printErr !== \"undefined\") {\n\t    // printErr()/console.error() will add a newline, so we buffer until we\n\t    // receive one and then let it add it for us.\n\t    stdio.stderr = (function () {\n\t      var buffer = [];\n\t      return function (data) {\n\t        for (var i = 0; i < data.length; i++) {\n\t          var x = data.charAt(i);\n\t          if (x !== \"\\n\") {\n\t            buffer.push(x);\n\t          } else {\n\t            _printErr(buffer.join(\"\"));\n\t            buffer.splice(undefined, buffer.length);\n\t          }\n\t        }\n\t      };\n\t    })();\n\t  }\n\t\n\t  if (stdio.stdout === null) {\n\t    stdio.stdout = devNull.stdout;\n\t  }\n\t\n\t  if (stdio.stderr === null) {\n\t    stdio.stderr = devNull.stderr;\n\t  }\n\t\n\t  function pypyjs(opts) {\n\t\n\t    opts = opts || {};\n\t    this.rootURL = opts.rootURL;\n\t    this.totalMemory = opts.totalMemory || 128 * 1024 * 1024;\n\t    this.autoLoadModules = opts.autoLoadModules || true;\n\t    this._pendingModules = {};\n\t    this._loadedModules = {};\n\t    this._allModules = {};\n\t\n\t    // Allow opts to override default IO streams.\n\t    this.stdin = opts.stdin || stdio.stdin;\n\t    this.stdout = opts.stdout || stdio.stdout;\n\t    this.stderr = opts.stderr || stdio.stderr;\n\t\n\t    // Default to finding files relative to this very file.\n\t    if (!this.rootURL && !pypyjs.rootURL) {\n\t      pypyjs.rootURL = __dirname;\n\t    }\n\t    if (this.rootURL && this.rootURL.charAt(this.rootURL.length - 1) !== \"/\") {\n\t      this.rootURL += \"/\";\n\t    }\n\t\n\t    // If we haven't already done so, fetch and load the code for the VM.\n\t    // We do this once and cache the result for re-use, so that we don't\n\t    // have to pay asmjs compilation overhead each time we create the VM.\n\t\n\t    if (!pypyjs._vmBuilderPromise) {\n\t      pypyjs._vmBuilderPromise = this.fetch(\"pypyjs.vm.js\").then((function (xhr) {\n\t        // Parse the compiled code, hopefully asynchronously.\n\t        // Unfortunately our use of Function constructor here doesn't\n\t        // play very well with nodejs, where things like 'module' and\n\t        // 'require' are not in the global scope.  We have to pass them\n\t        // in explicitly as arguments.\n\t        var funcBody = [\n\t        // This is the compiled code for the VM.\n\t        xhr.responseText, '\\n',\n\t        // Ensure that some functions are available on the Module,\n\t        // for linking with jitted code.\n\t        'if (!Module._jitInvoke && typeof _jitInvoke !== \"undefined\") {', '  Module._jitInvoke = _jitInvoke;', '}',\n\t        // Keep some functions that are not exported by default, but\n\t        // which appear in this scope when evaluating the above.\n\t        \"Module._emjs_make_handle = _emjs_make_handle;\", \"Module._emjs_free = _emjs_free;\",\n\t        // Call dependenciesFulfilled if it won't be done automatically.\n\t        \"dependenciesFulfilled=function() { inDependenciesFulfilled(FS); };\", \"if(!memoryInitializer||(!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER))dependenciesFulfilled();\"].join(\"\");\n\t        return FunctionPromise(\"Module\", \"inDependenciesFulfilled\", \"require\", \"module\", \"__filename\", \"__dirname\", funcBody);\n\t      }).bind(this));\n\t    }\n\t\n\t    // Create a new instance of the compiled VM, bound to local state\n\t    // and a local Module object.\n\t\n\t    this._ready = new Promise((function (resolve, reject) {\n\t\n\t      // Initialize the Module object.\n\t      // We make it available on this object so that we can use\n\t      // its methods to execute code in the VM.\n\t      var Module = {};\n\t      this._module = Module;\n\t      Module.TOTAL_MEMORY = this.totalMemory;\n\t\n\t      // We will set up the filesystem manually when we're ready.\n\t      Module.noFSInit = true;\n\t      Module.thisProgram = \"/lib/pypyjs/pypyjs.js\";\n\t      Module.filePackagePrefixURL = this.rootURL || pypyjs.rootURL;\n\t      Module.memoryInitializerPrefixURL = this.rootURL || pypyjs.rootURL;\n\t      Module.locateFile = function (name) {\n\t        return (this.rootURL || pypyjs.rootURL) + name;\n\t      };\n\t\n\t      // Don't start or stop the program, just set it up.\n\t      // We'll call the API functions ourself.\n\t      Module.noInitialRun = true;\n\t      Module.noExitRuntime = true;\n\t\n\t      // Route stdin to an overridable method on the object.\n\t      var stdin = (function stdin() {\n\t        return this.stdin();\n\t      }).bind(this);\n\t\n\t      // Route stdout to an overridable method on the object.\n\t      // We buffer the output for efficiency.\n\t      var stdout_buffer = [];\n\t      var stdout = (function stdout(x) {\n\t        var c = String.fromCharCode(x);\n\t        stdout_buffer.push(c);\n\t        if (c === \"\\n\" || stdout_buffer.length >= 128) {\n\t          this.stdout(stdout_buffer.join(\"\"));\n\t          stdout_buffer = [];\n\t        }\n\t      }).bind(this);\n\t\n\t      // Route stderr to an overridable method on the object.\n\t      // We do not buffer stderr.\n\t      var stderr = (function stderr(x) {\n\t        var c = String.fromCharCode(x);\n\t        this.stderr(c);\n\t      }).bind(this);\n\t\n\t      // This is where execution will continue after loading\n\t      // the memory initialization data, if any.\n\t      var initializedResolve, initializedReject;\n\t      var initializedP = new Promise(function (resolve, reject) {\n\t        initializedResolve = resolve;\n\t        initializedReject = reject;\n\t      });\n\t      var FS;\n\t      var dependenciesFulfilled = function dependenciesFulfilled(fs) {\n\t        FS = fs;\n\t        // Initialize the filesystem state.\n\t        try {\n\t          FS.init(stdin, stdout, stderr);\n\t          Module.FS_createPath(\"/\", \"lib/pypyjs/lib_pypy\", true, false);\n\t          Module.FS_createPath(\"/\", \"lib/pypyjs/lib-python/2.7\", true, false);\n\t          initializedResolve();\n\t        } catch (err) {\n\t          initializedReject(err);\n\t        }\n\t      };\n\t\n\t      // Begin fetching the metadata for available python modules.\n\t      // With luck these can download while we jank around compiling\n\t      // all of that javascript.\n\t      // XXX TODO: also load memory initializer this way.\n\t      var moduleDataP = this.fetch(\"modules/index.json\");\n\t\n\t      pypyjs._vmBuilderPromise.then((function (vmBuilder) {\n\t        var args = [Module, dependenciesFulfilled, typeof undefined, typeof undefined, typeof undefined, typeof __dirname];\n\t        // This links the async-compiled module into our Module object.\n\t        vmBuilder.apply(null, args);\n\t        return initializedP;\n\t      }).bind(this)).then((function () {\n\t        // Continue with processing the downloaded module metadata.\n\t        return moduleDataP.then((function (xhr) {\n\t          // Store the module index, and load any preload modules.\n\t          var modIndex = JSON.parse(xhr.responseText);\n\t          this._allModules = modIndex.modules;\n\t          if (modIndex.preload) {\n\t            for (var name in modIndex.preload) {\n\t              this._writeModuleFile(name, modIndex.preload[name]);\n\t            }\n\t          }\n\t          // It's finally safe to launch the VM.\n\t          Module.run();\n\t          Module._rpython_startup_code();\n\t          var pypy_home = Module.intArrayFromString(\"/lib/pypyjs/pypyjs.js\");\n\t          pypy_home = Module.allocate(pypy_home, 'i8', Module.ALLOC_NORMAL);\n\t          Module._pypy_setup_home(pypy_home, 0);\n\t          Module._free(pypy_home);\n\t          var initCode = [\"import js\", \"import sys; sys.platform = 'js'\", \"import traceback\", \"top_level_scope = {'__name__': '__main__'}\"];\n\t          initCode.forEach(function (codeStr) {\n\t            var code = Module.intArrayFromString(codeStr);\n\t            var code = Module.allocate(code, 'i8', Module.ALLOC_NORMAL);\n\t            if (!code) {\n\t              throw new pypyjs.Error('Failed to allocate memory');\n\t            }\n\t            var res = Module._pypy_execute_source(code);\n\t            if (res < 0) {\n\t              throw new pypyjs.Error('Failed to execute python code');\n\t            }\n\t            Module._free(code);\n\t          });\n\t        }).bind(this));\n\t      }).bind(this)).then(resolve, reject);\n\t    }).bind(this));\n\t  };\n\t\n\t  // A simple file-fetching wrapper around XMLHttpRequest,\n\t  // that treats paths as relative to the pypyjs.js root url.\n\t  //\n\t  pypyjs.prototype.fetch = function (relpath, responseType) {\n\t    if (typeof window === \"undefined\") {\n\t      var localStorage = false;\n\t    } else {\n\t      var localStorage = window.localStorage;\n\t    }\n\t    var use_cache = pypyjs.cacheKey && localStorage && relpath != \"pypyjs.vm.js\";\n\t    if (use_cache) {\n\t      var item = localStorage.getItem(pypyjs.cacheKey + ':' + relpath);\n\t      if (item) {\n\t        return new Promise(function (resolve, reject) {\n\t          resolve({ responseText: item });\n\t        });\n\t      }\n\t    }\n\t    // For the web, use XMLHttpRequest.\n\t    if (typeof XMLHttpRequest !== \"undefined\") {\n\t      return new Promise((function (resolve, reject) {\n\t        var xhr = new XMLHttpRequest();\n\t        xhr.onload = function () {\n\t          if (xhr.status >= 400) {\n\t            reject(xhr);\n\t          } else {\n\t            if (use_cache && xhr.responseText) {\n\t              localStorage.setItem(pypyjs.cacheKey + ':' + relpath, xhr.responseText);\n\t            }\n\t            resolve(xhr);\n\t          }\n\t        };\n\t        var rootURL = this.rootURL || pypyjs.rootURL;\n\t        xhr.open('GET', rootURL + relpath, true);\n\t        xhr.responseType = responseType || \"text\";\n\t        xhr.send(null);\n\t      }).bind(this));\n\t    }\n\t    // For nodejs, use fs.readFile.\n\t    if (typeof fs !== \"undefined\" && typeof fs.readFile !== \"undefined\") {\n\t      return new Promise((function (resolve, reject) {\n\t        var rootURL = this.rootURL || pypyjs.rootURL;\n\t        fs.readFile(path.join(rootURL, relpath), function (err, data) {\n\t          if (err) return reject(err);\n\t          resolve({ responseText: data.toString() });\n\t        });\n\t      }).bind(this));\n\t    }\n\t    // For spidermonkey, use snarf (which has a binary read mode).\n\t    if (typeof snarf !== \"undefined\") {\n\t      return new Promise((function (resolve, reject) {\n\t        var rootURL = this.rootURL || pypyjs.rootURL;\n\t        var data = snarf(rootURL + relpath);\n\t        resolve({ responseText: data });\n\t      }).bind(this));\n\t    }\n\t    // For d8, use read() and readbuffer().\n\t    if (typeof read !== \"undefined\" && typeof readbuffer !== \"undefined\") {\n\t      return new Promise((function (resolve, reject) {\n\t        var rootURL = this.rootURL || pypyjs.rootURL;\n\t        var data = read(rootURL + relpath);\n\t        resolve({ responseText: data });\n\t      }).bind(this));\n\t    }\n\t    return new Promise(function (resolve, reject) {\n\t      reject(\"unable to fetch files\");\n\t    });\n\t  };\n\t\n\t  if (typeof localStorage !== \"undefined\") {\n\t    var localStorage = false;\n\t  }\n\t\n\t  // pypyjs.prototype.fetch = function fetch(relpath, responseType) {\n\t  //   // For the web, use XMLHttpRequest.\n\t  //   var use_cache = pypyjs.cacheKey && localStorage;\n\t  //   if (use_cache) {\n\t  //     if (var item = localStorage.getItem(pypyjs.cacheKey+'-'+relpath)) {\n\t  //       resolve({ responseText: item });\n\t  //     }\n\t  //   }\n\t  //   if (typeof XMLHttpRequest !== \"undefined\") {\n\t  //     return new Promise((function(resolve, reject) {\n\t  //       var xhr = new XMLHttpRequest();\n\t  //       xhr.onload = function() {\n\t  //         if (xhr.status >= 400) {\n\t  //           reject(xhr)\n\t  //         } else {\n\t  //           console.log(xhr.responseText);\n\t  //           if (use_cache && xhr.responseText) {\n\t  //             localStorage.setItem(pypyjs.cacheKey+'-'+relpath, xhr.responseText);\n\t  //           }\n\t  //           resolve(xhr);\n\t  //         }\n\t  //       };\n\t  //       var rootURL = this.rootURL || pypyjs.rootURL;\n\t  //       xhr.open('GET', rootURL + relpath, true);\n\t  //       xhr.responseType = responseType || \"text\";\n\t  //       xhr.send(null);\n\t  //     }).bind(this));\n\t  //   }\n\t  //   // For nodejs, use fs.readFile.\n\t  //   if (typeof fs !== \"undefined\" && typeof fs.readFile !== \"undefined\") {\n\t  //     return new Promise((function(resolve, reject) {\n\t  //       var rootURL = this.rootURL || pypyjs.rootURL;\n\t  //       fs.readFile(path.join(rootURL, relpath), function(err, data) {\n\t  //         if (err) return reject(err);\n\t  //         resolve({ responseText: data.toString() });\n\t  //       });\n\t  //     }).bind(this));\n\t  //   }\n\t  //   // For spidermonkey, use snarf (which has a binary read mode).\n\t  //   if (typeof snarf !== \"undefined\") {\n\t  //     return new Promise((function(resolve, reject) {\n\t  //       var rootURL = this.rootURL || pypyjs.rootURL;\n\t  //       var data = snarf(rootURL + relpath);\n\t  //       resolve({ responseText: data });\n\t  //     }).bind(this));\n\t  //   }\n\t  //   // For d8, use read() and readbuffer().\n\t  //   if (typeof read !== \"undefined\" && typeof readbuffer !== \"undefined\") {\n\t  //     return new Promise((function(resolve, reject) {\n\t  //       var rootURL = this.rootURL || pypyjs.rootURL;\n\t  //       var data = read(rootURL + relpath);\n\t  //       resolve({ responseText: data });\n\t  //     }).bind(this));\n\t  //   }\n\t  //   return new Promise(function(resolve, reject) {\n\t  //     reject(\"unable to fetch files\");\n\t  //   });\n\t  // };\n\t\n\t  // Method to execute python source directly in the VM.\n\t  //\n\t  // This is the basic way to push code into the pypyjs VM.\n\t  // Calling code should not use it directly; rather we use it\n\t  // as a primitive to build up a nicer execution API.\n\t  //\n\t  pypyjs.prototype._execute_source = function _execute_source(code) {\n\t    var Module = this._module;\n\t    code = \"try:\\n\" + \"  \" + code + \"\\n\" + \"except Exception:\\n\" + \"  typ, val, tb = sys.exc_info()\\n\" + \"  err_name = getattr(typ, '__name__', str(typ))\\n\" + \"  err_msg = str(val)\\n\" + \"  err_trace = traceback.format_exception(typ, val, tb)\\n\" + \"  err_trace = ''.join(err_trace)\\n\" + \"  js.globals['pypyjs']._lastErrorName = err_name\\n\" + \"  js.globals['pypyjs']._lastErrorMessage = err_msg\\n\" + \"  js.globals['pypyjs']._lastErrorTrace = err_trace\\n\";\n\t    var code_chars = Module.intArrayFromString(code);\n\t    var code_ptr = Module.allocate(code_chars, 'i8', Module.ALLOC_NORMAL);\n\t    if (!code_ptr) {\n\t      return Promise.reject(new pypyjs.Error(\"Failed to allocate memory\"));\n\t    }\n\t    var res = Module._pypy_execute_source(code_ptr);\n\t    Module._free(code_ptr);\n\t    // XXX TODO: races/re-entrancy on _lastError?\n\t    if (pypyjs._lastErrorName) {\n\t      var err = new pypyjs.Error(pypyjs._lastErrorName, pypyjs._lastErrorMessage, pypyjs._lastErrorTrace);\n\t      pypyjs._lastErrorName = null;\n\t      pypyjs._lastErrorMessage = null;\n\t      pypyjs._lastErrorTrace = null;\n\t      return Promise.reject(err);\n\t    }\n\t    if (res < 0) {\n\t      return Promise.reject(new pypyjs.Error(\"Error executing python code\"));\n\t    }\n\t    return Promise.resolve(null);\n\t  };\n\t\n\t  function _escape(value) {\n\t    return value.replace(/\\\\/g, \"\\\\\\\\\").replace(/'/g, \"\\\\'\");\n\t  }\n\t\n\t  // Method to determine when the interpreter is ready.\n\t  //\n\t  // This method returns a promise that will resolve once the interpreter\n\t  // is ready for use.\n\t  //\n\t  pypyjs.prototype.ready = function ready() {\n\t    return this._ready;\n\t  };\n\t\n\t  // Method to execute some python code.\n\t  //\n\t  // This passes the given python code to the VM for execution.\n\t  // It's fairly directly analogous to the \"exec\" statement in python.\n\t  // It is not possible to directly access the result of the code, if any.\n\t  // Rather you should store it into a variable and then use the get() method.\n\t  //\n\t  pypyjs.prototype.exec = function exec(code) {\n\t    return this._ready.then((function () {\n\t      var p = Promise.resolve();\n\t      // Find any \"import\" statements in the code,\n\t      // and ensure the modules are ready for loading.\n\t      if (this.autoLoadModules) {\n\t        p = p.then((function () {\n\t          return this.findImportedNames(code);\n\t        }).bind(this)).then((function (imports) {\n\t          return this.loadModuleData.apply(this, imports);\n\t        }).bind(this));\n\t      }\n\t      // Now we can execute the code in custom top-level scope.\n\t      code = 'exec \\'\\'\\'' + _escape(code) + '\\'\\'\\' in top_level_scope';\n\t      p = p.then((function () {\n\t        return this._execute_source(code);\n\t      }).bind(this));\n\t      return p;\n\t    }).bind(this));\n\t  };\n\t\n\t  // Method to evaluate an expression.\n\t  //\n\t  // This method evaluates an expression and returns its value (assuming the\n\t  // value can be translated into javascript).  It's fairly directly analogous\n\t  // to the \"eval\" function in python.\n\t  //\n\t  // For backwards-compatibility reasons, it will also evaluate statements.\n\t  // This behaviour is deprecated and will be removed in a future release.\n\t  //\n\t  pypyjs.prototype.eval = function (expr) {\n\t    return this._ready.then((function () {\n\t      // First try to execute it as an expression.\n\t      code = \"r = eval('\" + _escape(expr) + \"', top_level_scope)\";\n\t      return this._execute_source(code);\n\t    }).bind(this)).then((function () {\n\t      // If that succeeded, return the result.\n\t      return this.get(\"r\", true);\n\t    }).bind(this), (function (err) {\n\t      if (err && err.name && err.name !== \"SyntaxError\") {\n\t        throw err;\n\t      }\n\t      // If that failed, try again via exec().\n\t      if (typeof console !== \"undefined\") {\n\t        console.warn(\"Calling pypyjs.eval() with statements is deprecated.\");\n\t        console.warn(\"Use eval() for expressions, exec() for statements.\");\n\t      }\n\t      return this.exec(expr);\n\t    }).bind(this));\n\t  };\n\t\n\t  // Method to evaluate some python code from a file..\n\t  //\n\t  // This fetches the named file and passes it to the VM for execution.\n\t  //\n\t  pypyjs.prototype.execfile = function execfile(filename) {\n\t    return this.fetch(filename).then((function (xhr) {\n\t      var code = xhr.responseText;\n\t      return this.exec(code);\n\t    }).bind(this));\n\t  };\n\t\n\t  // Method to read a python variable.\n\t  //\n\t  // This tries to convert the value in the named python variable into an\n\t  // equivalent javascript value and returns it.  It will fail if the variable\n\t  // does not exist or contains a value that cannot be converted.\n\t  //\n\t  pypyjs._resultsID = 0;\n\t  pypyjs._resultsMap = {};\n\t  pypyjs.prototype.get = function get(name, _fromGlobals) {\n\t    var resid = \"\" + pypyjs._resultsID++;\n\t    // We can read from global scope for internal use; don't do this from calling code!\n\t    if (_fromGlobals) {\n\t      var namespace = \"globals()\";\n\t    } else {\n\t      var namespace = \"top_level_scope\";\n\t    }\n\t    return this._ready.then((function () {\n\t      var code = namespace + \".get('\" + _escape(name) + \"', js.undefined)\";\n\t      code = \"js.convert(\" + code + \")\";\n\t      code = \"js.globals['pypyjs']._resultsMap['\" + resid + \"'] = \" + code;\n\t      return this._execute_source(code);\n\t    }).bind(this)).then((function () {\n\t      var res = pypyjs._resultsMap[resid];\n\t      delete pypyjs._resultsMap[resid];\n\t      return res;\n\t    }).bind(this));\n\t  };\n\t\n\t  // Method to set a python variable to a javascript value.\n\t  //\n\t  // This generates a handle to the given object, and arranges for the named\n\t  // python variable to reference it via that handle.\n\t  //\n\t  pypyjs.prototype.set = function set(name, value) {\n\t    return this._ready.then((function () {\n\t      var Module = this._module;\n\t      var h = Module._emjs_make_handle(value);\n\t      name = _escape(name);\n\t      var code = \"top_level_scope['\" + name + \"'] = js.Value(\" + h + \")\";\n\t      return this._execute_source(code);\n\t    }).bind(this));\n\t  };\n\t\n\t  // Method to run an interactive REPL.\n\t  //\n\t  // This method takes takes callback function implementing the user\n\t  // input prompt, and runs a REPL loop using it.  The prompt function\n\t  // may either return the input as a string, or a promise resolving to\n\t  // the input as a string.  If not specified, we read from stdin (which\n\t  // works fine in e.g. nodejs, but is almost certainly not what you want\n\t  // in the browser, because it's blocking).\n\t  //\n\t  pypyjs.prototype.repl = function repl(prmpt) {\n\t    if (!prmpt) {\n\t      // If there's a custom stdin, or we're not in nodejs, then we should\n\t      // default to prompting on stdin/stdout.  For nodejs, we can build\n\t      // an async prompt atop process.stdin.\n\t      var buffer = \"\";\n\t      if (this.stdin !== devNull.stdin || typeof process === \"undefined\") {\n\t        prmpt = (function (ps1) {\n\t          var input;\n\t          this.stdout(ps1);\n\t          var c = this.stdin();\n\t          while (c) {\n\t            var idx = c.indexOf(\"\\n\");\n\t            if (idx >= 0) {\n\t              var input = buffer + c.substr(0, idx + 1);\n\t              buffer = c.substr(idx + 1);\n\t              return input;\n\t            }\n\t            buffer += c;\n\t            c = this.stdin();\n\t          }\n\t          input = buffer;\n\t          buffer = \"\";\n\t          return input;\n\t        }).bind(this);\n\t      } else {\n\t        prmpt = (function (ps1) {\n\t          return new Promise((function (resolve, reject) {\n\t            this.stdout(ps1);\n\t            var slurp = function slurp() {\n\t              process.stdin.once(\"readable\", function () {\n\t                var chunk = process.stdin.read();\n\t                if (chunk === null) {\n\t                  slurp();\n\t                } else {\n\t                  chunk = chunk.toString();\n\t                  var idx = chunk.indexOf(\"\\n\");\n\t                  if (idx < 0) {\n\t                    buffer += chunk;\n\t                    slurp();\n\t                  } else {\n\t                    resolve(buffer + chunk.substr(0, idx + 1));\n\t                    buffer = chunk.substr(idx + 1);\n\t                  }\n\t                }\n\t              });\n\t            };\n\t            slurp();\n\t          }).bind(this));\n\t        }).bind(this);\n\t      }\n\t    }\n\t    // Set up an InteractiveConsole instance,\n\t    // then loop forever via recursive promises.\n\t    return this._ready.then((function () {\n\t      return this.loadModuleData(\"code\");\n\t    }).bind(this)).then((function () {\n\t      return this._execute_source(\"import code\");\n\t    }).bind(this)).then((function () {\n\t      return this._execute_source(\"c = code.InteractiveConsole(top_level_scope)\");\n\t    }).bind(this)).then((function () {\n\t      return this._repl_loop(prmpt, \">>> \");\n\t    }).bind(this));\n\t  };\n\t\n\t  pypyjs.prototype._repl_loop = function _repl_loop(prmpt, ps1) {\n\t    return Promise.resolve().then((function () {\n\t      // Prompt for input, which may happen via async promise.\n\t      return prmpt.call(this, ps1);\n\t    }).bind(this)).then((function (input) {\n\t      // Push it into the InteractiveConsole, a line at a time.\n\t      var p = Promise.resolve();\n\t      input.split(\"\\n\").forEach((function (line) {\n\t        // Find any \"import\" statements in the code,\n\t        // and ensure the modules are ready for loading.\n\t        if (this.autoLoadModules) {\n\t          p = p.then((function () {\n\t            return this.findImportedNames(line);\n\t          }).bind(this)).then((function (imports) {\n\t            return this.loadModuleData.apply(this, imports);\n\t          }).bind(this));\n\t        }\n\t        var code = 'r = c.push(\\'' + _escape(line) + '\\')';\n\t        p = p.then((function () {\n\t          return this._execute_source(code);\n\t        }).bind(this));\n\t      }).bind(this));\n\t      return p;\n\t    }).bind(this)).then((function () {\n\t      // Check the result from the final push.\n\t      return this.get(\"r\", true);\n\t    }).bind(this)).then((function (r) {\n\t      // If r == 1, we're in a multi-line definition.\n\t      // Adjust the prompt accordingly.\n\t      if (r) {\n\t        return this._repl_loop(prmpt, \"... \");\n\t      } else {\n\t        return this._repl_loop(prmpt, \">>> \");\n\t      }\n\t    }).bind(this));\n\t  };\n\t\n\t  // Method to look for \"import\" statements in a code string.\n\t  // Returns a promise that will resolve to a list of imported module names.\n\t  //\n\t  // XXX TODO: this is far from complete and should not be done with a regex.\n\t  // Perhaps we can call into python's \"ast\" module for this parsing?\n\t  //\n\t  var importStatementRE = /(from\\s+([a-zA-Z0-9_\\.]+)\\s+)?import\\s+\\(?\\s*([a-zA-Z0-9_\\.\\*]+(\\s+as\\s+[a-zA-Z0-9_]+)?[ \\t]*,?[ \\t]*)+[ \\t]*\\)?/g;\n\t  pypyjs.prototype.findImportedNames = function findImportedNames(code) {\n\t    var match = null;\n\t    var imports = [];\n\t    importStatementRE.lastIndex = 0;\n\t    while ((match = importStatementRE.exec(code)) !== null) {\n\t      var relmod = match[2];\n\t      if (relmod) {\n\t        relmod = relmod + \".\";\n\t      } else {\n\t        relmod = \"\";\n\t      }\n\t      var submods = match[0].split(\"import\")[1];\n\t      while (submods && /[\\s(]/.test(submods.charAt(0))) {\n\t        submods = submods.substr(1);\n\t      }\n\t      while (submods && /[\\s)]/.test(submods.charAt(submods.length - 1))) {\n\t        submods = submods.substr(0, submods.length - 1);\n\t      }\n\t      submods = submods.split(/\\s*,\\s*/);\n\t      for (var i = 0; i < submods.length; i++) {\n\t        var submod = submods[i];\n\t        submod = submod.split(/\\s*as\\s*/)[0];\n\t        imports.push(relmod + submod);\n\t      }\n\t    }\n\t    return Promise.resolve(imports);\n\t  };\n\t\n\t  // Method to load the contents of a python module, along with\n\t  // any dependencies.  This populates the relevant paths within\n\t  // the VMs simulated filesystem so that is can find and import\n\t  // the specified module.\n\t  //\n\t  pypyjs.prototype.loadModuleData = function loadModuleData() /* names */{\n\t    // Each argument is a name that we want to import.\n\t    // We must find the longest prefix that is an available module\n\t    // and load it along with all its dependencies.\n\t    var modules = Array.prototype.slice.call(arguments);\n\t    return this._ready.then((function () {\n\t      var toLoad = {};\n\t      NEXTNAME: for (var i = 0; i < modules.length; i++) {\n\t        var name = modules[i];\n\t        // Find the nearest containing module for the given name.\n\t        // Note that it may not match a module at all, in which case we ignore it.\n\t        while (true) {\n\t          if (this._allModules[name]) {\n\t            break;\n\t          }\n\t          name = name.substr(0, name.lastIndexOf(\".\"));\n\t          if (!name) continue NEXTNAME;\n\t        }\n\t        this._findModuleDeps(name, toLoad);\n\t      }\n\t      // Now ensure that each module gets loaded.\n\t      // XXX TODO: we could load these concurrently.\n\t      var p = Promise.resolve();\n\t      for (var name in toLoad) {\n\t        p = p.then(this._makeLoadModuleData(name));\n\t      }\n\t      return p;\n\t    }).bind(this));\n\t  };\n\t\n\t  pypyjs.prototype._findModuleDeps = function _findModuleDeps(name, seen) {\n\t    if (!seen) seen = {};\n\t    var deps = [];\n\t    // If we don't know about this module, ignore it.\n\t    if (!this._allModules[name]) {\n\t      return seen;\n\t    }\n\t    // Depend on any explicitly-named imports.\n\t    var imports = this._allModules[name].imports;\n\t    if (imports) {\n\t      for (var i = 0; i < imports.length; i++) {\n\t        deps.push(imports[i]);\n\t      }\n\t    }\n\t    // Depend on the __init__.py for packages.\n\t    if (this._allModules[name].dir) {\n\t      deps.push(name + \".__init__\");\n\t    }\n\t    // Include the parent package, if any.\n\t    var idx = name.lastIndexOf(\".\");\n\t    if (idx !== -1) {\n\t      deps.push(name.substr(0, idx));\n\t    }\n\t    // Recurse for any previously-unseen dependencies.\n\t    seen[name] = true;\n\t    for (var i = 0; i < deps.length; i++) {\n\t      if (!seen[deps[i]]) {\n\t        this._findModuleDeps(deps[i], seen);\n\t      }\n\t    }\n\t    return seen;\n\t  };\n\t\n\t  pypyjs.prototype._makeLoadModuleData = function _makeLoadModuleData(name) {\n\t    return (function () {\n\t      // If we've already loaded this module, we're done.\n\t      if (this._loadedModules[name]) {\n\t        return Promise.resolve();\n\t      }\n\t      // If we're already in the process of loading it, use the existing promise.\n\t      if (this._pendingModules[name]) {\n\t        return this._pendingModules[name];\n\t      }\n\t      // If it's a package directory, there's not actually anything to do.\n\t      if (this._allModules[name].dir) {\n\t        return Promise.resolve();\n\t      }\n\t      // We need to fetch the module file and write it out.\n\t      var modfile = this._allModules[name].file;\n\t      var p = this.fetch(\"modules/\" + modfile).then((function (xhr) {\n\t        var contents = xhr.responseText;\n\t        this._writeModuleFile(name, contents);\n\t        delete this._pendingModules[name];\n\t      }).bind(this));\n\t      this._pendingModules[name] = p;\n\t      return p;\n\t    }).bind(this);\n\t  };\n\t\n\t  pypyjs.prototype._writeModuleFile = function _writeModuleFile(name, data) {\n\t    var Module = this._module;\n\t    var file = this._allModules[name].file;\n\t    // Create the containing directory first.\n\t    var dir = file.split(\"/\").slice(0, -1).join(\"/\");\n\t    try {\n\t      Module.FS_createPath(\"/lib/pypyjs/lib_pypy\", dir, true, false);\n\t    } catch (e) {}\n\t    // Now we can safely create the file.\n\t    var fullpath = \"/lib/pypyjs/lib_pypy/\" + file;\n\t    Module.FS_createDataFile(fullpath, \"\", data, true, false, true);\n\t    this._loadedModules[name] = true;\n\t  };\n\t\n\t  // An error class for reporting python exceptions back to calling code.\n\t  // XXX TODO: this could be a lot more user-friendly than a opaque error...\n\t\n\t  pypyjs.Error = function pypyjsError(name, message, trace) {\n\t    if (name && typeof message === \"undefined\") {\n\t      message = name;\n\t      name = \"\";\n\t    }\n\t    this.name = name || \"pypyjs.Error\";\n\t    this.message = message || \"pypyjs Unknown Error\";\n\t    this.trace = trace || \"\";\n\t  };\n\t  pypyjs.Error.prototype = new Error();\n\t  pypyjs.Error.prototype.constructor = pypyjs.Error;\n\t\n\t  // XXX TODO: expose the filesystem for manipulation by calling code.\n\t\n\t  // Add convenience methods directly on the 'pypyjs' function, that\n\t  // will invoke corresponding methods on a default VM instance.\n\t  // This makes it look like 'pypyjs' is a singleton VM instance.\n\t\n\t  pypyjs._defaultVM = null;\n\t  pypyjs.stdin = stdio.stdin;\n\t  pypyjs.stdout = stdio.stdout;\n\t  pypyjs.stderr = stdio.stderr;\n\t\n\t  var PUBLIC_NAMES = ['ready', 'exec', 'eval', 'execfile', 'get', 'set', 'repl', 'loadModuleData'];\n\t\n\t  PUBLIC_NAMES.forEach(function (name) {\n\t    pypyjs[name] = function () {\n\t      if (!pypyjs._defaultVM) {\n\t        pypyjs._defaultVM = new pypyjs({\n\t          stdin: function stdin() {\n\t            return pypyjs.stdin.apply(this, arguments);\n\t          },\n\t          stdout: function stdout() {\n\t            return pypyjs.stdout.apply(this, arguments);\n\t          },\n\t          stderr: function stderr() {\n\t            return pypyjs.stderr.apply(this, arguments);\n\t          }\n\t        });\n\t      }\n\t      return pypyjs._defaultVM[name].apply(pypyjs._defaultVM, arguments);\n\t    };\n\t  });\n\t\n\t  // For nodejs, run a repl when invoked directly from the command-line.\n\t\n\t  return pypyjs;\n\t})();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(450)))\n\n/***/ },\n/* 450 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 451 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!\n\t * @overview es6-promise - a tiny implementation of Promises/A+.\n\t * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n\t * @license   Licensed under MIT license\n\t *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n\t * @version   3.0.2\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t    function lib$es6$promise$utils$$objectOrFunction(x) {\n\t      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isFunction(x) {\n\t      return typeof x === 'function';\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isMaybeThenable(x) {\n\t      return typeof x === 'object' && x !== null;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$_isArray;\n\t    if (!Array.isArray) {\n\t      lib$es6$promise$utils$$_isArray = function (x) {\n\t        return Object.prototype.toString.call(x) === '[object Array]';\n\t      };\n\t    } else {\n\t      lib$es6$promise$utils$$_isArray = Array.isArray;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n\t    var lib$es6$promise$asap$$len = 0;\n\t    var lib$es6$promise$asap$$toString = {}.toString;\n\t    var lib$es6$promise$asap$$vertxNext;\n\t    var lib$es6$promise$asap$$customSchedulerFn;\n\t\n\t    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n\t      lib$es6$promise$asap$$len += 2;\n\t      if (lib$es6$promise$asap$$len === 2) {\n\t        // If len is 2, that means that we need to schedule an async flush.\n\t        // If additional callbacks are queued before the queue is flushed, they\n\t        // will be processed by this flush that we are scheduling.\n\t        if (lib$es6$promise$asap$$customSchedulerFn) {\n\t          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n\t        } else {\n\t          lib$es6$promise$asap$$scheduleFlush();\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n\t      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setAsap(asapFn) {\n\t      lib$es6$promise$asap$$asap = asapFn;\n\t    }\n\t\n\t    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n\t    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n\t    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n\t    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\t\n\t    // test for web worker but not in IE10\n\t    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n\t      typeof importScripts !== 'undefined' &&\n\t      typeof MessageChannel !== 'undefined';\n\t\n\t    // node\n\t    function lib$es6$promise$asap$$useNextTick() {\n\t      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n\t      // see https://github.com/cujojs/when/issues/410 for details\n\t      return function() {\n\t        process.nextTick(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    // vertx\n\t    function lib$es6$promise$asap$$useVertxTimer() {\n\t      return function() {\n\t        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useMutationObserver() {\n\t      var iterations = 0;\n\t      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n\t      var node = document.createTextNode('');\n\t      observer.observe(node, { characterData: true });\n\t\n\t      return function() {\n\t        node.data = (iterations = ++iterations % 2);\n\t      };\n\t    }\n\t\n\t    // web worker\n\t    function lib$es6$promise$asap$$useMessageChannel() {\n\t      var channel = new MessageChannel();\n\t      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n\t      return function () {\n\t        channel.port2.postMessage(0);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useSetTimeout() {\n\t      return function() {\n\t        setTimeout(lib$es6$promise$asap$$flush, 1);\n\t      };\n\t    }\n\t\n\t    var lib$es6$promise$asap$$queue = new Array(1000);\n\t    function lib$es6$promise$asap$$flush() {\n\t      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n\t        var callback = lib$es6$promise$asap$$queue[i];\n\t        var arg = lib$es6$promise$asap$$queue[i+1];\n\t\n\t        callback(arg);\n\t\n\t        lib$es6$promise$asap$$queue[i] = undefined;\n\t        lib$es6$promise$asap$$queue[i+1] = undefined;\n\t      }\n\t\n\t      lib$es6$promise$asap$$len = 0;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$attemptVertx() {\n\t      try {\n\t        var r = require;\n\t        var vertx = __webpack_require__(452);\n\t        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n\t        return lib$es6$promise$asap$$useVertxTimer();\n\t      } catch(e) {\n\t        return lib$es6$promise$asap$$useSetTimeout();\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$scheduleFlush;\n\t    // Decide what async method to use to triggering processing of queued callbacks:\n\t    if (lib$es6$promise$asap$$isNode) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n\t    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n\t    } else if (lib$es6$promise$asap$$isWorker) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n\t    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n\t    } else {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$noop() {}\n\t\n\t    var lib$es6$promise$$internal$$PENDING   = void 0;\n\t    var lib$es6$promise$$internal$$FULFILLED = 1;\n\t    var lib$es6$promise$$internal$$REJECTED  = 2;\n\t\n\t    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$selfFulfillment() {\n\t      return new TypeError(\"You cannot resolve a promise with itself\");\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$cannotReturnOwn() {\n\t      return new TypeError('A promises callback cannot return that same promise.');\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$getThen(promise) {\n\t      try {\n\t        return promise.then;\n\t      } catch(error) {\n\t        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n\t        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n\t      try {\n\t        then.call(value, fulfillmentHandler, rejectionHandler);\n\t      } catch(e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n\t       lib$es6$promise$asap$$asap(function(promise) {\n\t        var sealed = false;\n\t        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t          if (thenable !== value) {\n\t            lib$es6$promise$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$es6$promise$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\t\n\t        if (!sealed && error) {\n\t          sealed = true;\n\t          lib$es6$promise$$internal$$reject(promise, error);\n\t        }\n\t      }, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n\t      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n\t      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, thenable._result);\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n\t      if (maybeThenable.constructor === promise.constructor) {\n\t        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n\t      } else {\n\t        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\t\n\t        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n\t        } else if (then === undefined) {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        } else if (lib$es6$promise$utils$$isFunction(then)) {\n\t          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n\t        } else {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$resolve(promise, value) {\n\t      if (promise === value) {\n\t        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n\t      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n\t        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n\t      } else {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publishRejection(promise) {\n\t      if (promise._onerror) {\n\t        promise._onerror(promise._result);\n\t      }\n\t\n\t      lib$es6$promise$$internal$$publish(promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$fulfill(promise, value) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t\n\t      promise._result = value;\n\t      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\t\n\t      if (promise._subscribers.length !== 0) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$reject(promise, reason) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t      promise._state = lib$es6$promise$$internal$$REJECTED;\n\t      promise._result = reason;\n\t\n\t      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n\t      var subscribers = parent._subscribers;\n\t      var length = subscribers.length;\n\t\n\t      parent._onerror = null;\n\t\n\t      subscribers[length] = child;\n\t      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n\t      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\t\n\t      if (length === 0 && parent._state) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publish(promise) {\n\t      var subscribers = promise._subscribers;\n\t      var settled = promise._state;\n\t\n\t      if (subscribers.length === 0) { return; }\n\t\n\t      var child, callback, detail = promise._result;\n\t\n\t      for (var i = 0; i < subscribers.length; i += 3) {\n\t        child = subscribers[i];\n\t        callback = subscribers[i + settled];\n\t\n\t        if (child) {\n\t          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n\t        } else {\n\t          callback(detail);\n\t        }\n\t      }\n\t\n\t      promise._subscribers.length = 0;\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$ErrorObject() {\n\t      this.error = null;\n\t    }\n\t\n\t    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n\t      try {\n\t        return callback(detail);\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n\t        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n\t      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n\t          value, error, succeeded, failed;\n\t\n\t      if (hasCallback) {\n\t        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\t\n\t        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n\t          failed = true;\n\t          error = value.error;\n\t          value = null;\n\t        } else {\n\t          succeeded = true;\n\t        }\n\t\n\t        if (promise === value) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n\t          return;\n\t        }\n\t\n\t      } else {\n\t        value = detail;\n\t        succeeded = true;\n\t      }\n\t\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n\t        // noop\n\t      } else if (hasCallback && succeeded) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      } else if (failed) {\n\t        lib$es6$promise$$internal$$reject(promise, error);\n\t      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n\t      try {\n\t        resolver(function resolvePromise(value){\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function rejectPromise(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$reject(promise, e);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n\t      var enumerator = this;\n\t\n\t      enumerator._instanceConstructor = Constructor;\n\t      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (enumerator._validateInput(input)) {\n\t        enumerator._input     = input;\n\t        enumerator.length     = input.length;\n\t        enumerator._remaining = input.length;\n\t\n\t        enumerator._init();\n\t\n\t        if (enumerator.length === 0) {\n\t          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t        } else {\n\t          enumerator.length = enumerator.length || 0;\n\t          enumerator._enumerate();\n\t          if (enumerator._remaining === 0) {\n\t            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t          }\n\t        }\n\t      } else {\n\t        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n\t      return lib$es6$promise$utils$$isArray(input);\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n\t      return new Error('Array Methods must be provided an Array');\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n\t      this._result = new Array(this.length);\n\t    };\n\t\n\t    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n\t      var enumerator = this;\n\t\n\t      var length  = enumerator.length;\n\t      var promise = enumerator.promise;\n\t      var input   = enumerator._input;\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        enumerator._eachEntry(input[i], i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n\t      var enumerator = this;\n\t      var c = enumerator._instanceConstructor;\n\t\n\t      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n\t        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n\t          entry._onerror = null;\n\t          enumerator._settledAt(entry._state, i, entry._result);\n\t        } else {\n\t          enumerator._willSettleAt(c.resolve(entry), i);\n\t        }\n\t      } else {\n\t        enumerator._remaining--;\n\t        enumerator._result[i] = entry;\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n\t      var enumerator = this;\n\t      var promise = enumerator.promise;\n\t\n\t      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n\t        enumerator._remaining--;\n\t\n\t        if (state === lib$es6$promise$$internal$$REJECTED) {\n\t          lib$es6$promise$$internal$$reject(promise, value);\n\t        } else {\n\t          enumerator._result[i] = value;\n\t        }\n\t      }\n\t\n\t      if (enumerator._remaining === 0) {\n\t        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n\t      var enumerator = this;\n\t\n\t      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n\t      }, function(reason) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n\t      });\n\t    };\n\t    function lib$es6$promise$promise$all$$all(entries) {\n\t      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n\t    }\n\t    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n\t    function lib$es6$promise$promise$race$$race(entries) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (!lib$es6$promise$utils$$isArray(entries)) {\n\t        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n\t        return promise;\n\t      }\n\t\n\t      var length = entries.length;\n\t\n\t      function onFulfillment(value) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      }\n\t\n\t      function onRejection(reason) {\n\t        lib$es6$promise$$internal$$reject(promise, reason);\n\t      }\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n\t      }\n\t\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n\t    function lib$es6$promise$promise$resolve$$resolve(object) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (object && typeof object === 'object' && object.constructor === Constructor) {\n\t        return object;\n\t      }\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$resolve(promise, object);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\t    function lib$es6$promise$promise$reject$$reject(reason) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$reject(promise, reason);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\t\n\t    var lib$es6$promise$promise$$counter = 0;\n\t\n\t    function lib$es6$promise$promise$$needsResolver() {\n\t      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n\t    }\n\t\n\t    function lib$es6$promise$promise$$needsNew() {\n\t      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n\t    }\n\t\n\t    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n\t    /**\n\t      Promise objects represent the eventual result of an asynchronous operation. The\n\t      primary way of interacting with a promise is through its `then` method, which\n\t      registers callbacks to receive either a promise's eventual value or the reason\n\t      why the promise cannot be fulfilled.\n\t\n\t      Terminology\n\t      -----------\n\t\n\t      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n\t      - `thenable` is an object or function that defines a `then` method.\n\t      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n\t      - `exception` is a value that is thrown using the throw statement.\n\t      - `reason` is a value that indicates why a promise was rejected.\n\t      - `settled` the final resting state of a promise, fulfilled or rejected.\n\t\n\t      A promise can be in one of three states: pending, fulfilled, or rejected.\n\t\n\t      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n\t      state.  Promises that are rejected have a rejection reason and are in the\n\t      rejected state.  A fulfillment value is never a thenable.\n\t\n\t      Promises can also be said to *resolve* a value.  If this value is also a\n\t      promise, then the original promise's settled state will match the value's\n\t      settled state.  So a promise that *resolves* a promise that rejects will\n\t      itself reject, and a promise that *resolves* a promise that fulfills will\n\t      itself fulfill.\n\t\n\t\n\t      Basic Usage:\n\t      ------------\n\t\n\t      ```js\n\t      var promise = new Promise(function(resolve, reject) {\n\t        // on success\n\t        resolve(value);\n\t\n\t        // on failure\n\t        reject(reason);\n\t      });\n\t\n\t      promise.then(function(value) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Advanced Usage:\n\t      ---------------\n\t\n\t      Promises shine when abstracting away asynchronous interactions such as\n\t      `XMLHttpRequest`s.\n\t\n\t      ```js\n\t      function getJSON(url) {\n\t        return new Promise(function(resolve, reject){\n\t          var xhr = new XMLHttpRequest();\n\t\n\t          xhr.open('GET', url);\n\t          xhr.onreadystatechange = handler;\n\t          xhr.responseType = 'json';\n\t          xhr.setRequestHeader('Accept', 'application/json');\n\t          xhr.send();\n\t\n\t          function handler() {\n\t            if (this.readyState === this.DONE) {\n\t              if (this.status === 200) {\n\t                resolve(this.response);\n\t              } else {\n\t                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n\t              }\n\t            }\n\t          };\n\t        });\n\t      }\n\t\n\t      getJSON('/posts.json').then(function(json) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Unlike callbacks, promises are great composable primitives.\n\t\n\t      ```js\n\t      Promise.all([\n\t        getJSON('/posts'),\n\t        getJSON('/comments')\n\t      ]).then(function(values){\n\t        values[0] // => postsJSON\n\t        values[1] // => commentsJSON\n\t\n\t        return values;\n\t      });\n\t      ```\n\t\n\t      @class Promise\n\t      @param {function} resolver\n\t      Useful for tooling.\n\t      @constructor\n\t    */\n\t    function lib$es6$promise$promise$$Promise(resolver) {\n\t      this._id = lib$es6$promise$promise$$counter++;\n\t      this._state = undefined;\n\t      this._result = undefined;\n\t      this._subscribers = [];\n\t\n\t      if (lib$es6$promise$$internal$$noop !== resolver) {\n\t        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n\t          lib$es6$promise$promise$$needsResolver();\n\t        }\n\t\n\t        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n\t          lib$es6$promise$promise$$needsNew();\n\t        }\n\t\n\t        lib$es6$promise$$internal$$initializePromise(this, resolver);\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n\t    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n\t    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n\t    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n\t    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n\t    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n\t    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\t\n\t    lib$es6$promise$promise$$Promise.prototype = {\n\t      constructor: lib$es6$promise$promise$$Promise,\n\t\n\t    /**\n\t      The primary way of interacting with a promise is through its `then` method,\n\t      which registers callbacks to receive either a promise's eventual value or the\n\t      reason why the promise cannot be fulfilled.\n\t\n\t      ```js\n\t      findUser().then(function(user){\n\t        // user is available\n\t      }, function(reason){\n\t        // user is unavailable, and you are given the reason why\n\t      });\n\t      ```\n\t\n\t      Chaining\n\t      --------\n\t\n\t      The return value of `then` is itself a promise.  This second, 'downstream'\n\t      promise is resolved with the return value of the first promise's fulfillment\n\t      or rejection handler, or rejected if the handler throws an exception.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return user.name;\n\t      }, function (reason) {\n\t        return 'default name';\n\t      }).then(function (userName) {\n\t        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n\t        // will be `'default name'`\n\t      });\n\t\n\t      findUser().then(function (user) {\n\t        throw new Error('Found user, but still unhappy');\n\t      }, function (reason) {\n\t        throw new Error('`findUser` rejected and we're unhappy');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n\t        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n\t      });\n\t      ```\n\t      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        throw new PedagogicalException('Upstream error');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // The `PedgagocialException` is propagated all the way down to here\n\t      });\n\t      ```\n\t\n\t      Assimilation\n\t      ------------\n\t\n\t      Sometimes the value you want to propagate to a downstream promise can only be\n\t      retrieved asynchronously. This can be achieved by returning a promise in the\n\t      fulfillment or rejection handler. The downstream promise will then be pending\n\t      until the returned promise is settled. This is called *assimilation*.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // The user's comments are now available\n\t      });\n\t      ```\n\t\n\t      If the assimliated promise rejects, then the downstream promise will also reject.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // If `findCommentsByAuthor` fulfills, we'll have the value here\n\t      }, function (reason) {\n\t        // If `findCommentsByAuthor` rejects, we'll have the reason here\n\t      });\n\t      ```\n\t\n\t      Simple Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var result;\n\t\n\t      try {\n\t        result = findResult();\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t      findResult(function(result, err){\n\t        if (err) {\n\t          // failure\n\t        } else {\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findResult().then(function(result){\n\t        // success\n\t      }, function(reason){\n\t        // failure\n\t      });\n\t      ```\n\t\n\t      Advanced Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var author, books;\n\t\n\t      try {\n\t        author = findAuthor();\n\t        books  = findBooksByAuthor(author);\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t\n\t      function foundBooks(books) {\n\t\n\t      }\n\t\n\t      function failure(reason) {\n\t\n\t      }\n\t\n\t      findAuthor(function(author, err){\n\t        if (err) {\n\t          failure(err);\n\t          // failure\n\t        } else {\n\t          try {\n\t            findBoooksByAuthor(author, function(books, err) {\n\t              if (err) {\n\t                failure(err);\n\t              } else {\n\t                try {\n\t                  foundBooks(books);\n\t                } catch(reason) {\n\t                  failure(reason);\n\t                }\n\t              }\n\t            });\n\t          } catch(error) {\n\t            failure(err);\n\t          }\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findAuthor().\n\t        then(findBooksByAuthor).\n\t        then(function(books){\n\t          // found books\n\t      }).catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method then\n\t      @param {Function} onFulfilled\n\t      @param {Function} onRejected\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      then: function(onFulfillment, onRejection) {\n\t        var parent = this;\n\t        var state = parent._state;\n\t\n\t        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n\t          return this;\n\t        }\n\t\n\t        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\t        var result = parent._result;\n\t\n\t        if (state) {\n\t          var callback = arguments[state - 1];\n\t          lib$es6$promise$asap$$asap(function(){\n\t            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n\t          });\n\t        } else {\n\t          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n\t        }\n\t\n\t        return child;\n\t      },\n\t\n\t    /**\n\t      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n\t      as the catch block of a try/catch statement.\n\t\n\t      ```js\n\t      function findAuthor(){\n\t        throw new Error('couldn't find that author');\n\t      }\n\t\n\t      // synchronous\n\t      try {\n\t        findAuthor();\n\t      } catch(reason) {\n\t        // something went wrong\n\t      }\n\t\n\t      // async with promises\n\t      findAuthor().catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method catch\n\t      @param {Function} onRejection\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      'catch': function(onRejection) {\n\t        return this.then(null, onRejection);\n\t      }\n\t    };\n\t    function lib$es6$promise$polyfill$$polyfill() {\n\t      var local;\n\t\n\t      if (typeof global !== 'undefined') {\n\t          local = global;\n\t      } else if (typeof self !== 'undefined') {\n\t          local = self;\n\t      } else {\n\t          try {\n\t              local = Function('return this')();\n\t          } catch (e) {\n\t              throw new Error('polyfill failed because global object is unavailable in this environment');\n\t          }\n\t      }\n\t\n\t      var P = local.Promise;\n\t\n\t      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n\t        return;\n\t      }\n\t\n\t      local.Promise = lib$es6$promise$promise$$default;\n\t    }\n\t    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\t\n\t    var lib$es6$promise$umd$$ES6Promise = {\n\t      'Promise': lib$es6$promise$promise$$default,\n\t      'polyfill': lib$es6$promise$polyfill$$default\n\t    };\n\t\n\t    /* global define:true module:true window: true */\n\t    if (\"function\" === 'function' && __webpack_require__(453)['amd']) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module !== 'undefined' && module['exports']) {\n\t      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n\t    } else if (typeof this !== 'undefined') {\n\t      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n\t    }\n\t\n\t    lib$es6$promise$polyfill$$default();\n\t}).call(this);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(450), (function() { return this; }()), __webpack_require__(340)(module)))\n\n/***/ },\n/* 452 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 453 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ },\n/* 454 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//\n\t// FunctionPromise: possibly-asynchronous function constructor.\n\t//\n\t// This is a prototype polyfill for a FunctionPromise object as described in:\n\t//\n\t//    https://bugzilla.mozilla.org/show_bug.cgi?id=854627\n\t//\n\t// Where possible it will arrange for the function body to be parsed/compiled\n\t// off of the main thread, with the function object returned asynchronously\n\t// via a promise.  The fallback implementation processes just falls back to\n\t// the standard synchronous Function() constructor.\n\t//\n\t// It doesn't (yet) have the following features from the linked proposal:\n\t//\n\t//    * ability to copy to different workers\n\t//    * ability to store in IndexedDB\n\t//\n\t\"use strict\";\n\t\n\tfunction FunctionPromise() /* [args1[, args2[, ...argN]],], functionBody) */{\n\t\n\t  var useFallback = typeof window === \"undefined\" || window.FunctionPromise !== FunctionPromise || typeof document === \"undefined\" || typeof document.createElement === \"undefined\" || typeof document.head === \"undefined\" || typeof document.head.appendChild === \"undefined\" || typeof Blob === \"undefined\" || typeof URL === \"undefined\" || typeof URL.createObjectURL === \"undefined\";\n\t\n\t  var args = Array.prototype.slice.call(arguments);\n\t\n\t  // For the fallback case, we just use the normal Function constructor.\n\t\n\t  if (useFallback) {\n\t    try {\n\t      var fn = Function.apply(null, args);\n\t      return Promise.resolve(fn);\n\t    } catch (err) {\n\t      return Promise.reject(err);\n\t    }\n\t  }\n\t\n\t  // If we have all the necessary pieces, we can do this asynchronously\n\t  // by writing a <script> tag into the DOM.\n\t\n\t  var funcid = FunctionPromise._nextid++;\n\t\n\t  return new Promise(function (resolve, reject) {\n\t    try {\n\t      var funcSrc = [];\n\t      funcSrc.push(\"window.FunctionPromise._results[\" + funcid + \"]=\");\n\t      funcSrc.push(\"function(\");\n\t      if (args.length > 1) {\n\t        funcSrc.push(args[0]);\n\t        for (var i = 1; i < args.length - 1; i++) {\n\t          funcSrc.push(\",\");\n\t          funcSrc.push(args[i]);\n\t        }\n\t      }\n\t      funcSrc.push(\"){\");\n\t      funcSrc.push(args[args.length - 1]);\n\t      funcSrc.push(\"}\");\n\t      var dataUrl = URL.createObjectURL(new Blob(funcSrc));\n\t      var scriptTag = document.createElement(\"script\");\n\t      var cleanup = function cleanup() {\n\t        URL.revokeObjectURL(dataUrl);\n\t        scriptTag.remove();\n\t        delete window.FunctionPromise._results[funcid];\n\t      };\n\t      scriptTag.onerror = function () {\n\t        reject(new Error(\"unknown error loading FunctionPromise\"));\n\t        cleanup();\n\t      };\n\t      scriptTag.onload = function () {\n\t        if (window.FunctionPromise._results[funcid]) {\n\t          resolve(window.FunctionPromise._results[funcid]);\n\t        } else {\n\t          // No function, something must have gone wrong.\n\t          // Likely a syntax error in the function body string.\n\t          // Fall back to Function() constructor to surface it.\n\t          try {\n\t            Function.apply(null, args);\n\t            reject(new Error(\"unknown error fulfilling FunctionPromise\"));\n\t          } catch (err) {\n\t            reject(err);\n\t          }\n\t        }\n\t        cleanup();\n\t      };\n\t      scriptTag.src = dataUrl;\n\t      document.head.appendChild(scriptTag);\n\t    } catch (err) {\n\t      reject(err);\n\t    }\n\t  });\n\t}\n\t\n\tFunctionPromise._nextid = 0;\n\tFunctionPromise._results = {};\n\t\n\tif (typeof module !== \"undefined\" && typeof module.exports !== \"undefined\") {\n\t  if (typeof Promise === \"undefined\") {\n\t    Promise = __webpack_require__(451).Promise;\n\t  }\n\t  module.exports = FunctionPromise;\n\t}\n\n/***/ },\n/* 455 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length - 1; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Split a filename into [root, dir, basename, ext], unix version\n\t// 'root' is just a slash, or nothing.\n\tvar splitPathRe =\n\t    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\tvar splitPath = function(filename) {\n\t  return splitPathRe.exec(filename).slice(1);\n\t};\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function() {\n\t  var resolvedPath = '',\n\t      resolvedAbsolute = false;\n\t\n\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t    var path = (i >= 0) ? arguments[i] : process.cwd();\n\t\n\t    // Skip empty and invalid entries\n\t    if (typeof path !== 'string') {\n\t      throw new TypeError('Arguments to path.resolve must be strings');\n\t    } else if (!path) {\n\t      continue;\n\t    }\n\t\n\t    resolvedPath = path + '/' + resolvedPath;\n\t    resolvedAbsolute = path.charAt(0) === '/';\n\t  }\n\t\n\t  // At this point the path should be resolved to a full absolute path, but\n\t  // handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t  // Normalize the path\n\t  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function(path) {\n\t  var isAbsolute = exports.isAbsolute(path),\n\t      trailingSlash = substr(path, -1) === '/';\n\t\n\t  // Normalize the path\n\t  path = normalizeArray(filter(path.split('/'), function(p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t\n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t// posix version\n\texports.isAbsolute = function(path) {\n\t  return path.charAt(0) === '/';\n\t};\n\t\n\t// posix version\n\texports.join = function() {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function(p, index) {\n\t    if (typeof p !== 'string') {\n\t      throw new TypeError('Arguments to path.join must be strings');\n\t    }\n\t    return p;\n\t  }).join('/'));\n\t};\n\t\n\t\n\t// path.relative(from, to)\n\t// posix version\n\texports.relative = function(from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\texports.delimiter = ':';\n\t\n\texports.dirname = function(path) {\n\t  var result = splitPath(path),\n\t      root = result[0],\n\t      dir = result[1];\n\t\n\t  if (!root && !dir) {\n\t    // No dirname whatsoever\n\t    return '.';\n\t  }\n\t\n\t  if (dir) {\n\t    // It has a dirname, strip trailing slash\n\t    dir = dir.substr(0, dir.length - 1);\n\t  }\n\t\n\t  return root + dir;\n\t};\n\t\n\t\n\texports.basename = function(path, ext) {\n\t  var f = splitPath(path)[2];\n\t  // TODO: make this comparison case-insensitive on windows?\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\t\n\texports.extname = function(path) {\n\t  return splitPath(path)[3];\n\t};\n\t\n\tfunction filter (xs, f) {\n\t    if (xs.filter) return xs.filter(f);\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (f(xs[i], i, xs)) res.push(xs[i]);\n\t    }\n\t    return res;\n\t}\n\t\n\t// String.prototype.substr - negative index don't work in IE8\n\tvar substr = 'ab'.substr(-1) === 'b'\n\t    ? function (str, start, len) { return str.substr(start, len) }\n\t    : function (str, start, len) {\n\t        if (start < 0) start = str.length + start;\n\t        return str.substr(start, len);\n\t    }\n\t;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(450)))\n\n/***/ },\n/* 456 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(351));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  function wordRegexp(words) {\n\t    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n\t  }\n\t\n\t  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n\t  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n\t                        \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n\t                        \"for\", \"from\", \"global\", \"if\", \"import\",\n\t                        \"lambda\", \"pass\", \"raise\", \"return\",\n\t                        \"try\", \"while\", \"with\", \"yield\", \"in\"];\n\t  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n\t                        \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n\t                        \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n\t                        \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n\t                        \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n\t                        \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n\t                        \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n\t                        \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n\t                        \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n\t                        \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n\t                        \"Ellipsis\", \"__debug__\"];\n\t  var py2 = {builtins: [\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n\t                        \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n\t                        \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"],\n\t             keywords: [\"exec\", \"print\"]};\n\t  var py3 = {builtins: [\"ascii\", \"bytes\", \"exec\", \"print\"],\n\t             keywords: [\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]};\n\t\n\t  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\t\n\t  function top(state) {\n\t    return state.scopes[state.scopes.length - 1];\n\t  }\n\t\n\t  CodeMirror.defineMode(\"python\", function(conf, parserConf) {\n\t    var ERRORCLASS = \"error\";\n\t\n\t    var singleDelimiters = parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]/;\n\t    var doubleOperators = parserConf.doubleOperators || /^([!<>]==|<>|<<|>>|\\/\\/|\\*\\*)/;\n\t    var doubleDelimiters = parserConf.doubleDelimiters || /^(\\+=|\\-=|\\*=|%=|\\/=|&=|\\|=|\\^=)/;\n\t    var tripleDelimiters = parserConf.tripleDelimiters || /^(\\/\\/=|>>=|<<=|\\*\\*=)/;\n\t\n\t    if (parserConf.version && parseInt(parserConf.version, 10) == 3){\n\t        // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n\t        var singleOperators = parserConf.singleOperators || /^[\\+\\-\\*\\/%&|\\^~<>!@]/;\n\t        var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n\t    } else {\n\t        var singleOperators = parserConf.singleOperators || /^[\\+\\-\\*\\/%&|\\^~<>!]/;\n\t        var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n\t    }\n\t\n\t    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n\t\n\t    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n\t    if(parserConf.extra_keywords != undefined){\n\t      myKeywords = myKeywords.concat(parserConf.extra_keywords);\n\t    }\n\t    if(parserConf.extra_builtins != undefined){\n\t      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n\t    }\n\t    if (parserConf.version && parseInt(parserConf.version, 10) == 3) {\n\t      myKeywords = myKeywords.concat(py3.keywords);\n\t      myBuiltins = myBuiltins.concat(py3.builtins);\n\t      var stringPrefixes = new RegExp(\"^(([rb]|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n\t    } else {\n\t      myKeywords = myKeywords.concat(py2.keywords);\n\t      myBuiltins = myBuiltins.concat(py2.builtins);\n\t      var stringPrefixes = new RegExp(\"^(([rub]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n\t    }\n\t    var keywords = wordRegexp(myKeywords);\n\t    var builtins = wordRegexp(myBuiltins);\n\t\n\t    // tokenizers\n\t    function tokenBase(stream, state) {\n\t      // Handle scope changes\n\t      if (stream.sol() && top(state).type == \"py\") {\n\t        var scopeOffset = top(state).offset;\n\t        if (stream.eatSpace()) {\n\t          var lineOffset = stream.indentation();\n\t          if (lineOffset > scopeOffset)\n\t            pushScope(stream, state, \"py\");\n\t          else if (lineOffset < scopeOffset && dedent(stream, state))\n\t            state.errorToken = true;\n\t          return null;\n\t        } else {\n\t          var style = tokenBaseInner(stream, state);\n\t          if (scopeOffset > 0 && dedent(stream, state))\n\t            style += \" \" + ERRORCLASS;\n\t          return style;\n\t        }\n\t      }\n\t      return tokenBaseInner(stream, state);\n\t    }\n\t\n\t    function tokenBaseInner(stream, state) {\n\t      if (stream.eatSpace()) return null;\n\t\n\t      var ch = stream.peek();\n\t\n\t      // Handle Comments\n\t      if (ch == \"#\") {\n\t        stream.skipToEnd();\n\t        return \"comment\";\n\t      }\n\t\n\t      // Handle Number Literals\n\t      if (stream.match(/^[0-9\\.]/, false)) {\n\t        var floatLiteral = false;\n\t        // Floats\n\t        if (stream.match(/^\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n\t        if (stream.match(/^\\d+\\.\\d*/)) { floatLiteral = true; }\n\t        if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n\t        if (floatLiteral) {\n\t          // Float literals may be \"imaginary\"\n\t          stream.eat(/J/i);\n\t          return \"number\";\n\t        }\n\t        // Integers\n\t        var intLiteral = false;\n\t        // Hex\n\t        if (stream.match(/^0x[0-9a-f]+/i)) intLiteral = true;\n\t        // Binary\n\t        if (stream.match(/^0b[01]+/i)) intLiteral = true;\n\t        // Octal\n\t        if (stream.match(/^0o[0-7]+/i)) intLiteral = true;\n\t        // Decimal\n\t        if (stream.match(/^[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n\t          // Decimal literals may be \"imaginary\"\n\t          stream.eat(/J/i);\n\t          // TODO - Can you have imaginary longs?\n\t          intLiteral = true;\n\t        }\n\t        // Zero by itself with no other piece of number.\n\t        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n\t        if (intLiteral) {\n\t          // Integer literals may be \"long\"\n\t          stream.eat(/L/i);\n\t          return \"number\";\n\t        }\n\t      }\n\t\n\t      // Handle Strings\n\t      if (stream.match(stringPrefixes)) {\n\t        state.tokenize = tokenStringFactory(stream.current());\n\t        return state.tokenize(stream, state);\n\t      }\n\t\n\t      // Handle operators and Delimiters\n\t      if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters))\n\t        return \"punctuation\";\n\t\n\t      if (stream.match(doubleOperators) || stream.match(singleOperators))\n\t        return \"operator\";\n\t\n\t      if (stream.match(singleDelimiters))\n\t        return \"punctuation\";\n\t\n\t      if (state.lastToken == \".\" && stream.match(identifiers))\n\t        return \"property\";\n\t\n\t      if (stream.match(keywords) || stream.match(wordOperators))\n\t        return \"keyword\";\n\t\n\t      if (stream.match(builtins))\n\t        return \"builtin\";\n\t\n\t      if (stream.match(/^(self|cls)\\b/))\n\t        return \"variable-2\";\n\t\n\t      if (stream.match(identifiers)) {\n\t        if (state.lastToken == \"def\" || state.lastToken == \"class\")\n\t          return \"def\";\n\t        return \"variable\";\n\t      }\n\t\n\t      // Handle non-detected items\n\t      stream.next();\n\t      return ERRORCLASS;\n\t    }\n\t\n\t    function tokenStringFactory(delimiter) {\n\t      while (\"rub\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n\t        delimiter = delimiter.substr(1);\n\t\n\t      var singleline = delimiter.length == 1;\n\t      var OUTCLASS = \"string\";\n\t\n\t      function tokenString(stream, state) {\n\t        while (!stream.eol()) {\n\t          stream.eatWhile(/[^'\"\\\\]/);\n\t          if (stream.eat(\"\\\\\")) {\n\t            stream.next();\n\t            if (singleline && stream.eol())\n\t              return OUTCLASS;\n\t          } else if (stream.match(delimiter)) {\n\t            state.tokenize = tokenBase;\n\t            return OUTCLASS;\n\t          } else {\n\t            stream.eat(/['\"]/);\n\t          }\n\t        }\n\t        if (singleline) {\n\t          if (parserConf.singleLineStringErrors)\n\t            return ERRORCLASS;\n\t          else\n\t            state.tokenize = tokenBase;\n\t        }\n\t        return OUTCLASS;\n\t      }\n\t      tokenString.isString = true;\n\t      return tokenString;\n\t    }\n\t\n\t    function pushScope(stream, state, type) {\n\t      var offset = 0, align = null;\n\t      if (type == \"py\") {\n\t        while (top(state).type != \"py\")\n\t          state.scopes.pop();\n\t      }\n\t      offset = top(state).offset + (type == \"py\" ? conf.indentUnit : hangingIndent);\n\t      if (type != \"py\" && !stream.match(/^(\\s|#.*)*$/, false))\n\t        align = stream.column() + 1;\n\t      state.scopes.push({offset: offset, type: type, align: align});\n\t    }\n\t\n\t    function dedent(stream, state) {\n\t      var indented = stream.indentation();\n\t      while (top(state).offset > indented) {\n\t        if (top(state).type != \"py\") return true;\n\t        state.scopes.pop();\n\t      }\n\t      return top(state).offset != indented;\n\t    }\n\t\n\t    function tokenLexer(stream, state) {\n\t      var style = state.tokenize(stream, state);\n\t      var current = stream.current();\n\t\n\t      // Handle decorators\n\t      if (current == \"@\"){\n\t        if(parserConf.version && parseInt(parserConf.version, 10) == 3){\n\t            return stream.match(identifiers, false) ? \"meta\" : \"operator\";\n\t        } else {\n\t            return stream.match(identifiers, false) ? \"meta\" : ERRORCLASS;\n\t        }\n\t      }\n\t\n\t      if ((style == \"variable\" || style == \"builtin\")\n\t          && state.lastToken == \"meta\")\n\t        style = \"meta\";\n\t\n\t      // Handle scope changes.\n\t      if (current == \"pass\" || current == \"return\")\n\t        state.dedent += 1;\n\t\n\t      if (current == \"lambda\") state.lambda = true;\n\t      if (current == \":\" && !state.lambda && top(state).type == \"py\")\n\t        pushScope(stream, state, \"py\");\n\t\n\t      var delimiter_index = current.length == 1 ? \"[({\".indexOf(current) : -1;\n\t      if (delimiter_index != -1)\n\t        pushScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\t\n\t      delimiter_index = \"])}\".indexOf(current);\n\t      if (delimiter_index != -1) {\n\t        if (top(state).type == current) state.scopes.pop();\n\t        else return ERRORCLASS;\n\t      }\n\t      if (state.dedent > 0 && stream.eol() && top(state).type == \"py\") {\n\t        if (state.scopes.length > 1) state.scopes.pop();\n\t        state.dedent -= 1;\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    var external = {\n\t      startState: function(basecolumn) {\n\t        return {\n\t          tokenize: tokenBase,\n\t          scopes: [{offset: basecolumn || 0, type: \"py\", align: null}],\n\t          lastToken: null,\n\t          lambda: false,\n\t          dedent: 0\n\t        };\n\t      },\n\t\n\t      token: function(stream, state) {\n\t        var addErr = state.errorToken;\n\t        if (addErr) state.errorToken = false;\n\t        var style = tokenLexer(stream, state);\n\t\n\t        if (style && style != \"comment\")\n\t          state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n\t        if (style == \"punctuation\") style = null;\n\t\n\t        if (stream.eol() && state.lambda)\n\t          state.lambda = false;\n\t        return addErr ? style + \" \" + ERRORCLASS : style;\n\t      },\n\t\n\t      indent: function(state, textAfter) {\n\t        if (state.tokenize != tokenBase)\n\t          return state.tokenize.isString ? CodeMirror.Pass : 0;\n\t\n\t        var scope = top(state);\n\t        var closing = textAfter && textAfter.charAt(0) == scope.type;\n\t        if (scope.align != null)\n\t          return scope.align - (closing ? 1 : 0);\n\t        else if (closing && state.scopes.length > 1)\n\t          return state.scopes[state.scopes.length - 2].offset;\n\t        else\n\t          return scope.offset;\n\t      },\n\t\n\t      closeBrackets: {triples: \"'\\\"\"},\n\t      lineComment: \"#\",\n\t      fold: \"indent\"\n\t    };\n\t    return external;\n\t  });\n\t\n\t  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\t\n\t  var words = function(str) { return str.split(\" \"); };\n\t\n\t  CodeMirror.defineMIME(\"text/x-cython\", {\n\t    name: \"python\",\n\t    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except\"+\n\t                          \"extern gil include nogil property public\"+\n\t                          \"readonly struct union DEF IF ELIF ELSE\")\n\t  });\n\t\n\t});\n\n\n/***/ },\n/* 457 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(458);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(336)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../node_modules/gatsby/node_modules/css-loader/index.js!./../node_modules/stylus-loader/index.js!./playground.styl\", function() {\n\t\t\t\tvar newContent = require(\"!!./../node_modules/gatsby/node_modules/css-loader/index.js!./../node_modules/stylus-loader/index.js!./playground.styl\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 458 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(329)();\n\t// imports\n\texports.i(__webpack_require__(459), \"\");\n\t\n\t// module\n\texports.push([module.id, \".playground{top:106px;display:flex;flex-direction:row;min-width:960px}.playground,.playground .loading{position:absolute;left:0;right:0;bottom:0}.playground .loading{display:block;top:0;z-index:10000;background:hsla(0,0%,100%,.6)}.playground-schema{min-width:400px;width:36%;border-right:1px solid #e0e0e0;position:relative;z-index:100;display:flex;flex-direction:column}.playground-schema .cm-def:not(.CodeMirror-lint-mark-error),.playground-schema .cm-variable+.cm-keyword:not(.CodeMirror-lint-mark-error){transition:all .3s ease-in-out;background:transparent}.playground-schema .activeline .cm-def,.playground-schema .activeline .cm-variable+.cm-keyword{background:#d7d3f1;border-radius:1px;box-shadow:0 0 0 2px #d7d3f1}.playground-schema-editor{flex:1;position:relative}.playground-schema-editor .CodeMirror{font-size:13px;position:absolute;height:100%;width:100%;top:0;left:0;right:0;bottom:0;font-family:Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;color:#141823}.playground-schema-editor .CodeMirror-lines{padding:20px 0}.playground-schema-header{height:48px;box-sizing:border-box;font-family:Raleway,sans-serif;color:#999;font-weight:600;font-size:12px;text-transform:uppercase;line-height:52px;padding:0 12px;border-bottom:1px solid #d0d0d0;background:#f9f9f9}.playground-graphiql{flex:1;height:100%}.cm-s-graphene,.cm-s-graphene .cm-comment{color:#999}.cm-s-graphene .cm-punctuation{color:#555}.cm-s-graphene .cm-keyword{color:#a71d5d}.cm-s-graphene .cm-def{color:#1f61a0}.cm-s-graphene .cm-property{color:#333}.cm-s-graphene .cm-qualifier{color:#1c92a9}.cm-s-graphene .cm-attribute{color:#8b2bb9}.cm-s-graphene .cm-number{color:#2882f9}.cm-s-graphene .cm-string{color:#d64292}.cm-s-graphene .cm-builtin{color:#d47509}.cm-s-graphene .cm-string-2{color:#0b7fc7}.cm-s-graphene .cm-variable{color:#333}.cm-s-graphene .cm-meta{color:#b33086}.cm-s-graphene .cm-atom{color:#ca9800}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 459 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(329)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#graphiql-container{color:#141823;width:100%;display:-webkit-flex;display:flex;-webkit-flex-direction:row;flex-direction:row;height:100%;font-family:system,-apple-system,San Francisco,\\\\.SFNSDisplay-Regular,Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:14px}#graphiql-container .editorWrap{display:-webkit-flex;display:flex;-webkit-flex-direction:column;flex-direction:column;-webkit-flex:1;flex:1}#graphiql-container .title{display:none;font-size:18px}#graphiql-container .title em{font-family:georgia;font-size:19px}#graphiql-container .topBarWrap{flex-direction:row;background:#f9f9f9;height:48px}#graphiql-container .topBar,#graphiql-container .topBarWrap{display:-webkit-flex;display:flex;-webkit-flex-direction:row}#graphiql-container .topBar{border-bottom:1px solid #d0d0d0;cursor:default;-webkit-user-select:none;user-select:none;flex-direction:row;-webkit-flex:1;flex:1;-webkit-align-items:center;align-items:center}#graphiql-container .docExplorerShow{background:transparent;border:none;border-bottom:1px solid #d0d0d0;border-left:1px solid rgba(0,0,0,.2);color:#3b5998;cursor:pointer;font-size:14px;outline:0;padding:2px 20px 0 18px}#graphiql-container .docExplorerShow:before{border-left:2px solid #3b5998;border-top:2px solid #3b5998;content:'';display:inline-block;height:9px;margin:0 3px -1px 0;position:relative;width:9px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}#graphiql-container .editorBar{display:-webkit-flex;display:flex;-webkit-flex-direction:row;flex-direction:row;-webkit-flex:1;flex:1}#graphiql-container .queryWrap,#graphiql-container .resultWrap{display:-webkit-flex;display:flex;-webkit-flex-direction:column;flex-direction:column;-webkit-flex:1;flex:1}#graphiql-container .resultWrap{border-left:1px solid #e0e0e0}#graphiql-container .docExplorerWrap{box-shadow:0 0 8px rgba(0,0,0,.15);z-index:3;position:relative;background:#fff}#graphiql-container .docExplorerResizer{cursor:col-resize;height:100%;left:-5px;position:absolute;top:0;width:10px;z-index:10}#graphiql-container .docExplorerHide{cursor:pointer;font-size:18px;margin:-7px -8px -6px 0;padding:18px 16px 15px 12px}#graphiql-container .query-editor{-webkit-flex:1;flex:1;position:relative}#graphiql-container .variable-editor{height:30px;display:-webkit-flex;display:flex;-webkit-flex-direction:column;flex-direction:column;position:relative}#graphiql-container .variable-editor-title{background:#eee;border-bottom:1px solid #d6d6d6;border-top:1px solid #e0e0e0;color:#777;font-variant:small-caps;font-weight:700;letter-spacing:1px;line-height:14px;padding:6px 0 8px 43px;text-transform:lowercase;-webkit-user-select:none;user-select:none}#graphiql-container .codemirrorWrap,#graphiql-container .result-window{-webkit-flex:1;flex:1;position:relative}#graphiql-container .footer{background:#f6f7f8;border-left:1px solid #e0e0e0;border-top:1px solid #e0e0e0;margin-left:12px;position:relative}#graphiql-container .footer:before{background:#eee;bottom:0;content:\\\" \\\";left:-13px;position:absolute;top:-1px;width:12px}#graphiql-container .result-window .CodeMirror{background:#f6f7f8}#graphiql-container .result-window .CodeMirror-gutters{background-color:#eee;border-color:#e0e0e0;cursor:col-resize}#graphiql-container .result-window .CodeMirror-foldgutter,#graphiql-container .result-window .CodeMirror-foldgutter-folded:after,#graphiql-container .result-window .CodeMirror-foldgutter-open:after{padding-left:3px}#graphiql-container .execute-button{background:transparent;border:1px solid #777;border-radius:17px;cursor:pointer;fill:#444;height:34px;margin:0 14px;padding:0;width:34px}#graphiql-container .execute-button path{fill:#777}#graphiql-container .execute-button:hover{border-color:#333}#graphiql-container .execute-button:hover path{fill:#333}#graphiql-container .execute-button:active{background:#fff;border-color:#db594c}#graphiql-container .execute-button:active path{fill:#db594c}#graphiql-container .execute-button:focus{outline:0}#graphiql-container .CodeMirror-scroll{-webkit-overflow-scrolling:touch}#graphiql-container .CodeMirror{position:absolute;top:0;left:0;height:100%;width:100%;font-size:13px;font-family:Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;color:#141823}#graphiql-container .CodeMirror-lines{padding:20px 0}.CodeMirror-hint-information .content{-webkit-box-orient:vertical;color:#141823;display:-webkit-box;font-family:system,-apple-system,San Francisco,\\\\.SFNSDisplay-Regular,Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:13px;-webkit-line-clamp:3;line-height:16px;max-height:48px;overflow:hidden;text-overflow:-o-ellipsis-lastline}.CodeMirror-hint-information .content p:first-child{margin-top:0}.CodeMirror-hint-information .content p:last-child{margin-bottom:0}.CodeMirror-hint-information .infoType{color:#30a;margin-right:.5em;display:inline;cursor:pointer}.autoInsertedLeaf.cm-property{padding:2px 4px 1px;margin:-2px -4px -1px;border-radius:2px;border-bottom:2px solid hsla(0,0%,100%,0);-webkit-animation-duration:6s;animation-duration:6s;-webkit-animation-name:insertionFade;animation-name:insertionFade}@-webkit-keyframes insertionFade{0%,to{background:hsla(0,0%,100%,0);border-color:hsla(0,0%,100%,0)}15%,85%{background:#fbffc9;border-color:#f0f3c0}}@keyframes insertionFade{0%,to{background:hsla(0,0%,100%,0);border-color:hsla(0,0%,100%,0)}15%,85%{background:#fbffc9;border-color:#f0f3c0}}div.CodeMirror-lint-tooltip{background-color:#fff;color:#141823;border:0;border-radius:2px;box-shadow:0 1px 3px rgba(0,0,0,.45);font-family:system,-apple-system,San Francisco,\\\\.SFNSDisplay-Regular,Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:13px;line-height:16px;padding:6px 10px;opacity:0;transition:opacity .15s;-moz-transition:opacity .15s;-webkit-transition:opacity .15s;-o-transition:opacity .15s;-ms-transition:opacity .15s}div.CodeMirror-lint-message-error,div.CodeMirror-lint-message-warning{padding-left:23px}#graphiql-container .CodeMirror-foldmarker{border-radius:4px;background:#08f;background:-webkit-linear-gradient(#43a8ff,#0f83e8);background:linear-gradient(#43a8ff,#0f83e8);color:#fff;box-shadow:0 1px 1px rgba(0,0,0,.2),inset 0 0 0 1px rgba(0,0,0,.1);font-family:arial;line-height:0;padding:0 4px 1px;font-size:12px;margin:0 3px;text-shadow:0 -1px rgba(0,0,0,.1)}#graphiql-container div.CodeMirror span.CodeMirror-matchingbracket{color:#555;text-decoration:underline}#graphiql-container div.CodeMirror span.CodeMirror-nonmatchingbracket{color:red}#graphiql-container .cm-comment{color:#999}#graphiql-container .cm-punctuation{color:#555}#graphiql-container .cm-keyword{color:#b11a04}#graphiql-container .cm-def{color:#d2054e}#graphiql-container .cm-property{color:#1f61a0}#graphiql-container .cm-qualifier{color:#1c92a9}#graphiql-container .cm-attribute{color:#8b2bb9}#graphiql-container .cm-number{color:#2882f9}#graphiql-container .cm-string{color:#d64292}#graphiql-container .cm-builtin{color:#d47509}#graphiql-container .cm-string-2{color:#0b7fc7}#graphiql-container .cm-variable{color:#397d13}#graphiql-container .cm-meta{color:#b33086}#graphiql-container .cm-atom{color:#ca9800}.CodeMirror{font-family:monospace;height:300px;color:#000}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror div.CodeMirror-cursor{border-left:1px solid #000}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.CodeMirror.cm-fat-cursor div.CodeMirror-cursor{width:auto;border:0;background:#7e7}.CodeMirror.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite}@-webkit-keyframes blink{0%{background:#7e7}50%{background:none}to{background:#7e7}}@keyframes blink{0%{background:#7e7}50%{background:none}to{background:#7e7}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-ruler{border-left:1px solid #ccc;position:absolute}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;margin-bottom:-30px;*zoom:1;*display:inline}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;height:100%}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper{-webkit-user-select:none;-moz-user-select:none;user-select:none}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-code{outline:none}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-measure pre{position:static}.CodeMirror div.CodeMirror-cursor{position:absolute;border-right:none;width:0}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror ::selection{background:#d7d4f0}.CodeMirror ::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.CodeMirror span{*vertical-align:text-bottom}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:none}#graphiql-container .doc-explorer{background:#fff}#graphiql-container .doc-explorer-title-bar{cursor:default;display:-webkit-flex;display:flex;height:34px;line-height:14px;padding:8px 8px 5px;position:relative;-webkit-user-select:none;user-select:none}#graphiql-container .doc-explorer-title{padding:10px 0 10px 10px;font-weight:700;text-align:center;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;-webkit-flex:1;flex:1}#graphiql-container .doc-explorer-back{color:#3b5998;cursor:pointer;margin:-7px 0 -6px -8px;overflow-x:hidden;padding:17px 12px 16px 16px;text-overflow:ellipsis;white-space:nowrap}#graphiql-container .doc-explorer-back:before{border-left:2px solid #3b5998;border-top:2px solid #3b5998;content:'';display:inline-block;height:9px;margin:0 3px -1px 0;position:relative;width:9px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}#graphiql-container .doc-explorer-rhs{position:relative}#graphiql-container .doc-explorer-contents{background-color:#fff;border-top:1px solid #d6d6d6;bottom:0;left:0;min-width:300px;overflow-y:auto;padding:20px 15px;position:absolute;right:0;top:47px}#graphiql-container .doc-type-description blockquote:first-child,#graphiql-container .doc-type-description p:first-child{margin-top:0}#graphiql-container .doc-explorer-contents a{cursor:pointer;text-decoration:none}#graphiql-container .doc-explorer-contents a:hover{text-decoration:underline}#graphiql-container .doc-value-description{padding:4px 0 8px 12px}#graphiql-container .doc-category{margin:20px 0}#graphiql-container .doc-category-title{border-bottom:1px solid #e0e0e0;color:#777;cursor:default;font-size:14px;font-variant:small-caps;font-weight:700;letter-spacing:1px;margin:0 -15px 10px 0;padding:10px 0;-webkit-user-select:none;user-select:none}#graphiql-container .doc-category-item{margin:12px 0;color:#555}#graphiql-container .keyword{color:#b11a04}#graphiql-container .type-name{color:#ca9800}#graphiql-container .field-name{color:#1f61a0}#graphiql-container .value-name{color:#0b7fc7}#graphiql-container .arg-name{color:#8b2bb9}#graphiql-container .arg:after{content:', '}#graphiql-container .arg:last-child:after{content:''}.CodeMirror-foldmarker{color:blue;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-folded,.CodeMirror-foldgutter-open{cursor:pointer}.CodeMirror-foldgutter-open:after{content:\\\"\\\\25BE\\\"}.CodeMirror-foldgutter-folded:after{content:\\\"\\\\25B8\\\"}.CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:infobackground;border:1px solid #000;border-radius:4px 4px 4px 4px;color:infotext;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark-error,.CodeMirror-lint-mark-warning{background-position:left bottom;background-repeat:repeat-x}.CodeMirror-lint-mark-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\\\")}.CodeMirror-lint-mark-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-error,.CodeMirror-lint-marker-warning{background-position:center center;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message-error,.CodeMirror-lint-message-warning{padding-left:18px;background-position:top left;background-repeat:no-repeat}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-multiple{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\\\");background-repeat:no-repeat;background-position:right bottom;width:100%;height:100%}.CodeMirror-hints{font-family:Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;font-size:13px;list-style:none;margin:0;margin-left:-6px;max-height:14.5em;overflow-y:auto;overflow:hidden;padding:0}.CodeMirror-hints,.CodeMirror-hints-wrapper{background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.45);position:absolute;z-index:10}.CodeMirror-hints-wrapper{margin-left:-6px}.CodeMirror-hints-wrapper .CodeMirror-hints{box-shadow:none;position:relative;margin-left:0;z-index:0}.CodeMirror-hint{border-top:1px solid #f7f7f7;color:#141823;cursor:pointer;margin:0;max-width:300px;overflow:hidden;padding:2px 6px;white-space:pre}li.CodeMirror-hint-active{background-color:#08f;border-top-color:#fff;color:#fff}.CodeMirror-hint-information{border-top:1px solid silver;max-width:300px;padding:4px 6px;position:relative;z-index:1}.CodeMirror-hint-information:first-child{border-bottom:1px solid silver;border-top:none;margin-bottom:-1px}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }\n]));\n\n\n/** WEBPACK FOOTER **\n ** 1.1.js\n **/","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { RouteHandler, Link, State } from 'react-router';\nimport CodeMirror from 'codemirror';\nimport { graphql } from 'graphql';\nimport GraphiQL from 'graphiql';\nimport schema from './schema';\nimport pypyjs_vm from 'pypyjs';\n\nimport 'codemirror/mode/python/python';\nimport 'codemirror/addon/lint/lint';\nimport '../css/playground.styl';\n\nif (typeof PUBLIC_PATH === \"undefined\") {\n  var PUBLIC_PATH = '';\n}\n\npypyjs_vm.rootURL = `${PUBLIC_PATH}/playground/lib/`;\npypyjs_vm.cacheKey = 'graphene';\n\nvar baseCode = `import graphene\n\nclass Query(graphene.ObjectType):\n    hello = graphene.String()\n    ping = graphene.String(to=graphene.String())\n\n    def resolve_hello(self, args, info):\n        return 'World'\n\n    def resolve_ping(self, args, info):\n        return 'Pinging {}'.format(args.get('to'))\n\nschema = graphene.Schema(query=Query)\n`;\n\nCodeMirror.registerHelper('lint', 'python', function (text, options, editor) {\n  return (options.errors || []).map((error) => {\n    var tokens = editor.getLineTokens(error.line - 1);\n    tokens = tokens.filter((token, pos) => {\n      return !!token.type || token.string.trim().length > 0;\n    });\n    if (!tokens) return [];\n    return {\n      message: `${error.name}: ${error.message}`,\n      severity: 'error',\n      type: 'syntax',\n      from: CodeMirror.Pos(error.line - 1, tokens[0].start),\n      to: CodeMirror.Pos(error.line - 1, tokens[tokens.length-1].end),\n    };\n  });\n});\n\n// function graphQLFetcher(graphQLParams) {\n//   return fetch('http://swapi.graphene-python.org/graphql', {\n//     method: 'post',\n//     headers: { 'Content-Type': 'application/json' },\n//     body: JSON.stringify(graphQLParams),\n//   }).then(response => response.json());\n// }\nfunction graphQLFetcher(graphQLParams) {\n  return graphql(schema, graphQLParams.query);\n}\n// var schema = null;\n\nfunction syntaxError() {\n  var marker = document.createElement(\"div\");\n  marker.style.color = \"#822\";\n  marker.innerHTML = \"●\";\n  return marker;\n}\n\nvar default_interpreter;\nclass Playground extends React.Component {\n  constructor() {\n    super();\n    this.state = {pypyjs: false, stdout: '', response:''};\n  }\n  stdout() {\n    console.log('stdout', arguments);\n  }\n  componentDidMount() {\n    if (default_interpreter) {\n      this.pypy_interpreter = default_interpreter;\n      this.pypy_interpreter.stdout = this.stdout.bind(this);\n    }\n    else {\n      this.pypy_interpreter = new pypyjs_vm({\n        stdin: function(){},\n        stdout: this.stdout.bind(this),\n        stderr: function(){},\n        rootURL: `${PUBLIC_PATH}/playground/lib/`\n      });\n      default_interpreter = this.pypy_interpreter;\n    }\n\n    this.pypyjs = this.pypy_interpreter.ready().then(() => {\n      return this.pypy_interpreter.exec(`\nimport graphene\nimport js\nfrom collections import OrderedDict\nfrom graphql.core.execution.executor import Executor\nfrom graphql.core.execution.middlewares.sync import SynchronousExecutionMiddleware\nfrom graphql.core.error import GraphQLError, format_error\n\ndef get_wrapped(f):\n    if hasattr(f, 'func_closure') and f.func_closure:\n        return get_wrapped(f.func_closure[0].cell_contents)\n    return f\n\nclass TrackResolver(SynchronousExecutionMiddleware):\n    @staticmethod\n    def run_resolve_fn(resolver, original_resolver):\n        if resolver.func.__module__ == '__main__':\n            line = get_wrapped(resolver.func).resolver.func_code.co_firstlineno\n            js.globals.markLine(line-3)\n        return SynchronousExecutionMiddleware.run_resolve_fn(resolver, original_resolver)\n\n__graphene_executor = Executor([TrackResolver()], map_type=OrderedDict)\n`);\n    }).then(() => {\n      this.createSchema(baseCode);\n    }).then(() => {\n      this.setState({pypyjs: true, response:'\"Execute the query for see the results\"'});\n    });\n\n    window.markLine = (lineNo) => {\n      this.markLine(lineNo);\n    }\n\n    this.editor = CodeMirror(ReactDOM.findDOMNode(this.refs.schemaCode), {\n      value: baseCode,\n      mode:  \"python\",\n      theme: \"graphene\",\n      lineNumbers: true,\n      tabSize: 4,\n      indentUnit: 4,\n      gutters: [\"CodeMirror-linenumbers\", \"breakpoints\"],\n      lint: {\n        errors: [],\n      },\n    });\n    this.editor.on(\"change\", this.onEditorChange.bind(this));\n  }\n  onEditorChange() {\n    if (this.changeTimeout) {\n      clearTimeout(this.changeTimeout);\n    }\n    this.changeTimeout = setTimeout(() =>\n      this.updateSchema()\n    , 300);\n  }\n  updateSchema() {\n    this.createSchema(this.editor.getValue());\n  }\n  createSchema(code) {\n    if (this.previousCode == code) return;\n    console.log('createSchema');\n    this.validSchema = null;\n    this.pypyjs.then(() => {\n      return this.pypy_interpreter.exec(`\nschema = None\n${code}\nassert schema, 'You have to define a schema'\n`)\n    }).then(() => {\n      console.log('NO ERRORS');\n      this.removeErrors();\n      this.validSchema = true;\n    }, (err) => {\n      this.editor.options.lint.errors = [];\n      console.log('ERRORS', err);\n      this.logError(err);\n      this.validSchema = false;\n      // this.editor.setGutterMarker(5, \"breakpoints\", syntaxError());\n    }).then(this.updateGraphiQL.bind(this));\n    this.previousCode = code;\n  }\n  updateGraphiQL() {\n    if (this.validSchema) {\n      this.refs.graphiql.state.schema = null;\n      this.refs.graphiql.componentDidMount();\n      this.refs.graphiql.forceUpdate();\n      this.refs.graphiql.refs.docExplorer.forceUpdate();\n    }\n  }\n  logError(error) {\n    var lines = error.trace.split('\\n');\n    var file_errors = lines.map((errorLine) => {\n      return errorLine.match(/File \"<string>\", line (\\d+)/);\n    }).filter((x) => !! x);\n    if (!file_errors.length) return;\n    var line = parseInt(file_errors[file_errors.length-1][1]);\n    error.line = line-2;\n    if (error.name == \"ImportError\" && error.message == \"No module named django\") {\n      error.message = \"Django is not supported yet in Playground editor\";\n    }\n    this.editor.options.lint.errors.push(error);\n    CodeMirror.signal(this.editor, 'change', this.editor);\n  }\n  removeErrors() {\n    this.editor.options.lint.errors = [];\n    CodeMirror.signal(this.editor, 'change', this.editor);\n  }\n  fetcher (graphQLParams) {\n    if (!this.validSchema) {\n      return graphQLFetcher(arguments);\n    }\n    return this.execute(graphQLParams.query);\n  }\n  execute(query) {\n    // console.log('execute', query);\n    return this.pypyjs.then(() => {\n      var x = `\nimport json\nresult = __graphene_executor.execute(schema.schema, '''${query}''')\nresult_dict = {};\nif result.errors:\n  result_dict['errors'] = [format_error(e) for e in result.errors]\nif result.data:\n  result_dict['data'] = result.data\nresult_json = json.dumps(result_dict)\n`;\n      return this.pypy_interpreter.exec(x)\n    }\n    ).then(() =>\n      this.pypy_interpreter.get(`result_json`)\n    ).then((data) => {\n      var json_data = JSON.parse(data);\n      return json_data;\n    });\n  }\n  markLine(lineNo) {\n    console.log(lineNo);\n    var hlLine = this.editor.addLineClass(lineNo, \"text\", \"activeline\");\n    // var mark = this.editor.markText({line: lineNo, ch: 0}, {line: lineNo, ch: 10}, {className: \"called-function\"});\n    setTimeout(() => {\n        this.editor.removeLineClass(lineNo, \"text\", \"activeline\");\n    }, 1200);\n  }\n  render() {\n    return (\n      <div className=\"playground\">\n        {!this.state.pypyjs?<div className=\"loading\" />:null}\n        <div className=\"playground-schema\">\n          <header className=\"playground-schema-header\">\n            Schema\n          </header>\n          <div className=\"playground-schema-editor\" ref=\"schemaCode\" />\n        </div>\n        <div className=\"playground-graphiql\">\n            <GraphiQL ref=\"graphiql\" fetcher={this.fetcher.bind(this)} response={this.state.response} />\n        </div>\n      </div>\n    );\n  }\n}\n\nmodule.exports = Playground;\n\n\n\n/** WEBPACK FOOTER **\n ** ../playground/page.js\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    module.exports = mod();\n  else if (typeof define == \"function\" && define.amd) // AMD\n    return define([], mod);\n  else // Plain browser env\n    this.CodeMirror = mod();\n})(function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n  var webkit = /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) presto_version = Number(presto_version[1]);\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // EDITOR CONSTRUCTOR\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    if (options.autofocus && !mobile) display.input.focus();\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    var cm = this;\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || cm.hasFocus())\n      setTimeout(bind(onFocus, this), 20);\n    else\n      onBlur(this);\n\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n      optionHandlers[opt](this, options[opt], Init);\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) options.finishInit(this);\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      display.lineDiv.style.textRendering = \"auto\";\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\n    if (place) {\n      if (place.appendChild) place.appendChild(d.wrapper);\n      else place(d.wrapper);\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    input.init(d);\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line)) return 0;\n\n      var widgetsHeight = 0;\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n      }\n\n      if (wrapping)\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return widgetsHeight + th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find(0, true);\n      len -= cur.text.length - found.from.ch;\n      cur = found.to.line;\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    };\n  }\n\n  function NativeScrollbars(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function() {\n      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n    });\n    on(horiz, \"scroll\", function() {\n      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n  }\n\n  NativeScrollbars.prototype = copyObj({\n    update: function(measure) {\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n      var sWidth = measure.nativeBarWidth;\n\n      if (needsV) {\n        this.vert.style.display = \"block\";\n        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n        // A bug in IE8 can cause this value to be negative, so guard it.\n        this.vert.firstChild.style.height =\n          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n      } else {\n        this.vert.style.display = \"\";\n        this.vert.firstChild.style.height = \"0\";\n      }\n\n      if (needsH) {\n        this.horiz.style.display = \"block\";\n        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n        this.horiz.style.left = measure.barLeft + \"px\";\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n        this.horiz.firstChild.style.width =\n          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n      } else {\n        this.horiz.style.display = \"\";\n        this.horiz.firstChild.style.width = \"0\";\n      }\n\n      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n        if (sWidth == 0) this.zeroWidthHack();\n        this.checkedZeroWidth = true;\n      }\n\n      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n    },\n    setScrollLeft: function(pos) {\n      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n    },\n    setScrollTop: function(pos) {\n      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n    },\n    zeroWidthHack: function() {\n      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n      this.horiz.style.height = this.vert.style.width = w;\n      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n      this.disableHoriz = new Delayed;\n      this.disableVert = new Delayed;\n    },\n    enableZeroWidthBar: function(bar, delay) {\n      bar.style.pointerEvents = \"auto\";\n      function maybeDisable() {\n        // To find out whether the scrollbar is still visible, we\n        // check whether the element under the pixel in the bottom\n        // left corner of the scrollbar box is the scrollbar box\n        // itself (when the bar is still visible) or its filler child\n        // (when the bar is hidden). If it is still visible, we keep\n        // it enabled, if it's hidden, we disable pointer events.\n        var box = bar.getBoundingClientRect();\n        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n        if (elt != bar) bar.style.pointerEvents = \"none\";\n        else delay.set(1000, maybeDisable);\n      }\n      delay.set(1000, maybeDisable);\n    },\n    clear: function() {\n      var parent = this.horiz.parentNode;\n      parent.removeChild(this.horiz);\n      parent.removeChild(this.vert);\n    }\n  }, NativeScrollbars.prototype);\n\n  function NullScrollbars() {}\n\n  NullScrollbars.prototype = copyObj({\n    update: function() { return {bottom: 0, right: 0}; },\n    setScrollLeft: function() {},\n    setScrollTop: function() {},\n    clear: function() {}\n  }, NullScrollbars.prototype);\n\n  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n    }\n\n    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function() {\n        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function(pos, axis) {\n      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n      else setScrollTop(cm, pos);\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n  }\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) measure = measureForScrollbars(cm);\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        updateHeightsInViewport(cm);\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)};\n  }\n\n  // LINE NUMBERS\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n      if (cm.options.fixedGutter && view[i].gutter)\n        view[i].gutter.style.left = left;\n      var align = view[i].alignable;\n      if (align) for (var j = 0; j < align.length; j++)\n        align[j].style.left = left;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  }\n\n  // DISPLAY DRAWING\n\n  function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  }\n\n  DisplayUpdate.prototype.signal = function(emitter, type) {\n    if (hasHandler(emitter, type))\n      this.events.push(arguments);\n  };\n  DisplayUpdate.prototype.finish = function() {\n    for (var i = 0; i < this.events.length; i++)\n      signal.apply(null, this.events[i]);\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      return false;\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      return false;\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var focused = activeElt();\n    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          break;\n      }\n      if (!updateDisplayIfNeeded(cm, update)) break;\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    var total = measure.docHeight + cm.display.barHeight;\n    cm.display.heightForcer.style.top = total + \"px\";\n    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + \"px\";\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], height;\n      if (cur.hidden) continue;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n      }\n      var diff = cur.line.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n          updateWidgetHeight(cur.rest[j]);\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n      line.widgets[i].height = line.widgets[i].node.offsetHeight;\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        node.style.display = \"none\";\n      else\n        node.parentNode.removeChild(node);\n      return next;\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) {\n      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) cur = rm(cur);\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) cur = rm(cur);\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") updateLineText(cm, lineView);\n      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n      else if (type == \"class\") updateLineClasses(lineView);\n      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n    }\n    return lineView.node;\n  }\n\n  function updateLineBackground(lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) cls += \" CodeMirror-linebackground\";\n    if (lineView.background) {\n      if (cls) lineView.background.className = cls;\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n    return buildLineContent(cm, lineView);\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) lineView.node = built.pre;\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(lineView) {\n    updateLineBackground(lineView);\n    if (lineView.line.wrapClass)\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    else if (lineView.node != lineView.text)\n      lineView.node.className = \"\";\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + cm.display.lineNumInnerWidth + \"px\"));\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n      }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) lineView.alignable = null;\n    for (var node = lineView.node.firstChild, next; node; node = next) {\n      var next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        lineView.node.removeChild(node);\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) lineView.bgClass = built.bgClass;\n    if (built.textClass) lineView.textClass = built.textClass;\n\n    updateLineClasses(lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node;\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) return;\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // POSITION OBJECT\n\n  // A Pos instance represents a position within the text.\n  var Pos = CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\n  function copyPos(x) {return Pos(x.line, x.ch);}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\n  // INPUT HANDLING\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // This will be set to an array of strings when copying, so that,\n  // when pasting, we know what kind of selections the copied text\n  // was made out of.\n  var lastCopied = null;\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) sel = doc.sel;\n\n    var paste = cm.state.pasteIncoming || origin == \"paste\";\n    var textLines = doc.splitLines(inserted), multiPaste = null;\n    // When pasing N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.length; i++)\n            multiPaste.push(doc.splitLines(lastCopied[i]));\n        }\n      } else if (textLines.length == sel.ranges.length) {\n        multiPaste = map(textLines, function(l) { return [l]; });\n      }\n    }\n\n    // Normal behavior is to insert the new text into every selection\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          from = Pos(from.line, from.ch - deleted);\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n      }\n      var updateInput = cm.curOp.updateInput;\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      triggerElectric(cm, inserted);\n\n    ensureCursorVisible(cm);\n    cm.curOp.updateInput = updateInput;\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n    if (pasted) {\n      e.preventDefault();\n      if (!isReadOnly(cm) && !cm.options.disableInput)\n        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n      return true;\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break;\n          }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          indented = indentLine(cm, range.head.line, \"smart\");\n      }\n      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges};\n  }\n\n  function disableBrowserMagic(field) {\n    field.setAttribute(\"autocorrect\", \"off\");\n    field.setAttribute(\"autocapitalize\", \"off\");\n    field.setAttribute(\"spellcheck\", \"false\");\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  function TextareaInput(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Tracks when input.reset has punted to just putting a short\n    // string into the textarea instead of the full selection.\n    this.inaccurateSelection = false;\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) te.style.width = \"1000px\";\n    else te.setAttribute(\"wrap\", \"off\");\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) te.style.border = \"1px solid black\";\n    disableBrowserMagic(te);\n    return div;\n  }\n\n  TextareaInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = this.cm;\n\n      // Wraps and hides input textarea\n      var div = this.wrapper = hiddenTextarea();\n      // The semihidden textarea that is focused when the editor is\n      // focused, and receives input.\n      var te = this.textarea = div.firstChild;\n      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n      if (ios) te.style.width = \"0px\";\n\n      on(te, \"input\", function() {\n        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n        input.poll();\n      });\n\n      on(te, \"paste\", function(e) {\n        if (handlePaste(e, cm)) return true;\n\n        cm.state.pasteIncoming = true;\n        input.fastPoll();\n      });\n\n      function prepareCopyCut(e) {\n        if (cm.somethingSelected()) {\n          lastCopied = cm.getSelections();\n          if (input.inaccurateSelection) {\n            input.prevInput = \"\";\n            input.inaccurateSelection = false;\n            te.value = lastCopied.join(\"\\n\");\n            selectInput(te);\n          }\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = ranges.text;\n          if (e.type == \"cut\") {\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n          } else {\n            input.prevInput = \"\";\n            te.value = ranges.text.join(\"\\n\");\n            selectInput(te);\n          }\n        }\n        if (e.type == \"cut\") cm.state.cutIncoming = true;\n      }\n      on(te, \"cut\", prepareCopyCut);\n      on(te, \"copy\", prepareCopyCut);\n\n      on(display.scroller, \"paste\", function(e) {\n        if (eventInWidget(display, e)) return;\n        cm.state.pasteIncoming = true;\n        input.focus();\n      });\n\n      // Prevent normal selection in the editor (we handle our own)\n      on(display.lineSpace, \"selectstart\", function(e) {\n        if (!eventInWidget(display, e)) e_preventDefault(e);\n      });\n\n      on(te, \"compositionstart\", function() {\n        var start = cm.getCursor(\"from\");\n        if (input.composing) input.composing.range.clear()\n        input.composing = {\n          start: start,\n          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n        };\n      });\n      on(te, \"compositionend\", function() {\n        if (input.composing) {\n          input.poll();\n          input.composing.range.clear();\n          input.composing = null;\n        }\n      });\n    },\n\n    prepareSelection: function() {\n      // Redraw the selection and/or cursor\n      var cm = this.cm, display = cm.display, doc = cm.doc;\n      var result = prepareSelection(cm);\n\n      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n      if (cm.options.moveInputWithCursor) {\n        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                            headPos.top + lineOff.top - wrapOff.top));\n        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                             headPos.left + lineOff.left - wrapOff.left));\n      }\n\n      return result;\n    },\n\n    showSelection: function(drawn) {\n      var cm = this.cm, display = cm.display;\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n      if (drawn.teTop != null) {\n        this.wrapper.style.top = drawn.teTop + \"px\";\n        this.wrapper.style.left = drawn.teLeft + \"px\";\n      }\n    },\n\n    // Reset the input to correspond to the selection (or to be empty,\n    // when not typing and nothing is selected)\n    reset: function(typing) {\n      if (this.contextMenuPending) return;\n      var minimal, selected, cm = this.cm, doc = cm.doc;\n      if (cm.somethingSelected()) {\n        this.prevInput = \"\";\n        var range = doc.sel.primary();\n        minimal = hasCopyEvent &&\n          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n        var content = minimal ? \"-\" : selected || cm.getSelection();\n        this.textarea.value = content;\n        if (cm.state.focused) selectInput(this.textarea);\n        if (ie && ie_version >= 9) this.hasSelection = content;\n      } else if (!typing) {\n        this.prevInput = this.textarea.value = \"\";\n        if (ie && ie_version >= 9) this.hasSelection = null;\n      }\n      this.inaccurateSelection = minimal;\n    },\n\n    getField: function() { return this.textarea; },\n\n    supportsTouch: function() { return false; },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n        try { this.textarea.focus(); }\n        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n      }\n    },\n\n    blur: function() { this.textarea.blur(); },\n\n    resetPosition: function() {\n      this.wrapper.style.top = this.wrapper.style.left = 0;\n    },\n\n    receivedFocus: function() { this.slowPoll(); },\n\n    // Poll for input changes, using the normal rate of polling. This\n    // runs as long as the editor is focused.\n    slowPoll: function() {\n      var input = this;\n      if (input.pollingFast) return;\n      input.polling.set(this.cm.options.pollInterval, function() {\n        input.poll();\n        if (input.cm.state.focused) input.slowPoll();\n      });\n    },\n\n    // When an event has just come in that is likely to add or change\n    // something in the input textarea, we poll faster, to ensure that\n    // the change appears on the screen quickly.\n    fastPoll: function() {\n      var missed = false, input = this;\n      input.pollingFast = true;\n      function p() {\n        var changed = input.poll();\n        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n        else {input.pollingFast = false; input.slowPoll();}\n      }\n      input.polling.set(20, p);\n    },\n\n    // Read input from the textarea, and update the document to match.\n    // When something is selected, it is present in the textarea, and\n    // selected (unless it is huge, in which case a placeholder is\n    // used). When nothing is selected, the cursor sits after previously\n    // seen text (can be empty), which is stored in prevInput (we must\n    // not reset the textarea when typing, because that breaks IME).\n    poll: function() {\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n      // Since this is called a *lot*, try to bail out as cheaply as\n      // possible when it is clear that nothing happened. hasSelection\n      // will be the case when there is a lot of text in the textarea,\n      // in which case reading its value would be expensive.\n      if (this.contextMenuPending || !cm.state.focused ||\n          (hasSelection(input) && !prevInput && !this.composing) ||\n          isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)\n        return false;\n\n      var text = input.value;\n      // If nothing changed, bail.\n      if (text == prevInput && !cm.somethingSelected()) return false;\n      // Work around nonsensical selection resetting in IE9/10, and\n      // inexplicable appearance of private area unicode characters on\n      // some key combos in Mac (#2689).\n      if (ie && ie_version >= 9 && this.hasSelection === text ||\n          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n        cm.display.input.reset();\n        return false;\n      }\n\n      if (cm.doc.sel == cm.display.selForContextMenu) {\n        var first = text.charCodeAt(0);\n        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n      }\n      // Find the part of the input that is actually new\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\n      var self = this;\n      runInOp(cm, function() {\n        applyTextInput(cm, text.slice(same), prevInput.length - same,\n                       null, self.composing ? \"*compose\" : null);\n\n        // Don't leave long text in the textarea, since it makes further polling slow\n        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n        else self.prevInput = text;\n\n        if (self.composing) {\n          self.composing.range.clear();\n          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n                                             {className: \"CodeMirror-composing\"});\n        }\n      });\n      return true;\n    },\n\n    ensurePolled: function() {\n      if (this.pollingFast && this.poll()) this.pollingFast = false;\n    },\n\n    onKeyPress: function() {\n      if (ie && ie_version >= 9) this.hasSelection = null;\n      this.fastPoll();\n    },\n\n    onContextMenu: function(e) {\n      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n      if (!pos || presto) return; // Opera is difficult.\n\n      // Reset the current text selection only if the click is done outside of the selection\n      // and 'resetSelectionOnContextMenu' option is true.\n      var reset = cm.options.resetSelectionOnContextMenu;\n      if (reset && cm.doc.sel.contains(pos) == -1)\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\n      var oldCSS = te.style.cssText;\n      input.wrapper.style.position = \"absolute\";\n      te.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n      display.input.focus();\n      if (webkit) window.scrollTo(null, oldScrollY);\n      display.input.reset();\n      // Adds \"Select all\" to context menu in FF\n      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n      input.contextMenuPending = true;\n      display.selForContextMenu = cm.doc.sel;\n      clearTimeout(display.detectingSelectAll);\n\n      // Select-all will be greyed out if there's nothing to select, so\n      // this adds a zero-width space so that we can later check whether\n      // it got selected.\n      function prepareSelectAllHack() {\n        if (te.selectionStart != null) {\n          var selected = cm.somethingSelected();\n          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n          te.value = \"\\u21da\"; // Used to catch context-menu undo\n          te.value = extval;\n          input.prevInput = selected ? \"\" : \"\\u200b\";\n          te.selectionStart = 1; te.selectionEnd = extval.length;\n          // Re-set this, in case some other handler touched the\n          // selection in the meantime.\n          display.selForContextMenu = cm.doc.sel;\n        }\n      }\n      function rehide() {\n        input.contextMenuPending = false;\n        input.wrapper.style.position = \"relative\";\n        te.style.cssText = oldCSS;\n        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\n        // Try to detect the user choosing select-all\n        if (te.selectionStart != null) {\n          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n          var i = 0, poll = function() {\n            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n              operation(cm, commands.selectAll)(cm);\n            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n            else display.input.reset();\n          };\n          display.detectingSelectAll = setTimeout(poll, 200);\n        }\n      }\n\n      if (ie && ie_version >= 9) prepareSelectAllHack();\n      if (captureRightClick) {\n        e_stop(e);\n        var mouseup = function() {\n          off(window, \"mouseup\", mouseup);\n          setTimeout(rehide, 20);\n        };\n        on(window, \"mouseup\", mouseup);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    },\n\n    readOnlyChanged: function(val) {\n      if (!val) this.reset();\n    },\n\n    setUneditable: nothing,\n\n    needsContentAttribute: false\n  }, TextareaInput.prototype);\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  function ContentEditableInput(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.gracePeriod = false;\n  }\n\n  ContentEditableInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = input.cm;\n      var div = input.div = display.lineDiv;\n      disableBrowserMagic(div);\n\n      on(div, \"paste\", function(e) { handlePaste(e, cm); })\n\n      on(div, \"compositionstart\", function(e) {\n        var data = e.data;\n        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n        if (!data) return;\n        var prim = cm.doc.sel.primary();\n        var line = cm.getLine(prim.head.line);\n        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n        if (found > -1 && found <= prim.head.ch)\n          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n                                                Pos(prim.head.line, found + data.length));\n      });\n      on(div, \"compositionupdate\", function(e) {\n        input.composing.data = e.data;\n      });\n      on(div, \"compositionend\", function(e) {\n        var ours = input.composing;\n        if (!ours) return;\n        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n          ours.data = e.data;\n        // Need a small delay to prevent other code (input event,\n        // selection polling) from doing damage when fired right after\n        // compositionend.\n        setTimeout(function() {\n          if (!ours.handled)\n            input.applyComposition(ours);\n          if (input.composing == ours)\n            input.composing = null;\n        }, 50);\n      });\n\n      on(div, \"touchstart\", function() {\n        input.forceCompositionEnd();\n      });\n\n      on(div, \"input\", function() {\n        if (input.composing) return;\n        if (isReadOnly(cm) || !input.pollContent())\n          runInOp(input.cm, function() {regChange(cm);});\n      });\n\n      function onCopyCut(e) {\n        if (cm.somethingSelected()) {\n          lastCopied = cm.getSelections();\n          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = ranges.text;\n          if (e.type == \"cut\") {\n            cm.operation(function() {\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n              cm.replaceSelection(\"\", null, \"cut\");\n            });\n          }\n        }\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        if (e.clipboardData && !ios) {\n          e.preventDefault();\n          e.clipboardData.clearData();\n          e.clipboardData.setData(\"text/plain\", lastCopied.join(\"\\n\"));\n        } else {\n          // Old-fashioned briefly-focus-a-textarea hack\n          var kludge = hiddenTextarea(), te = kludge.firstChild;\n          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n          te.value = lastCopied.join(\"\\n\");\n          var hadFocus = document.activeElement;\n          selectInput(te);\n          setTimeout(function() {\n            cm.display.lineSpace.removeChild(kludge);\n            hadFocus.focus();\n          }, 50);\n        }\n      }\n      on(div, \"copy\", onCopyCut);\n      on(div, \"cut\", onCopyCut);\n    },\n\n    prepareSelection: function() {\n      var result = prepareSelection(this.cm, false);\n      result.focus = this.cm.state.focused;\n      return result;\n    },\n\n    showSelection: function(info) {\n      if (!info || !this.cm.display.view.length) return;\n      if (info.focus) this.showPrimarySelection();\n      this.showMultipleSelections(info);\n    },\n\n    showPrimarySelection: function() {\n      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n        return;\n\n      var start = posToDOM(this.cm, prim.from());\n      var end = posToDOM(this.cm, prim.to());\n      if (!start && !end) return;\n\n      var view = this.cm.display.view;\n      var old = sel.rangeCount && sel.getRangeAt(0);\n      if (!start) {\n        start = {node: view[0].measure.map[2], offset: 0};\n      } else if (!end) { // FIXME dangerously hacky\n        var measure = view[view.length - 1].measure;\n        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n      }\n\n      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n      if (rng) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n        if (old && sel.anchorNode == null) sel.addRange(old);\n        else if (gecko) this.startGracePeriod();\n      }\n      this.rememberSelection();\n    },\n\n    startGracePeriod: function() {\n      var input = this;\n      clearTimeout(this.gracePeriod);\n      this.gracePeriod = setTimeout(function() {\n        input.gracePeriod = false;\n        if (input.selectionChanged())\n          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n      }, 20);\n    },\n\n    showMultipleSelections: function(info) {\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n    },\n\n    rememberSelection: function() {\n      var sel = window.getSelection();\n      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n    },\n\n    selectionInEditor: function() {\n      var sel = window.getSelection();\n      if (!sel.rangeCount) return false;\n      var node = sel.getRangeAt(0).commonAncestorContainer;\n      return contains(this.div, node);\n    },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n    },\n    blur: function() { this.div.blur(); },\n    getField: function() { return this.div; },\n\n    supportsTouch: function() { return true; },\n\n    receivedFocus: function() {\n      var input = this;\n      if (this.selectionInEditor())\n        this.pollSelection();\n      else\n        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\n      function poll() {\n        if (input.cm.state.focused) {\n          input.pollSelection();\n          input.polling.set(input.cm.options.pollInterval, poll);\n        }\n      }\n      this.polling.set(this.cm.options.pollInterval, poll);\n    },\n\n    selectionChanged: function() {\n      var sel = window.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n    },\n\n    pollSelection: function() {\n      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n        var sel = window.getSelection(), cm = this.cm;\n        this.rememberSelection();\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n        if (anchor && head) runInOp(cm, function() {\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n        });\n      }\n    },\n\n    pollContent: function() {\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n      var from = sel.from(), to = sel.to();\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\n      var fromIndex;\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n        var fromLine = lineNo(display.view[0].line);\n        var fromNode = display.view[0].node;\n      } else {\n        var fromLine = lineNo(display.view[fromIndex].line);\n        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n      }\n      var toIndex = findViewIndex(cm, to.line);\n      if (toIndex == display.view.length - 1) {\n        var toLine = display.viewTo - 1;\n        var toNode = display.lineDiv.lastChild;\n      } else {\n        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n        var toNode = display.view[toIndex + 1].node.previousSibling;\n      }\n\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n      while (newText.length > 1 && oldText.length > 1) {\n        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n        else break;\n      }\n\n      var cutFront = 0, cutEnd = 0;\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n        ++cutFront;\n      var newBot = lst(newText), oldBot = lst(oldText);\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n      while (cutEnd < maxCutEnd &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n        ++cutEnd;\n\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n      newText[0] = newText[0].slice(cutFront);\n\n      var chFrom = Pos(fromLine, cutFront);\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n        return true;\n      }\n    },\n\n    ensurePolled: function() {\n      this.forceCompositionEnd();\n    },\n    reset: function() {\n      this.forceCompositionEnd();\n    },\n    forceCompositionEnd: function() {\n      if (!this.composing || this.composing.handled) return;\n      this.applyComposition(this.composing);\n      this.composing.handled = true;\n      this.div.blur();\n      this.div.focus();\n    },\n    applyComposition: function(composing) {\n      if (isReadOnly(this.cm))\n        operation(this.cm, regChange)(this.cm)\n      else if (composing.data && composing.data != composing.startData)\n        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n    },\n\n    setUneditable: function(node) {\n      node.contentEditable = \"false\"\n    },\n\n    onKeyPress: function(e) {\n      e.preventDefault();\n      if (!isReadOnly(this.cm))\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n    },\n\n    readOnlyChanged: function(val) {\n      this.div.contentEditable = String(val != \"nocursor\")\n    },\n\n    onContextMenu: nothing,\n    resetPosition: nothing,\n\n    needsContentAttribute: true\n  }, ContentEditableInput.prototype);\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) return null;\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result;\n  }\n\n  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        return locateNodeInLineView(lineView, node, offset);\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad);\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) offset = textNode.nodeValue.length;\n    }\n    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n            return Pos(line, ch);\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) return badPos(found, bad);\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        return badPos(Pos(found.line, found.ch - dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        return badPos(Pos(found.line, found.ch + dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n  }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText != null) {\n          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n          text += cmText;\n          return;\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find()))\n            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n          return;\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n        for (var i = 0; i < node.childNodes.length; i++)\n          walk(node.childNodes[i]);\n        if (/^(pre|div|p)$/i.test(node.nodeName))\n          closing = true;\n      } else if (node.nodeType == 3) {\n        var val = node.nodeValue;\n        if (!val) return;\n        if (closing) {\n          text += lineSep;\n          closing = false;\n        }\n        text += val;\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) break;\n      from = from.nextSibling;\n    }\n    return text;\n  }\n\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // SELECTION / CURSOR\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  }\n\n  Selection.prototype = {\n    primary: function() { return this.ranges[this.primIndex]; },\n    equals: function(other) {\n      if (other == this) return true;\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var here = this.ranges[i], there = other.ranges[i];\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n      }\n      return true;\n    },\n    deepCopy: function() {\n      for (var out = [], i = 0; i < this.ranges.length; i++)\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n      return new Selection(out, this.primIndex);\n    },\n    somethingSelected: function() {\n      for (var i = 0; i < this.ranges.length; i++)\n        if (!this.ranges[i].empty()) return true;\n      return false;\n    },\n    contains: function(pos, end) {\n      if (!end) end = pos;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var range = this.ranges[i];\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n          return i;\n      }\n      return -1;\n    }\n  };\n\n  function Range(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  }\n\n  Range.prototype = {\n    from: function() { return minPos(this.anchor, this.head); },\n    to: function() { return maxPos(this.anchor, this.head); },\n    empty: function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    }\n  };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(ranges, primIndex) {\n    var prim = ranges[primIndex];\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      if (cmp(prev.to(), cur.from()) >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) --primIndex;\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n  function clipPosArray(doc, array) {\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n    return out;\n  }\n\n  // SELECTION UPDATES\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(doc, range, head, other) {\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options) {\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head));\n      }\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n    else return sel;\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      sel = filterSelectionChange(doc, sel);\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      ensureCursorVisible(doc.cm);\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) return;\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) out = sel.ranges.slice(0, i);\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, \"beforeCursorEnter\");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;\n                else {--i; continue;}\n              }\n            }\n            if (!m.atomic) continue;\n            var newPos = m.find(dir < 0 ? -1 : 1);\n            if (cmp(newPos, curPos) == 0) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n      return curPos;\n    }\n  }\n\n  // SELECTION DRAWING\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (primary === false && i == doc.sel.primIndex) continue;\n      var range = doc.sel.ranges[i];\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        drawSelectionCursor(cm, range.head, curFragment);\n      if (!collapsed)\n        drawSelectionRange(cm, range, selFragment);\n    }\n    return result;\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = leftSide;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = leftSide;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = rightSide;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < leftSide + 1) left = leftSide;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    else if (cm.options.cursorBlinkRate < 0)\n      display.cursorDiv.style.visibility = \"hidden\";\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.viewTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changedLines = [];\n\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) line.styleClasses = newCls;\n        else if (oldCls) line.styleClasses = null;\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) changedLines.push(doc.frontier);\n        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changedLines.length) runInOp(cm, function() {\n      for (var i = 0; i < changedLines.length; i++)\n        regLineChange(cm, changedLines[i], \"text\");\n    });\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingH(display) {\n    if (display.cachedPaddingH) return display.cachedPaddingH;\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n    return data;\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineView.rest[i] == line)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineNo(lineView.rest[i]) > lineN)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      return cm.display.view[findViewIndex(cm, lineN)];\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      return ext;\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      view = updateExternalMeasurement(cm, line);\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    };\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) ch = -1;\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) prepared.cache[key] = found;\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom};\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      var mStart = map[i], mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) collapse = \"right\";\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          collapse = bias;\n        if (bias == \"left\" && start == 0)\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        if (bias == \"right\" && start == mEnd - mStart)\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        break;\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n          rect = node.parentNode.getBoundingClientRect();\n        } else if (ie && cm.options.lineWrapping) {\n          var rects = range(node, start, end).getClientRects();\n          if (rects.length)\n            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n          else\n            rect = nullRect;\n        } else {\n          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n        }\n        if (rect.left || rect.right || start == 0) break;\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) collapse = bias = \"right\";\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      else\n        rect = node.getBoundingClientRect();\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n      else\n        rect = nullRect;\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    for (var i = 0; i < heights.length - 1; i++)\n      if (mid < heights[i]) break;\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) result.bogus = true;\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result;\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      return rect;\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n        lineView.measure.caches[i] = {};\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0, pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find(0, true);\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineN = lineNo(lineObj = mergedPos.to.line);\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var operationGroup = null;\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: null,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    if (operationGroup) {\n      operationGroup.ops.push(cm.curOp);\n    } else {\n      cm.curOp.ownsGroup = operationGroup = {\n        ops: [cm.curOp],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        callbacks[i].call(null);\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n      }\n    } while (i < callbacks.length);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp, group = op.ownsGroup;\n    if (!group) return;\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      for (var i = 0; i < group.ops.length; i++)\n        group.ops[i].cm.curOp = null;\n      endOperations(group);\n    }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_finish(ops[i]);\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) findMaxLine(cm);\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      op.preparedSelection = display.input.prepareSelection();\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      cm.display.maxLineChanged = false;\n    }\n\n    if (op.preparedSelection)\n      cm.display.input.showSelection(op.preparedSelection);\n    if (op.updatedDisplay)\n      setDocumentHeight(cm, op.barMeasure);\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      updateScrollbars(cm, op.barMeasure);\n\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      cm.display.input.reset(op.typing);\n    if (op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus()))\n      ensureFocus(op.cm);\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      display.wheelStartX = display.wheelStartY = null;\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n      display.scrollbars.setScrollTop(doc.scrollTop);\n      display.scroller.scrollTop = doc.scrollTop;\n    }\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));\n      display.scrollbars.setScrollLeft(doc.scrollLeft);\n      display.scroller.scrollLeft = doc.scrollLeft;\n      alignHorizontally(cm);\n    }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    if (display.wrapper.offsetHeight)\n      doc.scrollTop = cm.display.scroller.scrollTop;\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      signal(cm, \"changes\", cm, op.changeObjs);\n    if (op.update)\n      op.update.finish();\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) return f();\n    startOperation(cm);\n    try { return f(); }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) return f.apply(cm, arguments);\n      startOperation(cm);\n      try { return f.apply(cm, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) return f.apply(this, arguments);\n      startOperation(this);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(this); }\n    };\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) return f.apply(this, arguments);\n      startOperation(cm);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n\n  // VIEW TRACKING\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array;\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    if (!lendiff) lendiff = 0;\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      display.updateLineNumbers = from;\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        resetView(cm);\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut = viewCuttingPoint(cm, from, from, -1);\n      if (cut) {\n        display.view = display.view.slice(0, cut.index);\n        display.viewTo = cut.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        ext.lineN += lendiff;\n      else if (from < ext.lineN + ext.size)\n        display.externalMeasured = null;\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      display.externalMeasured = null;\n\n    if (line < display.viewFrom || line >= display.viewTo) return;\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) return;\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) arr.push(type);\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) return null;\n    n -= cm.display.viewFrom;\n    if (n < 0) return null;\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) return i;\n    }\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      return {index: index, lineN: newN};\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n      n += view[i].size;\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) return null;\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN};\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      else if (display.viewFrom < from)\n        display.view = display.view.slice(findViewIndex(cm, from));\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      else if (display.viewTo > to)\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n    }\n    return dirty;\n  }\n\n  // EVENT HANDLERS\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    else\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    };\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) return false;\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\n    }\n    function farAway(touch, other) {\n      if (other.left == null) return true;\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20;\n    }\n    on(d.scroller, \"touchstart\", function(e) {\n      if (!isMouseLikeTouchEvent(e)) {\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function() {\n      if (d.activeTouch) d.activeTouch.moved = true;\n    });\n    on(d.scroller, \"touchend\", function(e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          range = new Range(pos, pos);\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          range = cm.findWordAt(pos);\n        else // Triple tap\n          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function(e){onDragStart(cm, e);},\n      drop: operation(cm, onDrop),\n      leave: function() {clearDragCursor(cm);}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", bind(onFocus, cm));\n    on(inp, \"blur\", bind(onBlur, cm));\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != CodeMirror.Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n      return;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  // MOUSE EVENTS\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        return true;\n    }\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null; }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords;\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e)) return;\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n    window.focus();\n\n    switch (e_button(e)) {\n    case 1:\n      // #3261: make sure, that we're not starting a second selection\n      if (cm.state.selectingText)\n        cm.state.selectingText(e);\n      else if (start)\n        leftButtonDown(cm, e, start);\n      else if (e_target(e) == display.scroller)\n        e_preventDefault(e);\n      break;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(function() {display.input.focus();}, 20);\n      e_preventDefault(e);\n      break;\n    case 3:\n      if (captureRightClick) onContextMenu(cm, e);\n      else delayBlurEvent(cm);\n      break;\n    }\n  }\n\n  var lastClick, lastDoubleClick;\n  function leftButtonDown(cm, e, start) {\n    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n    else cm.curOp.focus = activeElt();\n\n    var now = +new Date, type;\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n      type = \"triple\";\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n    } else {\n      type = \"single\";\n      lastClick = {time: now, pos: start};\n    }\n\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&\n        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n      leftButtonStartDrag(cm, e, start, modifier);\n    else\n      leftButtonSelect(cm, e, start, type, modifier);\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, e, start, modifier) {\n    var display = cm.display, startTime = +new Date;\n    var dragEnd = operation(cm, function(e2) {\n      if (webkit) display.scroller.draggable = false;\n      cm.state.draggingText = false;\n      off(document, \"mouseup\", dragEnd);\n      off(display.scroller, \"drop\", dragEnd);\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n        e_preventDefault(e2);\n        if (!modifier && +new Date - 200 < startTime)\n          extendSelection(cm.doc, start);\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n        else\n          display.input.focus();\n      }\n    });\n    // Let the drag handler handle this.\n    if (webkit) display.scroller.draggable = true;\n    cm.state.draggingText = dragEnd;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\n    on(document, \"mouseup\", dragEnd);\n    on(display.scroller, \"drop\", dragEnd);\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, e, start, type, addNew) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(e);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (addNew && !e.shiftKey) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        ourRange = ranges[ourIndex];\n      else\n        ourRange = new Range(start, start);\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (e.altKey) {\n      type = \"rect\";\n      if (!addNew) ourRange = new Range(start, start);\n      start = posFromMouse(cm, e, true, true);\n      ourIndex = -1;\n    } else if (type == \"double\") {\n      var word = cm.findWordAt(start);\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n      else\n        ourRange = word;\n    } else if (type == \"triple\") {\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n      else\n        ourRange = line;\n    } else {\n      ourRange = extendRange(doc, ourRange, start);\n    }\n\n    if (!addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) return;\n      lastPos = pos;\n\n      if (type == \"rect\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          else if (text.length > leftPos)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n        }\n        if (!ranges.length) ranges.push(new Range(start, start));\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var anchor = oldRange.anchor, head = pos;\n        if (type != \"single\") {\n          if (type == \"double\")\n            var range = cm.findWordAt(pos);\n          else\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n          if (cmp(range.anchor, anchor) > 0) {\n            head = range.head;\n            anchor = minPos(oldRange.from(), range.anchor);\n          } else {\n            head = range.anchor;\n            anchor = maxPos(oldRange.to(), range.head);\n          }\n        }\n        var ranges = startSel.ranges.slice(0);\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, type == \"rect\");\n      if (!cur) return;\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      e_preventDefault(e);\n      display.input.focus();\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function(e) {\n      if (!e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signal(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          return;\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function() {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function() {cm.display.input.focus();}, 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))\n            var selected = cm.listSelections();\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) for (var i = 0; i < selected.length; ++i)\n            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n          cm.replaceSelection(text, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) img.parentNode.removeChild(img);\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) return;\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // SCROLL EVENTS\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplaySimple(cm, {top: val});\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (gecko) updateDisplaySimple(cm);\n    startWorker(cm, 100);\n  }\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  var wheelEventDelta = function(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n    return {x: dx, y: dy};\n  };\n  CodeMirror.wheelEventPixels = function(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta;\n  };\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // KEY EVENTS\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) cm.display.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) return result;\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm);\n  }\n\n  var stopSeq = new Delayed;\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) return \"handled\";\n      stopSeq.set(50, function() {\n        if (cm.state.keySeq == seq) {\n          cm.state.keySeq = null;\n          cm.display.input.reset();\n        }\n      });\n      name = seq + \" \" + name;\n    }\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      cm.state.keySeq = name;\n    if (result == \"handled\")\n      signalLater(cm, \"keyHandled\", cm, name, e);\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    if (seq && !result && /\\'$/.test(name)) {\n      e_preventDefault(e);\n      return true;\n    }\n    return !!result;\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) return false;\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n          || dispatchKey(cm, name, e, function(b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 return doHandleBinding(cm, b);\n             });\n    } else {\n      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n                       function(b) { return doHandleBinding(cm, b, true); });\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) return;\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\", null, \"cut\");\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      showCrossHair(cm);\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) this.doc.sel.shift = false;\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    cm.display.input.onKeyPress(e);\n  }\n\n  // FOCUS/BLUR EVENTS\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function() {\n      if (cm.state.delayingBlurEvent) {\n        cm.state.delayingBlurEvent = false;\n        onBlur(cm);\n      }\n    }, 100);\n  }\n\n  function onFocus(cm) {\n    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.delayingBlurEvent) return;\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n    cm.display.input.onContextMenu(e);\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n  }\n\n  // UPDATING\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) return pos;\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    else\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex);\n  }\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    for (var i = 0; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        break;\n    }\n    if (i == source.length) return;\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return;\n        }\n        selAfter = event;\n      }\n      else break;\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return;\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) return;\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n                       Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        regLineChange(doc.cm, l, \"gutter\");\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n    else updateDoc(doc, change, spans);\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      signalCursorActivity(cm);\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      regChange(cm);\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      regLineChange(cm, from.line, \"text\");\n    else\n      regChange(cm, from.line, to.line + 1, lendiff);\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = doc.splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, coords) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n                           coords.left + \"px; width: 2px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) break;\n    }\n    return coords;\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (y2 - y1 > screen) y2 = y1 + screen;\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = x2 - x1 > screenw;\n    if (tooWide) x2 = x1 + screenw;\n    if (x1 < 10)\n      result.scrollLeft = 0;\n    else if (x1 < screenleft)\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n    else if (x2 > screenw + screenleft - 3)\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n    return result;\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollPos(cm, left, top) {\n    if (left != null || top != null) resolveScrollToPos(cm);\n    if (left != null)\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n    if (top != null)\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor(), from = cur, to = cur;\n    if (!cm.options.lineWrapping) {\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n      to = Pos(cur.line, cur.ch + 1);\n    }\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n                                    Math.min(from.top, to.top) - range.margin,\n                                    Math.max(from.right, to.right),\n                                    Math.max(from.bottom, to.bottom) + range.margin);\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n    }\n  }\n\n  // API UTILITIES\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) how = \"add\";\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) how = \"prev\";\n      else state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) line.stateAfter = null;\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true;\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\n        var range = doc.sel.ranges[i];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i, new Range(pos, pos));\n          break;\n        }\n      }\n    }\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n    return line;\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function() {\n      for (var i = kill.length - 1; i >= 0; i--)\n        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      ensureCursorVisible(cm);\n    });\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") moveOnce();\n    else if (unit == \"column\") moveOnce(true);\n    else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) type = \"s\";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  // EDITOR METHODS\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || maps[i].name == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: methodOp(function(how) {\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (!range.empty()) {\n          var from = range.from(), to = range.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            indentLine(this, j, how);\n          var newRanges = this.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n        } else if (range.head.line > end) {\n          indentLine(this, range.head.line, how, true);\n          end = range.head.line;\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise);\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true);\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) type = styles[2];\n      else for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else { type = styles[mid * 2 + 2]; break; }\n      }\n      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return found;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range = this.doc.sel.primary();\n      if (start == null) pos = range.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? range.from() : range.to();\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) line = this.doc.first;\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: methodOp(function(line, gutterID, value) {\n      return changeLine(this.doc, line, \"gutter\", function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: methodOp(function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regLineChange(cm, i, \"gutter\");\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd].call(null, this);\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var cm = this;\n      cm.extendSelectionsBy(function(range) {\n        if (cm.display.shift || cm.doc.extend || range.empty())\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n        else\n          return dir < 0 ? range.from() : range.to();\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        doc.replaceSelection(\"\", null, \"+delete\");\n      else\n        deleteNearSelection(this, function(range) {\n          var other = findPosH(doc, range.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n        });\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var cm = this, doc = this.doc, goals = [];\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function(range) {\n        if (collapse)\n          return dir < 0 ? range.from() : range.to();\n        var headPos = cursorCoords(cm, range.head, \"div\");\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\n        goals.push(headPos.left);\n        var pos = findPosV(cm, headPos, dir, unit);\n        if (unit == \"page\" && range == doc.sel.primary())\n          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n        return pos;\n      }, sel_move);\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n        doc.sel.ranges[i].goalColumn = goals[i];\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function(ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n        while (start > 0 && check(line.charAt(start - 1))) --start;\n        while (end < line.length && check(line.charAt(end))) ++end;\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n      else\n        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n\n    scrollTo: methodOp(function(x, y) {\n      if (x != null || y != null) resolveScrollToPos(this);\n      if (x != null) this.curOp.scrollLeft = x;\n      if (y != null) this.curOp.scrollTop = y;\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n    },\n\n    scrollIntoView: methodOp(function(range, margin) {\n      if (range == null) {\n        range = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) margin = this.options.cursorScrollMargin;\n      } else if (typeof range == \"number\") {\n        range = {from: Pos(range, 0), to: null};\n      } else if (range.from == null) {\n        range = {from: range, to: null};\n      }\n      if (!range.to) range.to = range.from;\n      range.margin = margin || 0;\n\n      if (range.from.line != null) {\n        resolveScrollToPos(this);\n        this.curOp.scrollToPos = range;\n      } else {\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n                                      Math.min(range.from.top, range.to.top) - range.margin,\n                                      Math.max(range.from.right, range.to.right),\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var cm = this;\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n      var lineNo = cm.display.viewFrom;\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n        ++lineNo;\n      });\n      cm.curOp.forceUpdate = true;\n      signal(cm, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        estimateLineHeights(this);\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input.getField();},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n  // Functions to run when options are changed.\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  // Passed to option handlers when there is no old value.\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function(cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) return;\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function(line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) break;\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n  });\n  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != CodeMirror.Init) cm.refresh();\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n  }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function(cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != CodeMirror.Init && getKeyMap(old);\n    if (prev && prev.detach) prev.detach(cm, next);\n    if (next.attach) next.attach(cm, prev || null);\n  });\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n  option(\"scrollbarStyle\", \"native\", function(cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n    }\n    cm.display.input.readOnlyChanged(val)\n  });\n  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function(cm, val) {\n    if (!val) cm.display.input.resetPosition();\n  });\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.getField().tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2)\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") found = {name: found};\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    }\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because nested\n  // modes need to do this for their inner modes.\n\n  var copyState = CodeMirror.copyState = function(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  };\n\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  };\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n    singleSelection: function(cm) {\n      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n          if (range.head.ch == len && range.head.line < cm.lastLine())\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n          else\n            return {from: range.head, to: Pos(range.head.line, len)};\n        } else {\n          return {from: range.from(), to: range.to()};\n        }\n      });\n    },\n    deleteLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0),\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n      });\n    },\n    delLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0), to: range.from()};\n      });\n    },\n    delWrappedLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n        return {from: leftPos, to: range.from()};\n      });\n    },\n    delWrappedLineRight: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n        return {from: range.from(), to: rightPos };\n      });\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    undoSelection: function(cm) {cm.undoSelection();},\n    redoSelection: function(cm) {cm.redoSelection();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n                            {origin: \"+move\", bias: 1});\n    },\n    goLineStartSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        return lineStartSmart(cm, range.head);\n      }, {origin: \"+move\", bias: 1});\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n                            {origin: \"+move\", bias: -1});\n    },\n    goLineRight: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: 0, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n    insertSoftTab: function(cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.execCommand(\"insertTab\");\n    },\n    transposeChars: function(cm) {\n      runInOp(cm, function() {\n        var ranges = cm.listSelections(), newSel = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n          if (line) {\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n              if (prev)\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                                prev.charAt(prev.length - 1),\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n            }\n          }\n          newSel.push(new Range(cur, cur));\n        }\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function(cm) {\n      runInOp(cm, function() {\n        var len = cm.listSelections().length;\n        for (var i = 0; i < len; i++) {\n          var range = cm.listSelections()[i];\n          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n          cm.indentLine(range.from().line + 1, null, true);\n        }\n        ensureCursorVisible(cm);\n      });\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    fallthrough: \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n      else if (/^a(lt)?$/i.test(mod)) alt = true;\n      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n      else if (/^s(hift)$/i.test(mod)) shift = true;\n      else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) name = \"Alt-\" + name;\n    if (ctrl) name = \"Ctrl-\" + name;\n    if (cmd) name = \"Cmd-\" + name;\n    if (shift) name = \"Shift-\" + name;\n    return name;\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  CodeMirror.normalizeKeyMap = function(keymap) {\n    var copy = {};\n    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n      if (value == \"...\") { delete keymap[keyname]; continue; }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val, name;\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) copy[name] = val;\n        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n      }\n      delete keymap[keyname];\n    }\n    for (var prop in copy) keymap[prop] = copy[prop];\n    return keymap;\n  };\n\n  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        return lookupKey(key, map.fallthrough, handle, context);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) return result;\n      }\n    }\n  };\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  };\n\n  // Look up the name of a key as indicated by an event object.\n  var keyName = CodeMirror.keyName = function(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n    var base = keyNames[event.keyCode], name = base;\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n    return name;\n  };\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val;\n  }\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      options.tabindex = textarea.tabIndex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function(cm) {\n      cm.save = save;\n      cm.getTextArea = function() { return textarea; };\n      cm.toTextArea = function() {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (typeof textarea.form.submit == \"function\")\n            textarea.form.submit = realSubmit;\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  var nextMarkerId = 0;\n\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n  eventMixin(TextMarker);\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) signalLater(this, \"clear\", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n      else if (cm) {\n        if (span.to != null) max = lineNo(line);\n        if (span.from != null) min = lineNo(line);\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm.doc);\n    }\n    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n    if (withOp) endOperation(cm);\n    if (this.parent) this.parent.clear();\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function(side, lineObj) {\n    if (side == null && this.type == \"bookmark\") side = 1;\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) return from;\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) return to;\n      }\n    }\n    return from && {from: from, to: to};\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) return;\n    runInOp(cm, function() {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          updateLineHeight(line, line.height + dHeight);\n      }\n    });\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) copyObj(options, marker, false);\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        updateMaxLine = true;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n      if (marker.atomic) reCheckSelection(cm.doc);\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      markers[i].parent = this;\n  };\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function(side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.widgetNode = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n                         function(m) { return m.parent; });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], linked = [marker.primary.doc];;\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    }\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    }\n    return nw;\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    }\n    return nw;\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) return null;\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          newParts.push({from: p.from, to: m.from});\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n        return true;\n    }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = merged.find(-1, true).line;\n    return line;\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n    return lines;\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) return lineN;\n    return lineNo(vis);\n  }\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) return lineN;\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) return lineN;\n    while (merged = collapsedSpanAtEnd(line))\n      line = merged.find(1, true).line;\n    return lineNo(line) + 1;\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.widgetNode) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  // LINE WIDGETS\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.doc = doc;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      addToScrollPos(cm, null, diff);\n  }\n\n  LineWidget.prototype.clear = function() {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) line.widgets = null;\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) runInOp(cm, function() {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n  };\n  LineWidget.prototype.changed = function() {\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(line, line.height + diff);\n    if (cm) runInOp(cm, function() {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n    });\n  };\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    var cm = widget.doc.cm;\n    if (!cm) return 0;\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n      if (widget.noHScroll)\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(doc, handle, \"widget\", function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n        cm.curOp.forceUpdate = true;\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        output[prop] = lineClass[2];\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        output[prop] += \" \" + lineClass[2];\n    }\n    return type;\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) return mode.blankLine(state);\n    if (!mode.innerMode) return;\n    var inner = CodeMirror.innerMode(mode, state);\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) return style;\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    function getObj(copy) {\n      return {start: stream.start, end: stream.pos,\n              string: stream.current(),\n              type: style || null,\n              state: copy ? copyState(doc.mode, state) : state};\n    }\n\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n    if (asArray) tokens = [];\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, state);\n      if (asArray) tokens.push(getObj(true));\n    }\n    return asArray ? tokens : getObj();\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 50000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, lineClasses, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"cm-overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n          }\n        }\n      }, lineClasses);\n    }\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var state = getStateBefore(cm, lineNo(line));\n      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n      line.stateAfter = state;\n      line.styles = result.styles;\n      if (result.classes) line.styleClasses = result.classes;\n      else if (line.styleClasses) line.styleClasses = null;\n      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n    }\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") callBlankLine(mode, state);\n    while (!stream.eol()) {\n      readToken(mode, stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) return null;\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        if (line.styleClasses.textClass)\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\n      builder.content.className = \"cm-tab-wrap-hack\";\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token;\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n    if (!text) return;\n    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) mustWrap = true;\n      builder.pos += text.length;\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt.setAttribute(\"role\", \"presentation\");\n          txt.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt);\n        builder.pos++;\n      }\n    }\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (title) token.title = title;\n      return builder.content.appendChild(token);\n    }\n    builder.content.appendChild(content);\n  }\n\n  function splitSpaces(old) {\n    var out = \" \";\n    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n    out += \" \";\n    return out;\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function(builder, text, style, startStyle, endStyle, title, css) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        for (var i = 0; i < order.length; i++) {\n          var part = order[i];\n          if (part.to > start && part.from <= start) break;\n        }\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        widget = builder.content.appendChild(document.createElement(\"span\"));\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [];\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return;\n          if (collapsed.to == pos) collapsed = false;\n        }\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      for (var i = start, result = []; i < end; ++i)\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\n      return result;\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added = linesFor(1, text.length - 1);\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added = linesFor(1, text.length - 1);\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, height = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.extend = false;\n\n    if (typeof text == \"string\") text = this.splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      setSelection(this, simpleSelection(top));\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") line = getLine(this, line);\n      return visualLine(line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") pos = range.head;\n      else if (start == \"anchor\") pos = range.anchor;\n      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n      else pos = range.from();\n      return pos;\n    },\n    listSelections: function() { return this.sel.ranges; },\n    somethingSelected: function() {return this.sel.somethingSelected();},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads, options));\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      extendSelections(this, map(this.sel.ranges, f), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) return;\n      for (var i = 0, out = []; i < ranges.length; i++)\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head));\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      setSelection(this, normalizeSelection(out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) return lines;\n      else return lines.join(lineSep || this.lineSeparator());\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n        parts[i] = sel;\n      }\n      return parts;\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        dup[i] = code;\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i = changes.length - 1; i >= 0; i--)\n        makeChange(this, changes[i]);\n      if (newSel) setSelectionReplaceHistory(this, newSel);\n      else if (this.cm) ensureCursorVisible(this.cm);\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend;},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n      return {undo: done, redo: undone};\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (classTest(cls).test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function(line) {\n        var spans = line.markedSpans;\n        if (spans) for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(lineNo == from.line && from.ch > span.to ||\n                span.from == null && lineNo != from.line||\n                lineNo == to.line && span.from > to.ch) &&\n              (!filter || filter(span.marker)))\n            found.push(span.marker.parent || span.marker);\n        }\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;},\n\n    splitLines: function(str) {\n      if (this.lineSep) return str.split(this.lineSep);\n      return splitLinesAuto(str);\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) findMaxLine(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    for (var chunk = doc; !chunk.lines;) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0; i < chunk.children.length; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) array.pop();\n      else break;\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, ore are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        pushSelectionToHistory(doc.sel, hist.done);\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) hist.done.shift();\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) signal(doc, \"historyAdded\");\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      hist.done[hist.done.length - 1] = sel;\n    else\n      pushSelectionToHistory(sel, hist.done);\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      clearSelectionEvents(hist.undone);\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      dest.push(sel);\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue;\n      }\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT UTILITIES\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  };\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  };\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var on = CodeMirror.on = function(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  };\n\n  var noHandlers = []\n  function getHandlers(emitter, type, copy) {\n    var arr = emitter._handlers && emitter._handlers[type]\n    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n    else return arr || noHandlers\n  }\n\n  var off = CodeMirror.off = function(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var handlers = getHandlers(emitter, type, false)\n      for (var i = 0; i < handlers.length; ++i)\n        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n    }\n  };\n\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type, true)\n    if (!handlers.length) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n  };\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type, false)\n    if (!arr.length) return;\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      list.push(bnd(arr[i]));\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) return;\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n      set.push(arr[i]);\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype.set = function(ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        return n + (end - i);\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  };\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) nextTab = string.length;\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        return pos + Math.min(skipped, goal - col);\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) return pos;\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n  else if (ie) // Suppress mysterious IE10 errors\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      if (array[i] == elt) return i;\n    return -1;\n  }\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n    return out;\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) copyObj(props, inst);\n    return inst;\n  };\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) target = {};\n    for (var prop in obj)\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        target[prop] = obj[prop];\n    return target;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  };\n  function isWordChar(ch, helper) {\n    if (!helper) return isWordCharBasic(ch);\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  var range;\n  if (document.createRange) range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r;\n  };\n  else range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r; }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r;\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  var contains = CodeMirror.contains = function(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      child = child.parentNode;\n    if (parent.contains)\n      return parent.contains(child);\n    do {\n      if (child.nodeType == 11) child = child.host;\n      if (child == parent) return true;\n    } while (child = child.parentNode);\n  };\n\n  function activeElt() {\n    var activeElement = document.activeElement;\n    while (activeElement && activeElement.root && activeElement.root.activeElement)\n      activeElement = activeElement.root.activeElement;\n    return activeElement;\n  }\n  // Older versions of IE throws unspecified error when touching\n  // document.activeElement in some cases (during loading, in iframe)\n  if (ie && ie_version < 11) activeElt = function() {\n    try { return document.activeElement; }\n    catch(e) { return document.body; }\n  };\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n  var rmClass = CodeMirror.rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n  var addClass = CodeMirror.addClass = function(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n  };\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n    return b;\n  }\n\n  // WINDOW-WIDE EVENTS\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.body.getElementsByClassName) return;\n    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) f(cm);\n    }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) return;\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100);\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function() {\n      forEachCodeMirror(onBlur);\n    });\n  }\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node;\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) return badBidiRects;\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    return badBidiRects = (r1.right - r0.right < 3);\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) return badZoomedRects;\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  }\n\n  // KEY NAMES\n\n  var keyNames = CodeMirror.keyNames = {\n    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, \"ltr\");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line = getLine(cm.doc, lineN);\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      lineN = null;\n    }\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS);\n    }\n    return start;\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is needed in order to move 'visually' through bi-directional\n  // text -- i.e., pressing left should make the cursor go left, even\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\n  // LTR text touch each other. This often requires the cursor offset\n  // to move more than one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n    function charType(code) {\n      if (code <= 0xf7) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n      else if (code == 0x200c) return \"b\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push(new BidiSpan(0, start, i));\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n      if (order[0].level == 2)\n        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n      if (order[0].level != lst(order).level)\n        order.push(new BidiSpan(order[0].level, len, len));\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"5.9.0\";\n\n  return CodeMirror;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/lib/codemirror.js\n ** module id = 351\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n// The primary entry point into fulfilling a GraphQL request.\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _graphql = require('./graphql');\n\nObject.defineProperty(exports, 'graphql', {\n  enumerable: true,\n  get: function get() {\n    return _graphql.graphql;\n  }\n});\n\n// Produce a GraphQL type schema.\n\nvar _typeSchema = require('./type/schema');\n\nObject.defineProperty(exports, 'GraphQLSchema', {\n  enumerable: true,\n  get: function get() {\n    return _typeSchema.GraphQLSchema;\n  }\n});\n\n// Define GraphQL types.\n\nvar _typeDefinition = require('./type/definition');\n\nObject.defineProperty(exports, 'GraphQLScalarType', {\n  enumerable: true,\n  get: function get() {\n    return _typeDefinition.GraphQLScalarType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLObjectType', {\n  enumerable: true,\n  get: function get() {\n    return _typeDefinition.GraphQLObjectType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLInterfaceType', {\n  enumerable: true,\n  get: function get() {\n    return _typeDefinition.GraphQLInterfaceType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLUnionType', {\n  enumerable: true,\n  get: function get() {\n    return _typeDefinition.GraphQLUnionType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLEnumType', {\n  enumerable: true,\n  get: function get() {\n    return _typeDefinition.GraphQLEnumType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLInputObjectType', {\n  enumerable: true,\n  get: function get() {\n    return _typeDefinition.GraphQLInputObjectType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLList', {\n  enumerable: true,\n  get: function get() {\n    return _typeDefinition.GraphQLList;\n  }\n});\nObject.defineProperty(exports, 'GraphQLNonNull', {\n  enumerable: true,\n  get: function get() {\n    return _typeDefinition.GraphQLNonNull;\n  }\n});\n\n// Use pre-defined GraphQL scalar types.\n\nvar _typeScalars = require('./type/scalars');\n\nObject.defineProperty(exports, 'GraphQLInt', {\n  enumerable: true,\n  get: function get() {\n    return _typeScalars.GraphQLInt;\n  }\n});\nObject.defineProperty(exports, 'GraphQLFloat', {\n  enumerable: true,\n  get: function get() {\n    return _typeScalars.GraphQLFloat;\n  }\n});\nObject.defineProperty(exports, 'GraphQLString', {\n  enumerable: true,\n  get: function get() {\n    return _typeScalars.GraphQLString;\n  }\n});\nObject.defineProperty(exports, 'GraphQLBoolean', {\n  enumerable: true,\n  get: function get() {\n    return _typeScalars.GraphQLBoolean;\n  }\n});\nObject.defineProperty(exports, 'GraphQLID', {\n  enumerable: true,\n  get: function get() {\n    return _typeScalars.GraphQLID;\n  }\n});\n\n// Format GraphQL errors.\n\nvar _errorFormatError = require('./error/formatError');\n\nObject.defineProperty(exports, 'formatError', {\n  enumerable: true,\n  get: function get() {\n    return _errorFormatError.formatError;\n  }\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/index.js\n ** module id = 352\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * This is the primary entry point function for fulfilling GraphQL operations\n * by parsing, validating, and executing a GraphQL document along side a\n * GraphQL schema.\n *\n * More sophisticated GraphQL servers, such as those which persist queries,\n * may wish to separate the validation and execution phases to a static time\n * tooling step, and a server runtime step.\n *\n * schema:\n *    The GraphQL type system to use when validating and executing a query.\n * requestString:\n *    A GraphQL language formatted string representing the requested operation.\n * rootValue:\n *    The value provided as the first argument to resolver functions on the top\n *    level type (e.g. the query object type).\n * variableValues:\n *    A mapping of variable name to runtime value to use for all variables\n *    defined in the requestString.\n * operationName:\n *    The name of the operation to use if requestString contains multiple\n *    possible operations. Can be omitted if requestString contains only\n *    one operation.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.graphql = graphql;\n\n/**\n * The result of a GraphQL parse, validation and execution.\n *\n * `data` is the result of a successful execution of the query.\n * `errors` is included when any errors occurred as a non-empty array.\n */\n\nvar _languageSource = require('./language/source');\n\nvar _languageParser = require('./language/parser');\n\nvar _validationValidate = require('./validation/validate');\n\nvar _executionExecute = require('./execution/execute');\n\nfunction graphql(schema, requestString, rootValue, variableValues, operationName) {\n  return new Promise(function (resolve) {\n    var source = new _languageSource.Source(requestString || '', 'GraphQL request');\n    var documentAST = (0, _languageParser.parse)(source);\n    var validationErrors = (0, _validationValidate.validate)(schema, documentAST);\n    if (validationErrors.length > 0) {\n      resolve({ errors: validationErrors });\n    } else {\n      resolve((0, _executionExecute.execute)(schema, documentAST, rootValue, variableValues, operationName));\n    }\n  })['catch'](function (error) {\n    return { errors: [error] };\n  });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/graphql.js\n ** module id = 353\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * A representation of source input to GraphQL. The name is optional,\n * but is mostly useful for clients who store GraphQL documents in\n * source files; for example, if the GraphQL input is in a file Foo.graphql,\n * it might be useful for name to be \"Foo.graphql\".\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar Source = function Source(body, name) {\n  _classCallCheck(this, Source);\n\n  this.body = body;\n  this.name = name || 'GraphQL';\n};\n\nexports.Source = Source;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/language/source.js\n ** module id = 354\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\n/**\n * Configuration options to control parser behavior\n */\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseConstValue = parseConstValue;\nexports.parseType = parseType;\nexports.parseNamedType = parseNamedType;\n\nvar _source = require('./source');\n\nvar _error = require('../error');\n\nvar _lexer = require('./lexer');\n\nvar _kinds = require('./kinds');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\nfunction parse(source, options) {\n  var sourceObj = source instanceof _source.Source ? source : new _source.Source(source);\n  var parser = makeParser(sourceObj, options || {});\n  return parseDocument(parser);\n}\n\n/**\n * Given a string containing a GraphQL value, parse the AST for that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n */\n\nfunction parseValue(source, options) {\n  var sourceObj = source instanceof _source.Source ? source : new _source.Source(source);\n  var parser = makeParser(sourceObj, options || {});\n  return parseValueLiteral(parser);\n}\n\n/**\n * Converts a name lex token into a name parse node.\n */\nfunction parseName(parser) {\n  var token = expect(parser, _lexer.TokenKind.NAME);\n  return {\n    kind: _kinds.NAME,\n    value: token.value,\n    loc: loc(parser, token.start)\n  };\n}\n\n// Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\nfunction parseDocument(parser) {\n  var start = parser.token.start;\n\n  var definitions = [];\n  do {\n    definitions.push(parseDefinition(parser));\n  } while (!skip(parser, _lexer.TokenKind.EOF));\n\n  return {\n    kind: _kinds.DOCUMENT,\n    definitions: definitions,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * Definition :\n *   - OperationDefinition\n *   - FragmentDefinition\n *   - TypeDefinition\n */\nfunction parseDefinition(parser) {\n  if (peek(parser, _lexer.TokenKind.BRACE_L)) {\n    return parseOperationDefinition(parser);\n  }\n\n  if (peek(parser, _lexer.TokenKind.NAME)) {\n    switch (parser.token.value) {\n      case 'query':\n      case 'mutation':\n      // Note: subscription is an experimental non-spec addition.\n      case 'subscription':\n        return parseOperationDefinition(parser);\n\n      case 'fragment':\n        return parseFragmentDefinition(parser);\n\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'scalar':\n      case 'enum':\n      case 'input':\n      case 'extend':\n        return parseTypeDefinition(parser);\n    }\n  }\n\n  throw unexpected(parser);\n}\n\n// Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n *\n * OperationType : one of query mutation\n */\nfunction parseOperationDefinition(parser) {\n  var start = parser.token.start;\n  if (peek(parser, _lexer.TokenKind.BRACE_L)) {\n    return {\n      kind: _kinds.OPERATION_DEFINITION,\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: parseSelectionSet(parser),\n      loc: loc(parser, start)\n    };\n  }\n  var operationToken = expect(parser, _lexer.TokenKind.NAME);\n  var operation = operationToken.value;\n  var name;\n  if (peek(parser, _lexer.TokenKind.NAME)) {\n    name = parseName(parser);\n  }\n  return {\n    kind: _kinds.OPERATION_DEFINITION,\n    operation: operation,\n    name: name,\n    variableDefinitions: parseVariableDefinitions(parser),\n    directives: parseDirectives(parser),\n    selectionSet: parseSelectionSet(parser),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\nfunction parseVariableDefinitions(parser) {\n  return peek(parser, _lexer.TokenKind.PAREN_L) ? many(parser, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\nfunction parseVariableDefinition(parser) {\n  var start = parser.token.start;\n  return {\n    kind: _kinds.VARIABLE_DEFINITION,\n    variable: parseVariable(parser),\n    type: (expect(parser, _lexer.TokenKind.COLON), parseType(parser)),\n    defaultValue: skip(parser, _lexer.TokenKind.EQUALS) ? parseValueLiteral(parser, true) : null,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * Variable : $ Name\n */\nfunction parseVariable(parser) {\n  var start = parser.token.start;\n  expect(parser, _lexer.TokenKind.DOLLAR);\n  return {\n    kind: _kinds.VARIABLE,\n    name: parseName(parser),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * SelectionSet : { Selection+ }\n */\nfunction parseSelectionSet(parser) {\n  var start = parser.token.start;\n  return {\n    kind: _kinds.SELECTION_SET,\n    selections: many(parser, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\nfunction parseSelection(parser) {\n  return peek(parser, _lexer.TokenKind.SPREAD) ? parseFragment(parser) : parseField(parser);\n}\n\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\nfunction parseField(parser) {\n  var start = parser.token.start;\n\n  var nameOrAlias = parseName(parser);\n  var alias;\n  var name;\n  if (skip(parser, _lexer.TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(parser);\n  } else {\n    alias = null;\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: _kinds.FIELD,\n    alias: alias,\n    name: name,\n    arguments: parseArguments(parser),\n    directives: parseDirectives(parser),\n    selectionSet: peek(parser, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(parser) : null,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * Arguments : ( Argument+ )\n */\nfunction parseArguments(parser) {\n  return peek(parser, _lexer.TokenKind.PAREN_L) ? many(parser, _lexer.TokenKind.PAREN_L, parseArgument, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * Argument : Name : Value\n */\nfunction parseArgument(parser) {\n  var start = parser.token.start;\n  return {\n    kind: _kinds.ARGUMENT,\n    name: parseName(parser),\n    value: (expect(parser, _lexer.TokenKind.COLON), parseValueLiteral(parser, false)),\n    loc: loc(parser, start)\n  };\n}\n\n// Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\nfunction parseFragment(parser) {\n  var start = parser.token.start;\n  expect(parser, _lexer.TokenKind.SPREAD);\n  if (peek(parser, _lexer.TokenKind.NAME) && parser.token.value !== 'on') {\n    return {\n      kind: _kinds.FRAGMENT_SPREAD,\n      name: parseFragmentName(parser),\n      directives: parseDirectives(parser),\n      loc: loc(parser, start)\n    };\n  }\n  var typeCondition = null;\n  if (parser.token.value === 'on') {\n    advance(parser);\n    typeCondition = parseNamedType(parser);\n  }\n  return {\n    kind: _kinds.INLINE_FRAGMENT,\n    typeCondition: typeCondition,\n    directives: parseDirectives(parser),\n    selectionSet: parseSelectionSet(parser),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\nfunction parseFragmentDefinition(parser) {\n  var start = parser.token.start;\n  expectKeyword(parser, 'fragment');\n  return {\n    kind: _kinds.FRAGMENT_DEFINITION,\n    name: parseFragmentName(parser),\n    typeCondition: (expectKeyword(parser, 'on'), parseNamedType(parser)),\n    directives: parseDirectives(parser),\n    selectionSet: parseSelectionSet(parser),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * FragmentName : Name but not `on`\n */\nfunction parseFragmentName(parser) {\n  if (parser.token.value === 'on') {\n    throw unexpected(parser);\n  }\n  return parseName(parser);\n}\n\n// Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\nfunction parseValueLiteral(parser, isConst) {\n  var token = parser.token;\n  switch (token.kind) {\n    case _lexer.TokenKind.BRACKET_L:\n      return parseList(parser, isConst);\n    case _lexer.TokenKind.BRACE_L:\n      return parseObject(parser, isConst);\n    case _lexer.TokenKind.INT:\n      advance(parser);\n      return {\n        kind: _kinds.INT,\n        value: token.value,\n        loc: loc(parser, token.start)\n      };\n    case _lexer.TokenKind.FLOAT:\n      advance(parser);\n      return {\n        kind: _kinds.FLOAT,\n        value: token.value,\n        loc: loc(parser, token.start)\n      };\n    case _lexer.TokenKind.STRING:\n      advance(parser);\n      return {\n        kind: _kinds.STRING,\n        value: token.value,\n        loc: loc(parser, token.start)\n      };\n    case _lexer.TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        advance(parser);\n        return {\n          kind: _kinds.BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(parser, token.start)\n        };\n      } else if (token.value !== 'null') {\n        advance(parser);\n        return {\n          kind: _kinds.ENUM,\n          value: token.value,\n          loc: loc(parser, token.start)\n        };\n      }\n      break;\n    case _lexer.TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(parser);\n      }\n      break;\n  }\n  throw unexpected(parser);\n}\n\nfunction parseConstValue(parser) {\n  return parseValueLiteral(parser, true);\n}\n\nfunction parseValueValue(parser) {\n  return parseValueLiteral(parser, false);\n}\n\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\nfunction parseList(parser, isConst) {\n  var start = parser.token.start;\n  var item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: _kinds.LIST,\n    values: any(parser, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\nfunction parseObject(parser, isConst) {\n  var start = parser.token.start;\n  expect(parser, _lexer.TokenKind.BRACE_L);\n  var fields = [];\n  while (!skip(parser, _lexer.TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(parser, isConst));\n  }\n  return {\n    kind: _kinds.OBJECT,\n    fields: fields,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\nfunction parseObjectField(parser, isConst) {\n  var start = parser.token.start;\n  return {\n    kind: _kinds.OBJECT_FIELD,\n    name: parseName(parser),\n    value: (expect(parser, _lexer.TokenKind.COLON), parseValueLiteral(parser, isConst)),\n    loc: loc(parser, start)\n  };\n}\n\n// Implements the parsing rules in the Directives section.\n\n/**\n * Directives : Directive+\n */\nfunction parseDirectives(parser) {\n  var directives = [];\n  while (peek(parser, _lexer.TokenKind.AT)) {\n    directives.push(parseDirective(parser));\n  }\n  return directives;\n}\n\n/**\n * Directive : @ Name Arguments?\n */\nfunction parseDirective(parser) {\n  var start = parser.token.start;\n  expect(parser, _lexer.TokenKind.AT);\n  return {\n    kind: _kinds.DIRECTIVE,\n    name: parseName(parser),\n    arguments: parseArguments(parser),\n    loc: loc(parser, start)\n  };\n}\n\n// Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\n\nfunction parseType(parser) {\n  var start = parser.token.start;\n  var type;\n  if (skip(parser, _lexer.TokenKind.BRACKET_L)) {\n    type = parseType(parser);\n    expect(parser, _lexer.TokenKind.BRACKET_R);\n    type = {\n      kind: _kinds.LIST_TYPE,\n      type: type,\n      loc: loc(parser, start)\n    };\n  } else {\n    type = parseNamedType(parser);\n  }\n  if (skip(parser, _lexer.TokenKind.BANG)) {\n    return {\n      kind: _kinds.NON_NULL_TYPE,\n      type: type,\n      loc: loc(parser, start)\n    };\n  }\n  return type;\n}\n\n/**\n * NamedType : Name\n */\n\nfunction parseNamedType(parser) {\n  var start = parser.token.start;\n  return {\n    kind: _kinds.NAMED_TYPE,\n    name: parseName(parser),\n    loc: loc(parser, start)\n  };\n}\n\n// Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeDefinition :\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - ScalarTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n *   - TypeExtensionDefinition\n */\nfunction parseTypeDefinition(parser) {\n  if (!peek(parser, _lexer.TokenKind.NAME)) {\n    throw unexpected(parser);\n  }\n  switch (parser.token.value) {\n    case 'type':\n      return parseObjectTypeDefinition(parser);\n    case 'interface':\n      return parseInterfaceTypeDefinition(parser);\n    case 'union':\n      return parseUnionTypeDefinition(parser);\n    case 'scalar':\n      return parseScalarTypeDefinition(parser);\n    case 'enum':\n      return parseEnumTypeDefinition(parser);\n    case 'input':\n      return parseInputObjectTypeDefinition(parser);\n    case 'extend':\n      return parseTypeExtensionDefinition(parser);\n    default:\n      throw unexpected(parser);\n  }\n}\n\n/**\n * ObjectTypeDefinition : type Name ImplementsInterfaces? { FieldDefinition+ }\n */\nfunction parseObjectTypeDefinition(parser) {\n  var start = parser.token.start;\n  expectKeyword(parser, 'type');\n  var name = parseName(parser);\n  var interfaces = parseImplementsInterfaces(parser);\n  var fields = any(parser, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.OBJECT_TYPE_DEFINITION,\n    name: name,\n    interfaces: interfaces,\n    fields: fields,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * ImplementsInterfaces : implements NamedType+\n */\nfunction parseImplementsInterfaces(parser) {\n  var types = [];\n  if (parser.token.value === 'implements') {\n    advance(parser);\n    do {\n      types.push(parseNamedType(parser));\n    } while (!peek(parser, _lexer.TokenKind.BRACE_L));\n  }\n  return types;\n}\n\n/**\n * FieldDefinition : Name ArgumentsDefinition? : Type\n */\nfunction parseFieldDefinition(parser) {\n  var start = parser.token.start;\n  var name = parseName(parser);\n  var args = parseArgumentDefs(parser);\n  expect(parser, _lexer.TokenKind.COLON);\n  var type = parseType(parser);\n  return {\n    kind: _kinds.FIELD_DEFINITION,\n    name: name,\n    arguments: args,\n    type: type,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\nfunction parseArgumentDefs(parser) {\n  if (!peek(parser, _lexer.TokenKind.PAREN_L)) {\n    return [];\n  }\n  return many(parser, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n}\n\n/**\n * InputValueDefinition : Name : Type DefaultValue?\n */\nfunction parseInputValueDef(parser) {\n  var start = parser.token.start;\n  var name = parseName(parser);\n  expect(parser, _lexer.TokenKind.COLON);\n  var type = parseType(parser);\n  var defaultValue = null;\n  if (skip(parser, _lexer.TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(parser);\n  }\n  return {\n    kind: _kinds.INPUT_VALUE_DEFINITION,\n    name: name,\n    type: type,\n    defaultValue: defaultValue,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * InterfaceTypeDefinition : interface Name { FieldDefinition+ }\n */\nfunction parseInterfaceTypeDefinition(parser) {\n  var start = parser.token.start;\n  expectKeyword(parser, 'interface');\n  var name = parseName(parser);\n  var fields = any(parser, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INTERFACE_TYPE_DEFINITION,\n    name: name,\n    fields: fields,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * UnionTypeDefinition : union Name = UnionMembers\n */\nfunction parseUnionTypeDefinition(parser) {\n  var start = parser.token.start;\n  expectKeyword(parser, 'union');\n  var name = parseName(parser);\n  expect(parser, _lexer.TokenKind.EQUALS);\n  var types = parseUnionMembers(parser);\n  return {\n    kind: _kinds.UNION_TYPE_DEFINITION,\n    name: name,\n    types: types,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * UnionMembers :\n *   - NamedType\n *   - UnionMembers | NamedType\n */\nfunction parseUnionMembers(parser) {\n  var members = [];\n  do {\n    members.push(parseNamedType(parser));\n  } while (skip(parser, _lexer.TokenKind.PIPE));\n  return members;\n}\n\n/**\n * ScalarTypeDefinition : scalar Name\n */\nfunction parseScalarTypeDefinition(parser) {\n  var start = parser.token.start;\n  expectKeyword(parser, 'scalar');\n  var name = parseName(parser);\n  return {\n    kind: _kinds.SCALAR_TYPE_DEFINITION,\n    name: name,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * EnumTypeDefinition : enum Name { EnumValueDefinition+ }\n */\nfunction parseEnumTypeDefinition(parser) {\n  var start = parser.token.start;\n  expectKeyword(parser, 'enum');\n  var name = parseName(parser);\n  var values = many(parser, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.ENUM_TYPE_DEFINITION,\n    name: name,\n    values: values,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * EnumValueDefinition : EnumValue\n *\n * EnumValue : Name\n */\nfunction parseEnumValueDefinition(parser) {\n  var start = parser.token.start;\n  var name = parseName(parser);\n  return {\n    kind: _kinds.ENUM_VALUE_DEFINITION,\n    name: name,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * InputObjectTypeDefinition : input Name { InputValueDefinition+ }\n */\nfunction parseInputObjectTypeDefinition(parser) {\n  var start = parser.token.start;\n  expectKeyword(parser, 'input');\n  var name = parseName(parser);\n  var fields = any(parser, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,\n    name: name,\n    fields: fields,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * TypeExtensionDefinition : extend ObjectTypeDefinition\n */\nfunction parseTypeExtensionDefinition(parser) {\n  var start = parser.token.start;\n  expectKeyword(parser, 'extend');\n  var definition = parseObjectTypeDefinition(parser);\n  return {\n    kind: _kinds.TYPE_EXTENSION_DEFINITION,\n    definition: definition,\n    loc: loc(parser, start)\n  };\n}\n\n// Core parsing utility functions\n\n/**\n * Returns the parser object that is used to store state throughout the\n * process of parsing.\n */\nfunction makeParser(source, options) {\n  var _lexToken = (0, _lexer.lex)(source);\n  return {\n    _lexToken: _lexToken,\n    source: source,\n    options: options,\n    prevEnd: 0,\n    token: _lexToken()\n  };\n}\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\nfunction loc(parser, start) {\n  if (parser.options.noLocation) {\n    return null;\n  }\n  if (parser.options.noSource) {\n    return { start: start, end: parser.prevEnd };\n  }\n  return { start: start, end: parser.prevEnd, source: parser.source };\n}\n\n/**\n * Moves the internal parser object to the next lexed token.\n */\nfunction advance(parser) {\n  var prevEnd = parser.token.end;\n  parser.prevEnd = prevEnd;\n  parser.token = parser._lexToken(prevEnd);\n}\n\n/**\n * Determines if the next token is of a given kind\n */\nfunction peek(parser, kind) {\n  return parser.token.kind === kind;\n}\n\n/**\n * If the next token is of the given kind, return true after advancing\n * the parser. Otherwise, do not change the parser state and return false.\n */\nfunction skip(parser, kind) {\n  var match = parser.token.kind === kind;\n  if (match) {\n    advance(parser);\n  }\n  return match;\n}\n\n/**\n * If the next token is of the given kind, return that token after advancing\n * the parser. Otherwise, do not change the parser state and return false.\n */\nfunction expect(parser, kind) {\n  var token = parser.token;\n  if (token.kind === kind) {\n    advance(parser);\n    return token;\n  }\n  throw (0, _error.syntaxError)(parser.source, token.start, 'Expected ' + (0, _lexer.getTokenKindDesc)(kind) + ', found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the parser. Otherwise, do not change the parser state and return\n * false.\n */\nfunction expectKeyword(parser, value) {\n  var token = parser.token;\n  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n    advance(parser);\n    return token;\n  }\n  throw (0, _error.syntaxError)(parser.source, token.start, 'Expected \"' + value + '\", found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\nfunction unexpected(parser, atToken) {\n  var token = atToken || parser.token;\n  return (0, _error.syntaxError)(parser.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction any(parser, openKind, parseFn, closeKind) {\n  expect(parser, openKind);\n  var nodes = [];\n  while (!skip(parser, closeKind)) {\n    nodes.push(parseFn(parser));\n  }\n  return nodes;\n}\n\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction many(parser, openKind, parseFn, closeKind) {\n  expect(parser, openKind);\n  var nodes = [parseFn(parser)];\n  while (!skip(parser, closeKind)) {\n    nodes.push(parseFn(parser));\n  }\n  return nodes;\n}\n\n/**\n * By default, the parser creates AST nodes that know the location\n * in the source that they correspond to. This configuration flag\n * disables that behavior for performance or testing.\n */\n\n/**\n * By default, the parser creates AST nodes that contain a reference\n * to the source that they were created from. This configuration flag\n * disables that behavior for performance or testing.\n */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/language/parser.js\n ** module id = 355\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _GraphQLError = require('./GraphQLError');\n\nObject.defineProperty(exports, 'GraphQLError', {\n  enumerable: true,\n  get: function get() {\n    return _GraphQLError.GraphQLError;\n  }\n});\n\nvar _syntaxError = require('./syntaxError');\n\nObject.defineProperty(exports, 'syntaxError', {\n  enumerable: true,\n  get: function get() {\n    return _syntaxError.syntaxError;\n  }\n});\n\nvar _locatedError = require('./locatedError');\n\nObject.defineProperty(exports, 'locatedError', {\n  enumerable: true,\n  get: function get() {\n    return _locatedError.locatedError;\n  }\n});\n\nvar _formatError = require('./formatError');\n\nObject.defineProperty(exports, 'formatError', {\n  enumerable: true,\n  get: function get() {\n    return _formatError.formatError;\n  }\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/error/index.js\n ** module id = 356\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _language = require('../language');\n\nvar GraphQLError = (function (_Error) {\n  _inherits(GraphQLError, _Error);\n\n  function GraphQLError(message,\n  // A flow bug keeps us from declaring nodes as an array of Node\n  nodes, /* Node */stack, source, positions) {\n    _classCallCheck(this, GraphQLError);\n\n    _get(Object.getPrototypeOf(GraphQLError.prototype), 'constructor', this).call(this, message);\n    this.message = message;\n\n    Object.defineProperty(this, 'stack', { value: stack || message });\n    Object.defineProperty(this, 'nodes', { value: nodes });\n\n    // Note: flow does not yet know about Object.defineProperty with `get`.\n    Object.defineProperty(this, 'source', {\n      get: function get() {\n        if (source) {\n          return source;\n        }\n        if (nodes && nodes.length > 0) {\n          var node = nodes[0];\n          return node && node.loc && node.loc.source;\n        }\n      }\n    });\n\n    Object.defineProperty(this, 'positions', {\n      get: function get() {\n        if (positions) {\n          return positions;\n        }\n        if (nodes) {\n          var nodePositions = nodes.map(function (node) {\n            return node.loc && node.loc.start;\n          });\n          if (nodePositions.some(function (p) {\n            return p;\n          })) {\n            return nodePositions;\n          }\n        }\n      }\n    });\n\n    Object.defineProperty(this, 'locations', {\n      get: function get() {\n        var _this = this;\n\n        if (this.positions && this.source) {\n          return this.positions.map(function (pos) {\n            return (0, _language.getLocation)(_this.source, pos);\n          });\n        }\n      }\n    });\n  }\n\n  return GraphQLError;\n})(Error);\n\nexports.GraphQLError = GraphQLError;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/error/GraphQLError.js\n ** module id = 357\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _kinds = require('./kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _location = require('./location');\n\nObject.defineProperty(exports, 'getLocation', {\n  enumerable: true,\n  get: function get() {\n    return _location.getLocation;\n  }\n});\nexports.Kind = Kind;\n\nvar _lexer = require('./lexer');\n\nObject.defineProperty(exports, 'lex', {\n  enumerable: true,\n  get: function get() {\n    return _lexer.lex;\n  }\n});\n\nvar _parser = require('./parser');\n\nObject.defineProperty(exports, 'parse', {\n  enumerable: true,\n  get: function get() {\n    return _parser.parse;\n  }\n});\nObject.defineProperty(exports, 'parseValue', {\n  enumerable: true,\n  get: function get() {\n    return _parser.parseValue;\n  }\n});\n\nvar _printer = require('./printer');\n\nObject.defineProperty(exports, 'print', {\n  enumerable: true,\n  get: function get() {\n    return _printer.print;\n  }\n});\n\nvar _source = require('./source');\n\nObject.defineProperty(exports, 'Source', {\n  enumerable: true,\n  get: function get() {\n    return _source.Source;\n  }\n});\n\nvar _visitor = require('./visitor');\n\nObject.defineProperty(exports, 'visit', {\n  enumerable: true,\n  get: function get() {\n    return _visitor.visit;\n  }\n});\nObject.defineProperty(exports, 'BREAK', {\n  enumerable: true,\n  get: function get() {\n    return _visitor.BREAK;\n  }\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/language/index.js\n ** module id = 358\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n// Name\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar NAME = 'Name';\n\nexports.NAME = NAME;\n// Document\n\nvar DOCUMENT = 'Document';\nexports.DOCUMENT = DOCUMENT;\nvar OPERATION_DEFINITION = 'OperationDefinition';\nexports.OPERATION_DEFINITION = OPERATION_DEFINITION;\nvar VARIABLE_DEFINITION = 'VariableDefinition';\nexports.VARIABLE_DEFINITION = VARIABLE_DEFINITION;\nvar VARIABLE = 'Variable';\nexports.VARIABLE = VARIABLE;\nvar SELECTION_SET = 'SelectionSet';\nexports.SELECTION_SET = SELECTION_SET;\nvar FIELD = 'Field';\nexports.FIELD = FIELD;\nvar ARGUMENT = 'Argument';\n\nexports.ARGUMENT = ARGUMENT;\n// Fragments\n\nvar FRAGMENT_SPREAD = 'FragmentSpread';\nexports.FRAGMENT_SPREAD = FRAGMENT_SPREAD;\nvar INLINE_FRAGMENT = 'InlineFragment';\nexports.INLINE_FRAGMENT = INLINE_FRAGMENT;\nvar FRAGMENT_DEFINITION = 'FragmentDefinition';\n\nexports.FRAGMENT_DEFINITION = FRAGMENT_DEFINITION;\n// Values\n\nvar INT = 'IntValue';\nexports.INT = INT;\nvar FLOAT = 'FloatValue';\nexports.FLOAT = FLOAT;\nvar STRING = 'StringValue';\nexports.STRING = STRING;\nvar BOOLEAN = 'BooleanValue';\nexports.BOOLEAN = BOOLEAN;\nvar ENUM = 'EnumValue';\nexports.ENUM = ENUM;\nvar LIST = 'ListValue';\nexports.LIST = LIST;\nvar OBJECT = 'ObjectValue';\nexports.OBJECT = OBJECT;\nvar OBJECT_FIELD = 'ObjectField';\n\nexports.OBJECT_FIELD = OBJECT_FIELD;\n// Directives\n\nvar DIRECTIVE = 'Directive';\n\nexports.DIRECTIVE = DIRECTIVE;\n// Types\n\nvar NAMED_TYPE = 'NamedType';\nexports.NAMED_TYPE = NAMED_TYPE;\nvar LIST_TYPE = 'ListType';\nexports.LIST_TYPE = LIST_TYPE;\nvar NON_NULL_TYPE = 'NonNullType';\n\nexports.NON_NULL_TYPE = NON_NULL_TYPE;\n// Type Definitions\n\nvar OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition';\nexports.OBJECT_TYPE_DEFINITION = OBJECT_TYPE_DEFINITION;\nvar FIELD_DEFINITION = 'FieldDefinition';\nexports.FIELD_DEFINITION = FIELD_DEFINITION;\nvar INPUT_VALUE_DEFINITION = 'InputValueDefinition';\nexports.INPUT_VALUE_DEFINITION = INPUT_VALUE_DEFINITION;\nvar INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition';\nexports.INTERFACE_TYPE_DEFINITION = INTERFACE_TYPE_DEFINITION;\nvar UNION_TYPE_DEFINITION = 'UnionTypeDefinition';\nexports.UNION_TYPE_DEFINITION = UNION_TYPE_DEFINITION;\nvar SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition';\nexports.SCALAR_TYPE_DEFINITION = SCALAR_TYPE_DEFINITION;\nvar ENUM_TYPE_DEFINITION = 'EnumTypeDefinition';\nexports.ENUM_TYPE_DEFINITION = ENUM_TYPE_DEFINITION;\nvar ENUM_VALUE_DEFINITION = 'EnumValueDefinition';\nexports.ENUM_VALUE_DEFINITION = ENUM_VALUE_DEFINITION;\nvar INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition';\nexports.INPUT_OBJECT_TYPE_DEFINITION = INPUT_OBJECT_TYPE_DEFINITION;\nvar TYPE_EXTENSION_DEFINITION = 'TypeExtensionDefinition';\nexports.TYPE_EXTENSION_DEFINITION = TYPE_EXTENSION_DEFINITION;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/language/kinds.js\n ** module id = 359\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Represents a location in a Source.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getLocation = getLocation;\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\n\nfunction getLocation(source, position) {\n  var line = 1;\n  var column = position + 1;\n  var lineRegexp = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n  var match;\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n  return { line: line, column: column };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/language/location.js\n ** module id = 360\n ** module chunks = 1\n **/","/*  /\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\n/**\n * A representation of a lexed Token. Value is optional, is it is\n * not needed for punctuators like BANG or PAREN_L.\n */\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.lex = lex;\nexports.getTokenDesc = getTokenDesc;\nexports.getTokenKindDesc = getTokenKindDesc;\n\nvar _error = require('../error');\n\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a function that acts like a generator in that every time\n * it is called, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return EOF tokens whenever\n * called.\n *\n * The argument to the lexer function is optional, and can be used to\n * rewind or fast forward the lexer to a new position in the source.\n */\n\nfunction lex(source) {\n  var prevPosition = 0;\n  return function nextToken(resetPosition) {\n    var token = readToken(source, resetPosition === undefined ? prevPosition : resetPosition);\n    prevPosition = token.end;\n    return token;\n  };\n}\n\n/**\n * An enum describing the different kinds of tokens that the lexer emits.\n */\nvar TokenKind = {\n  EOF: 1,\n  BANG: 2,\n  DOLLAR: 3,\n  PAREN_L: 4,\n  PAREN_R: 5,\n  SPREAD: 6,\n  COLON: 7,\n  EQUALS: 8,\n  AT: 9,\n  BRACKET_L: 10,\n  BRACKET_R: 11,\n  BRACE_L: 12,\n  PIPE: 13,\n  BRACE_R: 14,\n  NAME: 15,\n  VARIABLE: 16,\n  INT: 17,\n  FLOAT: 18,\n  STRING: 19\n};\n\nexports.TokenKind = TokenKind;\n/**\n * A helper function to describe a token as a string for debugging\n */\n\nfunction getTokenDesc(token) {\n  return token.value ? getTokenKindDesc(token.kind) + ' \"' + token.value + '\"' : getTokenKindDesc(token.kind);\n}\n\n/**\n * A helper function to describe a token kind as a string for debugging\n */\n\nfunction getTokenKindDesc(kind) {\n  return tokenDescription[kind];\n}\n\nvar tokenDescription = {};\ntokenDescription[TokenKind.EOF] = 'EOF';\ntokenDescription[TokenKind.BANG] = '!';\ntokenDescription[TokenKind.DOLLAR] = '$';\ntokenDescription[TokenKind.PAREN_L] = '(';\ntokenDescription[TokenKind.PAREN_R] = ')';\ntokenDescription[TokenKind.SPREAD] = '...';\ntokenDescription[TokenKind.COLON] = ':';\ntokenDescription[TokenKind.EQUALS] = '=';\ntokenDescription[TokenKind.AT] = '@';\ntokenDescription[TokenKind.BRACKET_L] = '[';\ntokenDescription[TokenKind.BRACKET_R] = ']';\ntokenDescription[TokenKind.BRACE_L] = '{';\ntokenDescription[TokenKind.PIPE] = '|';\ntokenDescription[TokenKind.BRACE_R] = '}';\ntokenDescription[TokenKind.NAME] = 'Name';\ntokenDescription[TokenKind.VARIABLE] = 'Variable';\ntokenDescription[TokenKind.INT] = 'Int';\ntokenDescription[TokenKind.FLOAT] = 'Float';\ntokenDescription[TokenKind.STRING] = 'String';\n\nvar charCodeAt = String.prototype.charCodeAt;\nvar slice = String.prototype.slice;\n\n/**\n * Helper function for constructing the Token object.\n */\nfunction makeToken(kind, start, end, value) {\n  return { kind: kind, start: start, end: end, value: value };\n}\n\nfunction printCharCode(code) {\n  return(\n    // NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? '<EOF>' :\n    // Trust JSON for ASCII.\n    code < 0x007F ? JSON.stringify(String.fromCharCode(code)) :\n    // Otherwise print the escaped form.\n    '\"\\\\u' + ('00' + code.toString(16).toUpperCase()).slice(-4) + '\"'\n  );\n}\n\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace and comments until it finds the next lexable\n * token, then lexes punctuators immediately or calls the appropriate helper\n * function for more complicated tokens.\n */\nfunction readToken(source, fromPosition) {\n  var body = source.body;\n  var bodyLength = body.length;\n\n  var position = positionAfterWhitespace(body, fromPosition);\n\n  if (position >= bodyLength) {\n    return makeToken(TokenKind.EOF, position, position);\n  }\n\n  var code = charCodeAt.call(body, position);\n\n  // SourceCharacter\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000A && code !== 0x000D) {\n    throw (0, _error.syntaxError)(source, position, 'Invalid character ' + printCharCode(code) + '.');\n  }\n\n  switch (code) {\n    // !\n    case 33:\n      return makeToken(TokenKind.BANG, position, position + 1);\n    // $\n    case 36:\n      return makeToken(TokenKind.DOLLAR, position, position + 1);\n    // (\n    case 40:\n      return makeToken(TokenKind.PAREN_L, position, position + 1);\n    // )\n    case 41:\n      return makeToken(TokenKind.PAREN_R, position, position + 1);\n    // .\n    case 46:\n      if (charCodeAt.call(body, position + 1) === 46 && charCodeAt.call(body, position + 2) === 46) {\n        return makeToken(TokenKind.SPREAD, position, position + 3);\n      }\n      break;\n    // :\n    case 58:\n      return makeToken(TokenKind.COLON, position, position + 1);\n    // =\n    case 61:\n      return makeToken(TokenKind.EQUALS, position, position + 1);\n    // @\n    case 64:\n      return makeToken(TokenKind.AT, position, position + 1);\n    // [\n    case 91:\n      return makeToken(TokenKind.BRACKET_L, position, position + 1);\n    // ]\n    case 93:\n      return makeToken(TokenKind.BRACKET_R, position, position + 1);\n    // {\n    case 123:\n      return makeToken(TokenKind.BRACE_L, position, position + 1);\n    // |\n    case 124:\n      return makeToken(TokenKind.PIPE, position, position + 1);\n    // }\n    case 125:\n      return makeToken(TokenKind.BRACE_R, position, position + 1);\n    // A-Z\n    case 65:case 66:case 67:case 68:case 69:case 70:case 71:case 72:\n    case 73:case 74:case 75:case 76:case 77:case 78:case 79:case 80:\n    case 81:case 82:case 83:case 84:case 85:case 86:case 87:case 88:\n    case 89:case 90:\n    // _\n    case 95:\n    // a-z\n    case 97:case 98:case 99:case 100:case 101:case 102:case 103:case 104:\n    case 105:case 106:case 107:case 108:case 109:case 110:case 111:\n    case 112:case 113:case 114:case 115:case 116:case 117:case 118:\n    case 119:case 120:case 121:case 122:\n      return readName(source, position);\n    // -\n    case 45:\n    // 0-9\n    case 48:case 49:case 50:case 51:case 52:\n    case 53:case 54:case 55:case 56:case 57:\n      return readNumber(source, position, code);\n    // \"\n    case 34:\n      return readString(source, position);\n  }\n\n  throw (0, _error.syntaxError)(source, position, 'Unexpected character ' + printCharCode(code) + '.');\n}\n\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * or commented character, then returns the position of that character for\n * lexing.\n */\nfunction positionAfterWhitespace(body, startPosition) {\n  var bodyLength = body.length;\n  var position = startPosition;\n  while (position < bodyLength) {\n    var code = charCodeAt.call(body, position);\n    // Skip Ignored\n    if (\n    // BOM\n    code === 0xFEFF ||\n    // White Space\n    code === 0x0009 || // tab\n    code === 0x0020 || // space\n    // Line Terminator\n    code === 0x000A || // new line\n    code === 0x000D || // carriage return\n    // Comma\n    code === 0x002C) {\n      ++position;\n      // Skip comments\n    } else if (code === 35) {\n        // #\n        ++position;\n        while (position < bodyLength && (code = charCodeAt.call(body, position)) !== null && (\n        // SourceCharacter but not LineTerminator\n        code > 0x001F || code === 0x0009) && code !== 0x000A && code !== 0x000D) {\n          ++position;\n        }\n      } else {\n        break;\n      }\n  }\n  return position;\n}\n\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\nfunction readNumber(source, start, firstCode) {\n  var code = firstCode;\n  var body = source.body;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = charCodeAt.call(body, ++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = charCodeAt.call(body, ++position);\n    if (code >= 48 && code <= 57) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid number, unexpected digit after 0: ' + printCharCode(code) + '.');\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    if (code === 43 || code === 45) {\n      // + -\n      code = charCodeAt.call(body, ++position);\n    }\n    position = readDigits(source, position, code);\n  }\n\n  return makeToken(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, slice.call(body, start, position));\n}\n\n/**\n * Returns the new position in the source after reading digits.\n */\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = charCodeAt.call(body, ++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n    return position;\n  }\n  throw (0, _error.syntaxError)(source, position, 'Invalid number, expected digit but got: ' + printCharCode(code) + '.');\n}\n\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D\\u2028\\u2029]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\nfunction readString(source, start) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && (code = charCodeAt.call(body, position)) !== null &&\n  // not LineTerminator\n  code !== 0x000A && code !== 0x000D &&\n  // not Quote (\")\n  code !== 34) {\n    // SourceCharacter\n    if (code < 0x0020 && code !== 0x0009) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');\n    }\n\n    ++position;\n    if (code === 92) {\n      // \\\n      value += slice.call(body, chunkStart, position - 1);\n      code = charCodeAt.call(body, position);\n      switch (code) {\n        case 34:\n          value += '\"';break;\n        case 47:\n          value += '\\/';break;\n        case 92:\n          value += '\\\\';break;\n        case 98:\n          value += '\\b';break;\n        case 102:\n          value += '\\f';break;\n        case 110:\n          value += '\\n';break;\n        case 114:\n          value += '\\r';break;\n        case 116:\n          value += '\\t';break;\n        case 117:\n          // u\n          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));\n          if (charCode < 0) {\n            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + ('\\\\u' + body.slice(position + 1, position + 5) + '.'));\n          }\n          value += String.fromCharCode(charCode);\n          position += 4;\n          break;\n        default:\n          throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: \\\\' + String.fromCharCode(code) + '.');\n      }\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  if (code !== 34) {\n    // quote (\")\n    throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n  }\n\n  value += slice.call(body, chunkStart, position);\n  return makeToken(TokenKind.STRING, start, position + 1, value);\n}\n\n/**\n * Converts four hexidecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 : // 0-9\n  a >= 65 && a <= 70 ? a - 55 : // A-F\n  a >= 97 && a <= 102 ? a - 87 : // a-f\n  -1;\n}\n\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\nfunction readName(source, position) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var end = position + 1;\n  var code = 0;\n  while (end !== bodyLength && (code = charCodeAt.call(body, end)) !== null && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++end;\n  }\n  return makeToken(TokenKind.NAME, position, end, slice.call(body, position, end));\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/language/lexer.js\n ** module id = 361\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.print = print;\n\nvar _visitor = require('./visitor');\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nfunction print(ast) {\n  return (0, _visitor.visit)(ast, { leave: printDocASTReducer });\n}\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n\n  // Document\n\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var defs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet;\n    return !name ? selectionSet : join([op, join([name, defs]), directives, selectionSet], ' ');\n  },\n\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable;\n    var type = _ref.type;\n    var defaultValue = _ref.defaultValue;\n    return variable + ': ' + type + wrap(' = ', defaultValue);\n  },\n\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias;\n    var name = _ref3.name;\n    var args = _ref3.arguments;\n    var directives = _ref3.directives;\n    var selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name;\n    var value = _ref4.value;\n    return name + ': ' + value;\n  },\n\n  // Fragments\n\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name;\n    var directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition;\n    var directives = _ref6.directives;\n    var selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name;\n    var typeCondition = _ref7.typeCondition;\n    var directives = _ref7.directives;\n    var selectionSet = _ref7.selectionSet;\n    return 'fragment ' + name + ' on ' + typeCondition + ' ' + wrap('', join(directives, ' '), ' ') + selectionSet;\n  },\n\n  // Value\n\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10) {\n    var value = _ref10.value;\n    return JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return JSON.stringify(value);\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name;\n    var value = _ref15.value;\n    return name + ': ' + value;\n  },\n\n  // Directive\n\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name;\n    var args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n\n  // Type\n\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n\n  // Type Definitions\n\n  ObjectTypeDefinition: function ObjectTypeDefinition(_ref20) {\n    var name = _ref20.name;\n    var interfaces = _ref20.interfaces;\n    var fields = _ref20.fields;\n    return 'type ' + name + ' ' + wrap('implements ', join(interfaces, ', '), ' ') + block(fields);\n  },\n\n  FieldDefinition: function FieldDefinition(_ref21) {\n    var name = _ref21.name;\n    var args = _ref21.arguments;\n    var type = _ref21.type;\n    return name + wrap('(', join(args, ', '), ')') + ': ' + type;\n  },\n\n  InputValueDefinition: function InputValueDefinition(_ref22) {\n    var name = _ref22.name;\n    var type = _ref22.type;\n    var defaultValue = _ref22.defaultValue;\n    return name + ': ' + type + wrap(' = ', defaultValue);\n  },\n\n  InterfaceTypeDefinition: function InterfaceTypeDefinition(_ref23) {\n    var name = _ref23.name;\n    var fields = _ref23.fields;\n    return 'interface ' + name + ' ' + block(fields);\n  },\n\n  UnionTypeDefinition: function UnionTypeDefinition(_ref24) {\n    var name = _ref24.name;\n    var types = _ref24.types;\n    return 'union ' + name + ' = ' + join(types, ' | ');\n  },\n\n  ScalarTypeDefinition: function ScalarTypeDefinition(_ref25) {\n    var name = _ref25.name;\n    return 'scalar ' + name;\n  },\n\n  EnumTypeDefinition: function EnumTypeDefinition(_ref26) {\n    var name = _ref26.name;\n    var values = _ref26.values;\n    return 'enum ' + name + ' ' + block(values);\n  },\n\n  EnumValueDefinition: function EnumValueDefinition(_ref27) {\n    var name = _ref27.name;\n    return name;\n  },\n\n  InputObjectTypeDefinition: function InputObjectTypeDefinition(_ref28) {\n    var name = _ref28.name;\n    var fields = _ref28.fields;\n    return 'input ' + name + ' ' + block(fields);\n  },\n\n  TypeExtensionDefinition: function TypeExtensionDefinition(_ref29) {\n    var definition = _ref29.definition;\n    return 'extend ' + definition;\n  }\n};\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print each item on its own line, wrapped in an indented \"{ }\" block.\n */\nfunction block(maybeArray) {\n  return length(maybeArray) ? indent('{\\n' + join(maybeArray, '\\n')) + '\\n}' : '';\n}\n\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && maybeString.replace(/\\n/g, '\\n  ');\n}\n\nfunction length(maybeArray) {\n  return maybeArray ? maybeArray.length : 0;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/language/printer.js\n ** module id = 362\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nexports.visit = visit;\nexports.visitInParallel = visitInParallel;\nexports.visitWithTypeInfo = visitWithTypeInfo;\nvar QueryDocumentKeys = {\n  Name: [],\n\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', 'typeCondition', 'directives', 'selectionSet'],\n\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n\n  Directive: ['name', 'arguments'],\n\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n\n  ObjectTypeDefinition: ['name', 'interfaces', 'fields'],\n  FieldDefinition: ['name', 'arguments', 'type'],\n  InputValueDefinition: ['name', 'type', 'defaultValue'],\n  InterfaceTypeDefinition: ['name', 'fields'],\n  UnionTypeDefinition: ['name', 'types'],\n  ScalarTypeDefinition: ['name'],\n  EnumTypeDefinition: ['name', 'values'],\n  EnumValueDefinition: ['name'],\n  InputObjectTypeDefinition: ['name', 'fields'],\n  TypeExtensionDefinition: ['definition']\n};\n\nexports.QueryDocumentKeys = QueryDocumentKeys;\nvar BREAK = {};\n\nexports.BREAK = BREAK;\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     var editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nfunction visit(root, visitor, keyMap) {\n  var visitorKeys = keyMap || QueryDocumentKeys;\n\n  var stack;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var parent;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var key;\n    var node;\n    var isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n          for (var k in node) {\n            if (node.hasOwnProperty(k)) {\n              clone[k] = node[k];\n            }\n          }\n          node = clone;\n        }\n        var editOffset = 0;\n        for (var ii = 0; ii < edits.length; ii++) {\n          var _edits$ii = _slicedToArray(edits[ii], 2);\n\n          var editKey = _edits$ii[0];\n          var editValue = _edits$ii[1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n      if (node === null || node === undefined) {\n        continue;\n      }\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = undefined;\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + JSON.stringify(node));\n      }\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (!isLeaving) {\n      stack = { inArray: inArray, index: index, keys: keys, edits: edits, prev: stack };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[0][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return maybeNode && typeof maybeNode.kind === 'string';\n}\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * Visitors must not directly modify the AST nodes and only returning false to\n * skip sub-branches is supported.\n */\n\nfunction visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */false);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === false) {\n              skipping[i] = node;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */true);\n          if (fn) {\n            fn.apply(visitors[i], arguments);\n          }\n        } else {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n *\n * Visitors must not directly modify the AST nodes and only returning false to\n * skip sub-branches is supported.\n */\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */false);\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n        if (result === false) {\n          typeInfo.leave(node);\n          return false;\n        }\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */true);\n      if (fn) {\n        fn.apply(visitor, arguments);\n      }\n      typeInfo.leave(node);\n    }\n  };\n}\n\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\nfunction getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      var specificKindVisitor = specificVisitor[kind];\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/language/visitor.js\n ** module id = 363\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.syntaxError = syntaxError;\n\nvar _languageLocation = require('../language/location');\n\nvar _GraphQLError = require('./GraphQLError');\n\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nfunction syntaxError(source, position, description) {\n  var location = (0, _languageLocation.getLocation)(source, position);\n  var error = new _GraphQLError.GraphQLError('Syntax Error ' + source.name + ' (' + location.line + ':' + location.column + ') ' + description + '\\n\\n' + highlightSourceAtLocation(source, location), undefined, undefined, source, [position]);\n  return error;\n}\n\n/**\n * Render a helpful description of the location of the error in the GraphQL\n * Source document.\n */\nfunction highlightSourceAtLocation(source, location) {\n  var line = location.line;\n  var prevLineNum = (line - 1).toString();\n  var lineNum = line.toString();\n  var nextLineNum = (line + 1).toString();\n  var padLen = nextLineNum.length;\n  var lines = source.body.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/g);\n  return (line >= 2 ? lpad(padLen, prevLineNum) + ': ' + lines[line - 2] + '\\n' : '') + lpad(padLen, lineNum) + ': ' + lines[line - 1] + '\\n' + Array(2 + padLen + location.column).join(' ') + '^\\n' + (line < lines.length ? lpad(padLen, nextLineNum) + ': ' + lines[line] + '\\n' : '');\n}\n\nfunction lpad(len, str) {\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/error/syntaxError.js\n ** module id = 364\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.locatedError = locatedError;\n\nvar _GraphQLError = require('./GraphQLError');\n\n/**\n * Given an arbitrary Error, presumably thrown while attempting to execute a\n * GraphQL operation, produce a new GraphQLError aware of the location in the\n * document responsible for the original Error.\n */\n\nfunction locatedError(error, nodes) {\n  var message = error ? error.message || String(error) : 'An unknown error occurred.';\n  var stack = error ? error.stack : null;\n  return new _GraphQLError.GraphQLError(message, nodes, stack);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/error/locatedError.js\n ** module id = 365\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.formatError = formatError;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nfunction formatError(error) {\n  (0, _jsutilsInvariant2['default'])(error, 'Received null or undefined error.');\n  return {\n    message: error.message,\n    locations: error.locations\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/error/formatError.js\n ** module id = 366\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = invariant;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nmodule.exports = exports[\"default\"];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/jsutils/invariant.js\n ** module id = 367\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.validate = validate;\nexports.visitUsingRules = visitUsingRules;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _error = require('../error');\n\nvar _languageVisitor = require('../language/visitor');\n\nvar _languageKinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_languageKinds);\n\nvar _typeSchema = require('../type/schema');\n\nvar _utilitiesTypeInfo = require('../utilities/TypeInfo');\n\nvar _specifiedRules = require('./specifiedRules');\n\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n */\n\nfunction validate(schema, ast, rules) {\n  (0, _jsutilsInvariant2['default'])(schema, 'Must provide schema');\n  (0, _jsutilsInvariant2['default'])(ast, 'Must provide document');\n  (0, _jsutilsInvariant2['default'])(schema instanceof _typeSchema.GraphQLSchema, 'Schema must be an instance of GraphQLSchema. Also ensure that there are ' + 'not multiple versions of GraphQL installed in your node_modules directory.');\n  var typeInfo = new _utilitiesTypeInfo.TypeInfo(schema);\n  return visitUsingRules(schema, typeInfo, ast, rules || _specifiedRules.specifiedRules);\n}\n\n/**\n * This uses a specialized visitor which runs multiple visitors in parallel,\n * while maintaining the visitor skip and break API.\n *\n * @internal\n */\n\nfunction visitUsingRules(schema, typeInfo, documentAST, rules) {\n  var context = new ValidationContext(schema, documentAST, typeInfo);\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  // Visit the whole document with each instance of all provided rules.\n  (0, _languageVisitor.visit)(documentAST, (0, _languageVisitor.visitWithTypeInfo)(typeInfo, (0, _languageVisitor.visitInParallel)(visitors)));\n  return context.getErrors();\n}\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\n\nvar ValidationContext = (function () {\n  function ValidationContext(schema, ast, typeInfo) {\n    _classCallCheck(this, ValidationContext);\n\n    this._schema = schema;\n    this._ast = ast;\n    this._typeInfo = typeInfo;\n    this._errors = [];\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  _createClass(ValidationContext, [{\n    key: 'reportError',\n    value: function reportError(error) {\n      this._errors.push(error);\n    }\n  }, {\n    key: 'getErrors',\n    value: function getErrors() {\n      return this._errors;\n    }\n  }, {\n    key: 'getSchema',\n    value: function getSchema() {\n      return this._schema;\n    }\n  }, {\n    key: 'getDocument',\n    value: function getDocument() {\n      return this._ast;\n    }\n  }, {\n    key: 'getFragment',\n    value: function getFragment(name) {\n      var fragments = this._fragments;\n      if (!fragments) {\n        this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n          if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n            frags[statement.name.value] = statement;\n          }\n          return frags;\n        }, {});\n      }\n      return fragments[name];\n    }\n  }, {\n    key: 'getFragmentSpreads',\n    value: function getFragmentSpreads(node) {\n      var spreads = this._fragmentSpreads.get(node);\n      if (!spreads) {\n        spreads = [];\n        var setsToVisit = [node.selectionSet];\n        while (setsToVisit.length !== 0) {\n          var set = setsToVisit.pop();\n          for (var i = 0; i < set.selections.length; i++) {\n            var selection = set.selections[i];\n            if (selection.kind === Kind.FRAGMENT_SPREAD) {\n              spreads.push(selection);\n            } else if (selection.selectionSet) {\n              setsToVisit.push(selection.selectionSet);\n            }\n          }\n        }\n        this._fragmentSpreads.set(node, spreads);\n      }\n      return spreads;\n    }\n  }, {\n    key: 'getRecursivelyReferencedFragments',\n    value: function getRecursivelyReferencedFragments(operation) {\n      var fragments = this._recursivelyReferencedFragments.get(operation);\n      if (!fragments) {\n        fragments = [];\n        var collectedNames = Object.create(null);\n        var nodesToVisit = [operation];\n        while (nodesToVisit.length !== 0) {\n          var _node = nodesToVisit.pop();\n          var spreads = this.getFragmentSpreads(_node);\n          for (var i = 0; i < spreads.length; i++) {\n            var fragName = spreads[i].name.value;\n            if (collectedNames[fragName] !== true) {\n              collectedNames[fragName] = true;\n              var fragment = this.getFragment(fragName);\n              if (fragment) {\n                fragments.push(fragment);\n                nodesToVisit.push(fragment);\n              }\n            }\n          }\n        }\n        this._recursivelyReferencedFragments.set(operation, fragments);\n      }\n      return fragments;\n    }\n  }, {\n    key: 'getVariableUsages',\n    value: function getVariableUsages(node) {\n      var _this = this;\n\n      var usages = this._variableUsages.get(node);\n      if (!usages) {\n        (function () {\n          usages = [];\n          var typeInfo = new _utilitiesTypeInfo.TypeInfo(_this._schema);\n          (0, _languageVisitor.visit)(node, (0, _languageVisitor.visitWithTypeInfo)(typeInfo, {\n            VariableDefinition: function VariableDefinition() {\n              return false;\n            },\n            Variable: function Variable(variable) {\n              usages.push({ node: variable, type: typeInfo.getInputType() });\n            }\n          }));\n          _this._variableUsages.set(node, usages);\n        })();\n      }\n      return usages;\n    }\n  }, {\n    key: 'getRecursiveVariableUsages',\n    value: function getRecursiveVariableUsages(operation) {\n      var usages = this._recursiveVariableUsages.get(operation);\n      if (!usages) {\n        usages = this.getVariableUsages(operation);\n        var fragments = this.getRecursivelyReferencedFragments(operation);\n        for (var i = 0; i < fragments.length; i++) {\n          Array.prototype.push.apply(usages, this.getVariableUsages(fragments[i]));\n        }\n        this._recursiveVariableUsages.set(operation, usages);\n      }\n      return usages;\n    }\n  }, {\n    key: 'getType',\n    value: function getType() {\n      return this._typeInfo.getType();\n    }\n  }, {\n    key: 'getParentType',\n    value: function getParentType() {\n      return this._typeInfo.getParentType();\n    }\n  }, {\n    key: 'getInputType',\n    value: function getInputType() {\n      return this._typeInfo.getInputType();\n    }\n  }, {\n    key: 'getFieldDef',\n    value: function getFieldDef() {\n      return this._typeInfo.getFieldDef();\n    }\n  }, {\n    key: 'getDirective',\n    value: function getDirective() {\n      return this._typeInfo.getDirective();\n    }\n  }, {\n    key: 'getArgument',\n    value: function getArgument() {\n      return this._typeInfo.getArgument();\n    }\n  }]);\n\n  return ValidationContext;\n})();\n\nexports.ValidationContext = ValidationContext;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/validate.js\n ** module id = 368\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _definition = require('./definition');\n\nvar _directives = require('./directives');\n\nvar _introspection = require('./introspection');\n\nvar _jsutilsFind = require('../jsutils/find');\n\nvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _utilitiesTypeComparators = require('../utilities/typeComparators');\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     var MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType\n *       mutation: MyAppMutationRootType\n *     });\n *\n */\n\nvar GraphQLSchema = (function () {\n  function GraphQLSchema(config) {\n    var _this = this;\n\n    _classCallCheck(this, GraphQLSchema);\n\n    (0, _jsutilsInvariant2['default'])(typeof config === 'object', 'Must provide configuration object.');\n\n    (0, _jsutilsInvariant2['default'])(config.query instanceof _definition.GraphQLObjectType, 'Schema query must be Object Type but got: ' + config.query + '.');\n    this._queryType = config.query;\n\n    (0, _jsutilsInvariant2['default'])(!config.mutation || config.mutation instanceof _definition.GraphQLObjectType, 'Schema mutation must be Object Type if provided but ' + ('got: ' + config.mutation + '.'));\n    this._mutationType = config.mutation;\n\n    (0, _jsutilsInvariant2['default'])(!config.subscription || config.subscription instanceof _definition.GraphQLObjectType, 'Schema subscription must be Object Type if provided but ' + ('got: ' + config.subscription + '.'));\n    this._subscriptionType = config.subscription;\n\n    (0, _jsutilsInvariant2['default'])(!config.directives || Array.isArray(config.directives) && config.directives.every(function (directive) {\n      return directive instanceof _directives.GraphQLDirective;\n    }), 'Schema directives must be Array<GraphQLDirective> if provided but ' + ('got: ' + config.directives + '.'));\n    // Provide `@include() and `@skip()` directives by default.\n    this._directives = config.directives || [_directives.GraphQLIncludeDirective, _directives.GraphQLSkipDirective];\n\n    // Build type map now to detect any errors within this schema.\n    this._typeMap = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), _introspection.__Schema].reduce(typeMapReducer, {});\n\n    // Enforce correct interface implementations\n    Object.keys(this._typeMap).forEach(function (typeName) {\n      var type = _this._typeMap[typeName];\n      if (type instanceof _definition.GraphQLObjectType) {\n        type.getInterfaces().forEach(function (iface) {\n          return assertObjectImplementsInterface(type, iface);\n        });\n      }\n    });\n  }\n\n  _createClass(GraphQLSchema, [{\n    key: 'getQueryType',\n    value: function getQueryType() {\n      return this._queryType;\n    }\n  }, {\n    key: 'getMutationType',\n    value: function getMutationType() {\n      return this._mutationType;\n    }\n  }, {\n    key: 'getSubscriptionType',\n    value: function getSubscriptionType() {\n      return this._subscriptionType;\n    }\n  }, {\n    key: 'getTypeMap',\n    value: function getTypeMap() {\n      return this._typeMap;\n    }\n  }, {\n    key: 'getType',\n    value: function getType(name) {\n      return this.getTypeMap()[name];\n    }\n  }, {\n    key: 'getDirectives',\n    value: function getDirectives() {\n      return this._directives;\n    }\n  }, {\n    key: 'getDirective',\n    value: function getDirective(name) {\n      return (0, _jsutilsFind2['default'])(this.getDirectives(), function (directive) {\n        return directive.name === name;\n      });\n    }\n  }]);\n\n  return GraphQLSchema;\n})();\n\nexports.GraphQLSchema = GraphQLSchema;\n\nfunction typeMapReducer(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var map = _x,\n        type = _x2;\n    reducedMap = fieldMap = undefined;\n    _again = false;\n\n    if (!type) {\n      return map;\n    }\n    if (type instanceof _definition.GraphQLList || type instanceof _definition.GraphQLNonNull) {\n      _x = map;\n      _x2 = type.ofType;\n      _again = true;\n      continue _function;\n    }\n    if (map[type.name]) {\n      (0, _jsutilsInvariant2['default'])(map[type.name] === type, 'Schema must contain unique named types but contains multiple ' + ('types named \"' + type + '\".'));\n      return map;\n    }\n    map[type.name] = type;\n\n    var reducedMap = map;\n\n    if (type instanceof _definition.GraphQLUnionType || type instanceof _definition.GraphQLInterfaceType) {\n      reducedMap = type.getPossibleTypes().reduce(typeMapReducer, reducedMap);\n    }\n\n    if (type instanceof _definition.GraphQLObjectType) {\n      reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n    }\n\n    if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType || type instanceof _definition.GraphQLInputObjectType) {\n      var fieldMap = type.getFields();\n      Object.keys(fieldMap).forEach(function (fieldName) {\n        var field = fieldMap[fieldName];\n\n        if (field.args) {\n          var fieldArgTypes = field.args.map(function (arg) {\n            return arg.type;\n          });\n          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n        }\n        reducedMap = typeMapReducer(reducedMap, field.type);\n      });\n    }\n\n    return reducedMap;\n  }\n}\n\nfunction assertObjectImplementsInterface(object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields();\n\n  // Assert each interface field is implemented.\n  Object.keys(ifaceFieldMap).forEach(function (fieldName) {\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName];\n\n    // Assert interface field exists on object.\n    (0, _jsutilsInvariant2['default'])(objectField, '\"' + iface + '\" expects field \"' + fieldName + '\" but \"' + object + '\" does not ' + 'provide it.');\n\n    // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n    (0, _jsutilsInvariant2['default'])((0, _utilitiesTypeComparators.isTypeSubTypeOf)(objectField.type, ifaceField.type), iface + '.' + fieldName + ' expects type \"' + ifaceField.type + '\" but ' + (object + '.' + fieldName + ' provides type \"' + objectField.type + '\".'));\n\n    // Assert each interface field arg is implemented.\n    ifaceField.args.forEach(function (ifaceArg) {\n      var argName = ifaceArg.name;\n      var objectArg = (0, _jsutilsFind2['default'])(objectField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      // Assert interface field arg exists on object field.\n      (0, _jsutilsInvariant2['default'])(objectArg, iface + '.' + fieldName + ' expects argument \"' + argName + '\" but ' + (object + '.' + fieldName + ' does not provide it.'));\n\n      // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      (0, _jsutilsInvariant2['default'])((0, _utilitiesTypeComparators.isEqualType)(ifaceArg.type, objectArg.type), iface + '.' + fieldName + '(' + argName + ':) expects type \"' + ifaceArg.type + '\" ' + ('but ' + object + '.' + fieldName + '(' + argName + ':) provides ') + ('type \"' + objectArg.type + '\".'));\n    });\n\n    // Assert additional arguments must not be required.\n    objectField.args.forEach(function (objectArg) {\n      var argName = objectArg.name;\n      var ifaceArg = (0, _jsutilsFind2['default'])(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n      if (!ifaceArg) {\n        (0, _jsutilsInvariant2['default'])(!(objectArg.type instanceof _definition.GraphQLNonNull), object + '.' + fieldName + '(' + argName + ':) is of required type ' + ('\"' + objectArg.type + '\" but is not also provided by the ') + ('interface ' + iface + '.' + fieldName + '.'));\n      }\n    });\n  });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/type/schema.js\n ** module id = 369\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n// Predicates\n\n/**\n * These are all of the possible kinds of types.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.isType = isType;\n\n/**\n * These types may be used as input types for arguments and directives.\n */\nexports.isInputType = isInputType;\n\n/**\n * These types may be used as output types as the result of fields.\n */\nexports.isOutputType = isOutputType;\n\n/**\n * These types may describe types which may be leaf values.\n */\nexports.isLeafType = isLeafType;\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexports.isCompositeType = isCompositeType;\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexports.isAbstractType = isAbstractType;\n\n/**\n * These types can all accept null as a value.\n */\nexports.getNullableType = getNullableType;\n\n/**\n * These named types do not include modifiers like List or NonNull.\n */\nexports.getNamedType = getNamedType;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\nvar _jsutilsKeyMap = require('../jsutils/keyMap');\n\nvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\nvar _languageKinds = require('../language/kinds');\n\nfunction isType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType || type instanceof GraphQLList || type instanceof GraphQLNonNull;\n}\n\nfunction isInputType(type) {\n  var namedType = getNamedType(type);\n  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLEnumType || namedType instanceof GraphQLInputObjectType;\n}\n\nfunction isOutputType(type) {\n  var namedType = getNamedType(type);\n  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLObjectType || namedType instanceof GraphQLInterfaceType || namedType instanceof GraphQLUnionType || namedType instanceof GraphQLEnumType;\n}\n\nfunction isLeafType(type) {\n  var namedType = getNamedType(type);\n  return namedType instanceof GraphQLScalarType || namedType instanceof GraphQLEnumType;\n}\n\nfunction isCompositeType(type) {\n  return type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;\n}\n\nfunction isAbstractType(type) {\n  return type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;\n}\n\nfunction getNullableType(type) {\n  return type instanceof GraphQLNonNull ? type.ofType : type;\n}\n\nfunction getNamedType(type) {\n  var unmodifiedType = type;\n  while (unmodifiedType instanceof GraphQLList || unmodifiedType instanceof GraphQLNonNull) {\n    unmodifiedType = unmodifiedType.ofType;\n  }\n  return unmodifiedType;\n}\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * Example:\n *\n *     var OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         return value % 2 === 1 ? value : null;\n *       }\n *     });\n *\n */\n\nvar GraphQLScalarType /* <T> */ = (function () {\n  /* <T> */\n  function GraphQLScalarType(config /* <T> */) {\n    _classCallCheck(this, GraphQLScalarType);\n\n    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    (0, _jsutilsInvariant2['default'])(typeof config.serialize === 'function', this + ' must provide \"serialize\" function. If this custom Scalar is ' + 'also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' + 'functions are also provided.');\n    if (config.parseValue || config.parseLiteral) {\n      (0, _jsutilsInvariant2['default'])(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function', this + ' must provide both \"parseValue\" and \"parseLiteral\" functions.');\n    }\n    this._scalarConfig = config;\n  }\n\n  _createClass(GraphQLScalarType, [{\n    key: 'serialize',\n    value: function serialize(value) /* T */{\n      var serializer = this._scalarConfig.serialize;\n      return serializer(value);\n    }\n  }, {\n    key: 'parseValue',\n    value: function parseValue(value) /* T */{\n      var parser = this._scalarConfig.parseValue;\n      return parser ? parser(value) : null;\n    }\n  }, {\n    key: 'parseLiteral',\n    value: function parseLiteral(valueAST) /* T */{\n      var parser = this._scalarConfig.parseLiteral;\n      return parser ? parser(valueAST) : null;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }]);\n\n  return GraphQLScalarType;\n})();\n\nexports.GraphQLScalarType = GraphQLScalarType;\n/* T */\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     var AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     var PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\n\nvar GraphQLObjectType = (function () {\n  function GraphQLObjectType(config) {\n    _classCallCheck(this, GraphQLObjectType);\n\n    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    if (config.isTypeOf) {\n      (0, _jsutilsInvariant2['default'])(typeof config.isTypeOf === 'function', this + ' must provide \"isTypeOf\" as a function.');\n    }\n    this.isTypeOf = config.isTypeOf;\n    this._typeConfig = config;\n    addImplementationToInterfaces(this);\n  }\n\n  _createClass(GraphQLObjectType, [{\n    key: 'getFields',\n    value: function getFields() {\n      return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n    }\n  }, {\n    key: 'getInterfaces',\n    value: function getInterfaces() {\n      return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }]);\n\n  return GraphQLObjectType;\n})();\n\nexports.GraphQLObjectType = GraphQLObjectType;\n\nfunction resolveMaybeThunk(thingOrThunk) {\n  return typeof thingOrThunk === 'function' ? thingOrThunk() : thingOrThunk;\n}\n\nfunction defineInterfaces(type, interfacesOrThunk) {\n  var interfaces = resolveMaybeThunk(interfacesOrThunk);\n  if (!interfaces) {\n    return [];\n  }\n  (0, _jsutilsInvariant2['default'])(Array.isArray(interfaces), type + ' interfaces must be an Array or a function which returns an Array.');\n  interfaces.forEach(function (iface) {\n    (0, _jsutilsInvariant2['default'])(iface instanceof GraphQLInterfaceType, type + ' may only implement Interface types, it cannot ' + ('implement: ' + iface + '.'));\n    if (typeof iface.resolveType !== 'function') {\n      (0, _jsutilsInvariant2['default'])(typeof type.isTypeOf === 'function', 'Interface Type ' + iface + ' does not provide a \"resolveType\" function ' + ('and implementing Type ' + type + ' does not provide a \"isTypeOf\" ') + 'function. There is no way to resolve this implementing type ' + 'during execution.');\n    }\n  });\n  return interfaces;\n}\n\nfunction defineFieldMap(type, fields) {\n  var fieldMap = resolveMaybeThunk(fields);\n  (0, _jsutilsInvariant2['default'])(isPlainObj(fieldMap), type + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');\n\n  var fieldNames = Object.keys(fieldMap);\n  (0, _jsutilsInvariant2['default'])(fieldNames.length > 0, type + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');\n\n  var resultFieldMap = {};\n  fieldNames.forEach(function (fieldName) {\n    assertValidName(fieldName);\n    var field = _extends({}, fieldMap[fieldName], {\n      name: fieldName\n    });\n    (0, _jsutilsInvariant2['default'])(!field.hasOwnProperty('isDeprecated'), type + '.' + fieldName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".');\n    (0, _jsutilsInvariant2['default'])(isOutputType(field.type), type + '.' + fieldName + ' field type must be Output Type but ' + ('got: ' + field.type + '.'));\n    if (!field.args) {\n      field.args = [];\n    } else {\n      (0, _jsutilsInvariant2['default'])(isPlainObj(field.args), type + '.' + fieldName + ' args must be an object with argument names ' + 'as keys.');\n      field.args = Object.keys(field.args).map(function (argName) {\n        assertValidName(argName);\n        var arg = field.args[argName];\n        (0, _jsutilsInvariant2['default'])(isInputType(arg.type), type + '.' + fieldName + '(' + argName + ':) argument type must be ' + ('Input Type but got: ' + arg.type + '.'));\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue === undefined ? null : arg.defaultValue\n        };\n      });\n    }\n    resultFieldMap[fieldName] = field;\n  });\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && typeof obj === 'object' && !Array.isArray(obj);\n}\n\n/**\n * Update the interfaces to know about this implementation.\n * This is an rare and unfortunate use of mutation in the type definition\n * implementations, but avoids an expensive \"getPossibleTypes\"\n * implementation for Interface types.\n */\nfunction addImplementationToInterfaces(impl) {\n  impl.getInterfaces().forEach(function (type) {\n    type._implementations.push(impl);\n  });\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     var EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\n\nvar GraphQLInterfaceType = (function () {\n  function GraphQLInterfaceType(config) {\n    _classCallCheck(this, GraphQLInterfaceType);\n\n    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    if (config.resolveType) {\n      (0, _jsutilsInvariant2['default'])(typeof config.resolveType === 'function', this + ' must provide \"resolveType\" as a function.');\n    }\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n    this._implementations = [];\n  }\n\n  _createClass(GraphQLInterfaceType, [{\n    key: 'getFields',\n    value: function getFields() {\n      return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n    }\n  }, {\n    key: 'getPossibleTypes',\n    value: function getPossibleTypes() {\n      return this._implementations;\n    }\n  }, {\n    key: 'isPossibleType',\n    value: function isPossibleType(type) {\n      var possibleTypes = this._possibleTypes || (this._possibleTypes = (0, _jsutilsKeyMap2['default'])(this.getPossibleTypes(), function (possibleType) {\n        return possibleType.name;\n      }));\n      return Boolean(possibleTypes[type.name]);\n    }\n  }, {\n    key: 'getObjectType',\n    value: function getObjectType(value, info) {\n      var resolver = this.resolveType;\n      return resolver ? resolver(value, info) : getTypeOf(value, info, this);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }]);\n\n  return GraphQLInterfaceType;\n})();\n\nexports.GraphQLInterfaceType = GraphQLInterfaceType;\n\nfunction getTypeOf(value, info, abstractType) {\n  var possibleTypes = abstractType.getPossibleTypes();\n  for (var i = 0; i < possibleTypes.length; i++) {\n    var type = possibleTypes[i];\n    if (typeof type.isTypeOf === 'function' && type.isTypeOf(value, info)) {\n      return type;\n    }\n  }\n}\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     var PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\n\nvar GraphQLUnionType = (function () {\n  function GraphQLUnionType(config) {\n    var _this = this;\n\n    _classCallCheck(this, GraphQLUnionType);\n\n    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    if (config.resolveType) {\n      (0, _jsutilsInvariant2['default'])(typeof config.resolveType === 'function', this + ' must provide \"resolveType\" as a function.');\n    }\n    this.resolveType = config.resolveType;\n    (0, _jsutilsInvariant2['default'])(Array.isArray(config.types) && config.types.length > 0, 'Must provide Array of types for Union ' + config.name + '.');\n    config.types.forEach(function (type) {\n      (0, _jsutilsInvariant2['default'])(type instanceof GraphQLObjectType, _this + ' may only contain Object types, it cannot contain: ' + type + '.');\n      if (typeof _this.resolveType !== 'function') {\n        (0, _jsutilsInvariant2['default'])(typeof type.isTypeOf === 'function', 'Union Type ' + _this + ' does not provide a \"resolveType\" function ' + ('and possible Type ' + type + ' does not provide a \"isTypeOf\" ') + 'function. There is no way to resolve this possible type ' + 'during execution.');\n      }\n    });\n    this._types = config.types;\n    this._typeConfig = config;\n  }\n\n  _createClass(GraphQLUnionType, [{\n    key: 'getPossibleTypes',\n    value: function getPossibleTypes() {\n      return this._types;\n    }\n  }, {\n    key: 'isPossibleType',\n    value: function isPossibleType(type) {\n      var possibleTypeNames = this._possibleTypeNames;\n      if (!possibleTypeNames) {\n        this._possibleTypeNames = possibleTypeNames = this.getPossibleTypes().reduce(function (map, possibleType) {\n          return (map[possibleType.name] = true, map);\n        }, {});\n      }\n      return possibleTypeNames[type.name] === true;\n    }\n  }, {\n    key: 'getObjectType',\n    value: function getObjectType(value, info) {\n      var resolver = this._typeConfig.resolveType;\n      return resolver ? resolver(value, info) : getTypeOf(value, info, this);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }]);\n\n  return GraphQLUnionType;\n})();\n\nexports.GraphQLUnionType = GraphQLUnionType;\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     var RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\n\nvar GraphQLEnumType /* <T> */ = (function () {\n  function GraphQLEnumType(config /* <T> */) {\n    _classCallCheck(this, GraphQLEnumType);\n\n    this.name = config.name;\n    assertValidName(config.name);\n    this.description = config.description;\n    this._values = defineEnumValues(this, config.values);\n    this._enumConfig = config;\n  }\n\n  _createClass(GraphQLEnumType, [{\n    key: 'getValues',\n    value: function getValues() /* <T> */{\n      return this._values;\n    }\n  }, {\n    key: 'serialize',\n    value: function serialize(value /* T */) {\n      var enumValue = this._getValueLookup().get(value);\n      return enumValue ? enumValue.name : null;\n    }\n  }, {\n    key: 'parseValue',\n    value: function parseValue(value) /* T */{\n      var enumValue = this._getNameLookup()[value];\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  }, {\n    key: 'parseLiteral',\n    value: function parseLiteral(valueAST) /* T */{\n      if (valueAST.kind === _languageKinds.ENUM) {\n        var enumValue = this._getNameLookup()[valueAST.value];\n        if (enumValue) {\n          return enumValue.value;\n        }\n      }\n    }\n  }, {\n    key: '_getValueLookup',\n    value: function _getValueLookup() {\n      if (!this._valueLookup) {\n        var lookup = new Map();\n        this.getValues().forEach(function (value) {\n          lookup.set(value.value, value);\n        });\n        this._valueLookup = lookup;\n      }\n      return this._valueLookup;\n    }\n  }, {\n    key: '_getNameLookup',\n    value: function _getNameLookup() {\n      if (!this._nameLookup) {\n        var lookup = Object.create(null);\n        this.getValues().forEach(function (value) {\n          lookup[value.name] = value;\n        });\n        this._nameLookup = lookup;\n      }\n      return this._nameLookup;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }]);\n\n  return GraphQLEnumType;\n})();\n\nexports.GraphQLEnumType = GraphQLEnumType;\n\nfunction defineEnumValues(type, valueMap /* <T> */\n) /* <T> */{\n  (0, _jsutilsInvariant2['default'])(isPlainObj(valueMap), type + ' values must be an object with value names as keys.');\n  var valueNames = Object.keys(valueMap);\n  (0, _jsutilsInvariant2['default'])(valueNames.length > 0, type + ' values must be an object with value names as keys.');\n  return valueNames.map(function (valueName) {\n    assertValidName(valueName);\n    var value = valueMap[valueName];\n    (0, _jsutilsInvariant2['default'])(isPlainObj(value), type + '.' + valueName + ' must refer to an object with a \"value\" key ' + ('representing an internal value but got: ' + value + '.'));\n    (0, _jsutilsInvariant2['default'])(!value.hasOwnProperty('isDeprecated'), type + '.' + valueName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".');\n    return {\n      name: valueName,\n      description: value.description,\n      deprecationReason: value.deprecationReason,\n      value: (0, _jsutilsIsNullish2['default'])(value.value) ? valueName : value.value\n    };\n  });\n}\n\n/* <T> */ /* T */\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     var GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\n\nvar GraphQLInputObjectType = (function () {\n  function GraphQLInputObjectType(config) {\n    _classCallCheck(this, GraphQLInputObjectType);\n\n    (0, _jsutilsInvariant2['default'])(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this._typeConfig = config;\n  }\n\n  _createClass(GraphQLInputObjectType, [{\n    key: 'getFields',\n    value: function getFields() {\n      return this._fields || (this._fields = this._defineFieldMap());\n    }\n  }, {\n    key: '_defineFieldMap',\n    value: function _defineFieldMap() {\n      var _this2 = this;\n\n      var fieldMap = resolveMaybeThunk(this._typeConfig.fields);\n      (0, _jsutilsInvariant2['default'])(isPlainObj(fieldMap), this + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');\n      var fieldNames = Object.keys(fieldMap);\n      (0, _jsutilsInvariant2['default'])(fieldNames.length > 0, this + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.');\n      var resultFieldMap = {};\n      fieldNames.forEach(function (fieldName) {\n        assertValidName(fieldName);\n        var field = _extends({}, fieldMap[fieldName], {\n          name: fieldName\n        });\n        (0, _jsutilsInvariant2['default'])(isInputType(field.type), _this2 + '.' + fieldName + ' field type must be Input Type but ' + ('got: ' + field.type + '.'));\n        resultFieldMap[fieldName] = field;\n      });\n      return resultFieldMap;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }]);\n\n  return GraphQLInputObjectType;\n})();\n\nexports.GraphQLInputObjectType = GraphQLInputObjectType;\n\n/**\n * List Modifier\n *\n * A list is a kind of type marker, a wrapping type which points to another\n * type. Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     var PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: new GraphQLList(Person) },\n *         children: { type: new GraphQLList(Person) },\n *       })\n *     })\n *\n */\n\nvar GraphQLList = (function () {\n  function GraphQLList(type) {\n    _classCallCheck(this, GraphQLList);\n\n    (0, _jsutilsInvariant2['default'])(isType(type), 'Can only create List of a GraphQLType but got: ' + type + '.');\n    this.ofType = type;\n  }\n\n  /**\n   * Non-Null Modifier\n   *\n   * A non-null is a kind of type marker, a wrapping type which points to another\n   * type. Non-null types enforce that their values are never null and can ensure\n   * an error is raised if this ever occurs during a request. It is useful for\n   * fields which you can make a strong guarantee on non-nullability, for example\n   * usually the id field of a database row will never be null.\n   *\n   * Example:\n   *\n   *     var RowType = new GraphQLObjectType({\n   *       name: 'Row',\n   *       fields: () => ({\n   *         id: { type: new GraphQLNonNull(GraphQLString) },\n   *       })\n   *     })\n   *\n   * Note: the enforcement of non-nullability occurs within the executor.\n   */\n\n  _createClass(GraphQLList, [{\n    key: 'toString',\n    value: function toString() {\n      return '[' + String(this.ofType) + ']';\n    }\n  }]);\n\n  return GraphQLList;\n})();\n\nexports.GraphQLList = GraphQLList;\n\nvar GraphQLNonNull = (function () {\n  function GraphQLNonNull(type) {\n    _classCallCheck(this, GraphQLNonNull);\n\n    (0, _jsutilsInvariant2['default'])(isType(type) && !(type instanceof GraphQLNonNull), 'Can only create NonNull of a Nullable GraphQLType but got: ' + type + '.');\n    this.ofType = type;\n  }\n\n  _createClass(GraphQLNonNull, [{\n    key: 'toString',\n    value: function toString() {\n      return this.ofType.toString() + '!';\n    }\n  }]);\n\n  return GraphQLNonNull;\n})();\n\nexports.GraphQLNonNull = GraphQLNonNull;\n\nvar NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n\n// Helper to assert that provided names are valid.\nfunction assertValidName(name) {\n  (0, _jsutilsInvariant2['default'])(NAME_RX.test(name), 'Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but \"' + name + '\" does not.');\n}\n/* <T> */ /* T */ /* T */\n/**\n * Optionally provide a custom type resolver function. If one is not provided,\n * the default implementation will call `isTypeOf` on each implementing\n * Object type.\n */\n\n/**\n * Optionally provide a custom type resolver function. If one is not provided,\n * the default implementation will call `isTypeOf` on each implementing\n * Object type.\n */\n/* <T> */ /* <T> */ /* T */ /* T */ /* <T> */ /* <T> */ /* <T> */ /* <T> */ /* T */ /* <T> */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/type/definition.js\n ** module id = 370\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Returns true if a value is null, undefined, or NaN.\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = isNullish;\n\nfunction isNullish(value) {\n  return value === null || value === undefined || value !== value;\n}\n\nmodule.exports = exports[\"default\"];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/jsutils/isNullish.js\n ** module id = 371\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Creates a keyed JS object from an array, given a function to produce the keys\n * for each value in the array.\n *\n * This provides a convenient lookup for the array items if the key function\n * produces unique results.\n *\n *     var phoneBook = [\n *       { name: 'Jon', num: '555-1234' },\n *       { name: 'Jenny', num: '867-5309' }\n *     ]\n *\n *     // { Jon: { name: 'Jon', num: '555-1234' },\n *     //   Jenny: { name: 'Jenny', num: '867-5309' } }\n *     var entriesByName = keyMap(\n *       phoneBook,\n *       entry => entry.name\n *     )\n *\n *     // { name: 'Jenny', num: '857-6309' }\n *     var jennyEntry = entriesByName['Jenny']\n *\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = keyMap;\n\nfunction keyMap(list, keyFn) {\n  return list.reduce(function (map, item) {\n    return (map[keyFn(item)] = item, map);\n  }, {});\n}\n\nmodule.exports = exports[\"default\"];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/jsutils/keyMap.js\n ** module id = 372\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _definition = require('./definition');\n\nvar _scalars = require('./scalars');\n\n/**\n * Directives are used by the GraphQL runtime as a way of modifying execution\n * behavior. Type system creators will usually not create these directly.\n */\n\nvar GraphQLDirective = function GraphQLDirective(config) {\n  _classCallCheck(this, GraphQLDirective);\n\n  this.name = config.name;\n  this.description = config.description;\n  this.args = config.args || [];\n  this.onOperation = Boolean(config.onOperation);\n  this.onFragment = Boolean(config.onFragment);\n  this.onField = Boolean(config.onField);\n};\n\nexports.GraphQLDirective = GraphQLDirective;\n\n/**\n * Used to conditionally include fields or fragments\n */\nvar GraphQLIncludeDirective = new GraphQLDirective({\n  name: 'include',\n  description: 'Directs the executor to include this field or fragment only when ' + 'the `if` argument is true.',\n  args: [{ name: 'if',\n    type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),\n    description: 'Included when true.' }],\n  onOperation: false,\n  onFragment: true,\n  onField: true\n});\n\nexports.GraphQLIncludeDirective = GraphQLIncludeDirective;\n/**\n * Used to conditionally skip (exclude) fields or fragments\n */\nvar GraphQLSkipDirective = new GraphQLDirective({\n  name: 'skip',\n  description: 'Directs the executor to skip this field or fragment when the `if` ' + 'argument is true.',\n  args: [{ name: 'if',\n    type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),\n    description: 'Skipped when true.' }],\n  onOperation: false,\n  onFragment: true,\n  onField: true\n});\nexports.GraphQLSkipDirective = GraphQLSkipDirective;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/type/directives.js\n ** module id = 373\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _definition = require('./definition');\n\nvar _language = require('../language');\n\n// Integers are only safe when between -(2^53 - 1) and 2^53 - 1 due to being\n// encoded in JavaScript and represented in JSON as double-precision floating\n// point numbers, as specified by IEEE 754.\nvar MAX_INT = 9007199254740991;\nvar MIN_INT = -9007199254740991;\n\nfunction coerceInt(value) {\n  var num = Number(value);\n  if (num === num && num <= MAX_INT && num >= MIN_INT) {\n    return (num < 0 ? Math.ceil : Math.floor)(num);\n  }\n  return null;\n}\n\nvar GraphQLInt = new _definition.GraphQLScalarType({\n  name: 'Int',\n  description: 'The `Int` scalar type represents non-fractional signed whole numeric ' + 'values. Int can represent values between -(2^53 - 1) and 2^53 - 1 since ' + 'represented in JSON as double-precision floating point numbers specified' + 'by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).',\n  serialize: coerceInt,\n  parseValue: coerceInt,\n  parseLiteral: function parseLiteral(ast) {\n    if (ast.kind === _language.Kind.INT) {\n      var num = parseInt(ast.value, 10);\n      if (num <= MAX_INT && num >= MIN_INT) {\n        return num;\n      }\n    }\n    return null;\n  }\n});\n\nexports.GraphQLInt = GraphQLInt;\nfunction coerceFloat(value) {\n  var num = Number(value);\n  return num === num ? num : null;\n}\n\nvar GraphQLFloat = new _definition.GraphQLScalarType({\n  name: 'Float',\n  description: 'The `Float` scalar type represents signed double-precision fractional ' + 'values as specified by ' + '[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ',\n  serialize: coerceFloat,\n  parseValue: coerceFloat,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === _language.Kind.FLOAT || ast.kind === _language.Kind.INT ? parseFloat(ast.value) : null;\n  }\n});\n\nexports.GraphQLFloat = GraphQLFloat;\nvar GraphQLString = new _definition.GraphQLScalarType({\n  name: 'String',\n  description: 'The `String` scalar type represents textual data, represented as UTF-8 ' + 'character sequences. The String type is most often used by GraphQL to ' + 'represent free-form human-readable text.',\n  serialize: String,\n  parseValue: String,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === _language.Kind.STRING ? ast.value : null;\n  }\n});\n\nexports.GraphQLString = GraphQLString;\nvar GraphQLBoolean = new _definition.GraphQLScalarType({\n  name: 'Boolean',\n  description: 'The `Boolean` scalar type represents `true` or `false`.',\n  serialize: Boolean,\n  parseValue: Boolean,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === _language.Kind.BOOLEAN ? ast.value : null;\n  }\n});\n\nexports.GraphQLBoolean = GraphQLBoolean;\nvar GraphQLID = new _definition.GraphQLScalarType({\n  name: 'ID',\n  description: 'The `ID` scalar type represents a unique identifier, often used to ' + 'refetch an object or as key for a cache. The ID type appears in a JSON ' + 'response as a String; however, it is not intended to be human-readable. ' + 'When expected as an input type, any string (such as `\"4\"`) or integer ' + '(such as `4`) input value will be accepted as an ID.',\n  serialize: String,\n  parseValue: String,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === _language.Kind.STRING || ast.kind === _language.Kind.INT ? ast.value : null;\n  }\n});\nexports.GraphQLID = GraphQLID;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/type/scalars.js\n ** module id = 374\n ** module chunks = 1\n **/","/*  weak */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\nvar _utilitiesAstFromValue = require('../utilities/astFromValue');\n\nvar _languagePrinter = require('../language/printer');\n\nvar _definition = require('./definition');\n\nvar _scalars = require('./scalars');\n\nvar __Schema = new _definition.GraphQLObjectType({\n  name: '__Schema',\n  description: 'A GraphQL Schema defines the capabilities of a GraphQL server. It ' + 'exposes all available types and directives on the server, as well as ' + 'the entry points for query, mutation, and subscription operations.',\n  fields: function fields() {\n    return {\n      types: {\n        description: 'A list of all types supported by this server.',\n        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),\n        resolve: function resolve(schema) {\n          var typeMap = schema.getTypeMap();\n          return Object.keys(typeMap).map(function (key) {\n            return typeMap[key];\n          });\n        }\n      },\n      queryType: {\n        description: 'The type that query operations will be rooted at.',\n        type: new _definition.GraphQLNonNull(__Type),\n        resolve: function resolve(schema) {\n          return schema.getQueryType();\n        }\n      },\n      mutationType: {\n        description: 'If this server supports mutation, the type that ' + 'mutation operations will be rooted at.',\n        type: __Type,\n        resolve: function resolve(schema) {\n          return schema.getMutationType();\n        }\n      },\n      subscriptionType: {\n        description: 'If this server support subscription, the type that ' + 'subscription operations will be rooted at.',\n        type: __Type,\n        resolve: function resolve(schema) {\n          return schema.getSubscriptionType();\n        }\n      },\n      directives: {\n        description: 'A list of all directives supported by this server.',\n        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),\n        resolve: function resolve(schema) {\n          return schema.getDirectives();\n        }\n      }\n    };\n  }\n});\n\nexports.__Schema = __Schema;\nvar __Directive = new _definition.GraphQLObjectType({\n  name: '__Directive',\n  description: 'A Directive provides a way to describe alternate runtime execution and ' + 'type validation behavior in a GraphQL document.' + '\\n\\nIn some cases, you need to provide options to alter GraphQL’s ' + 'execution behavior in ways field arguments will not suffice, such as ' + 'conditionally including or skipping a field. Directives provide this by ' + 'describing additional information to the executor.',\n  fields: function fields() {\n    return {\n      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },\n      description: { type: _scalars.GraphQLString },\n      args: {\n        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),\n        resolve: function resolve(directive) {\n          return directive.args || [];\n        }\n      },\n      onOperation: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) },\n      onFragment: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) },\n      onField: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) }\n    };\n  }\n});\n\nvar __Type = new _definition.GraphQLObjectType({\n  name: '__Type',\n  description: 'The fundamental unit of any GraphQL Schema is the type. There are ' + 'many kinds of types in GraphQL as represented by the `__TypeKind` enum.' + '\\n\\nDepending on the kind of a type, certain fields describe ' + 'information about that type. Scalar types provide no information ' + 'beyond a name and description, while Enum types provide their values. ' + 'Object and Interface types provide the fields they describe. Abstract ' + 'types, Union and Interface, provide the Object types possible ' + 'at runtime. List and NonNull types compose other types.',\n  fields: function fields() {\n    return {\n      kind: {\n        type: new _definition.GraphQLNonNull(__TypeKind),\n        resolve: function resolve(type) {\n          if (type instanceof _definition.GraphQLScalarType) {\n            return TypeKind.SCALAR;\n          } else if (type instanceof _definition.GraphQLObjectType) {\n            return TypeKind.OBJECT;\n          } else if (type instanceof _definition.GraphQLInterfaceType) {\n            return TypeKind.INTERFACE;\n          } else if (type instanceof _definition.GraphQLUnionType) {\n            return TypeKind.UNION;\n          } else if (type instanceof _definition.GraphQLEnumType) {\n            return TypeKind.ENUM;\n          } else if (type instanceof _definition.GraphQLInputObjectType) {\n            return TypeKind.INPUT_OBJECT;\n          } else if (type instanceof _definition.GraphQLList) {\n            return TypeKind.LIST;\n          } else if (type instanceof _definition.GraphQLNonNull) {\n            return TypeKind.NON_NULL;\n          }\n          throw new Error('Unknown kind of type: ' + type);\n        }\n      },\n      name: { type: _scalars.GraphQLString },\n      description: { type: _scalars.GraphQLString },\n      fields: {\n        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),\n        args: {\n          includeDeprecated: { type: _scalars.GraphQLBoolean, defaultValue: false }\n        },\n        resolve: function resolve(type, _ref) {\n          var includeDeprecated = _ref.includeDeprecated;\n\n          if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {\n            var fieldMap = type.getFields();\n            var fields = Object.keys(fieldMap).map(function (fieldName) {\n              return fieldMap[fieldName];\n            });\n            if (!includeDeprecated) {\n              fields = fields.filter(function (field) {\n                return !field.deprecationReason;\n              });\n            }\n            return fields;\n          }\n          return null;\n        }\n      },\n      interfaces: {\n        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),\n        resolve: function resolve(type) {\n          if (type instanceof _definition.GraphQLObjectType) {\n            return type.getInterfaces();\n          }\n        }\n      },\n      possibleTypes: {\n        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),\n        resolve: function resolve(type) {\n          if (type instanceof _definition.GraphQLInterfaceType || type instanceof _definition.GraphQLUnionType) {\n            return type.getPossibleTypes();\n          }\n        }\n      },\n      enumValues: {\n        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),\n        args: {\n          includeDeprecated: { type: _scalars.GraphQLBoolean, defaultValue: false }\n        },\n        resolve: function resolve(type, _ref2) {\n          var includeDeprecated = _ref2.includeDeprecated;\n\n          if (type instanceof _definition.GraphQLEnumType) {\n            var values = type.getValues();\n            if (!includeDeprecated) {\n              values = values.filter(function (value) {\n                return !value.deprecationReason;\n              });\n            }\n            return values;\n          }\n        }\n      },\n      inputFields: {\n        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),\n        resolve: function resolve(type) {\n          if (type instanceof _definition.GraphQLInputObjectType) {\n            var fieldMap = type.getFields();\n            return Object.keys(fieldMap).map(function (fieldName) {\n              return fieldMap[fieldName];\n            });\n          }\n        }\n      },\n      ofType: { type: __Type }\n    };\n  }\n});\n\nvar __Field = new _definition.GraphQLObjectType({\n  name: '__Field',\n  description: 'Object and Interface types are described by a list of Fields, each of ' + 'which has a name, potentially a list of arguments, and a return type.',\n  fields: function fields() {\n    return {\n      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },\n      description: { type: _scalars.GraphQLString },\n      args: {\n        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),\n        resolve: function resolve(field) {\n          return field.args || [];\n        }\n      },\n      type: { type: new _definition.GraphQLNonNull(__Type) },\n      isDeprecated: {\n        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),\n        resolve: function resolve(field) {\n          return !(0, _jsutilsIsNullish2['default'])(field.deprecationReason);\n        }\n      },\n      deprecationReason: {\n        type: _scalars.GraphQLString\n      }\n    };\n  }\n});\n\nvar __InputValue = new _definition.GraphQLObjectType({\n  name: '__InputValue',\n  description: 'Arguments provided to Fields or Directives and the input fields of an ' + 'InputObject are represented as Input Values which describe their type ' + 'and optionally a default value.',\n  fields: function fields() {\n    return {\n      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },\n      description: { type: _scalars.GraphQLString },\n      type: { type: new _definition.GraphQLNonNull(__Type) },\n      defaultValue: {\n        type: _scalars.GraphQLString,\n        description: 'A GraphQL-formatted string representing the default value for this ' + 'input value.',\n        resolve: function resolve(inputVal) {\n          return inputVal.defaultValue == null ? null : (0, _languagePrinter.print)((0, _utilitiesAstFromValue.astFromValue)(inputVal.defaultValue, inputVal));\n        }\n      }\n    };\n  }\n});\n\nvar __EnumValue = new _definition.GraphQLObjectType({\n  name: '__EnumValue',\n  description: 'One possible value for a given Enum. Enum values are unique values, not ' + 'a placeholder for a string or numeric value. However an Enum value is ' + 'returned in a JSON response as a string.',\n  fields: {\n    name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },\n    description: { type: _scalars.GraphQLString },\n    isDeprecated: {\n      type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),\n      resolve: function resolve(enumValue) {\n        return !(0, _jsutilsIsNullish2['default'])(enumValue.deprecationReason);\n      }\n    },\n    deprecationReason: {\n      type: _scalars.GraphQLString\n    }\n  }\n});\n\nvar TypeKind = {\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  LIST: 'LIST',\n  NON_NULL: 'NON_NULL'\n};\n\nexports.TypeKind = TypeKind;\nvar __TypeKind = new _definition.GraphQLEnumType({\n  name: '__TypeKind',\n  description: 'An enum describing what kind of type a given `__Type` is.',\n  values: {\n    SCALAR: {\n      value: TypeKind.SCALAR,\n      description: 'Indicates this type is a scalar.'\n    },\n    OBJECT: {\n      value: TypeKind.OBJECT,\n      description: 'Indicates this type is an object. ' + '`fields` and `interfaces` are valid fields.'\n    },\n    INTERFACE: {\n      value: TypeKind.INTERFACE,\n      description: 'Indicates this type is an interface. ' + '`fields` and `possibleTypes` are valid fields.'\n    },\n    UNION: {\n      value: TypeKind.UNION,\n      description: 'Indicates this type is a union. ' + '`possibleTypes` is a valid field.'\n    },\n    ENUM: {\n      value: TypeKind.ENUM,\n      description: 'Indicates this type is an enum. ' + '`enumValues` is a valid field.'\n    },\n    INPUT_OBJECT: {\n      value: TypeKind.INPUT_OBJECT,\n      description: 'Indicates this type is an input object. ' + '`inputFields` is a valid field.'\n    },\n    LIST: {\n      value: TypeKind.LIST,\n      description: 'Indicates this type is a list. ' + '`ofType` is a valid field.'\n    },\n    NON_NULL: {\n      value: TypeKind.NON_NULL,\n      description: 'Indicates this type is a non-null. ' + '`ofType` is a valid field.'\n    }\n  }\n});\n\n/**\n * Note that these are GraphQLFieldDefinition and not GraphQLFieldConfig,\n * so the format for args is different.\n */\n\nvar SchemaMetaFieldDef = {\n  name: '__schema',\n  type: new _definition.GraphQLNonNull(__Schema),\n  description: 'Access the current type schema of this server.',\n  args: [],\n  resolve: function resolve(source, args, _ref3) {\n    var schema = _ref3.schema;\n    return schema;\n  }\n};\n\nexports.SchemaMetaFieldDef = SchemaMetaFieldDef;\nvar TypeMetaFieldDef = {\n  name: '__type',\n  type: __Type,\n  description: 'Request the type information of a single type.',\n  args: [{ name: 'name', type: new _definition.GraphQLNonNull(_scalars.GraphQLString) }],\n  resolve: function resolve(source, _ref4, _ref5) {\n    var name = _ref4.name;\n    var schema = _ref5.schema;\n    return schema.getType(name);\n  }\n};\n\nexports.TypeMetaFieldDef = TypeMetaFieldDef;\nvar TypeNameMetaFieldDef = {\n  name: '__typename',\n  type: new _definition.GraphQLNonNull(_scalars.GraphQLString),\n  description: 'The name of the current Object type at runtime.',\n  args: [],\n  resolve: function resolve(source, args, _ref6) {\n    var parentType = _ref6.parentType;\n    return parentType.name;\n  }\n};\nexports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/type/introspection.js\n ** module id = 375\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.astFromValue = astFromValue;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\nvar _languageKinds = require('../language/kinds');\n\nvar _typeDefinition = require('../type/definition');\n\nvar _typeScalars = require('../type/scalars');\n\n/**\n * Produces a GraphQL Value AST given a JavaScript value.\n *\n * Optionally, a GraphQL type may be provided, which will be used to\n * disambiguate between value primitives.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n *\n */\n\nfunction astFromValue(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var value = _x,\n        type = _x2;\n    itemType = stringNum = isIntValue = fields = undefined;\n    _again = false;\n\n    if (type instanceof _typeDefinition.GraphQLNonNull) {\n      // Note: we're not checking that the result is non-null.\n      // This function is not responsible for validating the input value.\n      _x = value;\n      _x2 = type.ofType;\n      _again = true;\n      continue _function;\n    }\n\n    if ((0, _jsutilsIsNullish2['default'])(value)) {\n      return null;\n    }\n\n    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n    // the value is not an array, convert the value using the list's item type.\n    if (Array.isArray(value)) {\n      var itemType = type instanceof _typeDefinition.GraphQLList ? type.ofType : null;\n      return {\n        kind: _languageKinds.LIST,\n        values: value.map(function (item) {\n          return astFromValue(item, itemType);\n        })\n      };\n    } else if (type instanceof _typeDefinition.GraphQLList) {\n      // Because GraphQL will accept single values as a \"list of one\" when\n      // expecting a list, if there's a non-array value and an expected list type,\n      // create an AST using the list's item type.\n      _x = value;\n      _x2 = type.ofType;\n      _again = true;\n      continue _function;\n    }\n\n    if (typeof value === 'boolean') {\n      return { kind: _languageKinds.BOOLEAN, value: value };\n    }\n\n    // JavaScript numbers can be Float or Int values. Use the GraphQLType to\n    // differentiate if available, otherwise prefer Int if the value is a\n    // valid Int.\n    if (typeof value === 'number') {\n      var stringNum = String(value);\n      var isIntValue = /^[0-9]+$/.test(stringNum);\n      if (isIntValue) {\n        if (type === _typeScalars.GraphQLFloat) {\n          return { kind: _languageKinds.FLOAT, value: stringNum + '.0' };\n        }\n        return { kind: _languageKinds.INT, value: stringNum };\n      }\n      return { kind: _languageKinds.FLOAT, value: stringNum };\n    }\n\n    // JavaScript strings can be Enum values or String values. Use the\n    // GraphQLType to differentiate if possible.\n    if (typeof value === 'string') {\n      if (type instanceof _typeDefinition.GraphQLEnumType && /^[_a-zA-Z][_a-zA-Z0-9]*$/.test(value)) {\n        return { kind: _languageKinds.ENUM, value: value };\n      }\n      // Use JSON stringify, which uses the same string encoding as GraphQL,\n      // then remove the quotes.\n      return { kind: _languageKinds.STRING, value: JSON.stringify(value).slice(1, -1) };\n    }\n\n    // last remaining possible typeof\n    (0, _jsutilsInvariant2['default'])(typeof value === 'object');\n\n    // Populate the fields of the input object by creating ASTs from each value\n    // in the JavaScript object.\n    var fields = [];\n    Object.keys(value).forEach(function (fieldName) {\n      var fieldType;\n      if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n        var fieldDef = type.getFields()[fieldName];\n        fieldType = fieldDef && fieldDef.type;\n      }\n      var fieldValue = astFromValue(value[fieldName], fieldType);\n      if (fieldValue) {\n        fields.push({\n          kind: _languageKinds.OBJECT_FIELD,\n          name: { kind: _languageKinds.NAME, value: fieldName },\n          value: fieldValue\n        });\n      }\n    });\n    return { kind: _languageKinds.OBJECT, fields: fields };\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/astFromValue.js\n ** module id = 376\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = find;\n\nfunction find(list, predicate) {\n  for (var i = 0; i < list.length; i++) {\n    if (predicate(list[i])) {\n      return list[i];\n    }\n  }\n}\n\nmodule.exports = exports[\"default\"];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/jsutils/find.js\n ** module id = 377\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\n\nvar _typeDefinition = require('../type/definition');\n\nfunction isEqualType(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var typeA = _x,\n        typeB = _x2;\n    _again = false;\n\n    // Equivalent types are equal.\n    if (typeA === typeB) {\n      return true;\n    }\n\n    // If either type is non-null, the other must also be non-null.\n    if (typeA instanceof _typeDefinition.GraphQLNonNull && typeB instanceof _typeDefinition.GraphQLNonNull) {\n      _x = typeA.ofType;\n      _x2 = typeB.ofType;\n      _again = true;\n      continue _function;\n    }\n\n    // If either type is a list, the other must also be a list.\n    if (typeA instanceof _typeDefinition.GraphQLList && typeB instanceof _typeDefinition.GraphQLList) {\n      _x = typeA.ofType;\n      _x2 = typeB.ofType;\n      _again = true;\n      continue _function;\n    }\n\n    // Otherwise the types are not equal.\n    return false;\n  }\n}\n\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nfunction isTypeSubTypeOf(_x3, _x4) {\n  var _again2 = true;\n\n  _function2: while (_again2) {\n    var maybeSubType = _x3,\n        superType = _x4;\n    _again2 = false;\n\n    // Equivalent type is a valid subtype\n    if (maybeSubType === superType) {\n      return true;\n    }\n\n    // If superType is non-null, maybeSubType must also be nullable.\n    if (superType instanceof _typeDefinition.GraphQLNonNull) {\n      if (maybeSubType instanceof _typeDefinition.GraphQLNonNull) {\n        _x3 = maybeSubType.ofType;\n        _x4 = superType.ofType;\n        _again2 = true;\n        continue _function2;\n      }\n      return false;\n    } else if (maybeSubType instanceof _typeDefinition.GraphQLNonNull) {\n      // If superType is nullable, maybeSubType may be non-null.\n      _x3 = maybeSubType.ofType;\n      _x4 = superType;\n      _again2 = true;\n      continue _function2;\n    }\n\n    // If superType type is a list, maybeSubType type must also be a list.\n    if (superType instanceof _typeDefinition.GraphQLList) {\n      if (maybeSubType instanceof _typeDefinition.GraphQLList) {\n        _x3 = maybeSubType.ofType;\n        _x4 = superType.ofType;\n        _again2 = true;\n        continue _function2;\n      }\n      return false;\n    } else if (maybeSubType instanceof _typeDefinition.GraphQLList) {\n      // If superType is not a list, maybeSubType must also be not a list.\n      return false;\n    }\n\n    // If superType type is an abstract type, maybeSubType type may be a currently\n    // possible object type.\n    if ((0, _typeDefinition.isAbstractType)(superType) && maybeSubType instanceof _typeDefinition.GraphQLObjectType && superType.isPossibleType(maybeSubType)) {\n      return true;\n    }\n\n    // Otherwise, the child type is not a valid subtype of the parent type.\n    return false;\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/typeComparators.js\n ** module id = 378\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _languageKinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_languageKinds);\n\nvar _typeDefinition = require('../type/definition');\n\nvar _typeIntrospection = require('../type/introspection');\n\nvar _typeFromAST = require('./typeFromAST');\n\nvar _jsutilsFind = require('../jsutils/find');\n\nvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nvar TypeInfo = (function () {\n  function TypeInfo(schema,\n  // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n  }\n\n  /**\n   * Not exactly the same as the executor's definition of getFieldDef, in this\n   * statically evaluated environment we do not always have an Object type,\n   * and need to handle Interface and Union types.\n   */\n\n  _createClass(TypeInfo, [{\n    key: 'getType',\n    value: function getType() {\n      if (this._typeStack.length > 0) {\n        return this._typeStack[this._typeStack.length - 1];\n      }\n    }\n  }, {\n    key: 'getParentType',\n    value: function getParentType() {\n      if (this._parentTypeStack.length > 0) {\n        return this._parentTypeStack[this._parentTypeStack.length - 1];\n      }\n    }\n  }, {\n    key: 'getInputType',\n    value: function getInputType() {\n      if (this._inputTypeStack.length > 0) {\n        return this._inputTypeStack[this._inputTypeStack.length - 1];\n      }\n    }\n  }, {\n    key: 'getFieldDef',\n    value: function getFieldDef() {\n      if (this._fieldDefStack.length > 0) {\n        return this._fieldDefStack[this._fieldDefStack.length - 1];\n      }\n    }\n  }, {\n    key: 'getDirective',\n    value: function getDirective() {\n      return this._directive;\n    }\n  }, {\n    key: 'getArgument',\n    value: function getArgument() {\n      return this._argument;\n    }\n\n    // Flow does not yet handle this case.\n  }, {\n    key: 'enter',\n    value: function enter(node /* Node */) {\n      var schema = this._schema;\n      switch (node.kind) {\n        case Kind.SELECTION_SET:\n          var namedType = (0, _typeDefinition.getNamedType)(this.getType());\n          var compositeType;\n          if ((0, _typeDefinition.isCompositeType)(namedType)) {\n            // isCompositeType is a type refining predicate, so this is safe.\n            compositeType = namedType;\n          }\n          this._parentTypeStack.push(compositeType);\n          break;\n        case Kind.FIELD:\n          var parentType = this.getParentType();\n          var fieldDef;\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n          }\n          this._fieldDefStack.push(fieldDef);\n          this._typeStack.push(fieldDef && fieldDef.type);\n          break;\n        case Kind.DIRECTIVE:\n          this._directive = schema.getDirective(node.name.value);\n          break;\n        case Kind.OPERATION_DEFINITION:\n          var type = undefined;\n          if (node.operation === 'query') {\n            type = schema.getQueryType();\n          } else if (node.operation === 'mutation') {\n            type = schema.getMutationType();\n          } else if (node.operation === 'subscription') {\n            type = schema.getSubscriptionType();\n          }\n          this._typeStack.push(type);\n          break;\n        case Kind.INLINE_FRAGMENT:\n        case Kind.FRAGMENT_DEFINITION:\n          var typeConditionAST = node.typeCondition;\n          var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : this.getType();\n          this._typeStack.push(outputType);\n          break;\n        case Kind.VARIABLE_DEFINITION:\n          var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n          this._inputTypeStack.push(inputType);\n          break;\n        case Kind.ARGUMENT:\n          var argDef;\n          var argType;\n          var fieldOrDirective = this.getDirective() || this.getFieldDef();\n          if (fieldOrDirective) {\n            argDef = (0, _jsutilsFind2['default'])(fieldOrDirective.args, function (arg) {\n              return arg.name === node.name.value;\n            });\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n          this._argument = argDef;\n          this._inputTypeStack.push(argType);\n          break;\n        case Kind.LIST:\n          var listType = (0, _typeDefinition.getNullableType)(this.getInputType());\n          this._inputTypeStack.push(listType instanceof _typeDefinition.GraphQLList ? listType.ofType : undefined);\n          break;\n        case Kind.OBJECT_FIELD:\n          var objectType = (0, _typeDefinition.getNamedType)(this.getInputType());\n          var fieldType;\n          if (objectType instanceof _typeDefinition.GraphQLInputObjectType) {\n            var inputField = objectType.getFields()[node.name.value];\n            fieldType = inputField ? inputField.type : undefined;\n          }\n          this._inputTypeStack.push(fieldType);\n          break;\n      }\n    }\n  }, {\n    key: 'leave',\n    value: function leave(node) {\n      switch (node.kind) {\n        case Kind.SELECTION_SET:\n          this._parentTypeStack.pop();\n          break;\n        case Kind.FIELD:\n          this._fieldDefStack.pop();\n          this._typeStack.pop();\n          break;\n        case Kind.DIRECTIVE:\n          this._directive = null;\n          break;\n        case Kind.OPERATION_DEFINITION:\n        case Kind.INLINE_FRAGMENT:\n        case Kind.FRAGMENT_DEFINITION:\n          this._typeStack.pop();\n          break;\n        case Kind.VARIABLE_DEFINITION:\n          this._inputTypeStack.pop();\n          break;\n        case Kind.ARGUMENT:\n          this._argument = null;\n          this._inputTypeStack.pop();\n          break;\n        case Kind.LIST:\n        case Kind.OBJECT_FIELD:\n          this._inputTypeStack.pop();\n          break;\n      }\n    }\n  }]);\n\n  return TypeInfo;\n})();\n\nexports.TypeInfo = TypeInfo;\nfunction getFieldDef(schema, parentType, fieldAST) {\n  var name = fieldAST.name.value;\n  if (name === _typeIntrospection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _typeIntrospection.SchemaMetaFieldDef;\n  }\n  if (name === _typeIntrospection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _typeIntrospection.TypeMetaFieldDef;\n  }\n  if (name === _typeIntrospection.TypeNameMetaFieldDef.name && (parentType instanceof _typeDefinition.GraphQLObjectType || parentType instanceof _typeDefinition.GraphQLInterfaceType || parentType instanceof _typeDefinition.GraphQLUnionType)) {\n    return _typeIntrospection.TypeNameMetaFieldDef;\n  }\n  if (parentType instanceof _typeDefinition.GraphQLObjectType || parentType instanceof _typeDefinition.GraphQLInterfaceType) {\n    return parentType.getFields()[name];\n  }\n}\n// It may disappear in the future.\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/TypeInfo.js\n ** module id = 379\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.typeFromAST = typeFromAST;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _languageKinds = require('../language/kinds');\n\nvar _typeDefinition = require('../type/definition');\n\nfunction typeFromAST(schema, inputTypeAST) {\n  var innerType;\n  if (inputTypeAST.kind === _languageKinds.LIST_TYPE) {\n    innerType = typeFromAST(schema, inputTypeAST.type);\n    return innerType && new _typeDefinition.GraphQLList(innerType);\n  }\n  if (inputTypeAST.kind === _languageKinds.NON_NULL_TYPE) {\n    innerType = typeFromAST(schema, inputTypeAST.type);\n    return innerType && new _typeDefinition.GraphQLNonNull(innerType);\n  }\n  (0, _jsutilsInvariant2['default'])(inputTypeAST.kind === _languageKinds.NAMED_TYPE, 'Must be a named type.');\n  return schema.getType(inputTypeAST.name.value);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/typeFromAST.js\n ** module id = 380\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n// Spec Section: \"Operation Name Uniqueness\"\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _rulesUniqueOperationNames = require('./rules/UniqueOperationNames');\n\n// Spec Section: \"Lone Anonymous Operation\"\n\nvar _rulesLoneAnonymousOperation = require('./rules/LoneAnonymousOperation');\n\n// Spec Section: \"Fragment Spread Type Existence\"\n\nvar _rulesKnownTypeNames = require('./rules/KnownTypeNames');\n\n// Spec Section: \"Fragments on Composite Types\"\n\nvar _rulesFragmentsOnCompositeTypes = require('./rules/FragmentsOnCompositeTypes');\n\n// Spec Section: \"Variables are Input Types\"\n\nvar _rulesVariablesAreInputTypes = require('./rules/VariablesAreInputTypes');\n\n// Spec Section: \"Leaf Field Selections\"\n\nvar _rulesScalarLeafs = require('./rules/ScalarLeafs');\n\n// Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nvar _rulesFieldsOnCorrectType = require('./rules/FieldsOnCorrectType');\n\n// Spec Section: \"Fragment Name Uniqueness\"\n\nvar _rulesUniqueFragmentNames = require('./rules/UniqueFragmentNames');\n\n// Spec Section: \"Fragment spread target defined\"\n\nvar _rulesKnownFragmentNames = require('./rules/KnownFragmentNames');\n\n// Spec Section: \"Fragments must be used\"\n\nvar _rulesNoUnusedFragments = require('./rules/NoUnusedFragments');\n\n// Spec Section: \"Fragment spread is possible\"\n\nvar _rulesPossibleFragmentSpreads = require('./rules/PossibleFragmentSpreads');\n\n// Spec Section: \"Fragments must not form cycles\"\n\nvar _rulesNoFragmentCycles = require('./rules/NoFragmentCycles');\n\n// Spec Section: \"All Variable Used Defined\"\n\nvar _rulesNoUndefinedVariables = require('./rules/NoUndefinedVariables');\n\n// Spec Section: \"All Variables Used\"\n\nvar _rulesNoUnusedVariables = require('./rules/NoUnusedVariables');\n\n// Spec Section: \"Directives Are Defined\"\n\nvar _rulesKnownDirectives = require('./rules/KnownDirectives');\n\n// Spec Section: \"Argument Names\"\n\nvar _rulesKnownArgumentNames = require('./rules/KnownArgumentNames');\n\n// Spec Section: \"Argument Uniqueness\"\n\nvar _rulesUniqueArgumentNames = require('./rules/UniqueArgumentNames');\n\n// Spec Section: \"Argument Values Type Correctness\"\n\nvar _rulesArgumentsOfCorrectType = require('./rules/ArgumentsOfCorrectType');\n\n// Spec Section: \"Argument Optionality\"\n\nvar _rulesProvidedNonNullArguments = require('./rules/ProvidedNonNullArguments');\n\n// Spec Section: \"Variable Default Values Are Correctly Typed\"\n\nvar _rulesDefaultValuesOfCorrectType = require('./rules/DefaultValuesOfCorrectType');\n\n// Spec Section: \"All Variable Usages Are Allowed\"\n\nvar _rulesVariablesInAllowedPosition = require('./rules/VariablesInAllowedPosition');\n\n// Spec Section: \"Field Selection Merging\"\n\nvar _rulesOverlappingFieldsCanBeMerged = require('./rules/OverlappingFieldsCanBeMerged');\n\n// Spec Section: \"Input Object Field Uniqueness\"\n\nvar _rulesUniqueInputFieldNames = require('./rules/UniqueInputFieldNames');\n\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n */\nvar specifiedRules = [_rulesUniqueOperationNames.UniqueOperationNames, _rulesLoneAnonymousOperation.LoneAnonymousOperation, _rulesKnownTypeNames.KnownTypeNames, _rulesFragmentsOnCompositeTypes.FragmentsOnCompositeTypes, _rulesVariablesAreInputTypes.VariablesAreInputTypes, _rulesScalarLeafs.ScalarLeafs, _rulesFieldsOnCorrectType.FieldsOnCorrectType, _rulesUniqueFragmentNames.UniqueFragmentNames, _rulesKnownFragmentNames.KnownFragmentNames, _rulesNoUnusedFragments.NoUnusedFragments, _rulesPossibleFragmentSpreads.PossibleFragmentSpreads, _rulesNoFragmentCycles.NoFragmentCycles, _rulesNoUndefinedVariables.NoUndefinedVariables, _rulesNoUnusedVariables.NoUnusedVariables, _rulesKnownDirectives.KnownDirectives, _rulesKnownArgumentNames.KnownArgumentNames, _rulesUniqueArgumentNames.UniqueArgumentNames, _rulesArgumentsOfCorrectType.ArgumentsOfCorrectType, _rulesProvidedNonNullArguments.ProvidedNonNullArguments, _rulesDefaultValuesOfCorrectType.DefaultValuesOfCorrectType, _rulesVariablesInAllowedPosition.VariablesInAllowedPosition, _rulesOverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged, _rulesUniqueInputFieldNames.UniqueInputFieldNames];\nexports.specifiedRules = specifiedRules;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/specifiedRules.js\n ** module id = 381\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.duplicateOperationNameMessage = duplicateOperationNameMessage;\nexports.UniqueOperationNames = UniqueOperationNames;\n\nvar _error = require('../../error');\n\nfunction duplicateOperationNameMessage(operationName) {\n  return 'There can only be one operation named \"' + operationName + '\".';\n}\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n */\n\nfunction UniqueOperationNames(context) {\n  var knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      var operationName = node.name;\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(new _error.GraphQLError(duplicateOperationNameMessage(operationName.value), [knownOperationNames[operationName.value], operationName]));\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition() {\n      return false;\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/UniqueOperationNames.js\n ** module id = 382\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.anonOperationNotAloneMessage = anonOperationNotAloneMessage;\nexports.LoneAnonymousOperation = LoneAnonymousOperation;\n\nvar _error = require('../../error');\n\nvar _languageKinds = require('../../language/kinds');\n\nfunction anonOperationNotAloneMessage() {\n  return 'This anonymous operation must be the only defined operation.';\n}\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n */\n\nfunction LoneAnonymousOperation(context) {\n  var operationCount = 0;\n  return {\n    Document: function Document(node) {\n      operationCount = node.definitions.filter(function (definition) {\n        return definition.kind === _languageKinds.OPERATION_DEFINITION;\n      }).length;\n    },\n    OperationDefinition: function OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(new _error.GraphQLError(anonOperationNotAloneMessage(), [node]));\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/LoneAnonymousOperation.js\n ** module id = 383\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.unknownTypeMessage = unknownTypeMessage;\nexports.KnownTypeNames = KnownTypeNames;\n\nvar _error = require('../../error');\n\nfunction unknownTypeMessage(type) {\n  return 'Unknown type \"' + type + '\".';\n}\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\n\nfunction KnownTypeNames(context) {\n  return {\n    NamedType: function NamedType(node) {\n      var typeName = node.name.value;\n      var type = context.getSchema().getType(typeName);\n      if (!type) {\n        context.reportError(new _error.GraphQLError(unknownTypeMessage(typeName), [node]));\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/KnownTypeNames.js\n ** module id = 384\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.inlineFragmentOnNonCompositeErrorMessage = inlineFragmentOnNonCompositeErrorMessage;\nexports.fragmentOnNonCompositeErrorMessage = fragmentOnNonCompositeErrorMessage;\nexports.FragmentsOnCompositeTypes = FragmentsOnCompositeTypes;\n\nvar _error = require('../../error');\n\nvar _languagePrinter = require('../../language/printer');\n\nvar _typeDefinition = require('../../type/definition');\n\nfunction inlineFragmentOnNonCompositeErrorMessage(type) {\n  return 'Fragment cannot condition on non composite type \"' + type + '\".';\n}\n\nfunction fragmentOnNonCompositeErrorMessage(fragName, type) {\n  return 'Fragment \"' + fragName + '\" cannot condition on non composite ' + ('type \"' + type + '\".');\n}\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */\n\nfunction FragmentsOnCompositeTypes(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var type = context.getType();\n      if (node.typeCondition && type && !(0, _typeDefinition.isCompositeType)(type)) {\n        context.reportError(new _error.GraphQLError(inlineFragmentOnNonCompositeErrorMessage((0, _languagePrinter.print)(node.typeCondition)), [node.typeCondition]));\n      }\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var type = context.getType();\n      if (type && !(0, _typeDefinition.isCompositeType)(type)) {\n        context.reportError(new _error.GraphQLError(fragmentOnNonCompositeErrorMessage(node.name.value, (0, _languagePrinter.print)(node.typeCondition)), [node.typeCondition]));\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/FragmentsOnCompositeTypes.js\n ** module id = 385\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.nonInputTypeOnVarMessage = nonInputTypeOnVarMessage;\nexports.VariablesAreInputTypes = VariablesAreInputTypes;\n\nvar _error = require('../../error');\n\nvar _languagePrinter = require('../../language/printer');\n\nvar _typeDefinition = require('../../type/definition');\n\nvar _utilitiesTypeFromAST = require('../../utilities/typeFromAST');\n\nfunction nonInputTypeOnVarMessage(variableName, typeName) {\n  return 'Variable \"$' + variableName + '\" cannot be non-input type \"' + typeName + '\".';\n}\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n */\n\nfunction VariablesAreInputTypes(context) {\n  return {\n    VariableDefinition: function VariableDefinition(node) {\n      var type = (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), node.type);\n\n      // If the variable type is not an input type, return an error.\n      if (type && !(0, _typeDefinition.isInputType)(type)) {\n        var variableName = node.variable.name.value;\n        context.reportError(new _error.GraphQLError(nonInputTypeOnVarMessage(variableName, (0, _languagePrinter.print)(node.type)), [node.type]));\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/VariablesAreInputTypes.js\n ** module id = 386\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.noSubselectionAllowedMessage = noSubselectionAllowedMessage;\nexports.requiredSubselectionMessage = requiredSubselectionMessage;\nexports.ScalarLeafs = ScalarLeafs;\n\nvar _error = require('../../error');\n\nvar _typeDefinition = require('../../type/definition');\n\nfunction noSubselectionAllowedMessage(field, type) {\n  return 'Field \"' + field + '\" of type \"' + type + '\" must not have a sub selection.';\n}\n\nfunction requiredSubselectionMessage(field, type) {\n  return 'Field \"' + field + '\" of type \"' + type + '\" must have a sub selection.';\n}\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\n\nfunction ScalarLeafs(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getType();\n      if (type) {\n        if ((0, _typeDefinition.isLeafType)(type)) {\n          if (node.selectionSet) {\n            context.reportError(new _error.GraphQLError(noSubselectionAllowedMessage(node.name.value, type), [node.selectionSet]));\n          }\n        } else if (!node.selectionSet) {\n          context.reportError(new _error.GraphQLError(requiredSubselectionMessage(node.name.value, type), [node]));\n        }\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/ScalarLeafs.js\n ** module id = 387\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.undefinedFieldMessage = undefinedFieldMessage;\nexports.FieldsOnCorrectType = FieldsOnCorrectType;\n\nvar _error = require('../../error');\n\nfunction undefinedFieldMessage(fieldName, type) {\n  return 'Cannot query field \"' + fieldName + '\" on \"' + type + '\".';\n}\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typenamme\n */\n\nfunction FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n      if (type) {\n        var fieldDef = context.getFieldDef();\n        if (!fieldDef) {\n          context.reportError(new _error.GraphQLError(undefinedFieldMessage(node.name.value, type.name), [node]));\n        }\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/FieldsOnCorrectType.js\n ** module id = 388\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.duplicateFragmentNameMessage = duplicateFragmentNameMessage;\nexports.UniqueFragmentNames = UniqueFragmentNames;\n\nvar _error = require('../../error');\n\nfunction duplicateFragmentNameMessage(fragName) {\n  return 'There can only be one fragment named \"' + fragName + '\".';\n}\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n */\n\nfunction UniqueFragmentNames(context) {\n  var knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var fragmentName = node.name.value;\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(new _error.GraphQLError(duplicateFragmentNameMessage(fragmentName), [knownFragmentNames[fragmentName], node.name]));\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n      return false;\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/UniqueFragmentNames.js\n ** module id = 389\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.unknownFragmentMessage = unknownFragmentMessage;\nexports.KnownFragmentNames = KnownFragmentNames;\n\nvar _error = require('../../error');\n\nfunction unknownFragmentMessage(fragName) {\n  return 'Unknown fragment \"' + fragName + '\".';\n}\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n */\n\nfunction KnownFragmentNames(context) {\n  return {\n    FragmentSpread: function FragmentSpread(node) {\n      var fragmentName = node.name.value;\n      var fragment = context.getFragment(fragmentName);\n      if (!fragment) {\n        context.reportError(new _error.GraphQLError(unknownFragmentMessage(fragmentName), [node.name]));\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/KnownFragmentNames.js\n ** module id = 390\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.unusedFragMessage = unusedFragMessage;\nexports.NoUnusedFragments = NoUnusedFragments;\n\nvar _error = require('../../error');\n\nfunction unusedFragMessage(fragName) {\n  return 'Fragment \"' + fragName + '\" is never used.';\n}\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n */\n\nfunction NoUnusedFragments(context) {\n  var operationDefs = [];\n  var fragmentDefs = [];\n\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n    Document: {\n      leave: function leave() {\n        var fragmentNameUsed = Object.create(null);\n        operationDefs.forEach(function (operation) {\n          context.getRecursivelyReferencedFragments(operation).forEach(function (fragment) {\n            fragmentNameUsed[fragment.name.value] = true;\n          });\n        });\n\n        fragmentDefs.forEach(function (fragmentDef) {\n          var fragName = fragmentDef.name.value;\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(new _error.GraphQLError(unusedFragMessage(fragName), [fragmentDef]));\n          }\n        });\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/NoUnusedFragments.js\n ** module id = 391\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.typeIncompatibleSpreadMessage = typeIncompatibleSpreadMessage;\nexports.typeIncompatibleAnonSpreadMessage = typeIncompatibleAnonSpreadMessage;\nexports.PossibleFragmentSpreads = PossibleFragmentSpreads;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _error = require('../../error');\n\nvar _jsutilsKeyMap = require('../../jsutils/keyMap');\n\nvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\nvar _typeDefinition = require('../../type/definition');\n\nvar _utilitiesTypeFromAST = require('../../utilities/typeFromAST');\n\nfunction typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return 'Fragment \"' + fragName + '\" cannot be spread here as objects of ' + ('type \"' + parentType + '\" can never be of type \"' + fragType + '\".');\n}\n\nfunction typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + ('type \"' + parentType + '\" can never be of type \"' + fragType + '\".');\n}\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nfunction PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n      if (fragType && parentType && !doTypesOverlap(fragType, parentType)) {\n        context.reportError(new _error.GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n      if (fragType && parentType && !doTypesOverlap(fragType, parentType)) {\n        context.reportError(new _error.GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n  return frag && (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);\n}\n\nfunction doTypesOverlap(t1, t2) {\n  if (t1 === t2) {\n    return true;\n  }\n  if (t1 instanceof _typeDefinition.GraphQLObjectType) {\n    if (t2 instanceof _typeDefinition.GraphQLObjectType) {\n      return false;\n    }\n    return t2.getPossibleTypes().indexOf(t1) !== -1;\n  }\n  if (t1 instanceof _typeDefinition.GraphQLInterfaceType || t1 instanceof _typeDefinition.GraphQLUnionType) {\n    if (t2 instanceof _typeDefinition.GraphQLObjectType) {\n      return t1.getPossibleTypes().indexOf(t2) !== -1;\n    }\n    var t1TypeNames = (0, _jsutilsKeyMap2['default'])(t1.getPossibleTypes(), function (type) {\n      return type.name;\n    });\n    return t2.getPossibleTypes().some(function (type) {\n      return t1TypeNames[type.name];\n    });\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/PossibleFragmentSpreads.js\n ** module id = 392\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.cycleErrorMessage = cycleErrorMessage;\nexports.NoFragmentCycles = NoFragmentCycles;\n\nvar _error = require('../../error');\n\nfunction cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return 'Cannot spread fragment \"' + fragName + '\" within itself' + via + '.';\n}\n\nfunction NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null);\n\n  // Array of AST nodes used to produce meaningful errors\n  var spreadPath = [];\n\n  // Position in the spread path\n  var spreadPathIndexByName = Object.create(null);\n\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      if (!visitedFrags[node.name.value]) {\n        detectCycleRecursive(node);\n      }\n      return false;\n    }\n  };\n\n  // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n  function detectCycleRecursive(fragment) {\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n\n    var spreadNodes = context.getFragmentSpreads(fragment);\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var i = 0; i < spreadNodes.length; i++) {\n      var spreadNode = spreadNodes[i];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n\n      if (cycleIndex === undefined) {\n        spreadPath.push(spreadNode);\n        if (!visitedFrags[spreadName]) {\n          var spreadFragment = context.getFragment(spreadName);\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        }\n        spreadPath.pop();\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {\n          return s.name.value;\n        })), cyclePath.concat(spreadNode)));\n      }\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/NoFragmentCycles.js\n ** module id = 393\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.undefinedVarMessage = undefinedVarMessage;\nexports.NoUndefinedVariables = NoUndefinedVariables;\n\nvar _error = require('../../error');\n\nfunction undefinedVarMessage(varName, opName) {\n  return opName ? 'Variable \"$' + varName + '\" is not defined by operation \"' + opName + '\".' : 'Variable \"$' + varName + '\" is not defined.';\n}\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n */\n\nfunction NoUndefinedVariables(context) {\n  var variableNameDefined = Object.create(null);\n\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableNameDefined = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        usages.forEach(function (_ref) {\n          var node = _ref.node;\n\n          var varName = node.name.value;\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(new _error.GraphQLError(undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));\n          }\n        });\n      }\n    },\n    VariableDefinition: function VariableDefinition(varDefAST) {\n      variableNameDefined[varDefAST.variable.name.value] = true;\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/NoUndefinedVariables.js\n ** module id = 394\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.unusedVariableMessage = unusedVariableMessage;\nexports.NoUnusedVariables = NoUnusedVariables;\n\nvar _error = require('../../error');\n\nfunction unusedVariableMessage(varName) {\n  return 'Variable \"$' + varName + '\" is never used.';\n}\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n */\n\nfunction NoUnusedVariables(context) {\n  var variableDefs = [];\n\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableDefs = [];\n      },\n      leave: function leave(operation) {\n        var variableNameUsed = Object.create(null);\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        usages.forEach(function (_ref) {\n          var node = _ref.node;\n\n          variableNameUsed[node.name.value] = true;\n        });\n\n        variableDefs.forEach(function (variableDef) {\n          var variableName = variableDef.variable.name.value;\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(new _error.GraphQLError(unusedVariableMessage(variableName), [variableDef]));\n          }\n        });\n      }\n    },\n    VariableDefinition: function VariableDefinition(def) {\n      variableDefs.push(def);\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/NoUnusedVariables.js\n ** module id = 395\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.unknownDirectiveMessage = unknownDirectiveMessage;\nexports.misplacedDirectiveMessage = misplacedDirectiveMessage;\nexports.KnownDirectives = KnownDirectives;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _error = require('../../error');\n\nvar _jsutilsFind = require('../../jsutils/find');\n\nvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\nvar _languageKinds = require('../../language/kinds');\n\nfunction unknownDirectiveMessage(directiveName) {\n  return 'Unknown directive \"' + directiveName + '\".';\n}\n\nfunction misplacedDirectiveMessage(directiveName, placement) {\n  return 'Directive \"' + directiveName + '\" may not be used on \"' + placement + '\".';\n}\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n */\n\nfunction KnownDirectives(context) {\n  return {\n    Directive: function Directive(node, key, parent, path, ancestors) {\n      var directiveDef = (0, _jsutilsFind2['default'])(context.getSchema().getDirectives(), function (def) {\n        return def.name === node.name.value;\n      });\n      if (!directiveDef) {\n        context.reportError(new _error.GraphQLError(unknownDirectiveMessage(node.name.value), [node]));\n        return;\n      }\n      var appliedTo = ancestors[ancestors.length - 1];\n      switch (appliedTo.kind) {\n        case _languageKinds.OPERATION_DEFINITION:\n          if (!directiveDef.onOperation) {\n            context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, 'operation'), [node]));\n          }\n          break;\n        case _languageKinds.FIELD:\n          if (!directiveDef.onField) {\n            context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, 'field'), [node]));\n          }\n          break;\n        case _languageKinds.FRAGMENT_SPREAD:\n        case _languageKinds.INLINE_FRAGMENT:\n        case _languageKinds.FRAGMENT_DEFINITION:\n          if (!directiveDef.onFragment) {\n            context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, 'fragment'), [node]));\n          }\n          break;\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/KnownDirectives.js\n ** module id = 396\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.unknownArgMessage = unknownArgMessage;\nexports.unknownDirectiveArgMessage = unknownDirectiveArgMessage;\nexports.KnownArgumentNames = KnownArgumentNames;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _error = require('../../error');\n\nvar _jsutilsFind = require('../../jsutils/find');\n\nvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\nvar _jsutilsInvariant = require('../../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _languageKinds = require('../../language/kinds');\n\nfunction unknownArgMessage(argName, fieldName, type) {\n  return 'Unknown argument \"' + argName + '\" on field \"' + fieldName + '\" of ' + ('type \"' + type + '\".');\n}\n\nfunction unknownDirectiveArgMessage(argName, directiveName) {\n  return 'Unknown argument \"' + argName + '\" on directive \"@' + directiveName + '\".';\n}\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n */\n\nfunction KnownArgumentNames(context) {\n  return {\n    Argument: function Argument(node, key, parent, path, ancestors) {\n      var argumentOf = ancestors[ancestors.length - 1];\n      if (argumentOf.kind === _languageKinds.FIELD) {\n        var fieldDef = context.getFieldDef();\n        if (fieldDef) {\n          var fieldArgDef = (0, _jsutilsFind2['default'])(fieldDef.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n          if (!fieldArgDef) {\n            var parentType = context.getParentType();\n            (0, _jsutilsInvariant2['default'])(parentType);\n            context.reportError(new _error.GraphQLError(unknownArgMessage(node.name.value, fieldDef.name, parentType.name), [node]));\n          }\n        }\n      } else if (argumentOf.kind === _languageKinds.DIRECTIVE) {\n        var directive = context.getDirective();\n        if (directive) {\n          var directiveArgDef = (0, _jsutilsFind2['default'])(directive.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n          if (!directiveArgDef) {\n            context.reportError(new _error.GraphQLError(unknownDirectiveArgMessage(node.name.value, directive.name), [node]));\n          }\n        }\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/KnownArgumentNames.js\n ** module id = 397\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.duplicateArgMessage = duplicateArgMessage;\nexports.UniqueArgumentNames = UniqueArgumentNames;\n\nvar _error = require('../../error');\n\nfunction duplicateArgMessage(argName) {\n  return 'There can be only one argument named \"' + argName + '\".';\n}\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n */\n\nfunction UniqueArgumentNames(context) {\n  var knownArgNames = Object.create(null);\n  return {\n    Field: function Field() {\n      knownArgNames = Object.create(null);\n    },\n    Directive: function Directive() {\n      knownArgNames = Object.create(null);\n    },\n    Argument: function Argument(node) {\n      var argName = node.name.value;\n      if (knownArgNames[argName]) {\n        context.reportError(new _error.GraphQLError(duplicateArgMessage(argName), [knownArgNames[argName], node.name]));\n      } else {\n        knownArgNames[argName] = node.name;\n      }\n      return false;\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/UniqueArgumentNames.js\n ** module id = 398\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.badValueMessage = badValueMessage;\nexports.ArgumentsOfCorrectType = ArgumentsOfCorrectType;\n\nvar _error = require('../../error');\n\nvar _languagePrinter = require('../../language/printer');\n\nvar _utilitiesIsValidLiteralValue = require('../../utilities/isValidLiteralValue');\n\nfunction badValueMessage(argName, type, value, verboseErrors) {\n  var message = verboseErrors ? '\\n' + verboseErrors.join('\\n') : '';\n  return 'Argument \"' + argName + '\" has invalid value ' + value + '.' + message;\n}\n\n/**\n * Argument values of correct type\n *\n * A GraphQL document is only valid if all field argument literal values are\n * of the type expected by their position.\n */\n\nfunction ArgumentsOfCorrectType(context) {\n  return {\n    Argument: function Argument(argAST) {\n      var argDef = context.getArgument();\n      if (argDef) {\n        var errors = (0, _utilitiesIsValidLiteralValue.isValidLiteralValue)(argDef.type, argAST.value);\n        if (errors && errors.length > 0) {\n          context.reportError(new _error.GraphQLError(badValueMessage(argAST.name.value, argDef.type, (0, _languagePrinter.print)(argAST.value), errors), [argAST.value]));\n        }\n      }\n      return false;\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/ArgumentsOfCorrectType.js\n ** module id = 399\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.isValidLiteralValue = isValidLiteralValue;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar _languagePrinter = require('../language/printer');\n\nvar _languageKinds = require('../language/kinds');\n\nvar _typeDefinition = require('../type/definition');\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsKeyMap = require('../jsutils/keyMap');\n\nvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\n/**\n * Utility for validators which determines if a value literal AST is valid given\n * an input type.\n *\n * Note that this only validates literal values, variables are assumed to\n * provide values of the correct type.\n */\n\nfunction isValidLiteralValue(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var type = _x,\n        valueAST = _x2;\n    ofType = itemType = fields = errors = fieldASTs = _iteratorNormalCompletion = _didIteratorError = _iteratorError = fieldASTMap = _iteratorNormalCompletion2 = _didIteratorError2 = _iteratorError2 = parseResult = undefined;\n    _again = false;\n\n    // A value must be provided if the type is non-null.\n    if (type instanceof _typeDefinition.GraphQLNonNull) {\n      var ofType = type.ofType;\n      if (!valueAST) {\n        if (ofType.name) {\n          return ['Expected \"' + ofType.name + '!\", found null.'];\n        }\n        return ['Expected non-null value, found null.'];\n      }\n      _x = ofType;\n      _x2 = valueAST;\n      _again = true;\n      continue _function;\n    }\n\n    if (!valueAST) {\n      return [];\n    }\n\n    // This function only tests literals, and assumes variables will provide\n    // values of the correct type.\n    if (valueAST.kind === _languageKinds.VARIABLE) {\n      return [];\n    }\n\n    // Lists accept a non-list value as a list of one.\n    if (type instanceof _typeDefinition.GraphQLList) {\n      var itemType = type.ofType;\n      if (valueAST.kind === _languageKinds.LIST) {\n        return valueAST.values.reduce(function (acc, itemAST, index) {\n          var errors = isValidLiteralValue(itemType, itemAST);\n          return acc.concat(errors.map(function (error) {\n            return 'In element #' + index + ': ' + error;\n          }));\n        }, []);\n      }\n      _x = itemType;\n      _x2 = valueAST;\n      _again = true;\n      continue _function;\n    }\n\n    // Input objects check each defined field and look for undefined fields.\n    if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n      if (valueAST.kind !== _languageKinds.OBJECT) {\n        return ['Expected \"' + type.name + '\", found not an object.'];\n      }\n      var fields = type.getFields();\n\n      var errors = [];\n\n      // Ensure every provided field is defined.\n      var fieldASTs = valueAST.fields;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = fieldASTs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var providedFieldAST = _step.value;\n\n          if (!fields[providedFieldAST.name.value]) {\n            errors.push('In field \"' + providedFieldAST.name.value + '\": Unknown field.');\n          }\n        }\n\n        // Ensure every defined field is valid.\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var fieldASTMap = (0, _jsutilsKeyMap2['default'])(fieldASTs, function (fieldAST) {\n        return fieldAST.name.value;\n      });\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Object.keys(fields)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var fieldName = _step2.value;\n\n          var result = isValidLiteralValue(fields[fieldName].type, fieldASTMap[fieldName] && fieldASTMap[fieldName].value);\n          errors.push.apply(errors, _toConsumableArray(result.map(function (error) {\n            return 'In field \"' + fieldName + '\": ' + error;\n          })));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n            _iterator2['return']();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return errors;\n    }\n\n    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLScalarType || type instanceof _typeDefinition.GraphQLEnumType, 'Must be input type');\n\n    // Scalar/Enum input checks to ensure the type can parse the value to\n    // a non-null value.\n    var parseResult = type.parseLiteral(valueAST);\n    if ((0, _jsutilsIsNullish2['default'])(parseResult)) {\n      return ['Expected type \"' + type.name + '\", found ' + (0, _languagePrinter.print)(valueAST) + '.'];\n    }\n\n    return [];\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/isValidLiteralValue.js\n ** module id = 400\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.missingFieldArgMessage = missingFieldArgMessage;\nexports.missingDirectiveArgMessage = missingDirectiveArgMessage;\nexports.ProvidedNonNullArguments = ProvidedNonNullArguments;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _error = require('../../error');\n\nvar _jsutilsKeyMap = require('../../jsutils/keyMap');\n\nvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\nvar _typeDefinition = require('../../type/definition');\n\nfunction missingFieldArgMessage(fieldName, argName, type) {\n  return 'Field \"' + fieldName + '\" argument \"' + argName + '\" of type \"' + type + '\" ' + 'is required but not provided.';\n}\n\nfunction missingDirectiveArgMessage(directiveName, argName, type) {\n  return 'Directive \"@' + directiveName + '\" argument \"' + argName + '\" of type ' + ('\"' + type + '\" is required but not provided.');\n}\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null) field arguments\n * have been provided.\n */\n\nfunction ProvidedNonNullArguments(context) {\n  return {\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(fieldAST) {\n        var fieldDef = context.getFieldDef();\n        if (!fieldDef) {\n          return false;\n        }\n        var argASTs = fieldAST.arguments || [];\n\n        var argASTMap = (0, _jsutilsKeyMap2['default'])(argASTs, function (arg) {\n          return arg.name.value;\n        });\n        fieldDef.args.forEach(function (argDef) {\n          var argAST = argASTMap[argDef.name];\n          if (!argAST && argDef.type instanceof _typeDefinition.GraphQLNonNull) {\n            context.reportError(new _error.GraphQLError(missingFieldArgMessage(fieldAST.name.value, argDef.name, argDef.type), [fieldAST]));\n          }\n        });\n      }\n    },\n\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(directiveAST) {\n        var directiveDef = context.getDirective();\n        if (!directiveDef) {\n          return false;\n        }\n        var argASTs = directiveAST.arguments || [];\n\n        var argASTMap = (0, _jsutilsKeyMap2['default'])(argASTs, function (arg) {\n          return arg.name.value;\n        });\n        directiveDef.args.forEach(function (argDef) {\n          var argAST = argASTMap[argDef.name];\n          if (!argAST && argDef.type instanceof _typeDefinition.GraphQLNonNull) {\n            context.reportError(new _error.GraphQLError(missingDirectiveArgMessage(directiveAST.name.value, argDef.name, argDef.type), [directiveAST]));\n          }\n        });\n      }\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/ProvidedNonNullArguments.js\n ** module id = 401\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.defaultForNonNullArgMessage = defaultForNonNullArgMessage;\nexports.badValueForDefaultArgMessage = badValueForDefaultArgMessage;\nexports.DefaultValuesOfCorrectType = DefaultValuesOfCorrectType;\n\nvar _error = require('../../error');\n\nvar _languagePrinter = require('../../language/printer');\n\nvar _typeDefinition = require('../../type/definition');\n\nvar _utilitiesIsValidLiteralValue = require('../../utilities/isValidLiteralValue');\n\nfunction defaultForNonNullArgMessage(varName, type, guessType) {\n  return 'Variable \"$' + varName + '\" of type \"' + type + '\" is required and will not ' + ('use the default value. Perhaps you meant to use type \"' + guessType + '\".');\n}\n\nfunction badValueForDefaultArgMessage(varName, type, value, verboseErrors) {\n  var message = verboseErrors ? '\\n' + verboseErrors.join('\\n') : '';\n  return 'Variable \"$' + varName + ' has invalid default value ' + value + '.' + message;\n}\n\n/**\n * Variable default values of correct type\n *\n * A GraphQL document is only valid if all variable default values are of the\n * type expected by their definition.\n */\n\nfunction DefaultValuesOfCorrectType(context) {\n  return {\n    VariableDefinition: function VariableDefinition(varDefAST) {\n      var name = varDefAST.variable.name.value;\n      var defaultValue = varDefAST.defaultValue;\n      var type = context.getInputType();\n      if (type instanceof _typeDefinition.GraphQLNonNull && defaultValue) {\n        context.reportError(new _error.GraphQLError(defaultForNonNullArgMessage(name, type, type.ofType), [defaultValue]));\n      }\n      if (type && defaultValue) {\n        var errors = (0, _utilitiesIsValidLiteralValue.isValidLiteralValue)(type, defaultValue);\n        if (errors && errors.length > 0) {\n          context.reportError(new _error.GraphQLError(badValueForDefaultArgMessage(name, type, (0, _languagePrinter.print)(defaultValue), errors), [defaultValue]));\n        }\n      }\n      return false;\n    },\n    SelectionSet: function SelectionSet() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition() {\n      return false;\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/DefaultValuesOfCorrectType.js\n ** module id = 402\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.badVarPosMessage = badVarPosMessage;\nexports.VariablesInAllowedPosition = VariablesInAllowedPosition;\n\nvar _error = require('../../error');\n\nvar _typeDefinition = require('../../type/definition');\n\nvar _utilitiesTypeComparators = require('../../utilities/typeComparators');\n\nvar _utilitiesTypeFromAST = require('../../utilities/typeFromAST');\n\nfunction badVarPosMessage(varName, varType, expectedType) {\n  return 'Variable \"$' + varName + '\" of type \"' + varType + '\" used in position ' + ('expecting type \"' + expectedType + '\".');\n}\n\n/**\n * Variables passed to field arguments conform to type\n */\n\nfunction VariablesInAllowedPosition(context) {\n  var varDefMap = Object.create(null);\n\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        varDefMap = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        usages.forEach(function (_ref) {\n          var node = _ref.node;\n          var type = _ref.type;\n\n          var varName = node.name.value;\n          var varDef = varDefMap[varName];\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            var varType = (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), varDef.type);\n            if (varType && !(0, _utilitiesTypeComparators.isTypeSubTypeOf)(effectiveType(varType, varDef), type)) {\n              context.reportError(new _error.GraphQLError(badVarPosMessage(varName, varType, type), [varDef, node]));\n            }\n          }\n        });\n      }\n    },\n    VariableDefinition: function VariableDefinition(varDefAST) {\n      varDefMap[varDefAST.variable.name.value] = varDefAST;\n    }\n  };\n}\n\n// If a variable definition has a default value, it's effectively non-null.\nfunction effectiveType(varType, varDef) {\n  return !varDef.defaultValue || varType instanceof _typeDefinition.GraphQLNonNull ? varType : new _typeDefinition.GraphQLNonNull(varType);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/VariablesInAllowedPosition.js\n ** module id = 403\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.fieldsConflictMessage = fieldsConflictMessage;\nexports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;\n\n// Field name and reason.\n\n// Reason is a string, or a nested list of conflicts.\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _error = require('../../error');\n\nvar _jsutilsFind = require('../../jsutils/find');\n\nvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\nvar _languageKinds = require('../../language/kinds');\n\nvar _languagePrinter = require('../../language/printer');\n\nvar _typeDefinition = require('../../type/definition');\n\nvar _utilitiesTypeComparators = require('../../utilities/typeComparators');\n\nvar _utilitiesTypeFromAST = require('../../utilities/typeFromAST');\n\nfunction fieldsConflictMessage(responseName, reason) {\n  return 'Fields \"' + responseName + '\" conflict because ' + reasonMessage(reason) + '.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var responseName = _ref2[0];\n      var subreason = _ref2[1];\n      return 'subfields \"' + responseName + '\" conflict because ' + reasonMessage(subreason);\n    }).join(' and ');\n  }\n  return reason;\n}\n\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\nfunction OverlappingFieldsCanBeMerged(context) {\n  var comparedSet = new PairSet();\n\n  function findConflicts(fieldMap) {\n    var conflicts = [];\n    Object.keys(fieldMap).forEach(function (responseName) {\n      var fields = fieldMap[responseName];\n      if (fields.length > 1) {\n        for (var i = 0; i < fields.length; i++) {\n          for (var j = i; j < fields.length; j++) {\n            var conflict = findConflict(responseName, fields[i], fields[j]);\n            if (conflict) {\n              conflicts.push(conflict);\n            }\n          }\n        }\n      }\n    });\n    return conflicts;\n  }\n\n  function findConflict(responseName, field1, field2) {\n    var _field1 = _slicedToArray(field1, 3);\n\n    var parentType1 = _field1[0];\n    var ast1 = _field1[1];\n    var def1 = _field1[2];\n\n    var _field2 = _slicedToArray(field2, 3);\n\n    var parentType2 = _field2[0];\n    var ast2 = _field2[1];\n    var def2 = _field2[2];\n\n    // Not a pair.\n    if (ast1 === ast2) {\n      return;\n    }\n\n    // If the statically known parent types could not possibly apply at the same\n    // time, then it is safe to permit them to diverge as they will not present\n    // any ambiguity by differing.\n    // It is known that two parent types could never overlap if they are\n    // different Object types. Interface or Union types might overlap - if not\n    // in the current state of the schema, then perhaps in some future version,\n    // thus may not safely diverge.\n    if (parentType1 !== parentType2 && parentType1 instanceof _typeDefinition.GraphQLObjectType && parentType2 instanceof _typeDefinition.GraphQLObjectType) {\n      return;\n    }\n\n    // Memoize, do not report the same issue twice.\n    if (comparedSet.has(ast1, ast2)) {\n      return;\n    }\n    comparedSet.add(ast1, ast2);\n\n    var name1 = ast1.name.value;\n    var name2 = ast2.name.value;\n    if (name1 !== name2) {\n      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [ast1], [ast2]];\n    }\n\n    var type1 = def1 && def1.type;\n    var type2 = def2 && def2.type;\n    if (type1 && type2 && !(0, _utilitiesTypeComparators.isEqualType)(type1, type2)) {\n      return [[responseName, 'they return differing types ' + type1 + ' and ' + type2], [ast1], [ast2]];\n    }\n\n    if (!sameArguments(ast1.arguments || [], ast2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [ast1], [ast2]];\n    }\n\n    var selectionSet1 = ast1.selectionSet;\n    var selectionSet2 = ast2.selectionSet;\n    if (selectionSet1 && selectionSet2) {\n      var visitedFragmentNames = {};\n      var subfieldMap = collectFieldASTsAndDefs(context, (0, _typeDefinition.getNamedType)(type1), selectionSet1, visitedFragmentNames);\n      subfieldMap = collectFieldASTsAndDefs(context, (0, _typeDefinition.getNamedType)(type2), selectionSet2, visitedFragmentNames, subfieldMap);\n      var conflicts = findConflicts(subfieldMap);\n      if (conflicts.length > 0) {\n        return [[responseName, conflicts.map(function (_ref3) {\n          var _ref32 = _slicedToArray(_ref3, 1);\n\n          var reason = _ref32[0];\n          return reason;\n        })], conflicts.reduce(function (allFields, _ref4) {\n          var _ref42 = _slicedToArray(_ref4, 2);\n\n          var fields1 = _ref42[1];\n          return allFields.concat(fields1);\n        }, [ast1]), conflicts.reduce(function (allFields, _ref5) {\n          var _ref52 = _slicedToArray(_ref5, 3);\n\n          var fields2 = _ref52[2];\n          return allFields.concat(fields2);\n        }, [ast2])];\n      }\n    }\n  }\n\n  return {\n    SelectionSet: {\n      // Note: we validate on the reverse traversal so deeper conflicts will be\n      // caught first, for clearer error messages.\n      leave: function leave(selectionSet) {\n        var fieldMap = collectFieldASTsAndDefs(context, context.getParentType(), selectionSet);\n        var conflicts = findConflicts(fieldMap);\n        conflicts.forEach(function (_ref6) {\n          var _ref62 = _slicedToArray(_ref6, 3);\n\n          var _ref62$0 = _slicedToArray(_ref62[0], 2);\n\n          var responseName = _ref62$0[0];\n          var reason = _ref62$0[1];\n          var fields1 = _ref62[1];\n          var fields2 = _ref62[2];\n          return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n        });\n      }\n    }\n  };\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n  return arguments1.every(function (argument1) {\n    var argument2 = (0, _jsutilsFind2['default'])(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n    if (!argument2) {\n      return false;\n    }\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || (0, _languagePrinter.print)(value1) === (0, _languagePrinter.print)(value2);\n}\n\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * Note: This is not the same as execution's collectFields because at static\n * time we do not know what object type will be used, so we unconditionally\n * spread in all fragments.\n */\nfunction collectFieldASTsAndDefs(context, parentType, selectionSet, visitedFragmentNames, astAndDefs) {\n  var _visitedFragmentNames = visitedFragmentNames || {};\n  var _astAndDefs = astAndDefs || {};\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n    switch (selection.kind) {\n      case _languageKinds.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef;\n        if (parentType instanceof _typeDefinition.GraphQLObjectType || parentType instanceof _typeDefinition.GraphQLInterfaceType) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n        if (!_astAndDefs[responseName]) {\n          _astAndDefs[responseName] = [];\n        }\n        _astAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      case _languageKinds.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), selection.typeCondition) : parentType;\n        _astAndDefs = collectFieldASTsAndDefs(context, inlineFragmentType, selection.selectionSet, _visitedFragmentNames, _astAndDefs);\n        break;\n      case _languageKinds.FRAGMENT_SPREAD:\n        var fragName = selection.name.value;\n        if (_visitedFragmentNames[fragName]) {\n          continue;\n        }\n        _visitedFragmentNames[fragName] = true;\n        var fragment = context.getFragment(fragName);\n        if (!fragment) {\n          continue;\n        }\n        var fragmentType = (0, _utilitiesTypeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);\n        _astAndDefs = collectFieldASTsAndDefs(context, fragmentType, fragment.selectionSet, _visitedFragmentNames, _astAndDefs);\n        break;\n    }\n  }\n  return _astAndDefs;\n}\n\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\nvar PairSet = (function () {\n  function PairSet() {\n    _classCallCheck(this, PairSet);\n\n    this._data = new Map();\n  }\n\n  _createClass(PairSet, [{\n    key: 'has',\n    value: function has(a, b) {\n      var first = this._data.get(a);\n      return first && first.has(b);\n    }\n  }, {\n    key: 'add',\n    value: function add(a, b) {\n      _pairSetAdd(this._data, a, b);\n      _pairSetAdd(this._data, b, a);\n    }\n  }]);\n\n  return PairSet;\n})();\n\nfunction _pairSetAdd(data, a, b) {\n  var set = data.get(a);\n  if (!set) {\n    set = new Set();\n    data.set(a, set);\n  }\n  set.add(b);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/OverlappingFieldsCanBeMerged.js\n ** module id = 404\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.duplicateInputFieldMessage = duplicateInputFieldMessage;\nexports.UniqueInputFieldNames = UniqueInputFieldNames;\n\nvar _error = require('../../error');\n\nfunction duplicateInputFieldMessage(fieldName) {\n  return 'There can be only one input field named \"' + fieldName + '\".';\n}\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n */\n\nfunction UniqueInputFieldNames(context) {\n  var knownNameStack = [];\n  var knownNames = Object.create(null);\n\n  return {\n    ObjectValue: {\n      enter: function enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n      leave: function leave() {\n        knownNames = knownNameStack.pop();\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var fieldName = node.name.value;\n      if (knownNames[fieldName]) {\n        context.reportError(new _error.GraphQLError(duplicateInputFieldMessage(fieldName), [knownNames[fieldName], node.name]));\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n      return false;\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/rules/UniqueInputFieldNames.js\n ** module id = 405\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g \"a\"\n * 2) fragment \"spreads\" e.g. \"...c\"\n * 3) inline fragment \"spreads\" e.g. \"...on Type { a }\"\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n'use strict';\n\n/**\n * The result of execution. `data` is the result of executing the\n * query, `errors` is null if no errors occurred, and is a\n * non-empty array if an error occurred.\n */\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.execute = execute;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _error = require('../error');\n\nvar _jsutilsFind = require('../jsutils/find');\n\nvar _jsutilsFind2 = _interopRequireDefault(_jsutilsFind);\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\nvar _utilitiesTypeFromAST = require('../utilities/typeFromAST');\n\nvar _language = require('../language');\n\nvar _values = require('./values');\n\nvar _typeDefinition = require('../type/definition');\n\nvar _typeSchema = require('../type/schema');\n\nvar _typeIntrospection = require('../type/introspection');\n\nvar _typeDirectives = require('../type/directives');\n\n/**\n * Implements the \"Evaluating requests\" section of the GraphQL specification.\n *\n * Returns a Promise that will eventually be resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\n\nfunction execute(schema, documentAST, rootValue, variableValues, operationName) {\n  (0, _jsutilsInvariant2['default'])(schema, 'Must provide schema');\n  (0, _jsutilsInvariant2['default'])(schema instanceof _typeSchema.GraphQLSchema, 'Schema must be an instance of GraphQLSchema. Also ensure that there are ' + 'not multiple versions of GraphQL installed in your node_modules directory.');\n\n  // If a valid context cannot be created due to incorrect arguments,\n  // this will throw an error.\n  var context = buildExecutionContext(schema, documentAST, rootValue, variableValues, operationName);\n\n  // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  return new Promise(function (resolve) {\n    resolve(executeOperation(context, context.operation, rootValue));\n  })['catch'](function (error) {\n    // Errors from sub-fields of a NonNull type may propagate to the top level,\n    // at which point we still log the error and null the parent field, which\n    // in this case is the entire response.\n    context.errors.push(error);\n    return null;\n  }).then(function (data) {\n    if (!context.errors.length) {\n      return { data: data };\n    }\n    return { data: data, errors: context.errors };\n  });\n}\n\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n */\nfunction buildExecutionContext(schema, documentAST, rootValue, rawVariableValues, operationName) {\n  var errors = [];\n  var operation;\n  var fragments = {};\n  documentAST.definitions.forEach(function (definition) {\n    switch (definition.kind) {\n      case _language.Kind.OPERATION_DEFINITION:\n        if (!operationName && operation) {\n          throw new _error.GraphQLError('Must provide operation name if query contains multiple operations.');\n        }\n        if (!operationName || definition.name && definition.name.value === operationName) {\n          operation = definition;\n        }\n        break;\n      case _language.Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n      default:\n        throw new _error.GraphQLError('GraphQL cannot execute a request containing a ' + definition.kind + '.', definition);\n    }\n  });\n  if (!operation) {\n    if (!operationName) {\n      throw new _error.GraphQLError('Unknown operation named \"' + operationName + '\".');\n    } else {\n      throw new _error.GraphQLError('Must provide an operation.');\n    }\n  }\n  var variableValues = (0, _values.getVariableValues)(schema, operation.variableDefinitions || [], rawVariableValues || {});\n  var exeContext = { schema: schema, fragments: fragments, rootValue: rootValue, operation: operation, variableValues: variableValues, errors: errors };\n  return exeContext;\n}\n\n/**\n * Implements the \"Evaluating operations\" section of the spec.\n */\nfunction executeOperation(exeContext, operation, rootValue) {\n  var type = getOperationRootType(exeContext.schema, operation);\n  var fields = collectFields(exeContext, type, operation.selectionSet, {}, {});\n  if (operation.operation === 'mutation') {\n    return executeFieldsSerially(exeContext, type, rootValue, fields);\n  }\n  return executeFields(exeContext, type, rootValue, fields);\n}\n\n/**\n * Extracts the root type of the operation from the schema.\n */\nfunction getOperationRootType(schema, operation) {\n  switch (operation.operation) {\n    case 'query':\n      return schema.getQueryType();\n    case 'mutation':\n      var mutationType = schema.getMutationType();\n      if (!mutationType) {\n        throw new _error.GraphQLError('Schema is not configured for mutations', [operation]);\n      }\n      return mutationType;\n    case 'subscription':\n      var subscriptionType = schema.getSubscriptionType();\n      if (!subscriptionType) {\n        throw new _error.GraphQLError('Schema is not configured for subscriptions', [operation]);\n      }\n      return subscriptionType;\n    default:\n      throw new _error.GraphQLError('Can only execute queries, mutations and subscriptions', [operation]);\n  }\n}\n\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"write\" mode.\n */\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, fields) {\n  return Object.keys(fields).reduce(function (prevPromise, responseName) {\n    return prevPromise.then(function (results) {\n      var fieldASTs = fields[responseName];\n      var result = resolveField(exeContext, parentType, sourceValue, fieldASTs);\n      if (result === undefined) {\n        return results;\n      }\n      if (isThenable(result)) {\n        return result.then(function (resolvedResult) {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n      results[responseName] = result;\n      return results;\n    });\n  }, Promise.resolve({}));\n}\n\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"read\" mode.\n */\nfunction executeFields(exeContext, parentType, sourceValue, fields) {\n  var containsPromise = false;\n\n  var finalResults = Object.keys(fields).reduce(function (results, responseName) {\n    var fieldASTs = fields[responseName];\n    var result = resolveField(exeContext, parentType, sourceValue, fieldASTs);\n    if (result === undefined) {\n      return results;\n    }\n    results[responseName] = result;\n    if (isThenable(result)) {\n      containsPromise = true;\n    }\n    return results;\n  }, {});\n\n  // If there are no promises, we can just return the object\n  if (!containsPromise) {\n    return finalResults;\n  }\n\n  // Otherwise, results is a map from field name to the result\n  // of resolving that field, which is possibly a promise. Return\n  // a promise that will return this same map, but with any\n  // promises replaced with the values they resolved to.\n  return promiseForObject(finalResults);\n}\n\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns and Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n */\nfunction collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n    switch (selection.kind) {\n      case _language.Kind.FIELD:\n        if (!shouldIncludeNode(exeContext, selection.directives)) {\n          continue;\n        }\n        var name = getFieldEntryKey(selection);\n        if (!fields[name]) {\n          fields[name] = [];\n        }\n        fields[name].push(selection);\n        break;\n      case _language.Kind.INLINE_FRAGMENT:\n        if (!shouldIncludeNode(exeContext, selection.directives) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\n          continue;\n        }\n        collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n        break;\n      case _language.Kind.FRAGMENT_SPREAD:\n        var fragName = selection.name.value;\n        if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection.directives)) {\n          continue;\n        }\n        visitedFragmentNames[fragName] = true;\n        var fragment = exeContext.fragments[fragName];\n        if (!fragment || !shouldIncludeNode(exeContext, fragment.directives) || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n          continue;\n        }\n        collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n        break;\n    }\n  }\n  return fields;\n}\n\n/**\n * Determines if a field should be included based on the @include and @skip\n * directives, where @skip has higher precidence than @include.\n */\nfunction shouldIncludeNode(exeContext, directives) {\n  var skipAST = directives && (0, _jsutilsFind2['default'])(directives, function (directive) {\n    return directive.name.value === _typeDirectives.GraphQLSkipDirective.name;\n  });\n  if (skipAST) {\n    var _getArgumentValues = (0, _values.getArgumentValues)(_typeDirectives.GraphQLSkipDirective.args, skipAST.arguments, exeContext.variableValues);\n\n    var skipIf = _getArgumentValues['if'];\n\n    return !skipIf;\n  }\n\n  var includeAST = directives && (0, _jsutilsFind2['default'])(directives, function (directive) {\n    return directive.name.value === _typeDirectives.GraphQLIncludeDirective.name;\n  });\n  if (includeAST) {\n    var _getArgumentValues2 = (0, _values.getArgumentValues)(_typeDirectives.GraphQLIncludeDirective.args, includeAST.arguments, exeContext.variableValues);\n\n    var includeIf = _getArgumentValues2['if'];\n\n    return Boolean(includeIf);\n  }\n\n  return true;\n}\n\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(exeContext, fragment, type) {\n  var typeConditionAST = fragment.typeCondition;\n  if (!typeConditionAST) {\n    return true;\n  }\n  var conditionalType = (0, _utilitiesTypeFromAST.typeFromAST)(exeContext.schema, typeConditionAST);\n  if (conditionalType === type) {\n    return true;\n  }\n  if ((0, _typeDefinition.isAbstractType)(conditionalType)) {\n    return conditionalType.isPossibleType(type);\n  }\n  return false;\n}\n\n/**\n * This function transforms a JS object `{[key: string]: Promise<any>}` into\n * a `Promise<{[key: string]: any}>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nfunction promiseForObject(object) {\n  var keys = Object.keys(object);\n  var valuesAndPromises = keys.map(function (name) {\n    return object[name];\n  });\n  return Promise.all(valuesAndPromises).then(function (values) {\n    return values.reduce(function (resolvedObject, value, i) {\n      resolvedObject[keys[i]] = value;\n      return resolvedObject;\n    }, {});\n  });\n}\n\n/**\n * Implements the logic to compute the key of a given field’s entry\n */\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n\n/**\n * Resolves the field on the given source object. In particular, this\n * figures out the value that the field returns by calling its resolve function,\n * then calls completeValue to complete promises, serialize scalars, or execute\n * the sub-selection-set for objects.\n */\nfunction resolveField(exeContext, parentType, source, fieldASTs) {\n  var fieldAST = fieldASTs[0];\n  var fieldName = fieldAST.name.value;\n\n  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);\n  if (!fieldDef) {\n    return;\n  }\n\n  var returnType = fieldDef.type;\n  var resolveFn = fieldDef.resolve || defaultResolveFn;\n\n  // Build a JS object of arguments from the field.arguments AST, using the\n  // variables scope to fulfill any variable references.\n  // TODO: find a way to memoize, in case this field is within a List type.\n  var args = (0, _values.getArgumentValues)(fieldDef.args, fieldAST.arguments, exeContext.variableValues);\n\n  // The resolve function's optional third argument is a collection of\n  // information about the current execution state.\n  var info = {\n    fieldName: fieldName,\n    fieldASTs: fieldASTs,\n    returnType: returnType,\n    parentType: parentType,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues\n  };\n\n  // Get the resolve function, regardless of if its result is normal\n  // or abrupt (error).\n  var result = resolveOrError(resolveFn, source, args, info);\n\n  return completeValueCatchingError(exeContext, returnType, fieldASTs, info, result);\n}\n\n// Isolates the \"ReturnOrAbrupt\" behavior to not de-opt the `resolveField`\n// function. Returns the result of resolveFn or the abrupt-return Error object.\nfunction resolveOrError(resolveFn, source, args, info) {\n  try {\n    return resolveFn(source, args, info);\n  } catch (error) {\n    // Sometimes a non-error is thrown, wrap it as an Error for a\n    // consistent interface.\n    return error instanceof Error ? error : new Error(error);\n  }\n}\n\n// This is a small wrapper around completeValue which detects and logs errors\n// in the execution context.\nfunction completeValueCatchingError(exeContext, returnType, fieldASTs, info, result) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors.\n  if (returnType instanceof _typeDefinition.GraphQLNonNull) {\n    return completeValue(exeContext, returnType, fieldASTs, info, result);\n  }\n\n  // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n  try {\n    var completed = completeValue(exeContext, returnType, fieldASTs, info, result);\n    if (isThenable(completed)) {\n      // If `completeValue` returned a rejected promise, log the rejection\n      // error and resolve to null.\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, function (error) {\n        exeContext.errors.push(error);\n        return Promise.resolve(null);\n      });\n    }\n    return completed;\n  } catch (error) {\n    // If `completeValue` returned abruptly (threw an error), log the error\n    // and return null.\n    exeContext.errors.push(error);\n    return null;\n  }\n}\n\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Field entries\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by evaluating all sub-selections.\n */\nfunction completeValue(exeContext, returnType, fieldASTs, info, result) {\n  // If result is a Promise, apply-lift over completeValue.\n  if (isThenable(result)) {\n    return result.then(\n    // Once resolved to a value, complete that value.\n    function (resolved) {\n      return completeValue(exeContext, returnType, fieldASTs, info, resolved);\n    },\n    // If rejected, create a located error, and continue to reject.\n    function (error) {\n      return Promise.reject((0, _error.locatedError)(error, fieldASTs));\n    });\n  }\n\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw (0, _error.locatedError)(result, fieldASTs);\n  }\n\n  // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n  if (returnType instanceof _typeDefinition.GraphQLNonNull) {\n    var completed = completeValue(exeContext, returnType.ofType, fieldASTs, info, result);\n    if (completed === null) {\n      throw new _error.GraphQLError('Cannot return null for non-nullable ' + ('field ' + info.parentType + '.' + info.fieldName + '.'), fieldASTs);\n    }\n    return completed;\n  }\n\n  // If result is null-like, return null.\n  if ((0, _jsutilsIsNullish2['default'])(result)) {\n    return null;\n  }\n\n  // If field type is List, complete each item in the list with the inner type\n  if (returnType instanceof _typeDefinition.GraphQLList) {\n    (0, _jsutilsInvariant2['default'])(Array.isArray(result), 'User Error: expected iterable, but did not find one.');\n\n    // This is specified as a simple map, however we're optimizing the path\n    // where the list contains no Promises by avoiding creating another Promise.\n    var itemType = returnType.ofType;\n    var containsPromise = false;\n    var completedResults = result.map(function (item) {\n      var completedItem = completeValueCatchingError(exeContext, itemType, fieldASTs, info, item);\n      if (!containsPromise && isThenable(completedItem)) {\n        containsPromise = true;\n      }\n      return completedItem;\n    });\n\n    return containsPromise ? Promise.all(completedResults) : completedResults;\n  }\n\n  // If field type is Scalar or Enum, serialize to a valid value, returning\n  // null if serialization is not possible.\n  if (returnType instanceof _typeDefinition.GraphQLScalarType || returnType instanceof _typeDefinition.GraphQLEnumType) {\n    (0, _jsutilsInvariant2['default'])(returnType.serialize, 'Missing serialize method on type');\n    var serializedResult = returnType.serialize(result);\n    return (0, _jsutilsIsNullish2['default'])(serializedResult) ? null : serializedResult;\n  }\n\n  // Field type must be Object, Interface or Union and expect sub-selections.\n  var runtimeType;\n\n  if (returnType instanceof _typeDefinition.GraphQLObjectType) {\n    runtimeType = returnType;\n  } else if ((0, _typeDefinition.isAbstractType)(returnType)) {\n    var abstractType = returnType;\n    runtimeType = abstractType.getObjectType(result, info);\n    if (runtimeType && !abstractType.isPossibleType(runtimeType)) {\n      throw new _error.GraphQLError('Runtime Object type \"' + runtimeType + '\" is not a possible type ' + ('for \"' + abstractType + '\".'), fieldASTs);\n    }\n  }\n\n  if (!runtimeType) {\n    return null;\n  }\n\n  // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n  if (runtimeType.isTypeOf && !runtimeType.isTypeOf(result, info)) {\n    throw new _error.GraphQLError('Expected value of type \"' + runtimeType + '\" but got: ' + result + '.', fieldASTs);\n  }\n\n  // Collect sub-fields to execute to complete this value.\n  var subFieldASTs = {};\n  var visitedFragmentNames = {};\n  for (var i = 0; i < fieldASTs.length; i++) {\n    var selectionSet = fieldASTs[i].selectionSet;\n    if (selectionSet) {\n      subFieldASTs = collectFields(exeContext, runtimeType, selectionSet, subFieldASTs, visitedFragmentNames);\n    }\n  }\n\n  return executeFields(exeContext, runtimeType, result, subFieldASTs);\n}\n\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function.\n */\nfunction defaultResolveFn(source, args, _ref) {\n  var fieldName = _ref.fieldName;\n\n  var property = source[fieldName];\n  return typeof property === 'function' ? property.call(source) : property;\n}\n\n/**\n * Checks to see if this object acts like a Promise, i.e. has a \"then\"\n * function.\n */\nfunction isThenable(value) {\n  return value && typeof value === 'object' && typeof value.then === 'function';\n}\n\n/**\n * This method looks up the field on the given type defintion.\n * It has special casing for the two introspection fields, __schema\n * and __typename. __typename is special because it can always be\n * queried as a field, even in situations where no other fields\n * are allowed, like on a Union. __schema could get automatically\n * added to the query type, but that would require mutating type\n * definitions, which would cause issues.\n */\nfunction getFieldDef(schema, parentType, fieldName) {\n  if (fieldName === _typeIntrospection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _typeIntrospection.SchemaMetaFieldDef;\n  } else if (fieldName === _typeIntrospection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _typeIntrospection.TypeMetaFieldDef;\n  } else if (fieldName === _typeIntrospection.TypeNameMetaFieldDef.name) {\n    return _typeIntrospection.TypeNameMetaFieldDef;\n  }\n  return parentType.getFields()[fieldName];\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/execution/execute.js\n ** module id = 406\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getVariableValues = getVariableValues;\nexports.getArgumentValues = getArgumentValues;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _error = require('../error');\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\nvar _jsutilsKeyMap = require('../jsutils/keyMap');\n\nvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\nvar _utilitiesTypeFromAST = require('../utilities/typeFromAST');\n\nvar _utilitiesValueFromAST = require('../utilities/valueFromAST');\n\nvar _utilitiesIsValidJSValue = require('../utilities/isValidJSValue');\n\nvar _languagePrinter = require('../language/printer');\n\nvar _typeDefinition = require('../type/definition');\n\nfunction getVariableValues(schema, definitionASTs, inputs) {\n  return definitionASTs.reduce(function (values, defAST) {\n    var varName = defAST.variable.name.value;\n    values[varName] = getVariableValue(schema, defAST, inputs[varName]);\n    return values;\n  }, {});\n}\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n */\n\nfunction getArgumentValues(argDefs, argASTs, variableValues) {\n  if (!argDefs || !argASTs) {\n    return {};\n  }\n  var argASTMap = (0, _jsutilsKeyMap2['default'])(argASTs, function (arg) {\n    return arg.name.value;\n  });\n  return argDefs.reduce(function (result, argDef) {\n    var name = argDef.name;\n    var valueAST = argASTMap[name] ? argASTMap[name].value : null;\n    var value = (0, _utilitiesValueFromAST.valueFromAST)(valueAST, argDef.type, variableValues);\n    if ((0, _jsutilsIsNullish2['default'])(value)) {\n      value = argDef.defaultValue;\n    }\n    if (!(0, _jsutilsIsNullish2['default'])(value)) {\n      result[name] = value;\n    }\n    return result;\n  }, {});\n}\n\n/**\n * Given a variable definition, and any value of input, return a value which\n * adheres to the variable definition, or throw an error.\n */\nfunction getVariableValue(schema, definitionAST, input) {\n  var type = (0, _utilitiesTypeFromAST.typeFromAST)(schema, definitionAST.type);\n  var variable = definitionAST.variable;\n  if (!type || !(0, _typeDefinition.isInputType)(type)) {\n    throw new _error.GraphQLError('Variable \"$' + variable.name.value + '\" expected value of type ' + ('\"' + (0, _languagePrinter.print)(definitionAST.type) + '\" which cannot be used as an input type.'), [definitionAST]);\n  }\n  var inputType = type;\n  var errors = (0, _utilitiesIsValidJSValue.isValidJSValue)(input, inputType);\n  if (!errors.length) {\n    if ((0, _jsutilsIsNullish2['default'])(input)) {\n      var defaultValue = definitionAST.defaultValue;\n      if (defaultValue) {\n        return (0, _utilitiesValueFromAST.valueFromAST)(defaultValue, inputType);\n      }\n    }\n    return coerceValue(inputType, input);\n  }\n  if ((0, _jsutilsIsNullish2['default'])(input)) {\n    throw new _error.GraphQLError('Variable \"$' + variable.name.value + '\" of required type ' + ('\"' + (0, _languagePrinter.print)(definitionAST.type) + '\" was not provided.'), [definitionAST]);\n  }\n  var message = errors ? '\\n' + errors.join('\\n') : '';\n  throw new _error.GraphQLError('Variable \"$' + variable.name.value + '\" got invalid value ' + (JSON.stringify(input) + '.' + message), [definitionAST]);\n}\n\n/**\n * Given a type and any value, return a runtime value coerced to match the type.\n */\nfunction coerceValue(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var type = _x,\n        value = _x2;\n    nullableType = itemType = fields = parsed = undefined;\n    _again = false;\n\n    if (type instanceof _typeDefinition.GraphQLNonNull) {\n      // Note: we're not checking that the result of coerceValue is non-null.\n\n      var nullableType = type.ofType;\n      _x = nullableType;\n      _x2 = value;\n      _again = true;\n      continue _function;\n    }\n\n    if ((0, _jsutilsIsNullish2['default'])(value)) {\n      return null;\n    }\n\n    if (type instanceof _typeDefinition.GraphQLList) {\n      var itemType = type.ofType;\n      // TODO: support iterable input\n      if (Array.isArray(value)) {\n        return value.map(function (item) {\n          return coerceValue(itemType, item);\n        });\n      }\n      return [coerceValue(itemType, value)];\n    }\n\n    if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n      var fields = type.getFields();\n      return Object.keys(fields).reduce(function (obj, fieldName) {\n        var field = fields[fieldName];\n        var fieldValue = coerceValue(field.type, value[fieldName]);\n        if ((0, _jsutilsIsNullish2['default'])(fieldValue)) {\n          fieldValue = field.defaultValue;\n        }\n        if (!(0, _jsutilsIsNullish2['default'])(fieldValue)) {\n          obj[fieldName] = fieldValue;\n        }\n        return obj;\n      }, {});\n    }\n\n    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLScalarType || type instanceof _typeDefinition.GraphQLEnumType, 'Must be input type');\n\n    var parsed = type.parseValue(value);\n    if (!(0, _jsutilsIsNullish2['default'])(parsed)) {\n      return parsed;\n    }\n  }\n}\n// We only call this function after calling isValidJSValue.\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/execution/values.js\n ** module id = 407\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String / Enum Value  | String        |\n * | Int / Float          | Number        |\n *\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.valueFromAST = valueFromAST;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _jsutilsKeyMap = require('../jsutils/keyMap');\n\nvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\nvar _languageKinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_languageKinds);\n\nvar _typeDefinition = require('../type/definition');\n\nfunction valueFromAST(_x, _x2, _x3) {\n  var _again = true;\n\n  _function: while (_again) {\n    var valueAST = _x,\n        type = _x2,\n        variables = _x3;\n    nullableType = variableName = itemType = fields = fieldASTs = parsed = undefined;\n    _again = false;\n\n    if (type instanceof _typeDefinition.GraphQLNonNull) {\n      var nullableType = type.ofType;\n      // Note: we're not checking that the result of valueFromAST is non-null.\n      // We're assuming that this query has been validated and the value used\n      // here is of the correct type.\n      _x = valueAST;\n      _x2 = nullableType;\n      _x3 = variables;\n      _again = true;\n      continue _function;\n    }\n\n    if (!valueAST) {\n      return null;\n    }\n\n    if (valueAST.kind === Kind.VARIABLE) {\n      var variableName = valueAST.name.value;\n      if (!variables || !variables.hasOwnProperty(variableName)) {\n        return null;\n      }\n      // Note: we're not doing any checking that this variable is correct. We're\n      // assuming that this query has been validated and the variable usage here\n      // is of the correct type.\n      return variables[variableName];\n    }\n\n    if (type instanceof _typeDefinition.GraphQLList) {\n      var itemType = type.ofType;\n      if (valueAST.kind === Kind.LIST) {\n        return valueAST.values.map(function (itemAST) {\n          return valueFromAST(itemAST, itemType, variables);\n        });\n      }\n      return [valueFromAST(valueAST, itemType, variables)];\n    }\n\n    if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n      var fields = type.getFields();\n      if (valueAST.kind !== Kind.OBJECT) {\n        return null;\n      }\n      var fieldASTs = (0, _jsutilsKeyMap2['default'])(valueAST.fields, function (field) {\n        return field.name.value;\n      });\n      return Object.keys(fields).reduce(function (obj, fieldName) {\n        var field = fields[fieldName];\n        var fieldAST = fieldASTs[fieldName];\n        var fieldValue = valueFromAST(fieldAST && fieldAST.value, field.type, variables);\n        if ((0, _jsutilsIsNullish2['default'])(fieldValue)) {\n          fieldValue = field.defaultValue;\n        }\n        if (!(0, _jsutilsIsNullish2['default'])(fieldValue)) {\n          obj[fieldName] = fieldValue;\n        }\n        return obj;\n      }, {});\n    }\n\n    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLScalarType || type instanceof _typeDefinition.GraphQLEnumType, 'Must be input type');\n\n    var parsed = type.parseLiteral(valueAST);\n    if (!(0, _jsutilsIsNullish2['default'])(parsed)) {\n      return parsed;\n    }\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/valueFromAST.js\n ** module id = 408\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Given a JavaScript value and a GraphQL type, determine if the value will be\n * accepted for that type. This is primarily useful for validating the\n * runtime values of query variables.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.isValidJSValue = isValidJSValue;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\nvar _typeDefinition = require('../type/definition');\n\nfunction isValidJSValue(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var value = _x,\n        type = _x2;\n    ofType = itemType = fields = errors = _iteratorNormalCompletion = _didIteratorError = _iteratorError = _iteratorNormalCompletion2 = _didIteratorError2 = _iteratorError2 = parseResult = undefined;\n    _again = false;\n\n    // A value must be provided if the type is non-null.\n    if (type instanceof _typeDefinition.GraphQLNonNull) {\n      var ofType = type.ofType;\n      if ((0, _jsutilsIsNullish2['default'])(value)) {\n        if (ofType.name) {\n          return ['Expected \"' + ofType.name + '!\", found null.'];\n        }\n        return ['Expected non-null value, found null.'];\n      }\n      _x = value;\n      _x2 = ofType;\n      _again = true;\n      continue _function;\n    }\n\n    if ((0, _jsutilsIsNullish2['default'])(value)) {\n      return [];\n    }\n\n    // Lists accept a non-list value as a list of one.\n    if (type instanceof _typeDefinition.GraphQLList) {\n      var itemType = type.ofType;\n      if (Array.isArray(value)) {\n        return value.reduce(function (acc, item, index) {\n          var errors = isValidJSValue(item, itemType);\n          return acc.concat(errors.map(function (error) {\n            return 'In element #' + index + ': ' + error;\n          }));\n        }, []);\n      }\n      _x = value;\n      _x2 = itemType;\n      _again = true;\n      continue _function;\n    }\n\n    // Input objects check each defined field.\n    if (type instanceof _typeDefinition.GraphQLInputObjectType) {\n      if (typeof value !== 'object') {\n        return ['Expected \"' + type.name + '\", found not an object.'];\n      }\n      var fields = type.getFields();\n\n      var errors = [];\n\n      // Ensure every provided field is defined.\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = Object.keys(value)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var providedField = _step.value;\n\n          if (!fields[providedField]) {\n            errors.push('In field \"${providedField}\": Unknown field.');\n          }\n        }\n\n        // Ensure every defined field is valid.\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Object.keys(fields)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var fieldName = _step2.value;\n\n          var newErrors = isValidJSValue(value[fieldName], fields[fieldName].type);\n          errors.push.apply(errors, _toConsumableArray(newErrors.map(function (error) {\n            return 'In field \"' + fieldName + '\": ' + error;\n          })));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n            _iterator2['return']();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return errors;\n    }\n\n    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLScalarType || type instanceof _typeDefinition.GraphQLEnumType, 'Must be input type');\n\n    // Scalar/Enum input checks to ensure the type can parse the value to\n    // a non-null value.\n    var parseResult = type.parseValue(value);\n    if ((0, _jsutilsIsNullish2['default'])(parseResult)) {\n      return ['Expected type \"' + type.name + '\", found ' + JSON.stringify(value) + '.'];\n    }\n\n    return [];\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/isValidJSValue.js\n ** module id = 409\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n// The primary React component to use.\n'use strict';\n\nmodule.exports = require('./components/GraphiQL').GraphiQL;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/index.js\n ** module id = 410\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _graphqlType = require('graphql/type');\n\nvar _graphqlUtilities = require('graphql/utilities');\n\nvar _graphqlJsutilsFind = require('graphql/jsutils/find');\n\nvar _graphqlJsutilsFind2 = _interopRequireDefault(_graphqlJsutilsFind);\n\nvar _ExecuteButton = require('./ExecuteButton');\n\nvar _QueryEditor = require('./QueryEditor');\n\nvar _VariableEditor = require('./VariableEditor');\n\nvar _ResultViewer = require('./ResultViewer');\n\nvar _DocExplorer = require('./DocExplorer');\n\nvar _utilityFillLeafs = require('../utility/fillLeafs');\n\nvar _utilityElementPosition = require('../utility/elementPosition');\n\nvar _utilityIntrospectionQueries = require('../utility/introspectionQueries');\n\n/**\n * GraphiQL\n *\n * This React component is responsible for rendering the GraphiQL editor.\n *\n * Props:\n *\n *   - fetcher: a function which accepts GraphQL-HTTP parameters and returns\n *     a Promise which resolves to the GraphQL parsed JSON response.\n *\n *   - schema: an optional GraphQLSchema instance. If one is not provided,\n *     GraphiQL will fetch one using introspection.\n *\n *   - query: an optional GraphQL string to use as the initial displayed query,\n *     if not provided, the stored query or defaultQuery will be used.\n *\n *   - response: an optional JSON string to use as the initial displayed\n *     response. If not provided, no response will be initialy shown. You might\n *     provide this if illustrating the result of the initial query.\n *\n *   - storage: an instance of [Storage][] GraphiQL will use to persist state.\n *     Only `getItem` and `setItem` are called. Default: window.localStorage\n *\n *   - defaultQuery: an optional GraphQL string to use instead of a\n *     blank screen when a query was not found in the local cache.\n *\n *   - variables: an optional GraphQL string to use as the initial displayed\n *     query variables, if not provided, the stored variables will be used.\n *\n *   - onEditQuery: an optional function which will be called when the Query\n *     editor changes. The argument to the function will be the query string.\n *\n *   - onEditVariables: an optional function which will be called when the Query\n *     varible editor changes. The argument to the function will be the\n *     variables string.\n *\n *   - getDefaultFieldNames: an optional function used to provide default fields\n *     to non-leaf fields which invalidly lack a selection set.\n *     Accepts a GraphQLType instance and returns an array of field names.\n *     If not provided, a default behavior will be used.\n *\n * Children:\n *\n *   - <GraphiQL.Logo> Replace the GraphiQL logo with your own.\n *\n *   - <GraphiQL.Toolbar> Add a custom toolbar above GraphiQL.\n *\n *   - <GraphiQL.Footer> Add a custom footer below GraphiQL Results.\n *\n *\n * [Storage]: https://developer.mozilla.org/en-US/docs/Web/API/Storage\n */\n\nvar GraphiQL = (function (_React$Component) {\n  _inherits(GraphiQL, _React$Component);\n\n  /**\n   * Inspect the query, automatically filling in selection sets for non-leaf\n   * fields which do not yet have them.\n   *\n   * @public\n   */\n\n  GraphiQL.prototype.autoCompleteLeafs = function autoCompleteLeafs() {\n    var _fillLeafs = _utilityFillLeafs.fillLeafs(this.state.schema, this.state.query, this.props.getDefaultFieldNames);\n\n    var insertions = _fillLeafs.insertions;\n    var result = _fillLeafs.result;\n\n    if (insertions && insertions.length > 0) {\n      var editor = this.refs.queryEditor.getCodeMirror();\n      editor.operation(function () {\n        var cursor = editor.getCursor();\n        var cursorIndex = editor.indexFromPos(cursor);\n        editor.setValue(result);\n        var added = 0;\n        var markers = insertions.map(function (_ref) {\n          var index = _ref.index;\n          var string = _ref.string;\n          return editor.markText(editor.posFromIndex(index + added), editor.posFromIndex(index + (added += string.length)), {\n            className: 'autoInsertedLeaf',\n            clearOnEnter: true,\n            title: 'Automatically added leaf fields'\n          });\n        });\n        setTimeout(function () {\n          return markers.forEach(function (marker) {\n            return marker.clear();\n          });\n        }, 7000);\n        var newCursorIndex = cursorIndex;\n        insertions.forEach(function (_ref2) {\n          var index = _ref2.index;\n          var string = _ref2.string;\n\n          if (index < cursorIndex) {\n            newCursorIndex += string.length;\n          }\n        });\n        var newCursor = editor.posFromIndex(newCursorIndex);\n        editor.setCursor(newCursor);\n      });\n    }\n\n    return result;\n  };\n\n  // Lifecycle\n\n  _createClass(GraphiQL, null, [{\n    key: 'propTypes',\n    value: {\n      fetcher: _react.PropTypes.func.isRequired,\n      schema: _react.PropTypes.instanceOf(_graphqlType.GraphQLSchema),\n      query: _react.PropTypes.string,\n      response: _react.PropTypes.string,\n      storage: _react.PropTypes.shape({\n        getItem: _react.PropTypes.func,\n        setItem: _react.PropTypes.func\n      }),\n      defaultQuery: _react.PropTypes.string,\n      variables: _react.PropTypes.string,\n      onEditQuery: _react.PropTypes.func,\n      onEditVariables: _react.PropTypes.func,\n      getDefaultFieldNames: _react.PropTypes.func\n    },\n    enumerable: true\n  }]);\n\n  function GraphiQL(props) {\n    var _this = this;\n\n    _classCallCheck(this, GraphiQL);\n\n    _React$Component.call(this);\n\n    // Ensure props are correct\n\n    this._runEditorQuery = function () {\n      _this._editorQueryID++;\n      var queryID = _this._editorQueryID;\n\n      // Use the edited query after autoCompleteLeafs() runs or,\n      // in case autoCompletion fails (the function returns undefined),\n      // the current query from the editor.\n      var editedQuery = _this.autoCompleteLeafs() || _this.state.query;\n\n      _this._fetchQuery(editedQuery, _this.state.variables, function (result) {\n        if (queryID === _this._editorQueryID) {\n          _this.setState({ response: JSON.stringify(result, null, 2) });\n        }\n      });\n    };\n\n    this._onEditQuery = function (value) {\n      _this._storageSet('query', value);\n      _this.setState({ query: value });\n      if (_this.props.onEditQuery) {\n        return _this.props.onEditQuery(value);\n      }\n    };\n\n    this._onEditVariables = function (value) {\n      _this._storageSet('variables', value);\n      _this.setState({ variables: value });\n      if (_this.props.onEditVariables) {\n        _this.props.onEditVariables(value);\n      }\n    };\n\n    this._onHintInformationRender = function (elem) {\n      elem.addEventListener('click', _this._onClickHintInformation);\n\n      var onRemoveFn;\n      elem.addEventListener('DOMNodeRemoved', onRemoveFn = function () {\n        elem.removeEventListener('DOMNodeRemoved', onRemoveFn);\n        elem.removeEventListener('click', _this._onClickHintInformation);\n      });\n    };\n\n    this._onClickHintInformation = function (event) {\n      if (event.target.className === 'typeName') {\n        var typeName = event.target.innerHTML;\n        var schema = _this.state.schema;\n        if (schema) {\n          var type = schema.getType(typeName);\n          if (type) {\n            _this.setState({ docsOpen: true }, function () {\n              _this.refs.docExplorer.showDoc(type);\n            });\n          }\n        }\n      }\n    };\n\n    this._onToggleDocs = function () {\n      _this.setState({ docsOpen: !_this.state.docsOpen });\n    };\n\n    this._onResizeStart = function (downEvent) {\n      if (!_this._didClickDragBar(downEvent)) {\n        return;\n      }\n\n      downEvent.preventDefault();\n\n      var offset = downEvent.clientX - _utilityElementPosition.getLeft(downEvent.target);\n\n      var onMouseMove = function onMouseMove(moveEvent) {\n        if (moveEvent.buttons === 0) {\n          return onMouseUp();\n        }\n\n        var editorBar = _reactDom2['default'].findDOMNode(_this.refs.editorBar);\n        var leftSize = moveEvent.clientX - _utilityElementPosition.getLeft(editorBar) - offset;\n        var rightSize = editorBar.clientWidth - leftSize;\n        _this.setState({ editorFlex: leftSize / rightSize });\n      };\n\n      var onMouseUp = (function (_onMouseUp) {\n        function onMouseUp() {\n          return _onMouseUp.apply(this, arguments);\n        }\n\n        onMouseUp.toString = function () {\n          return _onMouseUp.toString();\n        };\n\n        return onMouseUp;\n      })(function () {\n        _this._storageSet('editorFlex', _this.state.editorFlex);\n\n        document.removeEventListener('mousemove', onMouseMove);\n        document.removeEventListener('mouseup', onMouseUp);\n        onMouseMove = null;\n        onMouseUp = null;\n      });\n\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', onMouseUp);\n    };\n\n    this._onDocsResizeStart = function (downEvent) {\n      downEvent.preventDefault();\n\n      var hadWidth = _this.state.docsWidth;\n      var offset = downEvent.clientX - _utilityElementPosition.getLeft(downEvent.target);\n\n      var onMouseMove = function onMouseMove(moveEvent) {\n        if (moveEvent.buttons === 0) {\n          return onMouseUp();\n        }\n\n        var app = _reactDom2['default'].findDOMNode(_this);\n        var cursorPos = moveEvent.clientX - _utilityElementPosition.getLeft(app) - offset;\n        var docsSize = app.clientWidth - cursorPos;\n\n        if (docsSize < 100) {\n          _this.setState({ docsOpen: false });\n        } else {\n          _this.setState({\n            docsOpen: true,\n            docsWidth: Math.min(docsSize, 650)\n          });\n        }\n      };\n\n      var onMouseUp = (function (_onMouseUp2) {\n        function onMouseUp() {\n          return _onMouseUp2.apply(this, arguments);\n        }\n\n        onMouseUp.toString = function () {\n          return _onMouseUp2.toString();\n        };\n\n        return onMouseUp;\n      })(function () {\n        if (_this.state.docsOpen) {\n          _this._storageSet('docExplorerWidth', _this.state.docsWidth);\n        } else {\n          _this.setState({ docsWidth: hadWidth });\n        }\n\n        document.removeEventListener('mousemove', onMouseMove);\n        document.removeEventListener('mouseup', onMouseUp);\n        onMouseMove = null;\n        onMouseUp = null;\n      });\n\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', onMouseUp);\n    };\n\n    this._onVariableResizeStart = function (downEvent) {\n      downEvent.preventDefault();\n\n      var didMove = false;\n      var wasOpen = _this.state.variableEditorOpen;\n      var hadHeight = _this.state.variableEditorHeight;\n      var offset = downEvent.clientY - _utilityElementPosition.getTop(downEvent.target);\n\n      var onMouseMove = function onMouseMove(moveEvent) {\n        if (moveEvent.buttons === 0) {\n          return onMouseUp();\n        }\n\n        didMove = true;\n\n        var editorBar = _reactDom2['default'].findDOMNode(_this.refs.editorBar);\n        var topSize = moveEvent.clientY - _utilityElementPosition.getTop(editorBar) - offset;\n        var bottomSize = editorBar.clientHeight - topSize;\n        if (bottomSize < 60) {\n          _this.setState({\n            variableEditorOpen: false,\n            variableEditorHeight: hadHeight\n          });\n        } else {\n          _this.setState({\n            variableEditorOpen: true,\n            variableEditorHeight: bottomSize\n          });\n        }\n      };\n\n      var onMouseUp = (function (_onMouseUp3) {\n        function onMouseUp() {\n          return _onMouseUp3.apply(this, arguments);\n        }\n\n        onMouseUp.toString = function () {\n          return _onMouseUp3.toString();\n        };\n\n        return onMouseUp;\n      })(function () {\n        if (didMove) {\n          _this._storageSet('variableEditorHeight', _this.state.variableEditorHeight);\n        } else {\n          _this.setState({ variableEditorOpen: !wasOpen });\n        }\n\n        document.removeEventListener('mousemove', onMouseMove);\n        document.removeEventListener('mouseup', onMouseUp);\n        onMouseMove = null;\n        onMouseUp = null;\n      });\n\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', onMouseUp);\n    };\n\n    if (typeof props.fetcher !== 'function') {\n      throw new TypeError('GraphiQL requires a fetcher function.');\n    }\n\n    // Cache the storage instance\n    this._storage = props.storage || window.localStorage;\n\n    // Determine the initial query to display.\n    var query = props.query || this._storageGet('query') || props.defaultQuery || defaultQuery;\n\n    // Determine the initial variables to display.\n    var variables = props.variables || this._storageGet('variables');\n\n    // Initialize state\n    this.state = {\n      schema: props.schema,\n      query: query,\n      variables: variables,\n      response: props.response,\n      editorFlex: this._storageGet('editorFlex') || 1,\n      variableEditorOpen: Boolean(variables),\n      variableEditorHeight: this._storageGet('variableEditorHeight') || 200,\n      docsOpen: false,\n      docsWidth: this._storageGet('docExplorerWidth') || 350\n    };\n\n    // Ensure only the last executed editor query is rendered.\n    this._editorQueryID = 0;\n  }\n\n  // Configure the UI by providing this Component as a child of GraphiQL.\n\n  GraphiQL.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var nextQuery = this.state.query;\n    var nextVariables = this.state.variables;\n    var nextResponse = this.state.response;\n    if (nextProps.query && nextProps.query !== nextQuery) {\n      nextQuery = nextProps.query;\n    }\n    if (nextProps.variables && nextProps.variables !== nextVariables) {\n      nextVariables = nextProps.variables;\n    }\n    if (nextProps.response && nextProps.response !== nextResponse) {\n      nextResponse = nextProps.response;\n    }\n    this.setState({\n      query: nextQuery,\n      variables: nextVariables,\n      response: nextResponse\n    });\n  };\n\n  GraphiQL.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    if (!this.state.schema) {\n      var fetcher = this.props.fetcher;\n\n      // Try the stock introspection query first, falling back on the\n      // sans-subscriptions query for services which do not yet support it.\n      fetcher({ query: _utilityIntrospectionQueries.introspectionQuery })['catch'](function () {\n        return fetcher({ query: _utilityIntrospectionQueries.introspectionQuerySansSubscriptions });\n      }).then(function (result) {\n        if (!result.data) {\n          _this2.setState({ response: JSON.stringify(result, null, 2) });\n        } else {\n          _this2.setState({ schema: _graphqlUtilities.buildClientSchema(result.data) });\n        }\n      })['catch'](function (error) {\n        _this2.setState({ response: error && error.stack || error });\n      });\n    }\n  };\n\n  GraphiQL.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    // When UI-altering state changes, simulate a window resize event so all\n    // CodeMirror instances become properly rendered.\n    if (this.state.variableEditorOpen !== prevState.variableEditorOpen || this.state.variableEditorHeight !== prevState.variableEditorHeight) {\n      window.dispatchEvent(new Event('resize'));\n    }\n  };\n\n  GraphiQL.prototype.render = function render() {\n    var children = [];\n    _react2['default'].Children.forEach(this.props.children, function (child) {\n      children.push(child);\n    });\n\n    var logo = _graphqlJsutilsFind2['default'](children, function (child) {\n      return child.type === GraphiQL.Logo;\n    }) || _react2['default'].createElement(GraphiQL.Logo, null);\n\n    var toolbar = _graphqlJsutilsFind2['default'](children, function (child) {\n      return child.type === GraphiQL.Toolbar;\n    });\n    var footer = _graphqlJsutilsFind2['default'](children, function (child) {\n      return child.type === GraphiQL.Footer;\n    });\n\n    var queryWrapStyle = {\n      WebkitFlex: this.state.editorFlex,\n      flex: this.state.editorFlex\n    };\n\n    var docWrapStyle = {\n      display: this.state.docsOpen ? 'block' : 'none',\n      width: this.state.docsWidth\n    };\n\n    var variableOpen = this.state.variableEditorOpen;\n    var variableStyle = {\n      height: variableOpen ? this.state.variableEditorHeight : null\n    };\n\n    return _react2['default'].createElement(\n      'div',\n      { id: 'graphiql-container' },\n      _react2['default'].createElement(\n        'div',\n        { className: 'editorWrap' },\n        _react2['default'].createElement(\n          'div',\n          { className: 'topBarWrap' },\n          _react2['default'].createElement(\n            'div',\n            { className: 'topBar' },\n            logo,\n            _react2['default'].createElement(_ExecuteButton.ExecuteButton, { onClick: this._runEditorQuery }),\n            toolbar\n          ),\n          !this.state.docsOpen && _react2['default'].createElement(\n            'button',\n            { className: 'docExplorerShow', onClick: this._onToggleDocs },\n            'Docs'\n          )\n        ),\n        _react2['default'].createElement(\n          'div',\n          {\n            ref: 'editorBar',\n            className: 'editorBar',\n            onMouseDown: this._onResizeStart\n          },\n          _react2['default'].createElement(\n            'div',\n            { className: 'queryWrap', style: queryWrapStyle },\n            _react2['default'].createElement(_QueryEditor.QueryEditor, {\n              ref: 'queryEditor',\n              schema: this.state.schema,\n              value: this.state.query,\n              onEdit: this._onEditQuery,\n              onHintInformationRender: this._onHintInformationRender\n            }),\n            _react2['default'].createElement(\n              'div',\n              { className: 'variable-editor', style: variableStyle },\n              _react2['default'].createElement(\n                'div',\n                {\n                  className: 'variable-editor-title',\n                  style: { cursor: variableOpen ? 'row-resize' : 'n-resize' },\n                  onMouseDown: this._onVariableResizeStart\n                },\n                'Query Variables'\n              ),\n              _react2['default'].createElement(_VariableEditor.VariableEditor, {\n                value: this.state.variables,\n                onEdit: this._onEditVariables\n              })\n            )\n          ),\n          _react2['default'].createElement(\n            'div',\n            { className: 'resultWrap' },\n            _react2['default'].createElement(_ResultViewer.ResultViewer, { ref: 'result', value: this.state.response }),\n            footer\n          )\n        )\n      ),\n      _react2['default'].createElement(\n        'div',\n        { className: 'docExplorerWrap', style: docWrapStyle },\n        _react2['default'].createElement('div', {\n          className: 'docExplorerResizer',\n          onMouseDown: this._onDocsResizeStart\n        }),\n        _react2['default'].createElement(\n          _DocExplorer.DocExplorer,\n          { ref: 'docExplorer', schema: this.state.schema },\n          _react2['default'].createElement(\n            'div',\n            { className: 'docExplorerHide', onClick: this._onToggleDocs },\n            '✕'\n          )\n        )\n      )\n    );\n  };\n\n  // Private methods\n\n  GraphiQL.prototype._storageGet = function _storageGet(name) {\n    return this._storage.getItem('graphiql:' + name);\n  };\n\n  GraphiQL.prototype._storageSet = function _storageSet(name, value) {\n    this._storage.setItem('graphiql:' + name, value);\n  };\n\n  GraphiQL.prototype._fetchQuery = function _fetchQuery(query, variables, cb) {\n    var _this3 = this;\n\n    this.props.fetcher({ query: query, variables: variables }).then(cb)['catch'](function (error) {\n      _this3.setState({ response: error && error.stack || error });\n    });\n  };\n\n  GraphiQL.prototype._didClickDragBar = function _didClickDragBar(event) {\n    // Only for primary unmodified clicks\n    if (event.button !== 0 || event.ctrlKey) {\n      return false;\n    }\n    var target = event.target;\n    // We use codemirror's gutter as the drag bar.\n    if (target.className.indexOf('CodeMirror-gutter') !== 0) {\n      return false;\n    }\n    // Specifically the result window's drag bar.\n    var resultWindow = _reactDom2['default'].findDOMNode(this.refs.result);\n    while (target) {\n      if (target === resultWindow) {\n        return true;\n      }\n      target = target.parentNode;\n    }\n    return false;\n  };\n\n  return GraphiQL;\n})(_react2['default'].Component);\n\nexports.GraphiQL = GraphiQL;\nGraphiQL.Logo = (function (_React$Component2) {\n  _inherits(GraphiQLLogo, _React$Component2);\n\n  function GraphiQLLogo() {\n    _classCallCheck(this, GraphiQLLogo);\n\n    _React$Component2.apply(this, arguments);\n  }\n\n  GraphiQLLogo.prototype.render = function render() {\n    return _react2['default'].createElement(\n      'div',\n      { className: 'title' },\n      this.props.children || _react2['default'].createElement(\n        'span',\n        null,\n        'Graph',\n        _react2['default'].createElement(\n          'em',\n          null,\n          'i'\n        ),\n        'QL'\n      )\n    );\n  };\n\n  return GraphiQLLogo;\n})(_react2['default'].Component);\n\n// Configure the UI by providing this Component as a child of GraphiQL.\nGraphiQL.Toolbar = (function (_React$Component3) {\n  _inherits(GraphiQLToolbar, _React$Component3);\n\n  function GraphiQLToolbar() {\n    _classCallCheck(this, GraphiQLToolbar);\n\n    _React$Component3.apply(this, arguments);\n  }\n\n  GraphiQLToolbar.prototype.render = function render() {\n    return _react2['default'].createElement(\n      'div',\n      { className: 'toolbar' },\n      this.props.children\n    );\n  };\n\n  return GraphiQLToolbar;\n})(_react2['default'].Component);\n\n// Configure the UI by providing this Component as a child of GraphiQL.\nGraphiQL.Footer = (function (_React$Component4) {\n  _inherits(GraphiQLFooter, _React$Component4);\n\n  function GraphiQLFooter() {\n    _classCallCheck(this, GraphiQLFooter);\n\n    _React$Component4.apply(this, arguments);\n  }\n\n  GraphiQLFooter.prototype.render = function render() {\n    return _react2['default'].createElement(\n      'div',\n      { className: 'footer' },\n      this.props.children\n    );\n  };\n\n  return GraphiQLFooter;\n})(_react2['default'].Component);\n\nvar defaultQuery = '# Welcome to GraphiQL\\n#\\n# GraphiQL is an in-browser IDE for writing, validating, and\\n# testing GraphQL queries.\\n#\\n# Type queries into this side of the screen, and you will\\n# see intelligent typeaheads aware of the current GraphQL type schema and\\n# live syntax and validation errors highlighted within the text.\\n#\\n# To bring up the auto-complete at any point, just press Ctrl-Space.\\n#\\n# Press the run button above, or Cmd-Enter to execute the query, and the result\\n# will appear in the pane to the right.\\n\\n';\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/components/GraphiQL.js\n ** module id = 411\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n// GraphQL Schema definition\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _schema = require('./schema');\n\nObject.defineProperty(exports, 'GraphQLSchema', {\n  enumerable: true,\n  get: function get() {\n    return _schema.GraphQLSchema;\n  }\n});\n\nvar _definition = require('./definition');\n\nObject.defineProperty(exports, 'isType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.isType;\n  }\n});\nObject.defineProperty(exports, 'isInputType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.isInputType;\n  }\n});\nObject.defineProperty(exports, 'isOutputType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.isOutputType;\n  }\n});\nObject.defineProperty(exports, 'isLeafType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.isLeafType;\n  }\n});\nObject.defineProperty(exports, 'isCompositeType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.isCompositeType;\n  }\n});\nObject.defineProperty(exports, 'isAbstractType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.isAbstractType;\n  }\n});\nObject.defineProperty(exports, 'getNullableType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.getNullableType;\n  }\n});\nObject.defineProperty(exports, 'getNamedType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.getNamedType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLScalarType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLScalarType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLObjectType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLObjectType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLInterfaceType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLInterfaceType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLUnionType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLUnionType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLEnumType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLEnumType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLInputObjectType', {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLInputObjectType;\n  }\n});\nObject.defineProperty(exports, 'GraphQLList', {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLList;\n  }\n});\nObject.defineProperty(exports, 'GraphQLNonNull', {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLNonNull;\n  }\n});\n\n// Common built-in scalar instances.\n\nvar _scalars = require('./scalars');\n\nObject.defineProperty(exports, 'GraphQLInt', {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLInt;\n  }\n});\nObject.defineProperty(exports, 'GraphQLFloat', {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLFloat;\n  }\n});\nObject.defineProperty(exports, 'GraphQLString', {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLString;\n  }\n});\nObject.defineProperty(exports, 'GraphQLBoolean', {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLBoolean;\n  }\n});\nObject.defineProperty(exports, 'GraphQLID', {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLID;\n  }\n});\n\n// Predicates\n\n// Un-modifiers\n\n// Definitions\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/type/index.js\n ** module id = 412\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n// The GraphQL query recommended for a full schema introspection.\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _introspectionQuery = require('./introspectionQuery');\n\nObject.defineProperty(exports, 'introspectionQuery', {\n  enumerable: true,\n  get: function get() {\n    return _introspectionQuery.introspectionQuery;\n  }\n});\n\n// Gets the target Operation from a Document\n\nvar _getOperationAST = require('./getOperationAST');\n\nObject.defineProperty(exports, 'getOperationAST', {\n  enumerable: true,\n  get: function get() {\n    return _getOperationAST.getOperationAST;\n  }\n});\n\n// Build a GraphQLSchema from an introspection result.\n\nvar _buildClientSchema = require('./buildClientSchema');\n\nObject.defineProperty(exports, 'buildClientSchema', {\n  enumerable: true,\n  get: function get() {\n    return _buildClientSchema.buildClientSchema;\n  }\n});\n\n// Build a GraphQLSchema from a parsed GraphQL Schema language AST.\n\nvar _buildASTSchema = require('./buildASTSchema');\n\nObject.defineProperty(exports, 'buildASTSchema', {\n  enumerable: true,\n  get: function get() {\n    return _buildASTSchema.buildASTSchema;\n  }\n});\n\n// Extends an existing GraphQLSchema from a parsed GraphQL Schema language AST.\n\nvar _extendSchema = require('./extendSchema');\n\nObject.defineProperty(exports, 'extendSchema', {\n  enumerable: true,\n  get: function get() {\n    return _extendSchema.extendSchema;\n  }\n});\n\n// Print a GraphQLSchema to GraphQL Schema language.\n\nvar _schemaPrinter = require('./schemaPrinter');\n\nObject.defineProperty(exports, 'printSchema', {\n  enumerable: true,\n  get: function get() {\n    return _schemaPrinter.printSchema;\n  }\n});\nObject.defineProperty(exports, 'printIntrospectionSchema', {\n  enumerable: true,\n  get: function get() {\n    return _schemaPrinter.printIntrospectionSchema;\n  }\n});\n\n// Create a GraphQLType from a GraphQL language AST.\n\nvar _typeFromAST = require('./typeFromAST');\n\nObject.defineProperty(exports, 'typeFromAST', {\n  enumerable: true,\n  get: function get() {\n    return _typeFromAST.typeFromAST;\n  }\n});\n\n// Create a JavaScript value from a GraphQL language AST.\n\nvar _valueFromAST = require('./valueFromAST');\n\nObject.defineProperty(exports, 'valueFromAST', {\n  enumerable: true,\n  get: function get() {\n    return _valueFromAST.valueFromAST;\n  }\n});\n\n// Create a GraphQL language AST from a JavaScript value.\n\nvar _astFromValue = require('./astFromValue');\n\nObject.defineProperty(exports, 'astFromValue', {\n  enumerable: true,\n  get: function get() {\n    return _astFromValue.astFromValue;\n  }\n});\n\n// A helper to use within recursive-descent visitors which need to be aware of\n// the GraphQL type system.\n\nvar _TypeInfo = require('./TypeInfo');\n\nObject.defineProperty(exports, 'TypeInfo', {\n  enumerable: true,\n  get: function get() {\n    return _TypeInfo.TypeInfo;\n  }\n});\n\n// Determine if JavaScript values adhere to a GraphQL type.\n\nvar _isValidJSValue = require('./isValidJSValue');\n\nObject.defineProperty(exports, 'isValidJSValue', {\n  enumerable: true,\n  get: function get() {\n    return _isValidJSValue.isValidJSValue;\n  }\n});\n\n// Determine if AST values adhere to a GraphQL type.\n\nvar _isValidLiteralValue = require('./isValidLiteralValue');\n\nObject.defineProperty(exports, 'isValidLiteralValue', {\n  enumerable: true,\n  get: function get() {\n    return _isValidLiteralValue.isValidLiteralValue;\n  }\n});\n\n// Concatenates multiple AST together.\n\nvar _concatAST = require('./concatAST');\n\nObject.defineProperty(exports, 'concatAST', {\n  enumerable: true,\n  get: function get() {\n    return _concatAST.concatAST;\n  }\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/index.js\n ** module id = 413\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar introspectionQuery = '\\n  query IntrospectionQuery {\\n    __schema {\\n      queryType { name }\\n      mutationType { name }\\n      subscriptionType { name }\\n      types {\\n        ...FullType\\n      }\\n      directives {\\n        name\\n        description\\n        args {\\n          ...InputValue\\n        }\\n        onOperation\\n        onFragment\\n        onField\\n      }\\n    }\\n  }\\n\\n  fragment FullType on __Type {\\n    kind\\n    name\\n    description\\n    fields(includeDeprecated: true) {\\n      name\\n      description\\n      args {\\n        ...InputValue\\n      }\\n      type {\\n        ...TypeRef\\n      }\\n      isDeprecated\\n      deprecationReason\\n    }\\n    inputFields {\\n      ...InputValue\\n    }\\n    interfaces {\\n      ...TypeRef\\n    }\\n    enumValues(includeDeprecated: true) {\\n      name\\n      description\\n      isDeprecated\\n      deprecationReason\\n    }\\n    possibleTypes {\\n      ...TypeRef\\n    }\\n  }\\n\\n  fragment InputValue on __InputValue {\\n    name\\n    description\\n    type { ...TypeRef }\\n    defaultValue\\n  }\\n\\n  fragment TypeRef on __Type {\\n    kind\\n    name\\n    ofType {\\n      kind\\n      name\\n      ofType {\\n        kind\\n        name\\n        ofType {\\n          kind\\n          name\\n        }\\n      }\\n    }\\n  }\\n';\n\nexports.introspectionQuery = introspectionQuery;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/introspectionQuery.js\n ** module id = 414\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getOperationAST = getOperationAST;\n\nvar _languageKinds = require('../language/kinds');\n\nfunction getOperationAST(documentAST, operationName) {\n  var operation = null;\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var definition = documentAST.definitions[i];\n    if (definition.kind === _languageKinds.OPERATION_DEFINITION) {\n      if (!operationName) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n        operation = definition;\n      } else if (definition.name && definition.name.value === operationName) {\n        return definition;\n      }\n    }\n  }\n  return operation;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/getOperationAST.js\n ** module id = 415\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.buildClientSchema = buildClientSchema;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsKeyMap = require('../jsutils/keyMap');\n\nvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\nvar _jsutilsKeyValMap = require('../jsutils/keyValMap');\n\nvar _jsutilsKeyValMap2 = _interopRequireDefault(_jsutilsKeyValMap);\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _languageParser = require('../language/parser');\n\nvar _typeSchema = require('../type/schema');\n\nvar _typeDefinition = require('../type/definition');\n\nvar _typeScalars = require('../type/scalars');\n\nvar _typeDirectives = require('../type/directives');\n\nvar _typeIntrospection = require('../type/introspection');\n\nfunction buildClientSchema(introspection) {\n\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema;\n\n  // Converts the list of types into a keyMap based on the type names.\n  var typeIntrospectionMap = (0, _jsutilsKeyMap2['default'])(schemaIntrospection.types, function (type) {\n    return type.name;\n  });\n\n  // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n  var typeDefCache = {\n    String: _typeScalars.GraphQLString,\n    Int: _typeScalars.GraphQLInt,\n    Float: _typeScalars.GraphQLFloat,\n    Boolean: _typeScalars.GraphQLBoolean,\n    ID: _typeScalars.GraphQLID\n  };\n\n  // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n  function getType(typeRef) {\n    if (typeRef.kind === _typeIntrospection.TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      return new _typeDefinition.GraphQLList(getType(itemRef));\n    }\n    if (typeRef.kind === _typeIntrospection.TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      var nullableType = getType(nullableRef);\n      return new _typeDefinition.GraphQLNonNull(nullableType);\n    }\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n    var typeIntrospection = typeIntrospectionMap[typeName];\n    if (!typeIntrospection) {\n      throw new Error('Invalid or incomplete schema, unknown type: ' + typeName + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    (0, _jsutilsInvariant2['default'])((0, _typeDefinition.isInputType)(type), 'Introspection must provide input type for arguments.');\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    (0, _jsutilsInvariant2['default'])((0, _typeDefinition.isOutputType)(type), 'Introspection must provide output type for fields.');\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLObjectType, 'Introspection must provide object type for possibleTypes.');\n    return type;\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLInterfaceType, 'Introspection must provide interface type for interfaces.');\n    return type;\n  }\n\n  // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n  function buildType(type) {\n    switch (type.kind) {\n      case _typeIntrospection.TypeKind.SCALAR:\n        return buildScalarDef(type);\n      case _typeIntrospection.TypeKind.OBJECT:\n        return buildObjectDef(type);\n      case _typeIntrospection.TypeKind.INTERFACE:\n        return buildInterfaceDef(type);\n      case _typeIntrospection.TypeKind.UNION:\n        return buildUnionDef(type);\n      case _typeIntrospection.TypeKind.ENUM:\n        return buildEnumDef(type);\n      case _typeIntrospection.TypeKind.INPUT_OBJECT:\n        return buildInputObjectDef(type);\n      default:\n        throw new Error('Invalid or incomplete schema, unknown kind: ' + type.kind + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new _typeDefinition.GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize() {\n        return null;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new _typeDefinition.GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new _typeDefinition.GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      },\n      resolveType: function resolveType() {\n        throw new Error('Client Schema cannot be used for execution.');\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    return new _typeDefinition.GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType),\n      resolveType: function resolveType() {\n        throw new Error('Client Schema cannot be used for execution.');\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    return new _typeDefinition.GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: (0, _jsutilsKeyValMap2['default'])(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    return new _typeDefinition.GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    return (0, _jsutilsKeyValMap2['default'])(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args),\n        resolve: function resolve() {\n          throw new Error('Client Schema cannot be used for execution.');\n        }\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return (0, _jsutilsKeyValMap2['default'])(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? (0, _valueFromAST.valueFromAST)((0, _languageParser.parseValue)(inputValueIntrospection.defaultValue), type) : null;\n    return {\n      name: inputValueIntrospection.name,\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    return new _typeDirectives.GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      args: directiveIntrospection.args.map(buildInputValue),\n      onOperation: directiveIntrospection.onOperation,\n      onFragment: directiveIntrospection.onFragment,\n      onField: directiveIntrospection.onField\n    });\n  }\n\n  // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n  schemaIntrospection.types.forEach(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  });\n\n  // Get the root Query, Mutation, and Subscription types.\n  var queryType = getObjectType(schemaIntrospection.queryType);\n\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;\n\n  // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];\n\n  // Then produce and return a Schema with these types.\n  return new _typeSchema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    directives: directives\n  });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/buildClientSchema.js\n ** module id = 416\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Creates a keyed JS object from an array, given a function to produce the keys\n * and a function to produce the values from each item in the array.\n *\n *     var phoneBook = [\n *       { name: 'Jon', num: '555-1234' },\n *       { name: 'Jenny', num: '867-5309' }\n *     ]\n *\n *     // { Jon: '555-1234', Jenny: '867-5309' }\n *     var phonesByName = keyValMap(\n *       phoneBook,\n *       entry => entry.name,\n *       entry => entry.num\n *     )\n *\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = keyValMap;\n\nfunction keyValMap(list, keyFn, valFn) {\n  return list.reduce(function (map, item) {\n    return (map[keyFn(item)] = valFn(item), map);\n  }, {});\n}\n\nmodule.exports = exports[\"default\"];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/jsutils/keyValMap.js\n ** module id = 417\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.buildASTSchema = buildASTSchema;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\nvar _jsutilsKeyMap = require('../jsutils/keyMap');\n\nvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\nvar _jsutilsKeyValMap = require('../jsutils/keyValMap');\n\nvar _jsutilsKeyValMap2 = _interopRequireDefault(_jsutilsKeyValMap);\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _languageKinds = require('../language/kinds');\n\nvar _type = require('../type');\n\nfunction buildWrappedType(innerType, inputTypeAST) {\n  if (inputTypeAST.kind === _languageKinds.LIST_TYPE) {\n    return new _type.GraphQLList(buildWrappedType(innerType, inputTypeAST.type));\n  }\n  if (inputTypeAST.kind === _languageKinds.NON_NULL_TYPE) {\n    return new _type.GraphQLNonNull(buildWrappedType(innerType, inputTypeAST.type));\n  }\n  return innerType;\n}\n\nfunction getInnerTypeName(_x) {\n  var _again = true;\n\n  _function: while (_again) {\n    var typeAST = _x;\n    _again = false;\n\n    if (typeAST.kind === _languageKinds.LIST_TYPE || typeAST.kind === _languageKinds.NON_NULL_TYPE) {\n      _x = typeAST.type;\n      _again = true;\n      continue _function;\n    }\n    return typeAST.name.value;\n  }\n}\n\n/**\n * This takes the ast of a schema document produced by parseSchema in\n * src/language/schema/parser.js.\n *\n * Given that AST it constructs a GraphQLSchema. As constructed\n * they are not particularly useful for non-introspection queries\n * since they have no resolve methods.\n */\n\nfunction buildASTSchema(ast, queryTypeName, mutationTypeName, subscriptionTypeName) {\n\n  if ((0, _jsutilsIsNullish2['default'])(ast)) {\n    throw new Error('must pass in ast');\n  }\n  if ((0, _jsutilsIsNullish2['default'])(queryTypeName)) {\n    throw new Error('must pass in query type');\n  }\n\n  var typeDefs = ast.definitions.filter(function (d) {\n    switch (d.kind) {\n      case _languageKinds.OBJECT_TYPE_DEFINITION:\n      case _languageKinds.INTERFACE_TYPE_DEFINITION:\n      case _languageKinds.ENUM_TYPE_DEFINITION:\n      case _languageKinds.UNION_TYPE_DEFINITION:\n      case _languageKinds.SCALAR_TYPE_DEFINITION:\n      case _languageKinds.INPUT_OBJECT_TYPE_DEFINITION:\n        return true;\n    }\n  });\n\n  var astMap = (0, _jsutilsKeyMap2['default'])(typeDefs, function (d) {\n    return d.name.value;\n  });\n\n  if ((0, _jsutilsIsNullish2['default'])(astMap[queryTypeName])) {\n    throw new Error('Specified query type ' + queryTypeName + ' not found in document.');\n  }\n\n  if (!(0, _jsutilsIsNullish2['default'])(mutationTypeName) && (0, _jsutilsIsNullish2['default'])(astMap[mutationTypeName])) {\n    throw new Error('Specified mutation type ' + mutationTypeName + ' not found in document.');\n  }\n\n  if (!(0, _jsutilsIsNullish2['default'])(subscriptionTypeName) && (0, _jsutilsIsNullish2['default'])(astMap[subscriptionTypeName])) {\n    throw new Error('Specified subscription type ' + subscriptionTypeName + ' not found in document.');\n  }\n\n  /**\n   * This generates a function that allows you to produce\n   * type definitions on demand. We produce the function\n   * in order to close over the memoization dictionaries\n   * that need to be retained over multiple functions calls.\n   **/\n  function getTypeDefProducer() {\n\n    var innerTypeMap = {\n      String: _type.GraphQLString,\n      Int: _type.GraphQLInt,\n      Float: _type.GraphQLFloat,\n      Boolean: _type.GraphQLBoolean,\n      ID: _type.GraphQLID\n    };\n\n    return function (typeAST) {\n      var typeName = getInnerTypeName(typeAST);\n      if (!(0, _jsutilsIsNullish2['default'])(innerTypeMap[typeName])) {\n        return buildWrappedType(innerTypeMap[typeName], typeAST);\n      }\n\n      if ((0, _jsutilsIsNullish2['default'])(astMap[typeName])) {\n        throw new Error('Type ' + typeName + ' not found in document');\n      }\n\n      var innerTypeDef = makeSchemaDef(astMap[typeName]);\n      if ((0, _jsutilsIsNullish2['default'])(innerTypeDef)) {\n        throw new Error('Nothing constructed for ' + typeName);\n      }\n      innerTypeMap[typeName] = innerTypeDef;\n      return buildWrappedType(innerTypeDef, typeAST);\n    };\n  }\n\n  var produceTypeDef = getTypeDefProducer(ast);\n\n  ast.definitions.forEach(produceTypeDef);\n\n  var queryType = produceTypeDef(astMap[queryTypeName]);\n\n  var schemaBody = {\n    query: queryType\n  };\n\n  if (!(0, _jsutilsIsNullish2['default'])(mutationTypeName)) {\n    schemaBody.mutation = produceTypeDef(astMap[mutationTypeName]);\n  }\n\n  if (!(0, _jsutilsIsNullish2['default'])(subscriptionTypeName)) {\n    schemaBody.subscription = produceTypeDef(astMap[subscriptionTypeName]);\n  }\n\n  return new _type.GraphQLSchema(schemaBody);\n\n  function makeSchemaDef(def) {\n    if ((0, _jsutilsIsNullish2['default'])(def)) {\n      throw new Error('def must be defined');\n    }\n    switch (def.kind) {\n      case _languageKinds.OBJECT_TYPE_DEFINITION:\n        return makeTypeDef(def);\n      case _languageKinds.INTERFACE_TYPE_DEFINITION:\n        return makeInterfaceDef(def);\n      case _languageKinds.ENUM_TYPE_DEFINITION:\n        return makeEnumDef(def);\n      case _languageKinds.UNION_TYPE_DEFINITION:\n        return makeUnionDef(def);\n      case _languageKinds.SCALAR_TYPE_DEFINITION:\n        return makeScalarDef(def);\n      case _languageKinds.INPUT_OBJECT_TYPE_DEFINITION:\n        return makeInputObjectDef(def);\n      default:\n        throw new Error(def.kind + ' not supported');\n    }\n  }\n\n  function makeTypeDef(def) {\n    var typeName = def.name.value;\n    var config = {\n      name: typeName,\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      },\n      interfaces: function interfaces() {\n        return makeImplementedInterfaces(def);\n      }\n    };\n    return new _type.GraphQLObjectType(config);\n  }\n\n  function makeFieldDefMap(def) {\n    return (0, _jsutilsKeyValMap2['default'])(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: produceTypeDef(field.type),\n        args: makeInputValues(field.arguments)\n      };\n    });\n  }\n\n  function makeImplementedInterfaces(def) {\n    return def.interfaces.map(function (inter) {\n      return produceTypeDef(inter);\n    });\n  }\n\n  function makeInputValues(values) {\n    return (0, _jsutilsKeyValMap2['default'])(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = produceTypeDef(value.type);\n      return { type: type, defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type) };\n    });\n  }\n\n  function makeInterfaceDef(def) {\n    var typeName = def.name.value;\n    var config = {\n      name: typeName,\n      resolveType: function resolveType() {\n        return null;\n      },\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      }\n    };\n    return new _type.GraphQLInterfaceType(config);\n  }\n\n  function makeEnumDef(def) {\n    var enumType = new _type.GraphQLEnumType({\n      name: def.name.value,\n      values: (0, _jsutilsKeyValMap2['default'])(def.values, function (v) {\n        return v.name.value;\n      }, function () {\n        return {};\n      })\n    });\n\n    return enumType;\n  }\n\n  function makeUnionDef(def) {\n    return new _type.GraphQLUnionType({\n      name: def.name.value,\n      resolveType: function resolveType() {\n        return null;\n      },\n      types: def.types.map(function (t) {\n        return produceTypeDef(t);\n      })\n    });\n  }\n\n  function makeScalarDef(def) {\n    return new _type.GraphQLScalarType({\n      name: def.name.value,\n      serialize: function serialize() {\n        return null;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function makeInputObjectDef(def) {\n    return new _type.GraphQLInputObjectType({\n      name: def.name.value,\n      fields: function fields() {\n        return makeInputValues(def.fields);\n      }\n    });\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/buildASTSchema.js\n ** module id = 418\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.extendSchema = extendSchema;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsKeyMap = require('../jsutils/keyMap');\n\nvar _jsutilsKeyMap2 = _interopRequireDefault(_jsutilsKeyMap);\n\nvar _jsutilsKeyValMap = require('../jsutils/keyValMap');\n\nvar _jsutilsKeyValMap2 = _interopRequireDefault(_jsutilsKeyValMap);\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _errorGraphQLError = require('../error/GraphQLError');\n\nvar _typeSchema = require('../type/schema');\n\nvar _typeDefinition = require('../type/definition');\n\nvar _typeScalars = require('../type/scalars');\n\nvar _languageKinds = require('../language/kinds');\n\nfunction extendSchema(schema, documentAST) {\n  (0, _jsutilsInvariant2['default'])(schema instanceof _typeSchema.GraphQLSchema, 'Must provide valid GraphQLSchema');\n\n  (0, _jsutilsInvariant2['default'])(documentAST && documentAST.kind === _languageKinds.DOCUMENT, 'Must provide valid Document AST');\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefinitionMap = {};\n  var typeExtensionsMap = {};\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n    switch (def.kind) {\n      case _languageKinds.OBJECT_TYPE_DEFINITION:\n      case _languageKinds.INTERFACE_TYPE_DEFINITION:\n      case _languageKinds.ENUM_TYPE_DEFINITION:\n      case _languageKinds.UNION_TYPE_DEFINITION:\n      case _languageKinds.SCALAR_TYPE_DEFINITION:\n      case _languageKinds.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n        if (schema.getType(typeName)) {\n          throw new _errorGraphQLError.GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n        typeDefinitionMap[typeName] = def;\n        break;\n      case _languageKinds.TYPE_EXTENSION_DEFINITION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.definition.name.value;\n        var existingType = schema.getType(extendedTypeName);\n        if (!existingType) {\n          throw new _errorGraphQLError.GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def.definition]);\n        }\n        if (!(existingType instanceof _typeDefinition.GraphQLObjectType)) {\n          throw new _errorGraphQLError.GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def.definition]);\n        }\n        var extensions = typeExtensionsMap[extendedTypeName];\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [def];\n        }\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n    }\n  }\n\n  // If this document contains no new types, then return the same unmodified\n  // GraphQLSchema instance.\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0) {\n    return schema;\n  }\n\n  // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n  var typeDefCache = {\n    String: _typeScalars.GraphQLString,\n    Int: _typeScalars.GraphQLInt,\n    Float: _typeScalars.GraphQLFloat,\n    Boolean: _typeScalars.GraphQLBoolean,\n    ID: _typeScalars.GraphQLID\n  };\n\n  // Get the root Query, Mutation, and Subscription types.\n  var queryType = getTypeFromDef(schema.getQueryType());\n\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? getTypeFromDef(existingMutationType) : null;\n\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? getTypeFromDef(existingSubscriptionType) : null;\n\n  // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n  Object.keys(schema.getTypeMap()).forEach(function (typeName) {\n    return getTypeFromDef(schema.getType(typeName));\n  });\n\n  // Do the same with new types.\n  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n    return getTypeFromAST(typeDefinitionMap[typeName]);\n  });\n\n  // Then produce and return a Schema with these types.\n  return new _typeSchema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    // Copy directives.\n    directives: schema.getDirectives()\n  });\n\n  // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getTypeFromDef(typeDef) {\n    var type = _getNamedType(typeDef.name);\n    (0, _jsutilsInvariant2['default'])(type, 'Invalid schema');\n    return type;\n  }\n\n  function getTypeFromAST(astNode) {\n    var type = _getNamedType(astNode.name.value);\n    if (!type) {\n      throw new _errorGraphQLError.GraphQLError('Unknown type: \"' + astNode.name.value + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [astNode]);\n    }\n    return type;\n  }\n\n  // Given a name, returns a type from either the existing schema or an\n  // added type.\n  function _getNamedType(typeName) {\n    var cachedTypeDef = typeDefCache[typeName];\n    if (cachedTypeDef) {\n      return cachedTypeDef;\n    }\n\n    var existingType = schema.getType(typeName);\n    if (existingType) {\n      var typeDef = extendType(existingType);\n      typeDefCache[typeName] = typeDef;\n      return typeDef;\n    }\n\n    var typeAST = typeDefinitionMap[typeName];\n    if (typeAST) {\n      var typeDef = buildType(typeAST);\n      typeDefCache[typeName] = typeDef;\n      return typeDef;\n    }\n  }\n\n  // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n  function extendType(type) {\n    if (type instanceof _typeDefinition.GraphQLObjectType) {\n      return extendObjectType(type);\n    }\n    if (type instanceof _typeDefinition.GraphQLInterfaceType) {\n      return extendInterfaceType(type);\n    }\n    if (type instanceof _typeDefinition.GraphQLUnionType) {\n      return extendUnionType(type);\n    }\n    return type;\n  }\n\n  function extendObjectType(type) {\n    return new _typeDefinition.GraphQLObjectType({\n      name: type.name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      }\n    });\n  }\n\n  function extendInterfaceType(type) {\n    return new _typeDefinition.GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      resolveType: throwClientSchemaExecutionError\n    });\n  }\n\n  function extendUnionType(type) {\n    return new _typeDefinition.GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getPossibleTypes().map(getTypeFromDef),\n      resolveType: throwClientSchemaExecutionError\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getTypeFromDef);\n\n    // If there are any extensions to the interfaces, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.interfaces.forEach(function (namedType) {\n          var interfaceName = namedType.name.value;\n          if (interfaces.some(function (def) {\n            return def.name === interfaceName;\n          })) {\n            throw new _errorGraphQLError.GraphQLError('\\'Type \"' + type.name + '\" already implements \"' + interfaceName + '\". ' + 'It cannot also be implemented in this type extension.', [namedType]);\n          }\n          interfaces.push(getTypeFromAST(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = {};\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: (0, _jsutilsKeyMap2['default'])(field.args, function (arg) {\n          return arg.name;\n        }),\n        resolve: throwClientSchemaExecutionError\n      };\n    });\n\n    // If there are any extensions to the fields, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n          if (oldFieldMap[fieldName]) {\n            throw new _errorGraphQLError.GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n          newFieldMap[fieldName] = {\n            type: buildFieldType(field.type),\n            args: buildInputValues(field.arguments),\n            resolve: throwClientSchemaExecutionError\n          };\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(type) {\n    if (type instanceof _typeDefinition.GraphQLList) {\n      return new _typeDefinition.GraphQLList(extendFieldType(type.ofType));\n    }\n    if (type instanceof _typeDefinition.GraphQLNonNull) {\n      return new _typeDefinition.GraphQLNonNull(extendFieldType(type.ofType));\n    }\n    return getTypeFromDef(type);\n  }\n\n  function buildType(typeAST) {\n    switch (typeAST.kind) {\n      case _languageKinds.OBJECT_TYPE_DEFINITION:\n        return buildObjectType(typeAST);\n      case _languageKinds.INTERFACE_TYPE_DEFINITION:\n        return buildInterfaceType(typeAST);\n      case _languageKinds.UNION_TYPE_DEFINITION:\n        return buildUnionType(typeAST);\n      case _languageKinds.SCALAR_TYPE_DEFINITION:\n        return buildScalarType(typeAST);\n      case _languageKinds.ENUM_TYPE_DEFINITION:\n        return buildEnumType(typeAST);\n      case _languageKinds.INPUT_OBJECT_TYPE_DEFINITION:\n        return buildInputObjectType(typeAST);\n    }\n  }\n\n  function buildObjectType(typeAST) {\n    return new _typeDefinition.GraphQLObjectType({\n      name: typeAST.name.value,\n      interfaces: function interfaces() {\n        return buildImplementedInterfaces(typeAST);\n      },\n      fields: function fields() {\n        return buildFieldMap(typeAST);\n      }\n    });\n  }\n\n  function buildInterfaceType(typeAST) {\n    return new _typeDefinition.GraphQLInterfaceType({\n      name: typeAST.name.value,\n      fields: function fields() {\n        return buildFieldMap(typeAST);\n      },\n      resolveType: throwClientSchemaExecutionError\n    });\n  }\n\n  function buildUnionType(typeAST) {\n    return new _typeDefinition.GraphQLUnionType({\n      name: typeAST.name.value,\n      types: typeAST.types.map(getTypeFromAST),\n      resolveType: throwClientSchemaExecutionError\n    });\n  }\n\n  function buildScalarType(typeAST) {\n    return new _typeDefinition.GraphQLScalarType({\n      name: typeAST.name.value,\n      serialize: function serialize() {\n        return null;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function buildEnumType(typeAST) {\n    return new _typeDefinition.GraphQLEnumType({\n      name: typeAST.name.value,\n      values: (0, _jsutilsKeyValMap2['default'])(typeAST.values, function (v) {\n        return v.name.value;\n      }, function () {\n        return {};\n      })\n    });\n  }\n\n  function buildInputObjectType(typeAST) {\n    return new _typeDefinition.GraphQLInputObjectType({\n      name: typeAST.name.value,\n      fields: function fields() {\n        return buildInputValues(typeAST.fields);\n      }\n    });\n  }\n\n  function buildImplementedInterfaces(typeAST) {\n    return typeAST.interfaces.map(getTypeFromAST);\n  }\n\n  function buildFieldMap(typeAST) {\n    return (0, _jsutilsKeyValMap2['default'])(typeAST.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: buildFieldType(field.type),\n        args: buildInputValues(field.arguments),\n        resolve: throwClientSchemaExecutionError\n      };\n    });\n  }\n\n  function buildInputValues(values) {\n    return (0, _jsutilsKeyValMap2['default'])(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = buildFieldType(value.type);\n      return {\n        type: type,\n        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type)\n      };\n    });\n  }\n\n  function buildFieldType(typeAST) {\n    if (typeAST.kind === _languageKinds.LIST_TYPE) {\n      return new _typeDefinition.GraphQLList(buildFieldType(typeAST.type));\n    }\n    if (typeAST.kind === _languageKinds.NON_NULL_TYPE) {\n      return new _typeDefinition.GraphQLNonNull(buildFieldType(typeAST.type));\n    }\n    return getTypeFromAST(typeAST);\n  }\n}\n\nfunction throwClientSchemaExecutionError() {\n  throw new Error('Client Schema cannot be used for execution.');\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/extendSchema.js\n ** module id = 419\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.printSchema = printSchema;\nexports.printIntrospectionSchema = printIntrospectionSchema;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _jsutilsInvariant = require('../jsutils/invariant');\n\nvar _jsutilsInvariant2 = _interopRequireDefault(_jsutilsInvariant);\n\nvar _jsutilsIsNullish = require('../jsutils/isNullish');\n\nvar _jsutilsIsNullish2 = _interopRequireDefault(_jsutilsIsNullish);\n\nvar _utilitiesAstFromValue = require('../utilities/astFromValue');\n\nvar _languagePrinter = require('../language/printer');\n\nvar _typeDefinition = require('../type/definition');\n\nfunction printSchema(schema) {\n  return printFilteredSchema(schema, isDefinedType);\n}\n\nfunction printIntrospectionSchema(schema) {\n  return printFilteredSchema(schema, isIntrospectionType);\n}\n\nfunction isDefinedType(typename) {\n  return !isIntrospectionType(typename) && !isBuiltInScalar(typename);\n}\n\nfunction isIntrospectionType(typename) {\n  return typename.indexOf('__') === 0;\n}\n\nfunction isBuiltInScalar(typename) {\n  return typename === 'String' || typename === 'Boolean' || typename === 'Int' || typename === 'Float' || typename === 'ID';\n}\n\nfunction printFilteredSchema(schema, typeFilter) {\n  var typeMap = schema.getTypeMap();\n  var types = Object.keys(typeMap).filter(typeFilter).sort(function (name1, name2) {\n    return name1.localeCompare(name2);\n  }).map(function (typeName) {\n    return typeMap[typeName];\n  });\n  return types.map(printType).join('\\n\\n') + '\\n';\n}\n\nfunction printType(type) {\n  if (type instanceof _typeDefinition.GraphQLScalarType) {\n    return printScalar(type);\n  } else if (type instanceof _typeDefinition.GraphQLObjectType) {\n    return printObject(type);\n  } else if (type instanceof _typeDefinition.GraphQLInterfaceType) {\n    return printInterface(type);\n  } else if (type instanceof _typeDefinition.GraphQLUnionType) {\n    return printUnion(type);\n  } else if (type instanceof _typeDefinition.GraphQLEnumType) {\n    return printEnum(type);\n  }\n  (0, _jsutilsInvariant2['default'])(type instanceof _typeDefinition.GraphQLInputObjectType);\n  return printInputObject(type);\n}\n\nfunction printScalar(type) {\n  return 'scalar ' + type.name;\n}\n\nfunction printObject(type) {\n  var interfaces = type.getInterfaces();\n  var implementedInterfaces = interfaces.length ? ' implements ' + interfaces.map(function (i) {\n    return i.name;\n  }).join(', ') : '';\n  return 'type ' + type.name + implementedInterfaces + ' {\\n' + printFields(type) + '\\n' + '}';\n}\n\nfunction printInterface(type) {\n  return 'interface ' + type.name + ' {\\n' + printFields(type) + '\\n' + '}';\n}\n\nfunction printUnion(type) {\n  return 'union ' + type.name + ' = ' + type.getPossibleTypes().join(' | ');\n}\n\nfunction printEnum(type) {\n  var values = type.getValues();\n  return 'enum ' + type.name + ' {\\n' + values.map(function (v) {\n    return '  ' + v.name;\n  }).join('\\n') + '\\n' + '}';\n}\n\nfunction printInputObject(type) {\n  var fieldMap = type.getFields();\n  var fields = Object.keys(fieldMap).map(function (fieldName) {\n    return fieldMap[fieldName];\n  });\n  return 'input ' + type.name + ' {\\n' + fields.map(function (f) {\n    return '  ' + printInputValue(f);\n  }).join('\\n') + '\\n' + '}';\n}\n\nfunction printFields(type) {\n  var fieldMap = type.getFields();\n  var fields = Object.keys(fieldMap).map(function (fieldName) {\n    return fieldMap[fieldName];\n  });\n  return fields.map(function (f) {\n    return '  ' + f.name + printArgs(f) + ': ' + f.type;\n  }).join('\\n');\n}\n\nfunction printArgs(field) {\n  if (field.args.length === 0) {\n    return '';\n  }\n  return '(' + field.args.map(printInputValue).join(', ') + ')';\n}\n\nfunction printInputValue(arg) {\n  var argDecl = arg.name + ': ' + arg.type;\n  if (!(0, _jsutilsIsNullish2['default'])(arg.defaultValue)) {\n    argDecl += ' = ' + (0, _languagePrinter.print)((0, _utilitiesAstFromValue.astFromValue)(arg.defaultValue, arg.type));\n  }\n  return argDecl;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/schemaPrinter.js\n ** module id = 420\n ** module chunks = 1\n **/","\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.concatAST = concatAST;\n\nfunction concatAST(asts) {\n  var batchDefinitions = [];\n  for (var i = 0; i < asts.length; i++) {\n    var definitions = asts[i].definitions;\n    for (var j = 0; j < definitions.length; j++) {\n      batchDefinitions.push(definitions[j]);\n    }\n  }\n  return {\n    kind: 'Document',\n    definitions: batchDefinitions\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/utilities/concatAST.js\n ** module id = 421\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\n/**\n * ExecuteButton\n *\n * What a nice round shiny button. Cmd/Ctrl-Enter is the shortcut.\n */\n\nvar ExecuteButton = (function (_React$Component) {\n  _inherits(ExecuteButton, _React$Component);\n\n  function ExecuteButton() {\n    _classCallCheck(this, ExecuteButton);\n\n    _React$Component.apply(this, arguments);\n  }\n\n  ExecuteButton.prototype.render = function render() {\n    return _react2[\"default\"].createElement(\n      \"button\",\n      {\n        className: \"execute-button\",\n        onClick: this.props.onClick,\n        title: \"Execute Query (Ctrl-Enter)\" },\n      _react2[\"default\"].createElement(\n        \"svg\",\n        { width: \"34\", height: \"34\" },\n        _react2[\"default\"].createElement(\"path\", { d: \"M 11 9 L 24 16 L 11 23 z\" })\n      )\n    );\n  };\n\n  ExecuteButton.prototype.componentDidMount = function componentDidMount() {\n    var _this = this;\n\n    this.keyHandler = function (event) {\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 13) {\n        event.preventDefault();\n        if (_this.props.onClick) {\n          _this.props.onClick();\n        }\n      }\n    };\n    document.addEventListener('keydown', this.keyHandler, true);\n  };\n\n  ExecuteButton.prototype.componentWillUnmount = function componentWillUnmount() {\n    document.removeEventListener('keydown', this.keyHandler, true);\n  };\n\n  _createClass(ExecuteButton, null, [{\n    key: \"propTypes\",\n    value: {\n      onClick: _react.PropTypes.func\n    },\n    enumerable: true\n  }]);\n\n  return ExecuteButton;\n})(_react2[\"default\"].Component);\n\nexports.ExecuteButton = ExecuteButton;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/components/ExecuteButton.js\n ** module id = 422\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _marked = require('marked');\n\nvar _marked2 = _interopRequireDefault(_marked);\n\nvar _codemirror = require('codemirror');\n\nvar _codemirror2 = _interopRequireDefault(_codemirror);\n\nvar _graphqlType = require('graphql/type');\n\nrequire('codemirror/addon/hint/show-hint');\n\nrequire('codemirror/addon/comment/comment');\n\nrequire('codemirror/addon/edit/matchbrackets');\n\nrequire('codemirror/addon/edit/closebrackets');\n\nrequire('codemirror/addon/fold/foldgutter');\n\nrequire('codemirror/addon/fold/brace-fold');\n\nrequire('codemirror/addon/lint/lint');\n\nrequire('codemirror/keymap/sublime');\n\nrequire('codemirror-graphql/hint');\n\nrequire('codemirror-graphql/lint');\n\nrequire('codemirror-graphql/mode');\n\n/**\n * QueryEditor\n *\n * Maintains an instance of CodeMirror responsible for editing a GraphQL query.\n *\n * Props:\n *\n *   - schema: A GraphQLSchema instance enabling editor linting and hinting.\n *   - value: The text of the editor.\n *   - onEdit: A function called when the editor changes, given the edited text.\n *\n */\n\nvar QueryEditor = (function (_React$Component) {\n  _inherits(QueryEditor, _React$Component);\n\n  _createClass(QueryEditor, null, [{\n    key: 'propTypes',\n    value: {\n      schema: _react.PropTypes.instanceOf(_graphqlType.GraphQLSchema),\n      value: _react.PropTypes.string,\n      onEdit: _react.PropTypes.func\n    },\n    enumerable: true\n  }]);\n\n  function QueryEditor(props) {\n    var _this = this;\n\n    _classCallCheck(this, QueryEditor);\n\n    _React$Component.call(this);\n\n    // Keep a cached version of the value, this cache will be updated when the\n    // editor is updated, which can later be used to protect the editor from\n    // unnecessary updates during the update lifecycle.\n\n    this._onKeyUp = function (cm, event) {\n      var code = event.keyCode;\n      if (code >= 65 && code <= 90 || // letters\n      !event.shiftKey && code >= 48 && code <= 57 || // numbers\n      event.shiftKey && code === 189 || // underscore\n      event.shiftKey && code === 50 || // @\n      event.shiftKey && code === 57 // (\n      ) {\n          _this.editor.execCommand('autocomplete');\n        }\n    };\n\n    this._onEdit = function () {\n      if (!_this.ignoreChangeEvent) {\n        _this.cachedValue = _this.editor.getValue();\n        if (_this.props.onEdit) {\n          _this.props.onEdit(_this.cachedValue);\n        }\n      }\n    };\n\n    this._onHasCompletion = function (cm, data) {\n      var wrapper;\n      var information;\n\n      // When a hint result is selected, we touch the UI.\n      _codemirror2['default'].on(data, 'select', function (ctx, el) {\n        // Only the first time (usually when the hint UI is first displayed)\n        // do we create the wrapping node.\n        if (!wrapper) {\n          // Wrap the existing hint UI, so we have a place to put information.\n          var hintsUl = el.parentNode;\n          var container = hintsUl.parentNode;\n          wrapper = document.createElement('div');\n          container.appendChild(wrapper);\n\n          // CodeMirror vertically inverts the hint UI if there is not enough\n          // space below the cursor. Since this modified UI appends to the bottom\n          // of CodeMirror's existing UI, it could cover the cursor. This adjusts\n          // the positioning of the hint UI to accomodate.\n          var top = hintsUl.style.top;\n          var bottom = '';\n          var cursorTop = cm.cursorCoords().top;\n          if (parseInt(top, 10) < cursorTop) {\n            top = '';\n            bottom = window.innerHeight - cursorTop + 3 + 'px';\n          }\n\n          // Style the wrapper, remove positioning from hints. Note that usage\n          // of this option will need to specify CSS to remove some styles from\n          // the existing hint UI.\n          wrapper.className = 'CodeMirror-hints-wrapper';\n          wrapper.style.left = hintsUl.style.left;\n          wrapper.style.top = top;\n          wrapper.style.bottom = bottom;\n          hintsUl.style.left = '';\n          hintsUl.style.top = '';\n\n          // This \"information\" node will contain the additional info about the\n          // highlighted typeahead option.\n          information = document.createElement('div');\n          information.className = 'CodeMirror-hint-information';\n          if (bottom) {\n            wrapper.appendChild(information);\n            wrapper.appendChild(hintsUl);\n          } else {\n            wrapper.appendChild(hintsUl);\n            wrapper.appendChild(information);\n          }\n\n          // When CodeMirror attempts to remove the hint UI, we detect that it was\n          // removed from our wrapper and in turn remove the wrapper from the\n          // original container.\n          var onRemoveFn;\n          wrapper.addEventListener('DOMNodeRemoved', onRemoveFn = function (event) {\n            if (event.target === hintsUl) {\n              wrapper.removeEventListener('DOMNodeRemoved', onRemoveFn);\n              wrapper.parentNode.removeChild(wrapper);\n              wrapper = null;\n              information = null;\n              onRemoveFn = null;\n            }\n          });\n        }\n\n        // Now that the UI has been set up, add info to information.\n        var description = ctx.description ? _marked2['default'](ctx.description, { smartypants: true }) : 'Self descriptive.';\n        var type = ctx.type ? '<span class=\"infoType\">' + renderType(ctx.type) + '</span>' : '';\n\n        information.innerHTML = '<div class=\"content\">' + (description.slice(0, 3) === '<p>' ? '<p>' + type + description.slice(3) : type + description) + '</div>';\n\n        // Additional rendering?\n        var onHintInformationRender = _this.props.onHintInformationRender;\n        if (onHintInformationRender) {\n          onHintInformationRender(information);\n        }\n      });\n    };\n\n    this.cachedValue = props.value || '';\n  }\n\n  /**\n   * Public API for retrieving the CodeMirror instance from this\n   * React component.\n   */\n\n  QueryEditor.prototype.getCodeMirror = function getCodeMirror() {\n    return this.editor;\n  };\n\n  QueryEditor.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    this.editor = _codemirror2['default'](_reactDom2['default'].findDOMNode(this), {\n      value: this.props.value || '',\n      lineNumbers: true,\n      tabSize: 2,\n      mode: 'graphql',\n      theme: 'graphiql',\n      keyMap: 'sublime',\n      autoCloseBrackets: true,\n      matchBrackets: true,\n      showCursorWhenSelecting: true,\n      foldGutter: {\n        minFoldSize: 4\n      },\n      lint: {\n        schema: this.props.schema\n      },\n      hintOptions: {\n        schema: this.props.schema,\n        closeOnUnfocus: false,\n        completeSingle: false\n      },\n      gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n      extraKeys: {\n        'Cmd-Space': function CmdSpace() {\n          return _this2.editor.showHint({ completeSingle: true });\n        },\n        'Ctrl-Space': function CtrlSpace() {\n          return _this2.editor.showHint({ completeSingle: true });\n        },\n\n        // Editor improvements\n        'Ctrl-Left': 'goSubwordLeft',\n        'Ctrl-Right': 'goSubwordRight',\n        'Alt-Left': 'goGroupLeft',\n        'Alt-Right': 'goGroupRight'\n      }\n    });\n\n    this.editor.on('change', this._onEdit);\n    this.editor.on('keyup', this._onKeyUp);\n    this.editor.on('hasCompletion', this._onHasCompletion);\n  };\n\n  QueryEditor.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.editor.off('change', this._onEdit);\n    this.editor.off('keyup', this._onKeyUp);\n    this.editor.off('hasCompletion', this._onHasCompletion);\n    this.editor = null;\n  };\n\n  QueryEditor.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    // Ensure the changes caused by this update are not interpretted as\n    // user-input changes which could otherwise result in an infinite\n    // event loop.\n    this.ignoreChangeEvent = true;\n    if (this.props.schema !== prevProps.schema) {\n      this.editor.options.lint.schema = this.props.schema;\n      this.editor.options.hintOptions.schema = this.props.schema;\n      _codemirror2['default'].signal(this.editor, 'change', this.editor);\n    }\n    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {\n      this.cachedValue = this.props.value;\n      this.editor.setValue(this.props.value);\n    }\n    this.ignoreChangeEvent = false;\n  };\n\n  QueryEditor.prototype.render = function render() {\n    return _react2['default'].createElement('div', { className: 'query-editor' });\n  };\n\n  return QueryEditor;\n})(_react2['default'].Component);\n\nexports.QueryEditor = QueryEditor;\n\nfunction renderType(type) {\n  if (type instanceof _graphqlType.GraphQLNonNull) {\n    return renderType(type.ofType) + '!';\n  }\n  if (type instanceof _graphqlType.GraphQLList) {\n    return '[' + renderType(type.ofType) + ']';\n  }\n  return '<a class=\"typeName\">' + type.name + '</a>';\n}\n\n/**\n * Render a custom UI for CodeMirror's hint which includes additional info\n * about the type and description for the selected context.\n */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/components/QueryEditor.js\n ** module id = 423\n ** module chunks = 1\n **/","/**\n * marked - a markdown parser\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n */\n\n;(function() {\n\n/**\n * Block-Level Grammar\n */\n\nvar block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: noop,\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n  nptable: noop,\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n  blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n  table: noop,\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n  text: /^[^\\n]+/\n};\n\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\nblock.item = replace(block.item, 'gm')\n  (/bull/g, block.bullet)\n  ();\n\nblock.list = replace(block.list)\n  (/bull/g, block.bullet)\n  ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\n  ('def', '\\\\n+(?=' + block.def.source + ')')\n  ();\n\nblock.blockquote = replace(block.blockquote)\n  ('def', block.def)\n  ();\n\nblock._tag = '(?!(?:'\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\n\nblock.html = replace(block.html)\n  ('comment', /<!--[\\s\\S]*?-->/)\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n  (/tag/g, block._tag)\n  ();\n\nblock.paragraph = replace(block.paragraph)\n  ('hr', block.hr)\n  ('heading', block.heading)\n  ('lheading', block.lheading)\n  ('blockquote', block.blockquote)\n  ('tag', '<' + block._tag)\n  ('def', block.def)\n  ();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\n  paragraph: /^/,\n  heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\n});\n\nblock.gfm.paragraph = replace(block.paragraph)\n  ('(?!', '(?!'\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\n  ();\n\n/**\n * GFM + Tables Block Grammar\n */\n\nblock.tables = merge({}, block.gfm, {\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\n});\n\n/**\n * Block Lexer\n */\n\nfunction Lexer(options) {\n  this.tokens = [];\n  this.tokens.links = {};\n  this.options = options || marked.defaults;\n  this.rules = block.normal;\n\n  if (this.options.gfm) {\n    if (this.options.tables) {\n      this.rules = block.tables;\n    } else {\n      this.rules = block.gfm;\n    }\n  }\n}\n\n/**\n * Expose Block Rules\n */\n\nLexer.rules = block;\n\n/**\n * Static Lex Method\n */\n\nLexer.lex = function(src, options) {\n  var lexer = new Lexer(options);\n  return lexer.lex(src);\n};\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function(src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/\\u2424/g, '\\n');\n\n  return this.token(src, true);\n};\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function(src, top, bq) {\n  var src = src.replace(/^ +$/gm, '')\n    , next\n    , loose\n    , cap\n    , bull\n    , b\n    , item\n    , space\n    , i\n    , l;\n\n  while (src) {\n    // newline\n    if (cap = this.rules.newline.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        });\n      }\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      cap = cap[0].replace(/^ {4}/gm, '');\n      this.tokens.push({\n        type: 'code',\n        text: !this.options.pedantic\n          ? cap.replace(/\\n+$/, '')\n          : cap\n      });\n      continue;\n    }\n\n    // fences (gfm)\n    if (cap = this.rules.fences.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'code',\n        lang: cap[2],\n        text: cap[3] || ''\n      });\n      continue;\n    }\n\n    // heading\n    if (cap = this.rules.heading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[1].length,\n        text: cap[2]\n      });\n      continue;\n    }\n\n    // table no leading pipe (gfm)\n    if (top && (cap = this.rules.nptable.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i].split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // lheading\n    if (cap = this.rules.lheading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[2] === '=' ? 1 : 2,\n        text: cap[1]\n      });\n      continue;\n    }\n\n    // hr\n    if (cap = this.rules.hr.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'hr'\n      });\n      continue;\n    }\n\n    // blockquote\n    if (cap = this.rules.blockquote.exec(src)) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      });\n\n      cap = cap[0].replace(/^ *> ?/gm, '');\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top, true);\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      });\n\n      continue;\n    }\n\n    // list\n    if (cap = this.rules.list.exec(src)) {\n      src = src.substring(cap[0].length);\n      bull = cap[2];\n\n      this.tokens.push({\n        type: 'list_start',\n        ordered: bull.length > 1\n      });\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item);\n\n      next = false;\n      l = cap.length;\n      i = 0;\n\n      for (; i < l; i++) {\n        item = cap[i];\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (this.options.smartLists && i !== l - 1) {\n          b = block.bullet.exec(cap[i + 1])[0];\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n            src = cap.slice(i + 1).join('\\n') + src;\n            i = l - 1;\n          }\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item.charAt(item.length - 1) === '\\n';\n          if (!loose) loose = next;\n        }\n\n        this.tokens.push({\n          type: loose\n            ? 'loose_item_start'\n            : 'list_item_start'\n        });\n\n        // Recurse.\n        this.token(item, false, bq);\n\n        this.tokens.push({\n          type: 'list_item_end'\n        });\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      });\n\n      continue;\n    }\n\n    // html\n    if (cap = this.rules.html.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: cap[0]\n      });\n      continue;\n    }\n\n    // def\n    if ((!bq && top) && (cap = this.rules.def.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.links[cap[1].toLowerCase()] = {\n        href: cap[2],\n        title: cap[3]\n      };\n      continue;\n    }\n\n    // table (gfm)\n    if (top && (cap = this.rules.table.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i]\n          .replace(/^ *\\| *| *\\| *$/g, '')\n          .split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // top-level paragraph\n    if (top && (cap = this.rules.paragraph.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      });\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return this.tokens;\n};\n\n/**\n * Inline-Level Grammar\n */\n\nvar inline = {\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\n  url: noop,\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\n  link: /^!?\\[(inside)\\]\\(href\\)/,\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n  em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  br: /^ {2,}\\n(?!\\s*$)/,\n  del: noop,\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\n};\n\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\ninline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\n\ninline.link = replace(inline.link)\n  ('inside', inline._inside)\n  ('href', inline._href)\n  ();\n\ninline.reflink = replace(inline.reflink)\n  ('inside', inline._inside)\n  ();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: replace(inline.escape)('])', '~|])')(),\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n  text: replace(inline.text)\n    (']|', '~]|')\n    ('|', '|https?://|')\n    ()\n});\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: replace(inline.br)('{2,}', '*')(),\n  text: replace(inline.gfm.text)('{2,}', '*')()\n});\n\n/**\n * Inline Lexer & Compiler\n */\n\nfunction InlineLexer(links, options) {\n  this.options = options || marked.defaults;\n  this.links = links;\n  this.rules = inline.normal;\n  this.renderer = this.options.renderer || new Renderer;\n  this.renderer.options = this.options;\n\n  if (!this.links) {\n    throw new\n      Error('Tokens array requires a `links` property.');\n  }\n\n  if (this.options.gfm) {\n    if (this.options.breaks) {\n      this.rules = inline.breaks;\n    } else {\n      this.rules = inline.gfm;\n    }\n  } else if (this.options.pedantic) {\n    this.rules = inline.pedantic;\n  }\n}\n\n/**\n * Expose Inline Rules\n */\n\nInlineLexer.rules = inline;\n\n/**\n * Static Lexing/Compiling Method\n */\n\nInlineLexer.output = function(src, links, options) {\n  var inline = new InlineLexer(links, options);\n  return inline.output(src);\n};\n\n/**\n * Lexing/Compiling\n */\n\nInlineLexer.prototype.output = function(src) {\n  var out = ''\n    , link\n    , text\n    , href\n    , cap;\n\n  while (src) {\n    // escape\n    if (cap = this.rules.escape.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += cap[1];\n      continue;\n    }\n\n    // autolink\n    if (cap = this.rules.autolink.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[2] === '@') {\n        text = cap[1].charAt(6) === ':'\n          ? this.mangle(cap[1].substring(7))\n          : this.mangle(cap[1]);\n        href = this.mangle('mailto:') + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // url (gfm)\n    if (!this.inLink && (cap = this.rules.url.exec(src))) {\n      src = src.substring(cap[0].length);\n      text = escape(cap[1]);\n      href = text;\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // tag\n    if (cap = this.rules.tag.exec(src)) {\n      if (!this.inLink && /^<a /i.test(cap[0])) {\n        this.inLink = true;\n      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.inLink = false;\n      }\n      src = src.substring(cap[0].length);\n      out += this.options.sanitize\n        ? this.options.sanitizer\n          ? this.options.sanitizer(cap[0])\n          : escape(cap[0])\n        : cap[0]\n      continue;\n    }\n\n    // link\n    if (cap = this.rules.link.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.inLink = true;\n      out += this.outputLink(cap, {\n        href: cap[2],\n        title: cap[3]\n      });\n      this.inLink = false;\n      continue;\n    }\n\n    // reflink, nolink\n    if ((cap = this.rules.reflink.exec(src))\n        || (cap = this.rules.nolink.exec(src))) {\n      src = src.substring(cap[0].length);\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = this.links[link.toLowerCase()];\n      if (!link || !link.href) {\n        out += cap[0].charAt(0);\n        src = cap[0].substring(1) + src;\n        continue;\n      }\n      this.inLink = true;\n      out += this.outputLink(cap, link);\n      this.inLink = false;\n      continue;\n    }\n\n    // strong\n    if (cap = this.rules.strong.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.strong(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // em\n    if (cap = this.rules.em.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.em(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.codespan(escape(cap[2], true));\n      continue;\n    }\n\n    // br\n    if (cap = this.rules.br.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.br();\n      continue;\n    }\n\n    // del (gfm)\n    if (cap = this.rules.del.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.del(this.output(cap[1]));\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.text(escape(this.smartypants(cap[0])));\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return out;\n};\n\n/**\n * Compile Link\n */\n\nInlineLexer.prototype.outputLink = function(cap, link) {\n  var href = escape(link.href)\n    , title = link.title ? escape(link.title) : null;\n\n  return cap[0].charAt(0) !== '!'\n    ? this.renderer.link(href, title, this.output(cap[1]))\n    : this.renderer.image(href, title, escape(cap[1]));\n};\n\n/**\n * Smartypants Transformations\n */\n\nInlineLexer.prototype.smartypants = function(text) {\n  if (!this.options.smartypants) return text;\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n};\n\n/**\n * Mangle Links\n */\n\nInlineLexer.prototype.mangle = function(text) {\n  if (!this.options.mangle) return text;\n  var out = ''\n    , l = text.length\n    , i = 0\n    , ch;\n\n  for (; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n};\n\n/**\n * Renderer\n */\n\nfunction Renderer(options) {\n  this.options = options || {};\n}\n\nRenderer.prototype.code = function(code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  if (!lang) {\n    return '<pre><code>'\n      + (escaped ? code : escape(code, true))\n      + '\\n</code></pre>';\n  }\n\n  return '<pre><code class=\"'\n    + this.options.langPrefix\n    + escape(lang, true)\n    + '\">'\n    + (escaped ? code : escape(code, true))\n    + '\\n</code></pre>\\n';\n};\n\nRenderer.prototype.blockquote = function(quote) {\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\n};\n\nRenderer.prototype.html = function(html) {\n  return html;\n};\n\nRenderer.prototype.heading = function(text, level, raw) {\n  return '<h'\n    + level\n    + ' id=\"'\n    + this.options.headerPrefix\n    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\n    + '\">'\n    + text\n    + '</h'\n    + level\n    + '>\\n';\n};\n\nRenderer.prototype.hr = function() {\n  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n};\n\nRenderer.prototype.list = function(body, ordered) {\n  var type = ordered ? 'ol' : 'ul';\n  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\n};\n\nRenderer.prototype.listitem = function(text) {\n  return '<li>' + text + '</li>\\n';\n};\n\nRenderer.prototype.paragraph = function(text) {\n  return '<p>' + text + '</p>\\n';\n};\n\nRenderer.prototype.table = function(header, body) {\n  return '<table>\\n'\n    + '<thead>\\n'\n    + header\n    + '</thead>\\n'\n    + '<tbody>\\n'\n    + body\n    + '</tbody>\\n'\n    + '</table>\\n';\n};\n\nRenderer.prototype.tablerow = function(content) {\n  return '<tr>\\n' + content + '</tr>\\n';\n};\n\nRenderer.prototype.tablecell = function(content, flags) {\n  var type = flags.header ? 'th' : 'td';\n  var tag = flags.align\n    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\n    : '<' + type + '>';\n  return tag + content + '</' + type + '>\\n';\n};\n\n// span level renderer\nRenderer.prototype.strong = function(text) {\n  return '<strong>' + text + '</strong>';\n};\n\nRenderer.prototype.em = function(text) {\n  return '<em>' + text + '</em>';\n};\n\nRenderer.prototype.codespan = function(text) {\n  return '<code>' + text + '</code>';\n};\n\nRenderer.prototype.br = function() {\n  return this.options.xhtml ? '<br/>' : '<br>';\n};\n\nRenderer.prototype.del = function(text) {\n  return '<del>' + text + '</del>';\n};\n\nRenderer.prototype.link = function(href, title, text) {\n  if (this.options.sanitize) {\n    try {\n      var prot = decodeURIComponent(unescape(href))\n        .replace(/[^\\w:]/g, '')\n        .toLowerCase();\n    } catch (e) {\n      return '';\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {\n      return '';\n    }\n  }\n  var out = '<a href=\"' + href + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += '>' + text + '</a>';\n  return out;\n};\n\nRenderer.prototype.image = function(href, title, text) {\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += this.options.xhtml ? '/>' : '>';\n  return out;\n};\n\nRenderer.prototype.text = function(text) {\n  return text;\n};\n\n/**\n * Parsing & Compiling\n */\n\nfunction Parser(options) {\n  this.tokens = [];\n  this.token = null;\n  this.options = options || marked.defaults;\n  this.options.renderer = this.options.renderer || new Renderer;\n  this.renderer = this.options.renderer;\n  this.renderer.options = this.options;\n}\n\n/**\n * Static Parse Method\n */\n\nParser.parse = function(src, options, renderer) {\n  var parser = new Parser(options, renderer);\n  return parser.parse(src);\n};\n\n/**\n * Parse Loop\n */\n\nParser.prototype.parse = function(src) {\n  this.inline = new InlineLexer(src.links, this.options, this.renderer);\n  this.tokens = src.reverse();\n\n  var out = '';\n  while (this.next()) {\n    out += this.tok();\n  }\n\n  return out;\n};\n\n/**\n * Next Token\n */\n\nParser.prototype.next = function() {\n  return this.token = this.tokens.pop();\n};\n\n/**\n * Preview Next Token\n */\n\nParser.prototype.peek = function() {\n  return this.tokens[this.tokens.length - 1] || 0;\n};\n\n/**\n * Parse Text Tokens\n */\n\nParser.prototype.parseText = function() {\n  var body = this.token.text;\n\n  while (this.peek().type === 'text') {\n    body += '\\n' + this.next().text;\n  }\n\n  return this.inline.output(body);\n};\n\n/**\n * Parse Current Token\n */\n\nParser.prototype.tok = function() {\n  switch (this.token.type) {\n    case 'space': {\n      return '';\n    }\n    case 'hr': {\n      return this.renderer.hr();\n    }\n    case 'heading': {\n      return this.renderer.heading(\n        this.inline.output(this.token.text),\n        this.token.depth,\n        this.token.text);\n    }\n    case 'code': {\n      return this.renderer.code(this.token.text,\n        this.token.lang,\n        this.token.escaped);\n    }\n    case 'table': {\n      var header = ''\n        , body = ''\n        , i\n        , row\n        , cell\n        , flags\n        , j;\n\n      // header\n      cell = '';\n      for (i = 0; i < this.token.header.length; i++) {\n        flags = { header: true, align: this.token.align[i] };\n        cell += this.renderer.tablecell(\n          this.inline.output(this.token.header[i]),\n          { header: true, align: this.token.align[i] }\n        );\n      }\n      header += this.renderer.tablerow(cell);\n\n      for (i = 0; i < this.token.cells.length; i++) {\n        row = this.token.cells[i];\n\n        cell = '';\n        for (j = 0; j < row.length; j++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(row[j]),\n            { header: false, align: this.token.align[j] }\n          );\n        }\n\n        body += this.renderer.tablerow(cell);\n      }\n      return this.renderer.table(header, body);\n    }\n    case 'blockquote_start': {\n      var body = '';\n\n      while (this.next().type !== 'blockquote_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.blockquote(body);\n    }\n    case 'list_start': {\n      var body = ''\n        , ordered = this.token.ordered;\n\n      while (this.next().type !== 'list_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.list(body, ordered);\n    }\n    case 'list_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.token.type === 'text'\n          ? this.parseText()\n          : this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'loose_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'html': {\n      var html = !this.token.pre && !this.options.pedantic\n        ? this.inline.output(this.token.text)\n        : this.token.text;\n      return this.renderer.html(html);\n    }\n    case 'paragraph': {\n      return this.renderer.paragraph(this.inline.output(this.token.text));\n    }\n    case 'text': {\n      return this.renderer.paragraph(this.parseText());\n    }\n  }\n};\n\n/**\n * Helpers\n */\n\nfunction escape(html, encode) {\n  return html\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction unescape(html) {\n  return html.replace(/&([#\\w]+);/g, function(_, n) {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nfunction replace(regex, opt) {\n  regex = regex.source;\n  opt = opt || '';\n  return function self(name, val) {\n    if (!name) return new RegExp(regex, opt);\n    val = val.source || val;\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\nfunction noop() {}\nnoop.exec = noop;\n\nfunction merge(obj) {\n  var i = 1\n    , target\n    , key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\n\n/**\n * Marked\n */\n\nfunction marked(src, opt, callback) {\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n\n    var highlight = opt.highlight\n      , tokens\n      , pending\n      , i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt)\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    var done = function(err) {\n      if (err) {\n        opt.highlight = highlight;\n        return callback(err);\n      }\n\n      var out;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (err) return done(err);\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    if (opt) opt = merge({}, marked.defaults, opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occured:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  return marked;\n};\n\nmarked.defaults = {\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: false,\n  sanitizer: null,\n  mangle: true,\n  smartLists: false,\n  silent: false,\n  highlight: null,\n  langPrefix: 'lang-',\n  smartypants: false,\n  headerPrefix: '',\n  renderer: new Renderer,\n  xhtml: false\n};\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.parse = marked;\n\nif (typeof module !== 'undefined' && typeof exports === 'object') {\n  module.exports = marked;\n} else if (typeof define === 'function' && define.amd) {\n  define(function() { return marked; });\n} else {\n  this.marked = marked;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/~/marked/lib/marked.js\n ** module id = 424\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    var self = this;\n    cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      this.cm.off(\"cursorActivity\", this.activityFunc);\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i];\n      if (completion.hint) completion.hint(this.cm, data, completion);\n      else this.cm.replaceRange(getText(completion), completion.from || data.from,\n                                completion.to || data.to, \"complete\");\n      CodeMirror.signal(data, \"pick\", completion);\n      this.close();\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||\n          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return;\n      if (!this.options.hint.async) {\n        this.finishUpdate(this.options.hint(this.cm, this.options), first);\n      } else {\n        var myTick = ++this.tick, self = this;\n        this.options.hint(this.cm, function(data) {\n          if (self.tick == myTick) self.finishUpdate(data, first);\n        }, this.options);\n      }\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n      if (data && this.data && CodeMirror.cmpPos(data.from, this.data.from)) data = null;\n      this.data = data;\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n\n    var hints = this.hints = document.createElement(\"ul\");\n    hints.className = \"CodeMirror-hints\";\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(document.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    hints.style.left = left + \"px\";\n    hints.style.top = top + \"px\";\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);\n    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n    (completion.options.container || document.body).appendChild(hints);\n    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;\n    if (overlapY > 0) {\n      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);\n      if (curTop - height > 0) { // Fits above cursor\n        hints.style.top = (top = pos.top - height) + \"px\";\n        below = false;\n      } else if (height > winH) {\n        hints.style.height = (winH - 5) + \"px\";\n        hints.style.top = (top = pos.bottom - box.top) + \"px\";\n        var cursor = cm.getCursor();\n        if (data.from.ch != cursor.ch) {\n          pos = cm.cursorCoords(cursor);\n          hints.style.left = (left = pos.left) + \"px\";\n          box = hints.getBoundingClientRect();\n        }\n      }\n    }\n    var overlapX = box.right - winW;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = pos.left - overlapX) + \"px\";\n    }\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    var startScroll = cm.getScrollInfo();\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    if (completion.options.completeOnSingleClick)\n      CodeMirror.on(hints, \"mousemove\", function(e) {\n        var elt = getHintElement(hints, e.target || e.srcElement);\n        if (elt && elt.hintId != null)\n          widget.changeActive(elt.hintId);\n      });\n\n    CodeMirror.signal(data, \"select\", completions[0], hints.firstChild);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      if (node.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node.offsetTop - 3;\n      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var async = false, resolved\n      for (var i = 0; i < helpers.length; i++) if (helpers[i].async) async = true\n      if (async) {\n        resolved = function(cm, callback, options) {\n          var app = applicableHelpers(cm, helpers)\n          function run(i, result) {\n            if (i == app.length) return callback(null)\n            var helper = app[i]\n            if (helper.async) {\n              helper(cm, function(result) {\n                if (result) callback(result)\n                else run(i + 1)\n              }, options)\n            } else {\n              var result = helper(cm, options)\n              if (result) callback(result)\n              else run(i + 1)\n            }\n          }\n          run(0)\n        }\n        resolved.async = true\n      } else {\n        resolved = function(cm, options) {\n          var app = applicableHelpers(cm, helpers)\n          for (var i = 0; i < app.length; i++) {\n            var cur = app[i](cm, options)\n            if (cur && cur.list.length) return cur\n          }\n        }\n      }\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n    var to = CodeMirror.Pos(cur.line, token.end);\n    if (token.string && /\\w/.test(token.string[token.string.length - 1])) {\n      var term = token.string, from = CodeMirror.Pos(cur.line, token.start);\n    } else {\n      var term = \"\", from = to;\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnUnfocus: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/addon/hint/show-hint.js\n ** module id = 425\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = self.getModeAt(from);\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null) return;\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = self.getModeAt(from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        self.replaceRange(endString, to);\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = self.getModeAt(from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && (i != end || i == start) && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), endLine = end == start ? startLine : self.getLine(end);\n    var open = startLine.indexOf(startString), close = endLine.lastIndexOf(endString);\n    if (close == -1 && start != end) {\n      endLine = self.getLine(--end);\n      close = endLine.lastIndexOf(endString);\n    }\n    if (open == -1 || close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(Pos(start, open + 1))) ||\n        !/comment/.test(self.getTokenTypeAt(Pos(end, close + 1))))\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/addon/comment/comment.js\n ** module id = 426\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, strict, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init)\n      cm.off(\"cursorActivity\", doMatchBrackets);\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict, config){\n    return findMatchingBracket(this, pos, strict, config);\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/addon/edit/matchbrackets.js\n ** module id = 427\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var defaults = {\n    pairs: \"()[]{}''\\\"\\\"\",\n    triples: \"\",\n    explode: \"[]{}\"\n  };\n\n  var Pos = CodeMirror.Pos;\n\n  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.removeKeyMap(keyMap);\n      cm.state.closeBrackets = null;\n    }\n    if (val) {\n      cm.state.closeBrackets = val;\n      cm.addKeyMap(keyMap);\n    }\n  });\n\n  function getOption(conf, name) {\n    if (name == \"pairs\" && typeof conf == \"string\") return conf;\n    if (typeof conf == \"object\" && conf[name] != null) return conf[name];\n    return defaults[name];\n  }\n\n  var bind = defaults.pairs + \"`\";\n  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};\n  for (var i = 0; i < bind.length; i++)\n    keyMap[\"'\" + bind.charAt(i) + \"'\"] = handler(bind.charAt(i));\n\n  function handler(ch) {\n    return function(cm) { return handleChar(cm, ch); };\n  }\n\n  function getConfig(cm) {\n    var deflt = cm.state.closeBrackets;\n    if (!deflt) return null;\n    var mode = cm.getModeAt(cm.getCursor());\n    return mode.closeBrackets || deflt;\n  }\n\n  function handleBackspace(cm) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var cur = ranges[i].head;\n      cm.replaceRange(\"\", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n    }\n  }\n\n  function handleEnter(cm) {\n    var conf = getConfig(cm);\n    var explode = conf && getOption(conf, \"explode\");\n    if (!explode || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    cm.operation(function() {\n      cm.replaceSelection(\"\\n\\n\", null);\n      cm.execCommand(\"goCharLeft\");\n      ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var line = ranges[i].head.line;\n        cm.indentLine(line, null, true);\n        cm.indentLine(line + 1, null, true);\n      }\n    });\n  }\n\n  function contractSelection(sel) {\n    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};\n  }\n\n  function handleChar(cm, ch) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var pos = pairs.indexOf(ch);\n    if (pos == -1) return CodeMirror.Pass;\n    var triples = getOption(conf, \"triples\");\n\n    var identical = pairs.charAt(pos + 1) == ch;\n    var ranges = cm.listSelections();\n    var opening = pos % 2 == 0;\n\n    var type, next;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], cur = range.head, curType;\n      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n      if (opening && !range.empty()) {\n        curType = \"surround\";\n      } else if ((identical || !opening) && next == ch) {\n        if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n          curType = \"skipThree\";\n        else\n          curType = \"skip\";\n      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&\n                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch &&\n                 (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != ch)) {\n        curType = \"addFour\";\n      } else if (identical) {\n        if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, ch)) curType = \"both\";\n        else return CodeMirror.Pass;\n      } else if (opening && (cm.getLine(cur.line).length == cur.ch ||\n                             isClosingBracket(next, pairs) ||\n                             /\\s/.test(next))) {\n        curType = \"both\";\n      } else {\n        return CodeMirror.Pass;\n      }\n      if (!type) type = curType;\n      else if (type != curType) return CodeMirror.Pass;\n    }\n\n    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n    cm.operation(function() {\n      if (type == \"skip\") {\n        cm.execCommand(\"goCharRight\");\n      } else if (type == \"skipThree\") {\n        for (var i = 0; i < 3; i++)\n          cm.execCommand(\"goCharRight\");\n      } else if (type == \"surround\") {\n        var sels = cm.getSelections();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = left + sels[i] + right;\n        cm.replaceSelections(sels, \"around\");\n        sels = cm.listSelections().slice();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = contractSelection(sels[i]);\n        cm.setSelections(sels);\n      } else if (type == \"both\") {\n        cm.replaceSelection(left + right, null);\n        cm.triggerElectric(left + right);\n        cm.execCommand(\"goCharLeft\");\n      } else if (type == \"addFour\") {\n        cm.replaceSelection(left + left + left + left, \"before\");\n        cm.execCommand(\"goCharRight\");\n      }\n    });\n  }\n\n  function isClosingBracket(ch, pairs) {\n    var pos = pairs.lastIndexOf(ch);\n    return pos > -1 && pos % 2 == 1;\n  }\n\n  function charsAround(cm, pos) {\n    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\n                          Pos(pos.line, pos.ch + 1));\n    return str.length == 2 ? str : null;\n  }\n\n  // Project the token type that will exists after the given char is\n  // typed, and use it to determine whether it would cause the start\n  // of a string token.\n  function enteringString(cm, pos, ch) {\n    var line = cm.getLine(pos.line);\n    var token = cm.getTokenAt(pos);\n    if (/\\bstring2?\\b/.test(token.type)) return false;\n    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);\n    stream.pos = stream.start = token.start;\n    for (;;) {\n      var type1 = cm.getMode().token(stream, token.state);\n      if (stream.pos >= pos.ch + 1) return /\\bstring2?\\b/.test(type1);\n      stream.start = stream.pos;\n    }\n  }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/addon/edit/closebrackets.js\n ** module id = 428\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./foldcode\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"change\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", updateInViewport);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"change\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", updateInViewport);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarksAt(Pos(line));\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from;\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\n    var func = cm.foldOption(opts, \"rangeFinder\");\n    cm.eachLine(from, to, function(line) {\n      var mark = null;\n      if (isFolded(cm, cur)) {\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func && func(cm, pos);\n        if (range && range.to.line - range.from.line >= minSize)\n          mark = marker(opts.indicatorOpen);\n      }\n      cm.setGutterMarker(line, opts.gutter, mark);\n      ++cur;\n    });\n  }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts.rangeFinder);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/addon/fold/foldgutter.js\n ** module id = 429\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold && force !== \"fold\") {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: true,\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options) {\n    var widget = getOption(cm, options, \"widget\");\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n\n  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n    return getOption(this, options, name);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/addon/fold/foldcode.js\n ** module id = 430\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var startCh, tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\n  if (startCh == null) {\n    startToken = \"[\", endToken = \"]\";\n    startCh = findOpening(\"[\");\n  }\n\n  if (startCh == null) return;\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n  function hasImport(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var start = start.line, has = hasImport(start), prev;\n  if (!has || hasImport(start - 1) || ((prev = hasImport(start - 2)) && prev.end.line == start - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(start, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n  function hasInclude(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n  }\n\n  var start = start.line, has = hasInclude(start);\n  if (has == null || hasInclude(start - 1) != null) return null;\n  for (var end = start;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(start, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/addon/fold/brace-fold.js\n ** module id = 431\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n\n  function showTooltip(e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip\";\n    tt.appendChild(content.cloneNode(true));\n    document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n      tt.style.left = (e.clientX + 5) + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(e, content, node) {\n    var tooltip = showTooltip(e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n && n.nodeType == 11) n = n.host;\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, options, hasGutter) {\n    this.marked = [];\n    this.options = options;\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n    this.waitingFor = 0\n  }\n\n  function parseOptions(_cm, options) {\n    if (options instanceof Function) return {getAnnotations: options};\n    if (!options || options === true) options = {};\n    return options;\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function makeMarker(labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message-\" + severity;\n    tip.appendChild(document.createTextNode(ann.message));\n    return tip;\n  }\n\n  function lintAsync(cm, getAnnotations, passOptions) {\n    var state = cm.state.lint\n    var id = ++state.waitingFor\n    function abort() {\n      id = -1\n      cm.off(\"change\", abort)\n    }\n    cm.on(\"change\", abort)\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\n      cm.off(\"change\", abort)\n      if (state.waitingFor != id) return\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n      updateLinting(cm, annotations)\n    }, passOptions, cm);\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint, options = state.options;\n    var passOptions = options.options || options; // Support deprecated passing of `options` property in options\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!getAnnotations) return;\n    if (options.async || getAnnotations.async) {\n      lintAsync(cm, getAnnotations, passOptions)\n    } else {\n      updateLinting(cm, getAnnotations(cm.getValue(), passOptions, cm));\n    }\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    clearMarks(cm);\n    var state = cm.state.lint, options = state.options;\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,\n                                                       state.options.tooltips));\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);\n  }\n\n  function popupSpanTooltip(ann, e) {\n    var target = e.target || e.srcElement;\n    showTooltipFor(e, annotationTooltip(ann), target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) return popupSpanTooltip(ann, e);\n    }\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      if (cm.state.lint.options.lintOnChange !== false)\n        cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      clearTimeout(cm.state.lint.timeout);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);\n      if (state.options.lintOnChange !== false)\n        cm.on(\"change\", onChange);\n      if (state.options.tooltips != false)\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n\n  CodeMirror.defineExtension(\"performLint\", function() {\n    if (this.state.lint) startLinting(this);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/addon/lint/lint.js\n ** module id = 432\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type;\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds[map[\"Alt-Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n  cmds[map[\"Alt-Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\n  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\n  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  map[\"Shift-Tab\"] = \"indentLess\";\n\n  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  map[\"Shift-\" + ctrl + \"K\"] = \"deleteLine\";\n\n  function insertLine(cm, above) {\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n  }\n\n  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { insertLine(cm, false); };\n\n  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      if (cur.findNext()) {\n        cm.addSelection(cur.from(), cur.to());\n      } else {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        if (cur.findNext())\n          cm.addSelection(cur.from(), cur.to());\n      }\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var pos = cm.getCursor(), opening = cm.scanForBracket(pos, -1);\n    if (!opening) return;\n    for (;;) {\n      var closing = cm.scanForBracket(pos, 1);\n      if (!closing) return;\n      if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n        cm.setSelection(Pos(opening.pos.line, opening.pos.ch + 1), closing.pos, false);\n        return true;\n      }\n      pos = Pos(closing.pos.line, closing.pos.ch + 1);\n    }\n  }\n\n  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1);\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1);\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\n  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  map[ctrl + \"/\"] = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  map[ctrl + \"T\"] = \"transposeChars\";\n\n  function sortLines(cm, caseSensitive) {\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = range[++i].to().line;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort();\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -1 : a == b ? 0 : 1;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: end});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\n  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  map[\"Alt-Q\"] = \"wrapLines\";\n\n  var cK = ctrl + \"K \";\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\n  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    var cursor = cm.getCursor();\n    var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n    var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n    var indentUnit = cm.getOption(\"indentUnit\");\n\n    if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n      var prevIndent = new Pos(cursor.line,\n        CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n      // If no smart delete is happening (due to tab sizing) just do a regular delete\n      if (prevIndent.ch == cursor.ch) return CodeMirror.Pass;\n\n      return cm.replaceRange(\"\", prevIndent, cursor, \"+delete\");\n    } else {\n      return CodeMirror.Pass;\n    }\n  };\n\n  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  cmds[map[\"Shift-Alt-Up\"] = \"selectLinesUpward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line > cm.firstLine())\n          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n      }\n    });\n  };\n  cmds[map[\"Shift-Alt-Down\"] = \"selectLinesDownward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line < cm.lastLine())\n          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n      }\n    });\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"j\"] = \"unfoldAll\";\n\n  map[ctrl + \"I\"] = \"findIncremental\";\n  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n  map[ctrl + \"H\"] = \"replace\";\n  map[\"F3\"] = \"findNext\";\n  map[\"Shift-F3\"] = \"findPrev\";\n\n  CodeMirror.normalizeKeyMap(map);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/keymap/sublime.js\n ** module id = 433\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var Pos = CodeMirror.Pos;\n\n  function SearchCursor(doc, query, pos, caseFold) {\n    this.atOccurrence = false; this.doc = doc;\n    if (caseFold == null && typeof query == \"string\") caseFold = false;\n\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n    this.pos = {from: pos, to: pos};\n\n    // The matches method is filled in based on the type of query.\n    // It takes a position and a direction, and returns an object\n    // describing the next occurrence of the query, or null if no\n    // more matches were found.\n    if (typeof query != \"string\") { // Regexp match\n      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? \"ig\" : \"g\");\n      this.matches = function(reverse, pos) {\n        if (reverse) {\n          query.lastIndex = 0;\n          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;\n          for (;;) {\n            query.lastIndex = cutOff;\n            var newMatch = query.exec(line);\n            if (!newMatch) break;\n            match = newMatch;\n            start = match.index;\n            cutOff = match.index + (match[0].length || 1);\n            if (cutOff == line.length) break;\n          }\n          var matchLen = (match && match[0].length) || 0;\n          if (!matchLen) {\n            if (start == 0 && line.length == 0) {match = undefined;}\n            else if (start != doc.getLine(pos.line).length) {\n              matchLen++;\n            }\n          }\n        } else {\n          query.lastIndex = pos.ch;\n          var line = doc.getLine(pos.line), match = query.exec(line);\n          var matchLen = (match && match[0].length) || 0;\n          var start = match && match.index;\n          if (start + matchLen != line.length && !matchLen) matchLen = 1;\n        }\n        if (match && matchLen)\n          return {from: Pos(pos.line, start),\n                  to: Pos(pos.line, start + matchLen),\n                  match: match};\n      };\n    } else { // String query\n      var origQuery = query;\n      if (caseFold) query = query.toLowerCase();\n      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n      var target = query.split(\"\\n\");\n      // Different methods for single-line and multi-line queries\n      if (target.length == 1) {\n        if (!query.length) {\n          // Empty string would match anything and never progress, so\n          // we define it to match nothing instead.\n          this.matches = function() {};\n        } else {\n          this.matches = function(reverse, pos) {\n            if (reverse) {\n              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);\n              var match = line.lastIndexOf(query);\n              if (match > -1) {\n                match = adjustPos(orig, line, match);\n                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n              }\n             } else {\n               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);\n               var match = line.indexOf(query);\n               if (match > -1) {\n                 match = adjustPos(orig, line, match) + pos.ch;\n                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n               }\n            }\n          };\n        }\n      } else {\n        var origTarget = origQuery.split(\"\\n\");\n        this.matches = function(reverse, pos) {\n          var last = target.length - 1;\n          if (reverse) {\n            if (pos.line - (target.length - 1) < doc.firstLine()) return;\n            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;\n            var to = Pos(pos.line, origTarget[last].length);\n            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)\n              if (target[i] != fold(doc.getLine(ln))) return;\n            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            return {from: Pos(ln, cut), to: to};\n          } else {\n            if (pos.line + (target.length - 1) > doc.lastLine()) return;\n            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            var from = Pos(pos.line, cut);\n            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)\n              if (target[i] != fold(doc.getLine(ln))) return;\n            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;\n            return {from: from, to: Pos(ln, origTarget[last].length)};\n          }\n        };\n      }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false);},\n    findPrevious: function() {return this.find(true);},\n\n    find: function(reverse) {\n      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      function savePosAndFail(line) {\n        var pos = Pos(line, 0);\n        self.pos = {from: pos, to: pos};\n        self.atOccurrence = false;\n        return false;\n      }\n\n      for (;;) {\n        if (this.pos = this.matches(reverse, pos)) {\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        }\n        if (reverse) {\n          if (!pos.line) return savePosAndFail(0);\n          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);\n        }\n        else {\n          var maxLine = this.doc.lineCount();\n          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n          pos = Pos(pos.line + 1, 0);\n        }\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from;},\n    to: function() {if (this.atOccurrence) return this.pos.to;},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return;\n      var lines = CodeMirror.splitLines(newText);\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n    }\n  };\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos) {\n    if (orig.length == folded.length) return pos;\n    for (var pos1 = Math.min(pos, orig.length);;) {\n      var len1 = orig.slice(0, pos1).toLowerCase().length;\n      if (len1 < pos) ++pos1;\n      else if (len1 > pos) --pos1;\n      else return pos1;\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold);\n  });\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold);\n  });\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = [];\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n      ranges.push({anchor: cur.from(), head: cur.to()});\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/addon/search/searchcursor.js\n ** module id = 434\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _codemirror = require('codemirror');\n\nvar _codemirror2 = _interopRequireDefault(_codemirror);\n\nvar _graphqlType = require('graphql/type');\n\nvar _graphqlTypeIntrospection = require('graphql/type/introspection');\n\n/**\n * Registers a \"hint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"hint\" addon: https://codemirror.net/demo/complete.html\n * Given an editor, this helper will take the token at the cursor and return a\n * list of suggested tokens.\n *\n * Options:\n *\n *   - schema: GraphQLSchema provides the hinter with positionally relevant info\n *\n * Additional Events:\n *\n *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a\n *     new list of completion suggestions.\n *\n */\n_codemirror2['default'].registerHelper('hint', 'graphql', function (editor, options) {\n  var schema = options.schema;\n  if (!schema) {\n    return;\n  }\n\n  var cur = editor.getCursor();\n  var token = editor.getTokenAt(cur);\n  var typeInfo = getTypeInfo(schema, token.state);\n\n  var state = token.state;\n  var kind = state.kind;\n  var step = state.step;\n\n  if (token.type === 'comment') {\n    return;\n  }\n\n  // Definition kinds\n  if (kind === 'Document') {\n    return hintList(editor, options, cur, token, [{ text: 'query' }, { text: 'mutation' }, { text: 'subscription' }, { text: 'fragment' }, { text: '{' }]);\n  }\n\n  // Field names\n  if (kind === 'SelectionSet' || kind === 'Field' || kind === 'AliasedField') {\n    if (typeInfo.parentType) {\n      var fields;\n      if (typeInfo.parentType.getFields) {\n        var fieldObj = typeInfo.parentType.getFields();\n        fields = Object.keys(fieldObj).map(function (fieldName) {\n          return fieldObj[fieldName];\n        });\n      } else {\n        fields = [];\n      }\n      if (_graphqlType.isAbstractType(typeInfo.parentType)) {\n        fields.push(_graphqlTypeIntrospection.TypeNameMetaFieldDef);\n      }\n      if (typeInfo.parentType === schema.getQueryType()) {\n        fields.push(_graphqlTypeIntrospection.SchemaMetaFieldDef, _graphqlTypeIntrospection.TypeMetaFieldDef);\n      }\n      return hintList(editor, options, cur, token, fields.map(function (field) {\n        return {\n          text: field.name,\n          type: field.type,\n          description: field.description\n        };\n      }));\n    }\n  }\n\n  // Argument names\n  if (kind === 'Arguments' || kind === 'Argument' && step === 0) {\n    var argDefs = typeInfo.argDefs;\n    if (argDefs) {\n      return hintList(editor, options, cur, token, argDefs.map(function (argDef) {\n        return {\n          text: argDef.name,\n          type: argDef.type,\n          description: argDef.description\n        };\n      }));\n    }\n  }\n\n  // Input Object fields\n  if (kind === 'ObjectValue' || kind === 'ObjectField' && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      var objectFields = Object.keys(typeInfo.objectFieldDefs).map(function (fieldName) {\n        return typeInfo.objectFieldDefs[fieldName];\n      });\n      return hintList(editor, options, cur, token, objectFields.map(function (field) {\n        return {\n          text: field.name,\n          type: field.type,\n          description: field.description\n        };\n      }));\n    }\n  }\n\n  // Input values: Enum and Boolean\n  if (kind === 'EnumValue' || kind === 'ListValue' && step === 1 || kind === 'ObjectField' && step === 2 || kind === 'Argument' && step === 2) {\n    var namedInputType = _graphqlType.getNamedType(typeInfo.inputType);\n    if (namedInputType instanceof _graphqlType.GraphQLEnumType) {\n      var valueMap = namedInputType.getValues();\n      var values = Object.keys(valueMap).map(function (valueName) {\n        return valueMap[valueName];\n      });\n      return hintList(editor, options, cur, token, values.map(function (value) {\n        return {\n          text: value.name,\n          type: namedInputType,\n          description: value.description\n        };\n      }));\n    } else if (namedInputType === _graphqlType.GraphQLBoolean) {\n      return hintList(editor, options, cur, token, [{ text: 'true', type: _graphqlType.GraphQLBoolean, description: 'Not false.' }, { text: 'false', type: _graphqlType.GraphQLBoolean, description: 'Not true.' }]);\n    }\n  }\n\n  // Fragment type conditions\n  if (kind === 'TypeCondition' && step === 1 || kind === 'NamedType' && state.prevState.kind === 'TypeCondition') {\n    var possibleTypes;\n    if (typeInfo.parentType) {\n      possibleTypes = _graphqlType.isAbstractType(typeInfo.parentType) ? typeInfo.parentType.getPossibleTypes() : [typeInfo.parentType];\n    } else {\n      var typeMap = schema.getTypeMap();\n      possibleTypes = Object.keys(typeMap).map(function (typeName) {\n        return typeMap[typeName];\n      }).filter(_graphqlType.isCompositeType);\n    }\n    return hintList(editor, options, cur, token, possibleTypes.map(function (type) {\n      return {\n        text: type.name,\n        description: type.description\n      };\n    }));\n  }\n\n  // Variable definition types\n  if (kind === 'VariableDefinition' && step === 2 || kind === 'ListType' && step === 1 || kind === 'NamedType' && (state.prevState.kind === 'VariableDefinition' || state.prevState.kind === 'ListType')) {\n    var inputTypeMap = schema.getTypeMap();\n    var inputTypes = Object.keys(inputTypeMap).map(function (typeName) {\n      return inputTypeMap[typeName];\n    }).filter(_graphqlType.isInputType);\n    return hintList(editor, options, cur, token, inputTypes.map(function (type) {\n      return {\n        text: type.name,\n        description: type.description\n      };\n    }));\n  }\n\n  // Directive names\n  if (kind === 'Directive') {\n    var directives = schema.getDirectives().filter(function (directive) {\n      return directive.onField && state.prevState.kind === 'Field' || directive.onFragment && (state.prevState.kind === 'FragmentDefinition' || state.prevState.kind === 'InlineFragment' || state.prevState.kind === 'FragmentSpread') || directive.onOperation && (state.prevState.kind === 'Query' || state.prevState.kind === 'Mutation' || state.prevState.kind === 'Subscription');\n    });\n    return hintList(editor, options, cur, token, directives.map(function (directive) {\n      return {\n        text: directive.name,\n        description: directive.description\n      };\n    }));\n  }\n});\n\n// Utility for collecting rich type information given any token's state\n// from the graphql-mode parser.\nfunction getTypeInfo(schema, tokenState) {\n  var info = {\n    type: null,\n    parentType: null,\n    inputType: null,\n    directiveDef: null,\n    fieldDef: null,\n    argDef: null,\n    argDefs: null,\n    objectFieldDefs: null\n  };\n\n  forEachState(tokenState, function (state) {\n    switch (state.kind) {\n      case 'Query':case 'ShortQuery':\n        info.type = schema.getQueryType();\n        break;\n      case 'Mutation':\n        info.type = schema.getMutationType();\n        break;\n      case 'Subscription':\n        info.type = schema.getSubscriptionType();\n        break;\n      case 'InlineFragment':\n      case 'FragmentDefinition':\n        info.type = state.type && schema.getType(state.type);\n        break;\n      case 'Field':\n        info.fieldDef = info.type && state.name ? getFieldDef(schema, info.parentType, state.name) : null;\n        info.type = info.fieldDef && info.fieldDef.type;\n        break;\n      case 'SelectionSet':\n        info.parentType = _graphqlType.getNamedType(info.type);\n        break;\n      case 'Directive':\n        info.directiveDef = state.name && schema.getDirective(state.name);\n        break;\n      case 'Arguments':\n        info.argDefs = state.prevState.kind === 'Field' ? info.fieldDef && info.fieldDef.args : state.prevState.kind === 'Directive' ? info.directiveDef && info.directiveDef.args : null;\n        break;\n      case 'Argument':\n        info.argDef = null;\n        if (info.argDefs) {\n          for (var i = 0; i < info.argDefs.length; i++) {\n            if (info.argDefs[i].name === state.name) {\n              info.argDef = info.argDefs[i];\n              break;\n            }\n          }\n        }\n        info.inputType = info.argDef && info.argDef.type;\n        break;\n      case 'ListValue':\n        var nullableType = _graphqlType.getNullableType(info.inputType);\n        info.inputType = nullableType instanceof _graphqlType.GraphQLList ? nullableType.ofType : null;\n        break;\n      case 'ObjectValue':\n        var objectType = _graphqlType.getNamedType(info.inputType);\n        info.objectFieldDefs = objectType instanceof _graphqlType.GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case 'ObjectField':\n        var objectField = state.name && info.objectFieldDefs ? info.objectFieldDefs[state.name] : null;\n        info.inputType = objectField && objectField.type;\n        break;\n    }\n  });\n\n  return info;\n}\n\n// Utility for iterating through a state stack bottom-up.\nfunction forEachState(stack, fn) {\n  var reverseStateStack = [];\n  var state = stack;\n  while (state && state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (var i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n\n// Gets the field definition given a type and field name\nfunction getFieldDef(schema, type, fieldName) {\n  if (fieldName === _graphqlTypeIntrospection.SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n    return _graphqlTypeIntrospection.SchemaMetaFieldDef;\n  }\n  if (fieldName === _graphqlTypeIntrospection.TypeMetaFieldDef.name && schema.getQueryType() === type) {\n    return _graphqlTypeIntrospection.TypeMetaFieldDef;\n  }\n  if (fieldName === _graphqlTypeIntrospection.TypeNameMetaFieldDef.name && _graphqlType.isCompositeType(type)) {\n    return _graphqlTypeIntrospection.TypeNameMetaFieldDef;\n  }\n  if (type.getFields) {\n    return type.getFields()[fieldName];\n  }\n}\n\n// Create the expected hint response given a possible list and a token\nfunction hintList(editor, options, cursor, token, list) {\n  var hints = filterAndSortList(list, normalizeText(token.string));\n  if (!hints) {\n    return;\n  }\n\n  var tokenStart = token.type === null ? token.end : /\\w/.test(token.string[0]) ? token.start : token.start + 1;\n\n  var results = {\n    list: hints,\n    from: _codemirror2['default'].Pos(cursor.line, tokenStart),\n    to: _codemirror2['default'].Pos(cursor.line, token.end)\n  };\n\n  _codemirror2['default'].signal(editor, 'hasCompletion', editor, results, token);\n\n  return results;\n}\n\n// Given a list of hint entries and currently typed text, sort and filter to\n// provide a concise list.\nfunction filterAndSortList(list, text) {\n  var sorted = !text ? list : list.map(function (entry) {\n    return {\n      proximity: getProximity(normalizeText(entry.text), text),\n      entry: entry\n    };\n  }).filter(function (pair) {\n    return pair.proximity <= 2;\n  }).sort(function (a, b) {\n    return a.proximity - b.proximity || a.entry.text.length - b.entry.text.length;\n  }).map(function (pair) {\n    return pair.entry;\n  });\n\n  return sorted.length > 0 ? sorted : list;\n}\n\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, '');\n}\n\n// Determine a numeric proximity for a suggestion based on current text.\nfunction getProximity(suggestion, text) {\n  // start with lexical distance\n  var proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    // do not penalize long suggestions.\n    proximity -= suggestion.length - text.length - 1;\n    // penalize suggestions not starting with this phrase\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * This distance can be useful for detecting typos in input or sorting\n *\n * @param {string} a\n * @param {string} b\n * @return {int} distance in number of edits\n */\nfunction lexicalDistance(a, b) {\n  var i;\n  var j;\n  var d = [];\n  var aLength = a.length;\n  var bLength = b.length;\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      var cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n\n  return d[aLength][bLength];\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/~/codemirror-graphql/hint.js\n ** module id = 435\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _codemirror = require('codemirror');\n\nvar _codemirror2 = _interopRequireDefault(_codemirror);\n\nvar _graphqlLanguage = require('graphql/language');\n\nvar _graphqlValidation = require('graphql/validation');\n\n/**\n * Registers a \"lint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"lint\" addon: https://codemirror.net/demo/lint.html\n * Given the text within an editor, this helper will take that text and return\n * a list of linter issues, derived from GraphQL's parse and validate steps.\n *\n * Options:\n *\n *   - schema: GraphQLSchema provides the linter with positionally relevant info\n *\n */\n_codemirror2['default'].registerHelper('lint', 'graphql', function (text, options, editor) {\n  var schema = options.schema;\n  try {\n    var ast = _graphqlLanguage.parse(text);\n  } catch (error) {\n    var location = error.locations[0];\n    var pos = _codemirror2['default'].Pos(location.line - 1, location.column);\n    var token = editor.getTokenAt(pos);\n    return [{\n      message: error.message,\n      severity: 'error',\n      type: 'syntax',\n      from: _codemirror2['default'].Pos(location.line - 1, token.start),\n      to: _codemirror2['default'].Pos(location.line - 1, token.end)\n    }];\n  }\n  var errors = schema ? _graphqlValidation.validate(schema, ast) : [];\n  return mapCat(errors, function (error) {\n    return errorAnnotations(editor, error);\n  });\n});\n\nfunction errorAnnotations(editor, error) {\n  return error.nodes.map(function (node) {\n    var highlightNode = node.kind !== 'Variable' && node.name ? node.name : node.variable ? node.variable : node;\n    return {\n      message: error.message,\n      severity: 'error',\n      type: 'validation',\n      from: editor.posFromIndex(highlightNode.loc.start),\n      to: editor.posFromIndex(highlightNode.loc.end)\n    };\n  });\n}\n\n// General utility for map-cating (aka flat-mapping).\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/~/codemirror-graphql/lint.js\n ** module id = 436\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _validate = require('./validate');\n\nObject.defineProperty(exports, 'validate', {\n  enumerable: true,\n  get: function get() {\n    return _validate.validate;\n  }\n});\n\nvar _specifiedRules = require('./specifiedRules');\n\nObject.defineProperty(exports, 'specifiedRules', {\n  enumerable: true,\n  get: function get() {\n    return _specifiedRules.specifiedRules;\n  }\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphql/validation/index.js\n ** module id = 437\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _codemirror = require('codemirror');\n\nvar _codemirror2 = _interopRequireDefault(_codemirror);\n\n/**\n * The GraphQL mode is defined as a tokenizer along with a list of rules, each\n * of which is either a function or an array.\n *\n *   * Function: Provided a token and the stream, returns an expected next step.\n *   * Array: A list of steps to take in order.\n *\n * A step is either another rule, or a terminal description of a token. If it\n * is a rule, that rule is pushed onto the stack and the parsing continues from\n * that point.\n *\n * If it is a terminal description, the token is checked against it using a\n * `match` function. If the match is successful, the token is colored and the\n * rule is stepped forward. If the match is unsuccessful, the remainder of the\n * rule is skipped and the previous rule is advanced.\n *\n * This parsing algorithm allows for incremental online parsing within various\n * levels of the syntax tree and results in a structured `state` linked-list\n * which contains the relevant information to produce valuable typeaheads.\n */\n_codemirror2['default'].defineMode('graphql', function (config) {\n  return {\n    config: config,\n    token: getToken,\n    indent: indent,\n    startState: function startState() {\n      var initialState = { level: 0 };\n      pushRule(initialState, 'Document');\n      return initialState;\n    },\n    electricInput: /^\\s*[})\\]]/,\n    fold: 'brace',\n    lineComment: '#',\n    closeBrackets: {\n      pairs: '()[]{}\"\"',\n      explode: '()[]{}'\n    }\n  };\n});\n\nfunction getToken(stream, state) {\n  if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state);\n  }\n\n  // Remember initial indentation\n  if (stream.sol()) {\n    state.indentLevel = Math.floor(stream.indentation() / this.config.tabSize);\n  }\n\n  // Consume spaces and ignored characters\n  if (stream.eatSpace() || stream.eatWhile(',')) {\n    return null;\n  }\n\n  // Tokenize line comment\n  if (stream.match(this.lineComment)) {\n    stream.skipToEnd();\n    return 'comment';\n  }\n\n  // Lex a token from the stream\n  var token = lex(stream);\n\n  // If there's no matching token, skip ahead.\n  if (!token) {\n    stream.match(/\\w+|./);\n    return 'invalidchar';\n  }\n\n  // Save state before continuing.\n  saveState(state);\n\n  // Handle changes in expected indentation level\n  if (token.kind === 'Punctuation') {\n    if (/^[{([]/.test(token.value)) {\n      // Push on the stack of levels one level deeper than the current level.\n      state.levels = (state.levels || []).concat(state.indentLevel + 1);\n    } else if (/^[})\\]]/.test(token.value)) {\n      // Pop from the stack of levels.\n      // If the top of the stack is lower than the current level, lower the\n      // current level to match.\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n      if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n        state.indentLevel = levels[levels.length - 1];\n      }\n    }\n  }\n\n  while (state.rule) {\n    // If this is a forking rule, determine what rule to use based on\n    // the current token, otherwise expect based on the current step.\n    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n\n    if (expected) {\n      // Un-wrap optional/list ParseRules.\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n\n      // A string represents a Rule\n      if (typeof expected === 'string') {\n        pushRule(state, expected);\n        continue;\n      }\n\n      // Otherwise, match a Terminal.\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n        // If this token was a punctuator, advance the parse rule, otherwise\n        // mark the state to be advanced before the next token. This ensures\n        // that tokens which can be appended to keep the appropriate state.\n        if (token.kind === 'Punctuation') {\n          advanceRule(state);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n\n    unsuccessful(state);\n  }\n\n  // The parser does not know how to interpret this token, do not affect state.\n  restoreState(state);\n  return 'invalidchar';\n}\n\nfunction indent(state, textAfter) {\n  var levels = state.levels;\n  // If there is no stack of levels, use the current level.\n  // Otherwise, use the top level, pre-emptively dedenting for close braces.\n  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (this.electricInput.test(textAfter) ? 1 : 0);\n  return level * this.config.indentUnit;\n}\n\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n\nvar stateCache = {};\n\n// Save the current state in the cache.\nfunction saveState(state) {\n  assign(stateCache, state);\n}\n\n// Restore from the state cache.\nfunction restoreState(state) {\n  assign(state, stateCache);\n}\n\n// Push a new rule onto the state.\nfunction pushRule(state, ruleKind) {\n  state.prevState = assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = ParseRules[ruleKind];\n  state.step = 0;\n}\n\n// Pop the current rule from the state.\nfunction popRule(state) {\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.prevState = state.prevState.prevState;\n}\n\n// Advance the step of the current rule.\nfunction advanceRule(state) {\n  // Advance the step in the rule. If the rule is completed, pop\n  // the rule and advance the parent rule as well (recursively).\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    // Do not advance a List step so it has the opportunity to repeat itself.\n    if (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].isList)) {\n      state.step++;\n    }\n  }\n}\n\n// Unwind the state after an unsuccessful match.\nfunction unsuccessful(state) {\n  // Fall back to the parent rule until you get to an optional or list rule or\n  // until the entire stack of rules is empty.\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n\n  // If there is still a rule, it must be an optional or list rule.\n  // Consider this rule a success so that we may move past it.\n  if (state.rule) {\n    advanceRule(state);\n  }\n}\n\n// Given a stream, returns a { kind, value } pair, or null.\nfunction lex(stream) {\n  var kinds = Object.keys(LexRules);\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(LexRules[kinds[i]]);\n    if (match) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n\n// An optional rule.\nfunction opt(ofRule) {\n  return { ofRule: ofRule };\n}\n\n// A list of another rule.\nfunction list(ofRule) {\n  return { ofRule: ofRule, isList: true };\n}\n\n// Token of a kind\nfunction t(kind, style) {\n  return { style: style, match: function match(token) {\n      return token.kind === kind;\n    } };\n}\n\n// Punctuator\nfunction p(value, style) {\n  return {\n    style: style || 'punctuation',\n    match: function match(token) {\n      return token.kind === 'Punctuation' && token.value === value;\n    }\n  };\n}\n\n// A keyword Token\nfunction word(value) {\n  return {\n    style: 'keyword',\n    match: function match(token) {\n      return token.kind === 'Name' && token.value === value;\n    }\n  };\n}\n\n// A Name Token which will decorate the state with a `name`\nfunction name(style) {\n  return {\n    style: style,\n    match: function match(token) {\n      return token.kind === 'Name';\n    },\n    update: function update(state, token) {\n      state.name = token.value;\n    }\n  };\n}\n\n// A Name Token which will decorate the previous state with a `type`\nfunction type(style) {\n  return {\n    style: style,\n    match: function match(token) {\n      return token.kind === 'Name';\n    },\n    update: function update(state, token) {\n      state.prevState.type = token.value;\n    }\n  };\n}\n\n/**\n * The lexer rules. These are exactly as described by the spec.\n */\nvar LexRules = {\n  // The Name token.\n  Name: /^[_A-Za-z][_0-9A-Za-z]*/,\n\n  // All Punctuation used in GraphQL\n  Punctuation: /^(?:!|\\$|\\(|\\)|\\.\\.\\.|:|=|@|\\[|\\]|\\{|\\})/,\n\n  // Combines the IntValue and FloatValue tokens.\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n\n  // Note the closing quote is made optional as an IDE experience improvment.\n  String: /^\"(?:[^\"\\\\]|\\\\(?:b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?/\n};\n\n/**\n * The parser rules. These are very close to, but not exactly the same as the\n * spec. Minor deviations allow for a simpler implementation. The resulting\n * parser can parse everything the spec declares possible.\n */\nvar ParseRules = {\n  Document: [list('Definition')],\n  Definition: function Definition(token) {\n    switch (token.value) {\n      case 'query':\n        return 'Query';\n      case 'mutation':\n        return 'Mutation';\n      case 'subscription':\n        return 'Subscription';\n      case 'fragment':\n        return 'FragmentDefinition';\n      case '{':\n        return 'ShortQuery';\n    }\n  },\n  // Note: instead of \"Operation\", these rules have been separated out.\n  Query: [word('query'), opt(name('def')), opt('VariableDefinitions'), list('Directive'), 'SelectionSet'],\n  ShortQuery: ['SelectionSet'],\n  Mutation: [word('mutation'), opt(name('def')), opt('VariableDefinitions'), list('Directive'), 'SelectionSet'],\n  Subscription: [word('subscription'), opt(name('def')), opt('VariableDefinitions'), list('Directive'), 'SelectionSet'],\n  VariableDefinitions: [p('('), list('VariableDefinition'), p(')')],\n  VariableDefinition: ['Variable', p(':'), 'Type', opt('DefaultValue')],\n  Variable: [p('$', 'variable'), name('variable')],\n  DefaultValue: [p('='), 'Value'],\n  SelectionSet: [p('{'), list('Selection'), p('}')],\n  Selection: function Selection(token, stream) {\n    return token.value === '...' ? stream.match(/[\\s\\u00a0,]*on\\b/, false) ? 'InlineFragment' : 'FragmentSpread' : stream.match(/[\\s\\u00a0,]*:/, false) ? 'AliasedField' : 'Field';\n  },\n  // Note: this minor deviation of \"AliasedField\" simplifies the lookahead.\n  AliasedField: [name('qualifier'), p(':'), 'Field'],\n  Field: [name('property'), opt('Arguments'), list('Directive'), opt('SelectionSet')],\n  Arguments: [p('('), list('Argument'), p(')')],\n  Argument: [name('attribute'), p(':'), 'Value'],\n  FragmentSpread: [p('...'), name('def'), list('Directive')],\n  InlineFragment: [p('...'), opt('TypeCondition'), list('Directive'), 'SelectionSet'],\n  FragmentDefinition: [word('fragment'), name('def'), 'TypeCondition', list('Directive'), 'SelectionSet'],\n  TypeCondition: [word('on'), type('atom')],\n  // Variables could be parsed in cases where only Const is expected by spec.\n  Value: function Value(token) {\n    switch (token.kind) {\n      case 'Number':\n        return 'NumberValue';\n      case 'String':\n        return 'StringValue';\n      case 'Punctuation':\n        switch (token.value) {\n          case '[':\n            return 'ListValue';\n          case '{':\n            return 'ObjectValue';\n          case '$':\n            return 'Variable';\n        }\n        return null;\n      case 'Name':\n        switch (token.value) {\n          case 'true':case 'false':\n            return 'BooleanValue';\n        }\n        return 'EnumValue';\n    }\n  },\n  NumberValue: [t('Number', 'number')],\n  StringValue: [t('String', 'string')],\n  BooleanValue: [t('Name', 'builtin')],\n  EnumValue: [name('string-2')],\n  ListValue: [p('['), list('Value'), p(']')],\n  ObjectValue: [p('{'), list('ObjectField'), p('}')],\n  ObjectField: [name('attribute'), p(':'), 'Value'],\n  Type: function Type(token) {\n    return token.value === '[' ? 'ListType' : 'NamedType';\n  },\n  // NonNullType has been merged into ListType and NamedType to simplify.\n  ListType: [p('['), 'NamedType', p(']'), opt(p('!'))],\n  NamedType: [name('atom'), opt(p('!'))],\n  Directive: [p('@', 'meta'), name('meta'), opt('Arguments')]\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/~/codemirror-graphql/mode.js\n ** module id = 438\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _codemirror = require('codemirror');\n\nvar _codemirror2 = _interopRequireDefault(_codemirror);\n\nrequire('codemirror/addon/fold/brace-fold');\n\nrequire('codemirror/addon/fold/foldgutter');\n\nrequire('codemirror/addon/lint/lint');\n\nrequire('codemirror/keymap/sublime');\n\nrequire('codemirror/mode/javascript/javascript');\n\nrequire('../codemirror/lint/json-lint');\n\n/**\n * VariableEditor\n *\n * An instance of CodeMirror for editing variables defined in QueryEditor.\n *\n * Props:\n *\n *   - value: The text of the editor.\n *   - onEdit: A function called when the editor changes, given the edited text.\n *\n */\n\nvar VariableEditor = (function (_React$Component) {\n  _inherits(VariableEditor, _React$Component);\n\n  _createClass(VariableEditor, null, [{\n    key: 'propTypes',\n    value: {\n      value: _react.PropTypes.string,\n      onEdit: _react.PropTypes.func\n    },\n    enumerable: true\n  }]);\n\n  function VariableEditor(props) {\n    var _this = this;\n\n    _classCallCheck(this, VariableEditor);\n\n    _React$Component.call(this);\n\n    // Keep a cached version of the value, this cache will be updated when the\n    // editor is updated, which can later be used to protect the editor from\n    // unnecessary updates during the update lifecycle.\n\n    this._onEdit = function () {\n      if (!_this.ignoreChangeEvent) {\n        _this.cachedValue = _this.editor.getValue();\n        if (_this.props.onEdit) {\n          _this.props.onEdit(_this.cachedValue);\n        }\n      }\n    };\n\n    this.cachedValue = props.value || '';\n  }\n\n  VariableEditor.prototype.componentDidMount = function componentDidMount() {\n    this.editor = _codemirror2['default'](_reactDom2['default'].findDOMNode(this), {\n      value: this.props.value || '',\n      lineNumbers: true,\n      theme: 'graphiql',\n      mode: {\n        name: 'javascript',\n        json: true\n      },\n      lint: true,\n      autoCloseBrackets: true,\n      matchBrackets: true,\n      showCursorWhenSelecting: true,\n      keyMap: 'sublime',\n      foldGutter: {\n        minFoldSize: 4\n      },\n      gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n      extraKeys: {\n        // Editor improvements\n        'Ctrl-Left': 'goSubwordLeft',\n        'Ctrl-Right': 'goSubwordRight',\n        'Alt-Left': 'goGroupLeft',\n        'Alt-Right': 'goGroupRight'\n      }\n    });\n\n    this.editor.on('change', this._onEdit);\n  };\n\n  VariableEditor.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.editor.off('change', this._onEdit);\n    this.editor = null;\n  };\n\n  VariableEditor.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    // Ensure the changes caused by this update are not interpretted as\n    // user-input changes which could otherwise result in an infinite\n    // event loop.\n    this.ignoreChangeEvent = true;\n    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {\n      this.cachedValue = this.props.value;\n      this.editor.setValue(this.props.value);\n    }\n    this.ignoreChangeEvent = false;\n  };\n\n  VariableEditor.prototype.render = function render() {\n    return _react2['default'].createElement('div', { className: 'codemirrorWrap', ref: 'codemirror' });\n  };\n\n  return VariableEditor;\n})(_react2['default'].Component);\n\nexports.VariableEditor = VariableEditor;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/components/VariableEditor.js\n ** module id = 439\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// TODO actually recognize syntax of TypeScript constructs\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": kw(\"new\"), \"delete\": C, \"throw\": C, \"debugger\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"variable-3\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"interface\"),\n        \"extends\": kw(\"extends\"),\n        \"constructor\": kw(\"constructor\"),\n\n        // scope modifiers\n        \"public\": kw(\"public\"),\n        \"private\": kw(\"private\"),\n        \"protected\": kw(\"protected\"),\n        \"static\": kw(\"static\"),\n\n        // types\n        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/o/i)) {\n      stream.eatWhile(/[0-7]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/b/i)) {\n      stream.eatWhile(/[01]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (/^(?:operator|sof|keyword c|case|new|[\\[{}\\(,;:])$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, comprehension, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expression);\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == \":\") return cont(typedef);\n  }\n  function maybedefault(_, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function typedef(type) {\n    if (type == \"variable\") {cx.marked = \"variable-3\"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == \"spread\") return cont(funarg);\n    return pass(pattern, maybetype, maybedefault);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"extends\") return cont(expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      if (value == \"static\") {\n        cx.marked = \"keyword\";\n        return cont(classBody);\n      }\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(classGetterSetter, functiondef, classBody);\n      return cont(functiondef, classBody);\n    }\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n  }\n  function classGetterSetter(type) {\n    if (type != \"variable\") return pass();\n    cx.marked = \"property\";\n    return cont();\n  }\n  function afterExport(_type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == \"for\") return pass(comprehension, expect(\"]\"));\n    if (type == \",\") return cont(commasep(maybeexpressionNoComma, \"]\"));\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function comprehension(type) {\n    if (type == \"for\") return cont(forspec, comprehension);\n    if (type == \"if\") return cont(expression, comprehension);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/mode/javascript/javascript.js\n ** module id = 440\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _codemirror = require('codemirror');\n\nvar _codemirror2 = _interopRequireDefault(_codemirror);\n\nvar _jsonLint = require('./jsonLint');\n\n_codemirror2['default'].registerHelper('lint', 'json', function (text) {\n  var err = _jsonLint.jsonLint(text);\n  if (err) {\n    return [{\n      message: err.message,\n      severity: 'error',\n      from: getLocation(text, err.start),\n      to: getLocation(text, err.end)\n    }];\n  }\n  return [];\n});\n\nfunction getLocation(source, position) {\n  var line = 0;\n  var column = position;\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var match;\n  while ((match = lineRegexp.exec(source)) && match.index < position) {\n    line += 1;\n    column = position - (match.index + match[0].length);\n  }\n  return _codemirror2['default'].Pos(line, column);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/codemirror/lint/json-lint.js\n ** module id = 441\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n/**\n * This JSON parser simply walks the input, but does not generate an AST\n * or Value. Instead it returns either an syntax error object, or null.\n *\n * The returned syntax error object:\n *\n *   - message: string\n *   - start: int - the start inclusive offset of the syntax error\n *   - end: int - the end exclusive offset of the syntax error\n *\n */\n'use strict';\n\nexports.__esModule = true;\nexports.jsonLint = jsonLint;\n\nfunction jsonLint(str, looseMode) {\n  string = str;\n  strLen = str.length;\n  end = -1;\n  try {\n    ch();\n    lex();\n    if (looseMode) {\n      readVal();\n    } else {\n      readObj();\n    }\n    expect('EOF');\n  } catch (err) {\n    return err;\n  }\n}\n\nvar string;\nvar strLen;\nvar start;\nvar end;\nvar code;\nvar kind;\n\nfunction readObj() {\n  expect('{');\n  if (!skip('}')) {\n    do {\n      expect('String');\n      expect(':');\n      readVal();\n    } while (skip(','));\n    expect('}');\n  }\n}\n\nfunction readArr() {\n  expect('[');\n  if (!skip(']')) {\n    do {\n      readVal();\n    } while (skip(','));\n    expect(']');\n  }\n}\n\nfunction readVal() {\n  switch (kind) {\n    case '[':\n      return readArr();\n    case '{':\n      return readObj();\n    case 'String':\n      return lex();\n    default:\n      return expect('Value');\n  }\n}\n\nfunction syntaxError(message) {\n  return { message: message, start: start, end: end };\n}\n\nfunction expect(str) {\n  if (kind === str) {\n    return lex();\n  }\n  throw syntaxError('Expected ' + str + ' but got ' + string.slice(start, end) + '.');\n}\n\nfunction skip(k) {\n  if (kind === k) {\n    lex();\n    return true;\n  }\n}\n\nfunction ch() {\n  if (end < strLen) {\n    end++;\n    code = end === strLen ? 0 : string.charCodeAt(end);\n  }\n}\n\nfunction lex() {\n  while (code === 9 || code === 10 || code === 13 || code === 32) {\n    ch();\n  }\n\n  if (code === 0) {\n    kind = 'EOF';\n    return;\n  }\n\n  start = end;\n\n  switch (code) {\n    // \"\n    case 34:\n      kind = 'String';\n      return readString();\n    // -\n    case 45:\n    // 0-9\n    case 48:case 49:case 50:case 51:case 52:\n    case 53:case 54:case 55:case 56:case 57:\n      kind = 'Value';\n      return readNumber();\n    // f\n    case 102:\n      if (string.slice(start, start + 5) !== 'false') {\n        break;\n      }\n      end += 4;ch();\n\n      kind = 'Value';\n      return;\n    // n\n    case 110:\n      if (string.slice(start, start + 4) !== 'null') {\n        break;\n      }\n      end += 3;ch();\n\n      kind = 'Value';\n      return;\n    // t\n    case 116:\n      if (string.slice(start, start + 4) !== 'true') {\n        break;\n      }\n      end += 3;ch();\n\n      kind = 'Value';\n      return;\n  }\n\n  kind = string[start];\n  ch();\n}\n\nfunction readString() {\n  ch();\n  while (code !== 34) {\n    ch();\n    if (code === 92) {\n      // \\\n      ch();\n      switch (code) {\n        case 34: // '\n        case 47: // /\n        case 92: // \\\n        case 98: // b\n        case 102: // f\n        case 110: // n\n        case 114: // r\n        case 116:\n          // t\n          ch();\n          break;\n        case 117:\n          // u\n          ch();\n          readHex();\n          readHex();\n          readHex();\n          readHex();\n          break;\n        default:\n          throw syntaxError('Bad character escape sequence.');\n      }\n    } else if (end === strLen) {\n      throw syntaxError('Unterminated string.');\n    }\n  }\n\n  if (code === 34) {\n    ch();\n    return;\n  }\n\n  throw syntaxError('Unterminated string.');\n}\n\nfunction readHex() {\n  if (code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 70 || // A-F\n  code >= 97 && code <= 102 // a-f\n  ) {\n      return ch();\n    }\n  throw syntaxError('Expected hexadecimal digit.');\n}\n\nfunction readNumber() {\n  if (code === 45) {\n    // -\n    ch();\n  }\n\n  if (code === 48) {\n    // 0\n    ch();\n  } else {\n    readDigits();\n  }\n\n  if (code === 46) {\n    // .\n    ch();\n    readDigits();\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    ch();\n    if (code === 43 || code === 45) {\n      // + -\n      ch();\n    }\n    readDigits();\n  }\n}\n\nfunction readDigits() {\n  if (code < 48 || code > 57) {\n    // 0 - 9\n    throw syntaxError('Expected decimal digit.');\n  }\n  do {\n    ch();\n  } while (code >= 48 && code <= 57); // 0 - 9\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/codemirror/lint/jsonLint.js\n ** module id = 442\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _codemirror = require('codemirror');\n\nvar _codemirror2 = _interopRequireDefault(_codemirror);\n\nrequire('codemirror/addon/fold/foldgutter');\n\nrequire('codemirror/addon/fold/brace-fold');\n\nrequire('codemirror/keymap/sublime');\n\nrequire('codemirror/mode/javascript/javascript');\n\n/**\n * ResultViewer\n *\n * Maintains an instance of CodeMirror for viewing a GraphQL response.\n *\n * Props:\n *\n *   - value: The text of the editor.\n *\n */\n\nvar ResultViewer = (function (_React$Component) {\n  _inherits(ResultViewer, _React$Component);\n\n  function ResultViewer() {\n    _classCallCheck(this, ResultViewer);\n\n    _React$Component.apply(this, arguments);\n  }\n\n  ResultViewer.prototype.componentDidMount = function componentDidMount() {\n    this.viewer = _codemirror2['default'](_reactDom2['default'].findDOMNode(this), {\n      value: this.props.value || '',\n      readOnly: true,\n      theme: 'graphiql',\n      mode: {\n        name: 'javascript',\n        json: true\n      },\n      keyMap: 'sublime',\n      foldGutter: {\n        minFoldSize: 4\n      },\n      gutters: ['CodeMirror-foldgutter'],\n      extraKeys: {\n        // Editor improvements\n        'Ctrl-Left': 'goSubwordLeft',\n        'Ctrl-Right': 'goSubwordRight',\n        'Alt-Left': 'goGroupLeft',\n        'Alt-Right': 'goGroupRight'\n      }\n    });\n  };\n\n  ResultViewer.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.viewer = null;\n  };\n\n  ResultViewer.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n    return this.props.value !== nextProps.value;\n  };\n\n  ResultViewer.prototype.componentDidUpdate = function componentDidUpdate() {\n    this.viewer.setValue(this.props.value || '');\n  };\n\n  ResultViewer.prototype.render = function render() {\n    return _react2['default'].createElement('div', { className: 'result-window' });\n  };\n\n  _createClass(ResultViewer, null, [{\n    key: 'propTypes',\n    value: {\n      value: _react.PropTypes.string\n    },\n    enumerable: true\n  }]);\n\n  return ResultViewer;\n})(_react2['default'].Component);\n\nexports.ResultViewer = ResultViewer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/components/ResultViewer.js\n ** module id = 443\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _marked = require('marked');\n\nvar _marked2 = _interopRequireDefault(_marked);\n\nvar _graphqlType = require('graphql/type');\n\n/**\n * DocExplorer\n *\n * Shows documentations for GraphQL definitions from the schema.\n *\n * Props:\n *\n *   - schema: A required GraphQLSchema instance that provides GraphQL document\n *     definitions.\n *\n * Children:\n *\n *   - Any provided children will be positioned in the right-hand-side of the\n *     top bar. Typically this will be a \"close\" button for temporary explorer.\n *\n */\n\nvar DocExplorer = (function (_React$Component) {\n  _inherits(DocExplorer, _React$Component);\n\n  // Public API\n\n  DocExplorer.prototype.showDoc = function showDoc(typeOrField) {\n    var navStack = this.state.navStack;\n    var isCurrentlyShown = navStack.length > 0 && navStack[navStack.length - 1] === typeOrField;\n    if (!isCurrentlyShown) {\n      navStack = navStack.concat([typeOrField]);\n    }\n    this.setState({ navStack: navStack });\n  };\n\n  _createClass(DocExplorer, null, [{\n    key: 'propTypes',\n    value: {\n      schema: _react.PropTypes.instanceOf(_graphqlType.GraphQLSchema)\n    },\n    enumerable: true\n  }]);\n\n  function DocExplorer() {\n    var _this = this;\n\n    _classCallCheck(this, DocExplorer);\n\n    _React$Component.call(this);\n\n    this._onToggleBtnClick = function () {\n      _this.setState({ expanded: !_this.state.expanded });\n    };\n\n    this._onNavBackClick = function () {\n      _this.setState({ navStack: _this.state.navStack.slice(0, -1) });\n    };\n\n    this._onClickTypeOrField = function (typeOrField) {\n      _this.showDoc(typeOrField);\n    };\n\n    this.state = { navStack: [] };\n  }\n\n  // Render the top level Schema\n\n  DocExplorer.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return this.props.schema !== nextProps.schema || this.state.navStack !== nextState.navStack;\n  };\n\n  DocExplorer.prototype.render = function render() {\n    var schema = this.props.schema;\n    var navStack = this.state.navStack;\n\n    var typeOrField;\n    if (navStack.length > 0) {\n      typeOrField = navStack[navStack.length - 1];\n    }\n\n    var title;\n    var content;\n    if (typeOrField) {\n      title = typeOrField.name;\n      content = _graphqlType.isType(typeOrField) ? _react2['default'].createElement(TypeDoc, {\n        key: typeOrField.name,\n        type: typeOrField,\n        onClickType: this._onClickTypeOrField,\n        onClickField: this._onClickTypeOrField\n      }) : _react2['default'].createElement(FieldDoc, {\n        key: typeOrField.name,\n        field: typeOrField,\n        onClickType: this._onClickTypeOrField\n      });\n    } else if (schema) {\n      title = 'Documentation Explorer';\n      content = _react2['default'].createElement(SchemaDoc, {\n        schema: schema,\n        onClickType: this._onClickTypeOrField\n      });\n    }\n\n    var prevName;\n    if (navStack.length === 1) {\n      prevName = 'Schema';\n    } else if (navStack.length > 1) {\n      prevName = navStack[navStack.length - 2].name;\n    }\n\n    return _react2['default'].createElement(\n      'div',\n      { className: 'doc-explorer' },\n      _react2['default'].createElement(\n        'div',\n        { className: 'doc-explorer-title-bar' },\n        prevName && _react2['default'].createElement(\n          'div',\n          { className: 'doc-explorer-back', onClick: this._onNavBackClick },\n          prevName\n        ),\n        _react2['default'].createElement(\n          'div',\n          { className: 'doc-explorer-title' },\n          title\n        ),\n        _react2['default'].createElement(\n          'div',\n          { className: 'doc-explorer-rhs' },\n          this.props.children\n        )\n      ),\n      _react2['default'].createElement(\n        'div',\n        { className: 'doc-explorer-contents' },\n        content\n      )\n    );\n  };\n\n  return DocExplorer;\n})(_react2['default'].Component);\n\nexports.DocExplorer = DocExplorer;\n\nvar SchemaDoc = (function (_React$Component2) {\n  _inherits(SchemaDoc, _React$Component2);\n\n  function SchemaDoc() {\n    _classCallCheck(this, SchemaDoc);\n\n    _React$Component2.apply(this, arguments);\n  }\n\n  // Documentation for a Type\n\n  SchemaDoc.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n    return this.props.schema !== nextProps.schema;\n  };\n\n  SchemaDoc.prototype.render = function render() {\n    var schema = this.props.schema;\n    var queryType = schema.getQueryType();\n    var mutationType = schema.getMutationType();\n    var subscriptionType = schema.getSubscriptionType();\n\n    return _react2['default'].createElement(\n      'div',\n      null,\n      _react2['default'].createElement(Description, {\n        className: 'doc-type-description',\n        markdown: 'A GraphQL schema provides a root type for each kind of operation.'\n      }),\n      _react2['default'].createElement(\n        'div',\n        { className: 'doc-category' },\n        _react2['default'].createElement(\n          'div',\n          { className: 'doc-category-title' },\n          'root types'\n        ),\n        _react2['default'].createElement(\n          'div',\n          { className: 'doc-category-item' },\n          _react2['default'].createElement(\n            'span',\n            { className: 'keyword' },\n            'query'\n          ),\n          ': ',\n          _react2['default'].createElement(TypeLink, { type: queryType, onClick: this.props.onClickType })\n        ),\n        mutationType && _react2['default'].createElement(\n          'div',\n          { className: 'doc-category-item' },\n          _react2['default'].createElement(\n            'span',\n            { className: 'keyword' },\n            'mutation'\n          ),\n          ': ',\n          _react2['default'].createElement(TypeLink, { type: mutationType, onClick: this.props.onClickType })\n        ),\n        subscriptionType && _react2['default'].createElement(\n          'div',\n          { className: 'doc-category-item' },\n          _react2['default'].createElement(\n            'span',\n            { className: 'keyword' },\n            'subscription'\n          ),\n          ': ',\n          _react2['default'].createElement(TypeLink, {\n            type: subscriptionType,\n            onClick: this.props.onClickType\n          })\n        )\n      )\n    );\n  };\n\n  return SchemaDoc;\n})(_react2['default'].Component);\n\nvar TypeDoc = (function (_React$Component3) {\n  _inherits(TypeDoc, _React$Component3);\n\n  function TypeDoc() {\n    _classCallCheck(this, TypeDoc);\n\n    _React$Component3.apply(this, arguments);\n  }\n\n  // Documentation for a field\n\n  TypeDoc.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n    return this.props.type !== nextProps.type;\n  };\n\n  TypeDoc.prototype.render = function render() {\n    var type = this.props.type;\n    var onClickType = this.props.onClickType || function () {};\n    var onClickField = this.props.onClickField || function () {};\n\n    var typesTitle;\n    var types;\n    if (type instanceof _graphqlType.GraphQLUnionType) {\n      typesTitle = 'possible types';\n      types = type.getPossibleTypes();\n    } else if (type instanceof _graphqlType.GraphQLInterfaceType) {\n      typesTitle = 'implementations';\n      types = type.getPossibleTypes();\n    } else if (type instanceof _graphqlType.GraphQLObjectType) {\n      typesTitle = 'implements';\n      types = type.getInterfaces();\n    }\n\n    var typesDef;\n    if (types && types.length > 0) {\n      typesDef = _react2['default'].createElement(\n        'div',\n        { className: 'doc-category' },\n        _react2['default'].createElement(\n          'div',\n          { className: 'doc-category-title' },\n          typesTitle\n        ),\n        types.map(function (subtype) {\n          return _react2['default'].createElement(\n            'div',\n            { key: subtype.name, className: 'doc-category-item' },\n            _react2['default'].createElement(TypeLink, { type: subtype, onClick: onClickType })\n          );\n        })\n      );\n    }\n\n    // InputObject and Object\n    var fieldsDef;\n    if (type.getFields) {\n      var fieldMap = type.getFields();\n      var fields = Object.keys(fieldMap).map(function (name) {\n        return fieldMap[name];\n      });\n      fieldsDef = _react2['default'].createElement(\n        'div',\n        { className: 'doc-category' },\n        _react2['default'].createElement(\n          'div',\n          { className: 'doc-category-title' },\n          'fields'\n        ),\n        fields.map(function (field) {\n\n          // Field arguments\n          var argsDef;\n          if (field.args && field.args.length > 0) {\n            argsDef = field.args.map(function (arg) {\n              return _react2['default'].createElement(\n                'span',\n                { className: 'arg', key: arg.name },\n                _react2['default'].createElement(\n                  'span',\n                  { className: 'arg-name' },\n                  arg.name\n                ),\n                ': ',\n                _react2['default'].createElement(TypeLink, { type: arg.type, onClick: onClickType })\n              );\n            });\n          }\n\n          return _react2['default'].createElement(\n            'div',\n            { key: field.name, className: 'doc-category-item' },\n            _react2['default'].createElement(\n              'a',\n              {\n                className: 'field-name',\n                onClick: function (event) {\n                  return onClickField(field, type, event);\n                } },\n              field.name\n            ),\n            argsDef && ['(', _react2['default'].createElement(\n              'span',\n              null,\n              argsDef\n            ), ')'],\n            ': ',\n            _react2['default'].createElement(TypeLink, { type: field.type, onClick: onClickType })\n          );\n        })\n      );\n    }\n\n    var valuesDef;\n    if (type instanceof _graphqlType.GraphQLEnumType) {\n      valuesDef = _react2['default'].createElement(\n        'div',\n        { className: 'doc-category' },\n        _react2['default'].createElement(\n          'div',\n          { className: 'doc-category-title' },\n          'values'\n        ),\n        type.getValues().map(function (value) {\n          return _react2['default'].createElement(\n            'div',\n            { key: value.name, className: 'doc-category-item' },\n            _react2['default'].createElement(\n              'div',\n              { className: 'enum-value' },\n              value.name\n            ),\n            _react2['default'].createElement(Description, {\n              className: 'doc-value-description',\n              markdown: type.description\n            })\n          );\n        })\n      );\n    }\n\n    return _react2['default'].createElement(\n      'div',\n      null,\n      _react2['default'].createElement(Description, {\n        className: 'doc-type-description',\n        markdown: type.description || 'No Description'\n      }),\n      type instanceof _graphqlType.GraphQLObjectType && typesDef,\n      fieldsDef,\n      valuesDef,\n      !(type instanceof _graphqlType.GraphQLObjectType) && typesDef\n    );\n  };\n\n  return TypeDoc;\n})(_react2['default'].Component);\n\nvar FieldDoc = (function (_React$Component4) {\n  _inherits(FieldDoc, _React$Component4);\n\n  function FieldDoc() {\n    _classCallCheck(this, FieldDoc);\n\n    _React$Component4.apply(this, arguments);\n  }\n\n  // Renders a type link\n\n  FieldDoc.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n    return this.props.field !== nextProps.field;\n  };\n\n  FieldDoc.prototype.render = function render() {\n    var _this2 = this;\n\n    var field = this.props.field;\n\n    var argsDef;\n    if (field.args && field.args.length > 0) {\n      argsDef = _react2['default'].createElement(\n        'div',\n        { className: 'doc-category' },\n        _react2['default'].createElement(\n          'div',\n          { className: 'doc-category-title' },\n          'arguments'\n        ),\n        field.args.map(function (arg) {\n          return _react2['default'].createElement(\n            'div',\n            { key: arg.name, className: 'doc-category-item' },\n            _react2['default'].createElement(\n              'div',\n              null,\n              _react2['default'].createElement(\n                'span',\n                { className: 'arg-name' },\n                arg.name\n              ),\n              ': ',\n              _react2['default'].createElement(TypeLink, { type: arg.type, onClick: _this2.props.onClickType })\n            ),\n            _react2['default'].createElement(Description, {\n              className: 'doc-value-description',\n              markdown: arg.description\n            })\n          );\n        })\n      );\n    }\n\n    return _react2['default'].createElement(\n      'div',\n      null,\n      _react2['default'].createElement(Description, {\n        className: 'doc-type-description',\n        markdown: field.description || 'No Description'\n      }),\n      _react2['default'].createElement(\n        'div',\n        { className: 'doc-category' },\n        _react2['default'].createElement(\n          'div',\n          { className: 'doc-category-title' },\n          'type'\n        ),\n        _react2['default'].createElement(TypeLink, { type: field.type, onClick: this.props.onClickType })\n      ),\n      argsDef\n    );\n  };\n\n  return FieldDoc;\n})(_react2['default'].Component);\n\nvar TypeLink = (function (_React$Component5) {\n  _inherits(TypeLink, _React$Component5);\n\n  function TypeLink() {\n    _classCallCheck(this, TypeLink);\n\n    _React$Component5.apply(this, arguments);\n  }\n\n  TypeLink.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n    return this.props.type !== nextProps.type;\n  };\n\n  TypeLink.prototype.render = function render() {\n    return renderType(this.props.type, this.props.onClick);\n  };\n\n  return TypeLink;\n})(_react2['default'].Component);\n\nfunction renderType(type, onClick) {\n  if (type instanceof _graphqlType.GraphQLNonNull) {\n    return _react2['default'].createElement(\n      'span',\n      null,\n      renderType(type.ofType, onClick),\n      '!'\n    );\n  }\n  if (type instanceof _graphqlType.GraphQLList) {\n    return _react2['default'].createElement(\n      'span',\n      null,\n      '[',\n      renderType(type.ofType, onClick),\n      ']'\n    );\n  }\n  return _react2['default'].createElement(\n    'a',\n    { className: 'type-name', onClick: function (event) {\n        return onClick(type, event);\n      } },\n    type.name\n  );\n}\n\n// Renders a description\n\nvar Description = (function (_React$Component6) {\n  _inherits(Description, _React$Component6);\n\n  function Description() {\n    _classCallCheck(this, Description);\n\n    _React$Component6.apply(this, arguments);\n  }\n\n  Description.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n    return this.props.markdown !== nextProps.markdown;\n  };\n\n  Description.prototype.render = function render() {\n    var markdown = this.props.markdown;\n    if (!markdown) {\n      return _react2['default'].createElement('div', null);\n    }\n\n    var html = _marked2['default'](markdown);\n    return _react2['default'].createElement('div', {\n      className: this.props.className,\n      dangerouslySetInnerHTML: { __html: html }\n    });\n  };\n\n  return Description;\n})(_react2['default'].Component);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/components/DocExplorer.js\n ** module id = 444\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.__esModule = true;\nexports.fillLeafs = fillLeafs;\n\nvar _graphqlUtilities = require('graphql/utilities');\n\nvar _graphqlLanguage = require('graphql/language');\n\nvar _graphqlType = require('graphql/type');\n\n/**\n * Given a document string which may not be valid due to terminal fields not\n * representing leaf values (Spec Section: \"Leaf Field Selections\"), and a\n * function which provides reasonable default field names for a given type,\n * this function will attempt to produce a schema which is valid after filling\n * in selection sets for the invalid fields.\n *\n * Note that there is no guarantee that the result will be a valid query, this\n * utility represents a \"best effort\" which may be useful within IDE tools.\n */\n\nfunction fillLeafs(schema, docString, getDefaultFieldNames) {\n  var insertions = [];\n\n  if (!schema) {\n    return { insertions: insertions, result: docString };\n  }\n\n  var ast = undefined;\n  try {\n    ast = _graphqlLanguage.parse(docString);\n  } catch (error) {\n    return { insertions: insertions, result: docString };\n  }\n\n  var fieldNameFn = getDefaultFieldNames || defaultGetDefaultFieldNames;\n  var typeInfo = new _graphqlUtilities.TypeInfo(schema);\n  _graphqlLanguage.visit(ast, {\n    leave: function leave(node) {\n      typeInfo.leave(node);\n    },\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      if (node.kind === 'Field' && !node.selectionSet) {\n        var fieldType = typeInfo.getType();\n        var selectionSet = buildSelectionSet(fieldType, fieldNameFn);\n        if (selectionSet) {\n          var indent = getIndentation(docString, node.loc.start);\n          insertions.push({\n            index: node.loc.end,\n            string: ' ' + _graphqlLanguage.print(selectionSet).replace(/\\n/g, '\\n' + indent)\n          });\n        }\n      }\n    }\n  });\n\n  // Apply the insertions, but also return the insertions metadata.\n  return {\n    insertions: insertions,\n    result: withInsertions(docString, insertions)\n  };\n}\n\n// The default function to use for producing the default fields from a type.\n// This function first looks for some common patterns, and falls back to\n// including all leaf-type fields.\nfunction defaultGetDefaultFieldNames(type) {\n  var fields = type.getFields();\n\n  // Is there an `id` field?\n  if (fields['id']) {\n    return ['id'];\n  }\n\n  // Is there an `edges` field?\n  if (fields['edges']) {\n    return ['edges'];\n  }\n\n  // Is there an `node` field?\n  if (fields['node']) {\n    return ['node'];\n  }\n\n  // Include all leaf-type fields.\n  var leafFieldNames = [];\n  Object.keys(fields).forEach(function (fieldName) {\n    if (_graphqlType.isLeafType(fields[fieldName].type)) {\n      leafFieldNames.push(fieldName);\n    }\n  });\n  return leafFieldNames;\n}\n\n// Given a GraphQL type, and a function which produces field names, recursively\n// generate a SelectionSet which includes default fields.\nfunction buildSelectionSet(type, getDefaultFieldNames) {\n  // Unwrap any non-null or list types.\n  var namedType = _graphqlType.getNamedType(type);\n\n  // Unknown types and leaf types do not have selection sets.\n  if (!type || _graphqlType.isLeafType(type)) {\n    return;\n  }\n\n  // Get an array of field names to use.\n  var fieldNames = getDefaultFieldNames(namedType);\n\n  // If there are no field names to use, return no selection set.\n  if (!Array.isArray(fieldNames) || fieldNames.length === 0) {\n    return;\n  }\n\n  // Build a selection set of each field, calling buildSelectionSet recursively.\n  return {\n    kind: 'SelectionSet',\n    selections: fieldNames.map(function (fieldName) {\n      var fieldDef = namedType.getFields()[fieldName];\n      var fieldType = fieldDef ? fieldDef.type : null;\n      return {\n        kind: 'Field',\n        name: {\n          kind: 'Name',\n          value: fieldName\n        },\n        selectionSet: buildSelectionSet(fieldType, getDefaultFieldNames)\n      };\n    })\n  };\n}\n\n// Given an initial string, and a list of \"insertion\" { index, string } objects,\n// return a new string with these insertions applied.\nfunction withInsertions(initial, insertions) {\n  if (insertions.length === 0) {\n    return initial;\n  }\n  var edited = '';\n  var prevIndex = 0;\n  insertions.forEach(function (_ref) {\n    var index = _ref.index;\n    var string = _ref.string;\n\n    edited += initial.slice(prevIndex, index) + string;\n    prevIndex = index;\n  });\n  edited += initial.slice(prevIndex);\n  return edited;\n}\n\n// Given a string and an index, look backwards to find the string of whitespace\n// following the next previous line break.\nfunction getIndentation(str, index) {\n  var indentStart = index;\n  var indentEnd = index;\n  while (indentStart) {\n    var c = str.charCodeAt(indentStart - 1);\n    // line break\n    if (c === 10 || c === 13 || c === 0x2028 || c === 0x2029) {\n      break;\n    }\n    indentStart--;\n    // not white space\n    if (c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160) {\n      indentEnd = indentStart;\n    }\n  }\n  return str.substring(indentStart, indentEnd);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/utility/fillLeafs.js\n ** module id = 445\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE-examples file in the root directory of this source tree.\n */\n\n/**\n * Utility functions to get a pixel distance from left/top of the window.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\nexports.getLeft = getLeft;\nexports.getTop = getTop;\n\nfunction getLeft(initialElem) {\n  var pt = 0;\n  var elem = initialElem;\n  while (elem.offsetParent) {\n    pt += elem.offsetLeft;\n    elem = elem.offsetParent;\n  }\n  return pt;\n}\n\nfunction getTop(initialElem) {\n  var pt = 0;\n  var elem = initialElem;\n  while (elem.offsetParent) {\n    pt += elem.offsetTop;\n    elem = elem.offsetParent;\n  }\n  return pt;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/utility/elementPosition.js\n ** module id = 446\n ** module chunks = 1\n **/","/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.__esModule = true;\n\nvar _graphqlUtilities = require('graphql/utilities');\n\nexports.introspectionQuery = _graphqlUtilities.introspectionQuery;\n\n// Some GraphQL services do not support subscriptions and fail an introspection\n// query which includes the `subscriptionType` field as the stock introspection\n// query does. This backup query removes that field.\nvar introspectionQuerySansSubscriptions = '\\n  query IntrospectionQuery {\\n    __schema {\\n      queryType { name }\\n      mutationType { name }\\n      types {\\n        ...FullType\\n      }\\n      directives {\\n        name\\n        description\\n        args {\\n          ...InputValue\\n        }\\n        onOperation\\n        onFragment\\n        onField\\n      }\\n    }\\n  }\\n\\n  fragment FullType on __Type {\\n    kind\\n    name\\n    description\\n    fields(includeDeprecated: true) {\\n      name\\n      description\\n      args {\\n        ...InputValue\\n      }\\n      type {\\n        ...TypeRef\\n      }\\n      isDeprecated\\n      deprecationReason\\n    }\\n    inputFields {\\n      ...InputValue\\n    }\\n    interfaces {\\n      ...TypeRef\\n    }\\n    enumValues(includeDeprecated: true) {\\n      name\\n      description\\n      isDeprecated\\n      deprecationReason\\n    }\\n    possibleTypes {\\n      ...TypeRef\\n    }\\n  }\\n\\n  fragment InputValue on __InputValue {\\n    name\\n    description\\n    type { ...TypeRef }\\n    defaultValue\\n  }\\n\\n  fragment TypeRef on __Type {\\n    kind\\n    name\\n    ofType {\\n      kind\\n      name\\n      ofType {\\n        kind\\n        name\\n        ofType {\\n          kind\\n          name\\n        }\\n      }\\n    }\\n  }\\n';\nexports.introspectionQuerySansSubscriptions = introspectionQuerySansSubscriptions;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/graphiql/dist/utility/introspectionQueries.js\n ** module id = 447\n ** module chunks = 1\n **/","import {\n  GraphQLObjectType,\n  GraphQLString,\n  GraphQLSchema,\n} from 'graphql';\n\n\nexport default new GraphQLSchema({\n  query: new GraphQLObjectType({\n    name: 'Query',\n    fields: () => ({\n      __emptyField: {type: GraphQLString},\n    }),\n  }),\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ../playground/schema.js\n **/","//\n//  pypyjs:  an experimental in-browser python environment.\n//\n\n(function() {\n\n// Expose the main pypyjs function at global scope for this file,\n// as well as in any module exports or 'window' object we can find.\nif (this) {\n  this.pypyjs = pypyjs;\n}\nif (typeof window !== \"undefined\") {\n  window.pypyjs = pypyjs;\n}\nif (typeof module !== \"undefined\") {\n  if (typeof module.exports !== \"undefined\") {\n    module.exports = pypyjs;\n  }\n}\n\n\n// Generic debugging printf.\nvar debug = function(){};\nif (typeof console !== \"undefined\") {\n  debug = console.log.bind(console);\n} else if (typeof print !== \"undefined\" && typeof window === \"undefined\") {\n  debug = print;\n}\n\n\n// Find the directory containing this very file.\n// It can be quite difficult depending on execution environment...\nif (typeof __dirname === \"undefined\" || true) {\n  var __dirname = \"./\";\n  // A little hackery to find the URL of this very file.\n  // Throw an error, then parse the stack trace looking for filenames.\n  var errlines = (new Error()).stack.split(\"\\n\");\n  for (var i = 0; i < errlines.length; i++) {\n    var match = /(at Anonymous function \\(|at |@)(.+\\/)pypyjs.js/.exec(errlines[i]);\n    if (match) {\n      __dirname = match[2];\n      break;\n    }\n  }\n}\nif (__dirname.charAt(__dirname.length - 1) !== \"/\") {\n  __dirname += \"/\";\n}\n\n\nif (typeof Promise === \"undefined\") {\n  var Promise = require('es6-promise').Promise;\n}\n\n\n// Ensure we have reference to a 'FunctionPromise' constructor.\nvar FunctionPromise = require(\"./FunctionPromise.js\");\n\nif (typeof FunctionPromise === \"undefined\") {\n  throw \"FunctionPromise object not found\";\n}\n\n// Some extra goodies for nodejs.\nif (typeof process !== 'undefined') {\n  if (Object.prototype.toString.call(process) === '[object process]') {\n    var fs = require(\"fs\");\n    var path = require(\"path\");\n  }\n}\n\n// Create functions for handling default stdio streams.\n// These will be shared by all VM instances by default.\n//\n// We default stdout and stderr to process outputs if available,\n// printing/logging functions otherwise, and /dev/null if nothing\n// else is available.  Unfortunately there's no good way to read\n// synchronously from stdin in javascript, so that's always /dev/null.\n\nvar devNull = {\n  stdin: function() { return null; },\n  stdout: function() { },\n  stderr: function() { }\n}\n\nvar stdio = {\n  stdin: null,\n  stdout: null,\n  stderr: null\n}\n\nstdio.stdin = devNull.stdin;\n\nif (typeof process !== \"undefined\") {\n  if (typeof process.stdout !== \"undefined\") {\n    stdio.stdout = function(x) { process.stdout.write(x); }\n  }\n  if (typeof process.stderr !== \"undefined\") {\n    stdio.stderr = function(x) { process.stderr.write(x); }\n  }\n}\n\nvar _print, _printErr;\nif (typeof window === \"undefined\") {\n  // print, printErr from v8, spidermonkey\n  if (typeof print !== \"undefined\") {\n    _print = print;\n  }\n  if (typeof printErr !== \"undefined\") {\n    _printErr = printErr;\n  }\n}\nif (typeof console !== \"undefined\") {\n  if (typeof _print === \"undefined\") {\n    _print = console.log.bind(console);\n  }\n  if (typeof _printErr === \"undefined\") {\n    _printErr = console.error.bind(console);\n  }\n}\n\nif (stdio.stdout == null && typeof _print !== \"undefined\") {\n  // print()/console.log() will add a newline, so we buffer until we\n  // receive one and then let it add it for us.\n  stdio.stdout = (function() {\n    var buffer = [];\n    return function(data) {\n      for (var i = 0; i < data.length; i++) {\n        var x = data.charAt(i);\n        if (x !== \"\\n\") {\n          buffer.push(x);\n        } else {\n          _print(buffer.join(\"\"));\n          buffer.splice(undefined, buffer.length);\n        }\n      }\n    }\n  })();\n}\n\nif (stdio.stderr == null && typeof _printErr !== \"undefined\") {\n  // printErr()/console.error() will add a newline, so we buffer until we\n  // receive one and then let it add it for us.\n  stdio.stderr = (function() {\n    var buffer = [];\n    return function(data) {\n      for (var i = 0; i < data.length; i++) {\n        var x = data.charAt(i);\n        if (x !== \"\\n\") {\n          buffer.push(x);\n        } else {\n          _printErr(buffer.join(\"\"));\n          buffer.splice(undefined, buffer.length);\n        }\n      }\n    }\n  })();\n}\n\nif (stdio.stdout === null) {\n  stdio.stdout = devNull.stdout;\n}\n\nif (stdio.stderr === null) {\n  stdio.stderr = devNull.stderr;\n}\n\nfunction pypyjs(opts) {\n\n  opts = opts || {};\n  this.rootURL = opts.rootURL;\n  this.totalMemory = opts.totalMemory || 128 * 1024 * 1024;\n  this.autoLoadModules = opts.autoLoadModules || true;\n  this._pendingModules = {};\n  this._loadedModules = {};\n  this._allModules = {};\n\n  // Allow opts to override default IO streams.\n  this.stdin = opts.stdin || stdio.stdin;\n  this.stdout = opts.stdout || stdio.stdout;\n  this.stderr = opts.stderr || stdio.stderr;\n\n  // Default to finding files relative to this very file.\n  if (!this.rootURL && !pypyjs.rootURL) {\n    pypyjs.rootURL = __dirname;\n  }\n  if (this.rootURL && this.rootURL.charAt(this.rootURL.length - 1) !== \"/\") {\n    this.rootURL += \"/\";\n  } \n\n  // If we haven't already done so, fetch and load the code for the VM.\n  // We do this once and cache the result for re-use, so that we don't\n  // have to pay asmjs compilation overhead each time we create the VM.\n\n  if (! pypyjs._vmBuilderPromise) {\n    pypyjs._vmBuilderPromise = this.fetch(\"pypyjs.vm.js\").then((function(xhr) {\n      // Parse the compiled code, hopefully asynchronously.\n      // Unfortunately our use of Function constructor here doesn't\n      // play very well with nodejs, where things like 'module' and\n      // 'require' are not in the global scope.  We have to pass them\n      // in explicitly as arguments.\n      var funcBody = [\n        // This is the compiled code for the VM.\n        xhr.responseText,\n        '\\n',\n        // Ensure that some functions are available on the Module,\n        // for linking with jitted code.\n        'if (!Module._jitInvoke && typeof _jitInvoke !== \"undefined\") {',\n        '  Module._jitInvoke = _jitInvoke;',\n        '}',\n        // Keep some functions that are not exported by default, but\n        // which appear in this scope when evaluating the above.\n        \"Module._emjs_make_handle = _emjs_make_handle;\",\n        \"Module._emjs_free = _emjs_free;\",\n        // Call dependenciesFulfilled if it won't be done automatically.\n        \"dependenciesFulfilled=function() { inDependenciesFulfilled(FS); };\",\n        \"if(!memoryInitializer||(!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER))dependenciesFulfilled();\",\n      ].join(\"\");\n      return FunctionPromise(\"Module\", \"inDependenciesFulfilled\", \"require\",\n                             \"module\", \"__filename\", \"__dirname\", funcBody)\n    }).bind(this));\n  }\n\n  // Create a new instance of the compiled VM, bound to local state\n  // and a local Module object.\n\n  this._ready = new Promise((function(resolve, reject) {\n\n    // Initialize the Module object.\n    // We make it available on this object so that we can use\n    // its methods to execute code in the VM.\n    var Module = {};\n    this._module = Module;\n    Module.TOTAL_MEMORY = this.totalMemory;\n\n    // We will set up the filesystem manually when we're ready.\n    Module.noFSInit = true;\n    Module.thisProgram = \"/lib/pypyjs/pypyjs.js\";\n    Module.filePackagePrefixURL = this.rootURL || pypyjs.rootURL;\n    Module.memoryInitializerPrefixURL = this.rootURL || pypyjs.rootURL;\n    Module.locateFile = function(name) {\n      return (this.rootURL || pypyjs.rootURL) + name;\n    }\n\n    // Don't start or stop the program, just set it up.\n    // We'll call the API functions ourself.\n    Module.noInitialRun = true;\n    Module.noExitRuntime = true;\n\n    // Route stdin to an overridable method on the object.\n    var stdin = (function stdin() {\n      return this.stdin();\n    }).bind(this);\n \n    // Route stdout to an overridable method on the object.\n    // We buffer the output for efficiency.\n    var stdout_buffer = []\n    var stdout = (function stdout(x) {\n      var c = String.fromCharCode(x);\n      stdout_buffer.push(c);\n      if (c === \"\\n\" || stdout_buffer.length >= 128) {\n        this.stdout(stdout_buffer.join(\"\"));\n        stdout_buffer = [];\n      }\n    }).bind(this);\n\n    // Route stderr to an overridable method on the object.\n    // We do not buffer stderr.\n    var stderr = (function stderr(x) {\n      var c = String.fromCharCode(x);\n      this.stderr(c);\n    }).bind(this);\n\n    // This is where execution will continue after loading\n    // the memory initialization data, if any.\n    var initializedResolve, initializedReject;\n    var initializedP = new Promise(function(resolve, reject) {\n      initializedResolve = resolve;\n      initializedReject = reject;\n    });\n    var FS;\n    var dependenciesFulfilled = function(fs) {\n      FS = fs;\n      // Initialize the filesystem state.\n      try {\n        FS.init(stdin, stdout, stderr);\n        Module.FS_createPath(\"/\", \"lib/pypyjs/lib_pypy\", true, false);\n        Module.FS_createPath(\"/\", \"lib/pypyjs/lib-python/2.7\", true, false);\n        initializedResolve();\n      } catch (err) {\n        initializedReject(err);\n      }\n    }\n \n    // Begin fetching the metadata for available python modules.\n    // With luck these can download while we jank around compiling\n    // all of that javascript.\n    // XXX TODO: also load memory initializer this way.\n    var moduleDataP = this.fetch(\"modules/index.json\");\n\n    pypyjs._vmBuilderPromise.then((function(vmBuilder) {\n      var args = [\n        Module,\n        dependenciesFulfilled,\n        typeof undefined,\n        typeof undefined,\n        typeof undefined,\n        typeof __dirname\n      ];\n      // This links the async-compiled module into our Module object.\n      vmBuilder.apply(null, args);\n      return initializedP;\n    }).bind(this)).then((function() {\n      // Continue with processing the downloaded module metadata.\n      return moduleDataP.then((function(xhr) {\n        // Store the module index, and load any preload modules.\n        var modIndex = JSON.parse(xhr.responseText);\n        this._allModules = modIndex.modules;\n        if (modIndex.preload) {\n          for (var name in modIndex.preload) {\n            this._writeModuleFile(name, modIndex.preload[name]);\n          }\n        }\n        // It's finally safe to launch the VM.\n        Module.run();\n        Module._rpython_startup_code();\n        var pypy_home = Module.intArrayFromString(\"/lib/pypyjs/pypyjs.js\");\n        pypy_home = Module.allocate(pypy_home, 'i8', Module.ALLOC_NORMAL);\n        Module._pypy_setup_home(pypy_home, 0);\n        Module._free(pypy_home);\n        var initCode = [\n          \"import js\",\n          \"import sys; sys.platform = 'js'\",\n          \"import traceback\",\n          \"top_level_scope = {'__name__': '__main__'}\"\n        ];\n        initCode.forEach(function(codeStr) {\n          var code = Module.intArrayFromString(codeStr);\n          var code = Module.allocate(code, 'i8', Module.ALLOC_NORMAL);\n          if (!code) {\n            throw new pypyjs.Error('Failed to allocate memory');\n          }\n          var res = Module._pypy_execute_source(code);\n          if (res < 0) {\n            throw new pypyjs.Error('Failed to execute python code');\n          }\n          Module._free(code);\n        });\n      }).bind(this))\n    }).bind(this))\n    .then(resolve, reject);\n  }).bind(this));\n\n};\n\n\n// A simple file-fetching wrapper around XMLHttpRequest,\n// that treats paths as relative to the pypyjs.js root url.\n//\npypyjs.prototype.fetch = function (relpath, responseType) {\n  if (typeof window === \"undefined\") {\n    var localStorage = false;\n  }\n  else {\n    var localStorage = window.localStorage;\n  }\n  var use_cache = pypyjs.cacheKey && localStorage && relpath != \"pypyjs.vm.js\";\n  if (use_cache) {\n    var item = localStorage.getItem(pypyjs.cacheKey+':'+relpath);\n    if (item) {\n      return new Promise((function(resolve, reject) {\n        resolve({ responseText: item });\n      }))\n    }\n  }\n  // For the web, use XMLHttpRequest.\n  if (typeof XMLHttpRequest !== \"undefined\") {\n    return new Promise((function(resolve, reject) {\n      var xhr = new XMLHttpRequest();\n      xhr.onload = function() {\n        if (xhr.status >= 400) {\n          reject(xhr)\n        } else {\n          if (use_cache && xhr.responseText) {\n            localStorage.setItem(pypyjs.cacheKey+':'+relpath, xhr.responseText);\n          }\n          resolve(xhr);\n        }\n      };\n      var rootURL = this.rootURL || pypyjs.rootURL;\n      xhr.open('GET', rootURL + relpath, true);\n      xhr.responseType = responseType || \"text\";\n      xhr.send(null);\n    }).bind(this));\n  }\n  // For nodejs, use fs.readFile.\n  if (typeof fs !== \"undefined\" && typeof fs.readFile !== \"undefined\") {\n    return new Promise((function(resolve, reject) {\n      var rootURL = this.rootURL || pypyjs.rootURL;\n      fs.readFile(path.join(rootURL, relpath), function(err, data) {\n        if (err) return reject(err);\n        resolve({ responseText: data.toString() });\n      });\n    }).bind(this));\n  }\n  // For spidermonkey, use snarf (which has a binary read mode).\n  if (typeof snarf !== \"undefined\") {\n    return new Promise((function(resolve, reject) {\n      var rootURL = this.rootURL || pypyjs.rootURL;\n      var data = snarf(rootURL + relpath);\n      resolve({ responseText: data });\n    }).bind(this));\n  }\n  // For d8, use read() and readbuffer().\n  if (typeof read !== \"undefined\" && typeof readbuffer !== \"undefined\") {\n    return new Promise((function(resolve, reject) {\n      var rootURL = this.rootURL || pypyjs.rootURL;\n      var data = read(rootURL + relpath);\n      resolve({ responseText: data });\n    }).bind(this));\n  }\n  return new Promise(function(resolve, reject) {\n    reject(\"unable to fetch files\");\n  });\n};\n\nif (typeof localStorage !== \"undefined\") {\n  var localStorage = false;\n}\n\n// pypyjs.prototype.fetch = function fetch(relpath, responseType) {\n//   // For the web, use XMLHttpRequest.\n//   var use_cache = pypyjs.cacheKey && localStorage;\n//   if (use_cache) {\n//     if (var item = localStorage.getItem(pypyjs.cacheKey+'-'+relpath)) {\n//       resolve({ responseText: item });\n//     }\n//   }\n//   if (typeof XMLHttpRequest !== \"undefined\") {\n//     return new Promise((function(resolve, reject) {\n//       var xhr = new XMLHttpRequest();\n//       xhr.onload = function() {\n//         if (xhr.status >= 400) {\n//           reject(xhr)\n//         } else {\n//           console.log(xhr.responseText);\n//           if (use_cache && xhr.responseText) {\n//             localStorage.setItem(pypyjs.cacheKey+'-'+relpath, xhr.responseText);\n//           }\n//           resolve(xhr);\n//         }\n//       };\n//       var rootURL = this.rootURL || pypyjs.rootURL;\n//       xhr.open('GET', rootURL + relpath, true);\n//       xhr.responseType = responseType || \"text\";\n//       xhr.send(null);\n//     }).bind(this));\n//   }\n//   // For nodejs, use fs.readFile.\n//   if (typeof fs !== \"undefined\" && typeof fs.readFile !== \"undefined\") {\n//     return new Promise((function(resolve, reject) {\n//       var rootURL = this.rootURL || pypyjs.rootURL;\n//       fs.readFile(path.join(rootURL, relpath), function(err, data) {\n//         if (err) return reject(err);\n//         resolve({ responseText: data.toString() });\n//       });\n//     }).bind(this));\n//   }\n//   // For spidermonkey, use snarf (which has a binary read mode).\n//   if (typeof snarf !== \"undefined\") {\n//     return new Promise((function(resolve, reject) {\n//       var rootURL = this.rootURL || pypyjs.rootURL;\n//       var data = snarf(rootURL + relpath);\n//       resolve({ responseText: data });\n//     }).bind(this));\n//   }\n//   // For d8, use read() and readbuffer().\n//   if (typeof read !== \"undefined\" && typeof readbuffer !== \"undefined\") {\n//     return new Promise((function(resolve, reject) {\n//       var rootURL = this.rootURL || pypyjs.rootURL;\n//       var data = read(rootURL + relpath);\n//       resolve({ responseText: data });\n//     }).bind(this));\n//   }\n//   return new Promise(function(resolve, reject) {\n//     reject(\"unable to fetch files\");\n//   });\n// };\n\n\n// Method to execute python source directly in the VM.\n//\n// This is the basic way to push code into the pypyjs VM.\n// Calling code should not use it directly; rather we use it\n// as a primitive to build up a nicer execution API.\n//\npypyjs.prototype._execute_source = function _execute_source(code) {\n  var Module = this._module;\n  code = \"try:\\n\" +\n         \"  \" + code + \"\\n\" +\n         \"except Exception:\\n\" +\n         \"  typ, val, tb = sys.exc_info()\\n\" +\n         \"  err_name = getattr(typ, '__name__', str(typ))\\n\" +\n         \"  err_msg = str(val)\\n\" +\n         \"  err_trace = traceback.format_exception(typ, val, tb)\\n\" +\n         \"  err_trace = ''.join(err_trace)\\n\" +\n         \"  js.globals['pypyjs']._lastErrorName = err_name\\n\" +\n         \"  js.globals['pypyjs']._lastErrorMessage = err_msg\\n\" +\n         \"  js.globals['pypyjs']._lastErrorTrace = err_trace\\n\";\n  var code_chars = Module.intArrayFromString(code);\n  var code_ptr = Module.allocate(code_chars, 'i8', Module.ALLOC_NORMAL);\n  if (!code_ptr) {\n    return Promise.reject(new pypyjs.Error(\"Failed to allocate memory\"));\n  }\n  var res = Module._pypy_execute_source(code_ptr);\n  Module._free(code_ptr);\n  // XXX TODO: races/re-entrancy on _lastError?\n  if (pypyjs._lastErrorName) {\n    var err = new pypyjs.Error(\n      pypyjs._lastErrorName,\n      pypyjs._lastErrorMessage,\n      pypyjs._lastErrorTrace\n    );\n    pypyjs._lastErrorName = null;\n    pypyjs._lastErrorMessage = null;\n    pypyjs._lastErrorTrace = null;\n    return Promise.reject(err);\n  }\n  if (res < 0) {\n    return Promise.reject(new pypyjs.Error(\"Error executing python code\"));\n  }\n  return Promise.resolve(null);\n}\n\n\nfunction _escape(value) {\n  return value.replace(/\\\\/g, \"\\\\\\\\\").replace(/'/g, \"\\\\'\");\n}\n\n\n// Method to determine when the interpreter is ready.\n//\n// This method returns a promise that will resolve once the interpreter\n// is ready for use.\n//\npypyjs.prototype.ready = function ready() {\n  return this._ready;\n}\n\n\n// Method to execute some python code.\n//\n// This passes the given python code to the VM for execution.\n// It's fairly directly analogous to the \"exec\" statement in python.\n// It is not possible to directly access the result of the code, if any.\n// Rather you should store it into a variable and then use the get() method.\n//\npypyjs.prototype.exec = function exec(code) {\n  return this._ready.then((function() {\n    var p = Promise.resolve();\n    // Find any \"import\" statements in the code,\n    // and ensure the modules are ready for loading.\n    if (this.autoLoadModules) {\n      p = p.then((function() {\n        return this.findImportedNames(code);\n      }).bind(this))\n      .then((function(imports) {\n        return this.loadModuleData.apply(this, imports);\n      }).bind(this))\n    }\n    // Now we can execute the code in custom top-level scope.\n    code = 'exec \\'\\'\\'' + _escape(code) + '\\'\\'\\' in top_level_scope';\n    p = p.then((function() {\n      return this._execute_source(code);\n    }).bind(this));\n    return p;\n  }).bind(this));\n}\n\n\n// Method to evaluate an expression.\n//\n// This method evaluates an expression and returns its value (assuming the\n// value can be translated into javascript).  It's fairly directly analogous\n// to the \"eval\" function in python.\n//\n// For backwards-compatibility reasons, it will also evaluate statements.\n// This behaviour is deprecated and will be removed in a future release.\n//\npypyjs.prototype.eval = function (expr) {\n  return this._ready.then((function() {\n    // First try to execute it as an expression.\n    code = \"r = eval('\" + _escape(expr) + \"', top_level_scope)\";\n    return this._execute_source(code);\n  }).bind(this)).then(\n    (function() {\n      // If that succeeded, return the result.\n      return this.get(\"r\", true)\n    }).bind(this),\n    (function(err) {\n      if (err && err.name && err.name !== \"SyntaxError\") {\n        throw err;\n      }\n      // If that failed, try again via exec().\n      if (typeof console !== \"undefined\") {\n        console.warn(\"Calling pypyjs.eval() with statements is deprecated.\");\n        console.warn(\"Use eval() for expressions, exec() for statements.\");\n      }\n      return this.exec(expr);\n    }).bind(this)\n  )\n}\n\n// Method to evaluate some python code from a file..\n//\n// This fetches the named file and passes it to the VM for execution.\n//\npypyjs.prototype.execfile = function execfile(filename) {\n  return this.fetch(filename).then((function(xhr) {\n    var code = xhr.responseText;\n    return this.exec(code);\n  }).bind(this));\n}\n\n\n// Method to read a python variable.\n//\n// This tries to convert the value in the named python variable into an\n// equivalent javascript value and returns it.  It will fail if the variable\n// does not exist or contains a value that cannot be converted.\n//\npypyjs._resultsID = 0;\npypyjs._resultsMap = {};\npypyjs.prototype.get = function get(name, _fromGlobals) {\n  var resid = \"\"+(pypyjs._resultsID++);\n  // We can read from global scope for internal use; don't do this from calling code!\n  if (_fromGlobals) {\n    var namespace = \"globals()\";\n  } else {\n    var namespace = \"top_level_scope\";\n  }\n  return this._ready.then((function() {\n    var code = namespace + \".get('\" + _escape(name) + \"', js.undefined)\";\n    code = \"js.convert(\" + code + \")\"\n    code = \"js.globals['pypyjs']._resultsMap['\" + resid + \"'] = \" + code;\n    return this._execute_source(code);\n  }).bind(this)).then((function() {\n    var res = pypyjs._resultsMap[resid];\n    delete pypyjs._resultsMap[resid];\n    return res;\n  }).bind(this));\n}\n\n\n// Method to set a python variable to a javascript value.\n//\n// This generates a handle to the given object, and arranges for the named\n// python variable to reference it via that handle.\n//\npypyjs.prototype.set = function set(name, value) {\n  return this._ready.then((function() {\n    var Module = this._module;\n    var h = Module._emjs_make_handle(value);\n    name = _escape(name);\n    var code = \"top_level_scope['\" + name + \"'] = js.Value(\" + h + \")\";\n    return this._execute_source(code);\n  }).bind(this));\n}\n\n\n// Method to run an interactive REPL.\n//\n// This method takes takes callback function implementing the user\n// input prompt, and runs a REPL loop using it.  The prompt function\n// may either return the input as a string, or a promise resolving to\n// the input as a string.  If not specified, we read from stdin (which\n// works fine in e.g. nodejs, but is almost certainly not what you want\n// in the browser, because it's blocking).\n//\npypyjs.prototype.repl = function repl(prmpt) {\n  if (!prmpt) {\n    // If there's a custom stdin, or we're not in nodejs, then we should\n    // default to prompting on stdin/stdout.  For nodejs, we can build\n    // an async prompt atop process.stdin.\n    var buffer = \"\";\n    if (this.stdin !== devNull.stdin || typeof process === \"undefined\") {\n      prmpt = (function(ps1) {\n        var input;\n        this.stdout(ps1);\n        var c = this.stdin();\n        while (c) {\n          var idx = c.indexOf(\"\\n\");\n          if (idx >= 0) {\n            var input = buffer + c.substr(0, idx + 1);\n            buffer = c.substr(idx + 1);\n            return input;\n          }\n          buffer += c;\n          c = this.stdin();\n        }\n        input = buffer;\n        buffer = \"\";\n        return input;\n      }).bind(this);\n    } else {\n      prmpt = (function(ps1) {\n        return new Promise((function(resolve, reject) {\n          this.stdout(ps1);\n          var slurp = function() {\n            process.stdin.once(\"readable\", function() {\n              var chunk = process.stdin.read();\n              if (chunk === null) {\n                slurp();\n              } else {\n                chunk = chunk.toString();\n                var idx = chunk.indexOf(\"\\n\");\n                if (idx < 0) {\n                  buffer += chunk;\n                  slurp();\n                } else {\n                  resolve(buffer + chunk.substr(0, idx + 1));\n                  buffer = chunk.substr(idx + 1);\n                }\n              }\n            });\n          }\n          slurp();\n        }).bind(this));\n      }).bind(this);\n    }\n  }\n  // Set up an InteractiveConsole instance,\n  // then loop forever via recursive promises.\n  return this._ready.then((function() {\n    return this.loadModuleData(\"code\");\n  }).bind(this)).then((function() {\n    return this._execute_source(\"import code\");\n  }).bind(this)).then((function() {\n    return this._execute_source(\"c = code.InteractiveConsole(top_level_scope)\");\n  }).bind(this)).then((function() {\n    return this._repl_loop(prmpt, \">>> \");\n  }).bind(this));\n}\n\n\npypyjs.prototype._repl_loop = function _repl_loop(prmpt, ps1) {\n  return Promise.resolve().then((function() {\n    // Prompt for input, which may happen via async promise.\n    return prmpt.call(this, ps1);\n  }).bind(this)).then((function(input) {\n    // Push it into the InteractiveConsole, a line at a time.\n    var p = Promise.resolve();\n    input.split(\"\\n\").forEach((function(line) {\n      // Find any \"import\" statements in the code,\n      // and ensure the modules are ready for loading.\n      if (this.autoLoadModules) {\n        p = p.then((function() {\n          return this.findImportedNames(line);\n        }).bind(this))\n        .then((function(imports) {\n          return this.loadModuleData.apply(this, imports);\n        }).bind(this))\n      }\n      var code = 'r = c.push(\\'' + _escape(line) + '\\')';\n      p = p.then((function() {\n        return this._execute_source(code);\n      }).bind(this));\n    }).bind(this));\n    return p;\n  }).bind(this)).then((function() {\n    // Check the result from the final push.\n    return this.get(\"r\", true)\n  }).bind(this)).then((function(r) {\n    // If r == 1, we're in a multi-line definition.\n    // Adjust the prompt accordingly.\n    if (r) {\n      return this._repl_loop(prmpt, \"... \");\n    } else {\n      return this._repl_loop(prmpt, \">>> \");\n    }\n  }).bind(this));\n}\n\n\n// Method to look for \"import\" statements in a code string.\n// Returns a promise that will resolve to a list of imported module names.\n//\n// XXX TODO: this is far from complete and should not be done with a regex.\n// Perhaps we can call into python's \"ast\" module for this parsing?\n//\nvar importStatementRE = /(from\\s+([a-zA-Z0-9_\\.]+)\\s+)?import\\s+\\(?\\s*([a-zA-Z0-9_\\.\\*]+(\\s+as\\s+[a-zA-Z0-9_]+)?[ \\t]*,?[ \\t]*)+[ \\t]*\\)?/g\npypyjs.prototype.findImportedNames = function findImportedNames(code) {\n  var match = null;\n  var imports = [];\n  importStatementRE.lastIndex = 0;\n  while ((match = importStatementRE.exec(code)) !== null) {\n    var relmod = match[2];\n    if (relmod) {\n      relmod = relmod + \".\";\n    } else {\n      relmod = \"\";\n    }\n    var submods = match[0].split(\"import\")[1];\n    while (submods && /[\\s(]/.test(submods.charAt(0))) {\n      submods = submods.substr(1);\n    }\n    while (submods && /[\\s)]/.test(submods.charAt(submods.length - 1))) {\n      submods = submods.substr(0, submods.length - 1);\n    }\n    submods = submods.split(/\\s*,\\s*/);\n    for (var i = 0; i < submods.length; i++) {\n      var submod = submods[i];\n      submod = submod.split(/\\s*as\\s*/)[0];\n      imports.push(relmod + submod);\n    }\n  }\n  return Promise.resolve(imports);\n}\n\n\n// Method to load the contents of a python module, along with\n// any dependencies.  This populates the relevant paths within\n// the VMs simulated filesystem so that is can find and import\n// the specified module.\n//\npypyjs.prototype.loadModuleData = function loadModuleData(/* names */) {\n  // Each argument is a name that we want to import.\n  // We must find the longest prefix that is an available module\n  // and load it along with all its dependencies.\n  var modules = Array.prototype.slice.call(arguments);\n  return this._ready.then((function() {\n    var toLoad = {};\n    NEXTNAME: for (var i = 0; i < modules.length; i++) {\n      var name = modules[i];\n      // Find the nearest containing module for the given name.\n      // Note that it may not match a module at all, in which case we ignore it.\n      while (true) {\n        if (this._allModules[name]) {\n          break;\n        }\n        name = name.substr(0, name.lastIndexOf(\".\"));\n        if (!name) continue NEXTNAME;\n      }\n      this._findModuleDeps(name, toLoad);\n    } \n    // Now ensure that each module gets loaded.\n    // XXX TODO: we could load these concurrently.\n    var p = Promise.resolve();\n    for (var name in toLoad) {\n      p = p.then(this._makeLoadModuleData(name));\n    }\n    return p;\n  }).bind(this));\n}\n\n\npypyjs.prototype._findModuleDeps = function _findModuleDeps(name, seen) {\n  if (!seen) seen = {};\n  var deps = [];\n  // If we don't know about this module, ignore it.\n  if (!this._allModules[name]) {\n    return seen;\n  }\n  // Depend on any explicitly-named imports.\n  var imports = this._allModules[name].imports;\n  if (imports) {\n    for (var i = 0; i < imports.length; i++) {\n      deps.push(imports[i]);\n    }\n  }\n  // Depend on the __init__.py for packages.\n  if (this._allModules[name].dir) {\n    deps.push(name + \".__init__\");\n  }\n  // Include the parent package, if any.\n  var idx = name.lastIndexOf(\".\");\n  if (idx !== -1) {\n    deps.push(name.substr(0, idx));\n  }\n  // Recurse for any previously-unseen dependencies.\n  seen[name] = true;\n  for (var i = 0; i < deps.length; i++) {\n    if (!seen[deps[i]]) {\n      this._findModuleDeps(deps[i], seen);\n    }\n  }\n  return seen;\n}\n\n\npypyjs.prototype._makeLoadModuleData = function _makeLoadModuleData(name) {\n  return (function() {\n    // If we've already loaded this module, we're done.\n    if (this._loadedModules[name]) {\n      return Promise.resolve();\n    }\n    // If we're already in the process of loading it, use the existing promise.\n    if (this._pendingModules[name]) {\n      return this._pendingModules[name];\n    }\n    // If it's a package directory, there's not actually anything to do.\n    if (this._allModules[name].dir) {\n      return Promise.resolve();\n    }\n    // We need to fetch the module file and write it out.\n    var modfile = this._allModules[name].file;\n    var p = this.fetch(\"modules/\" + modfile)\n    .then((function(xhr) {\n      var contents = xhr.responseText;\n      this._writeModuleFile(name, contents)\n      delete this._pendingModules[name];\n    }).bind(this))\n    this._pendingModules[name] = p;\n    return p;\n  }).bind(this);\n}\n\n\npypyjs.prototype._writeModuleFile = function _writeModuleFile(name, data) {\n  var Module = this._module;\n  var file = this._allModules[name].file;\n  // Create the containing directory first.\n  var dir = file.split(\"/\").slice(0, -1).join(\"/\")\n  try {\n    Module.FS_createPath(\"/lib/pypyjs/lib_pypy\", dir, true, false);\n  } catch (e) { }\n  // Now we can safely create the file.\n  var fullpath = \"/lib/pypyjs/lib_pypy/\" + file;\n  Module.FS_createDataFile(fullpath, \"\", data, true, false, true);\n  this._loadedModules[name] = true;\n}\n\n\n// An error class for reporting python exceptions back to calling code.\n// XXX TODO: this could be a lot more user-friendly than a opaque error...\n\npypyjs.Error = function pypyjsError(name, message, trace) {\n  if (name && typeof message === \"undefined\") {\n    message = name;\n    name = \"\";\n  }\n  this.name = name || \"pypyjs.Error\";\n  this.message = message || \"pypyjs Unknown Error\";\n  this.trace = trace || \"\";\n}\npypyjs.Error.prototype = new Error();\npypyjs.Error.prototype.constructor = pypyjs.Error;\n\n\n\n// XXX TODO: expose the filesystem for manipulation by calling code.\n\n\n// Add convenience methods directly on the 'pypyjs' function, that\n// will invoke corresponding methods on a default VM instance.\n// This makes it look like 'pypyjs' is a singleton VM instance.\n\npypyjs._defaultVM = null;\npypyjs.stdin = stdio.stdin\npypyjs.stdout = stdio.stdout\npypyjs.stderr = stdio.stderr\n\nvar PUBLIC_NAMES = ['ready', 'exec', 'eval', 'execfile', 'get', 'set',\n                    'repl', 'loadModuleData'];\n\nPUBLIC_NAMES.forEach(function(name) {\n  pypyjs[name] = function() {\n    if (!pypyjs._defaultVM) {\n      pypyjs._defaultVM = new pypyjs({\n        stdin: function(){ return pypyjs.stdin.apply(this, arguments); },\n        stdout: function(){ return pypyjs.stdout.apply(this, arguments); },\n        stderr: function(){ return pypyjs.stderr.apply(this, arguments); },\n      });\n    }\n    return pypyjs._defaultVM[name].apply(pypyjs._defaultVM, arguments)\n  }\n})\n\n\n// For nodejs, run a repl when invoked directly from the command-line.\n\nreturn pypyjs;\n\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ../playground/graphene-js/pypyjs.js\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/process/browser.js\n ** module id = 450\n ** module chunks = 1\n **/","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.0.2\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$toString = {}.toString;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      var enumerator = this;\n\n      enumerator._instanceConstructor = Constructor;\n      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (enumerator._validateInput(input)) {\n        enumerator._input     = input;\n        enumerator.length     = input.length;\n        enumerator._remaining = input.length;\n\n        enumerator._init();\n\n        if (enumerator.length === 0) {\n          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n        } else {\n          enumerator.length = enumerator.length || 0;\n          enumerator._enumerate();\n          if (enumerator._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n      }\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return lib$es6$promise$utils$$isArray(input);\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var enumerator = this;\n\n      var length  = enumerator.length;\n      var promise = enumerator.promise;\n      var input   = enumerator._input;\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        enumerator._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var enumerator = this;\n      var c = enumerator._instanceConstructor;\n\n      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n          entry._onerror = null;\n          enumerator._settledAt(entry._state, i, entry._result);\n        } else {\n          enumerator._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        enumerator._remaining--;\n        enumerator._result[i] = entry;\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var enumerator = this;\n      var promise = enumerator.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        enumerator._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          enumerator._result[i] = value;\n        }\n      }\n\n      if (enumerator._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n    var lib$es6$promise$promise$$counter = 0;\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this._id = lib$es6$promise$promise$$counter++;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n          lib$es6$promise$promise$$needsResolver();\n        }\n\n        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n          lib$es6$promise$promise$$needsNew();\n        }\n\n        lib$es6$promise$$internal$$initializePromise(this, resolver);\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n          return this;\n        }\n\n        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n        var result = parent._result;\n\n        if (state) {\n          var callback = arguments[state - 1];\n          lib$es6$promise$asap$$asap(function(){\n            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/es6-promise/dist/es6-promise.js\n ** module id = 451\n ** module chunks = 1\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/buildin/amd-define.js\n ** module id = 453\n ** module chunks = 1\n **/","//\n// FunctionPromise: possibly-asynchronous function constructor.\n//\n// This is a prototype polyfill for a FunctionPromise object as described in:\n//\n//    https://bugzilla.mozilla.org/show_bug.cgi?id=854627\n//\n// Where possible it will arrange for the function body to be parsed/compiled\n// off of the main thread, with the function object returned asynchronously\n// via a promise.  The fallback implementation processes just falls back to\n// the standard synchronous Function() constructor.\n// \n// It doesn't (yet) have the following features from the linked proposal:\n//\n//    * ability to copy to different workers\n//    * ability to store in IndexedDB\n// \nfunction FunctionPromise(/* [args1[, args2[, ...argN]],], functionBody) */) {\n\n  var useFallback =\n    typeof window === \"undefined\" ||\n    window.FunctionPromise !== FunctionPromise ||\n    typeof document === \"undefined\" ||\n    typeof document.createElement === \"undefined\" ||\n    typeof document.head === \"undefined\" ||\n    typeof document.head.appendChild === \"undefined\" ||\n    typeof Blob === \"undefined\" ||\n    typeof URL === \"undefined\" ||\n    typeof URL.createObjectURL === \"undefined\";\n\n  var args = Array.prototype.slice.call(arguments);\n\n  // For the fallback case, we just use the normal Function constructor.\n\n  if (useFallback) {\n    try {\n      var fn = Function.apply(null, args);\n      return Promise.resolve(fn);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  // If we have all the necessary pieces, we can do this asynchronously\n  // by writing a <script> tag into the DOM.\n\n  var funcid = FunctionPromise._nextid++;\n\n  return new Promise(function(resolve, reject) {\n    try {\n      var funcSrc = [];\n      funcSrc.push(\"window.FunctionPromise._results[\" + funcid + \"]=\");\n      funcSrc.push(\"function(\");\n      if (args.length > 1) {\n        funcSrc.push(args[0]);\n        for (var i = 1; i < args.length - 1; i++) {\n          funcSrc.push(\",\");\n          funcSrc.push(args[i]);\n        }\n      }\n      funcSrc.push(\"){\");\n      funcSrc.push(args[args.length - 1]);\n      funcSrc.push(\"}\");\n      var dataUrl = URL.createObjectURL(new Blob(funcSrc));\n      var scriptTag = document.createElement(\"script\");\n      var cleanup = function() {\n        URL.revokeObjectURL(dataUrl);\n        scriptTag.remove();\n        delete window.FunctionPromise._results[funcid];\n      }\n      scriptTag.onerror = function() {\n        reject(new Error(\"unknown error loading FunctionPromise\"))\n        cleanup();\n      }\n      scriptTag.onload = function() {\n        if (window.FunctionPromise._results[funcid]) {\n          resolve(window.FunctionPromise._results[funcid]);\n        } else {\n          // No function, something must have gone wrong.\n          // Likely a syntax error in the function body string.\n          // Fall back to Function() constructor to surface it.\n          try {\n            Function.apply(null, args);\n            reject(new Error(\"unknown error fulfilling FunctionPromise\"));\n          } catch (err) {\n            reject(err);\n          }\n        }\n        cleanup();\n      }\n      scriptTag.src = dataUrl;\n      document.head.appendChild(scriptTag);\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\n\nFunctionPromise._nextid = 0;\nFunctionPromise._results = {};\n\nif (typeof module !== \"undefined\" && typeof module.exports !== \"undefined\") {\n  if (typeof Promise === \"undefined\") {\n    Promise = require('es6-promise').Promise;\n  }\n  module.exports = FunctionPromise;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../playground/graphene-js/FunctionPromise.js\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 455\n ** module chunks = 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n                        \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n                        \"for\", \"from\", \"global\", \"if\", \"import\",\n                        \"lambda\", \"pass\", \"raise\", \"return\",\n                        \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n                        \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n                        \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n                        \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n                        \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n                        \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n                        \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n                        \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n                        \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n                        \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n                        \"Ellipsis\", \"__debug__\"];\n  var py2 = {builtins: [\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                        \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                        \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"],\n             keywords: [\"exec\", \"print\"]};\n  var py3 = {builtins: [\"ascii\", \"bytes\", \"exec\", \"print\"],\n             keywords: [\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]};\n\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function(conf, parserConf) {\n    var ERRORCLASS = \"error\";\n\n    var singleDelimiters = parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]/;\n    var doubleOperators = parserConf.doubleOperators || /^([!<>]==|<>|<<|>>|\\/\\/|\\*\\*)/;\n    var doubleDelimiters = parserConf.doubleDelimiters || /^(\\+=|\\-=|\\*=|%=|\\/=|&=|\\|=|\\^=)/;\n    var tripleDelimiters = parserConf.tripleDelimiters || /^(\\/\\/=|>>=|<<=|\\*\\*=)/;\n\n    if (parserConf.version && parseInt(parserConf.version, 10) == 3){\n        // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n        var singleOperators = parserConf.singleOperators || /^[\\+\\-\\*\\/%&|\\^~<>!@]/;\n        var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n    } else {\n        var singleOperators = parserConf.singleOperators || /^[\\+\\-\\*\\/%&|\\^~<>!]/;\n        var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n    }\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n\n    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n    if(parserConf.extra_keywords != undefined){\n      myKeywords = myKeywords.concat(parserConf.extra_keywords);\n    }\n    if(parserConf.extra_builtins != undefined){\n      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n    }\n    if (parserConf.version && parseInt(parserConf.version, 10) == 3) {\n      myKeywords = myKeywords.concat(py3.keywords);\n      myBuiltins = myBuiltins.concat(py3.builtins);\n      var stringPrefixes = new RegExp(\"^(([rb]|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      myKeywords = myKeywords.concat(py2.keywords);\n      myBuiltins = myBuiltins.concat(py2.builtins);\n      var stringPrefixes = new RegExp(\"^(([rub]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins);\n\n    // tokenizers\n    function tokenBase(stream, state) {\n      // Handle scope changes\n      if (stream.sol() && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset)\n            pushScope(stream, state, \"py\");\n          else if (lineOffset < scopeOffset && dedent(stream, state))\n            state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state))\n            style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state) {\n      if (stream.eatSpace()) return null;\n\n      var ch = stream.peek();\n\n      // Handle Comments\n      if (ch == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      // Handle Number Literals\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false;\n        // Floats\n        if (stream.match(/^\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n        if (stream.match(/^\\d+\\.\\d*/)) { floatLiteral = true; }\n        if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        }\n        // Integers\n        var intLiteral = false;\n        // Hex\n        if (stream.match(/^0x[0-9a-f]+/i)) intLiteral = true;\n        // Binary\n        if (stream.match(/^0b[01]+/i)) intLiteral = true;\n        // Octal\n        if (stream.match(/^0o[0-7]+/i)) intLiteral = true;\n        // Decimal\n        if (stream.match(/^[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i);\n          // TODO - Can you have imaginary longs?\n          intLiteral = true;\n        }\n        // Zero by itself with no other piece of number.\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      }\n\n      // Handle Strings\n      if (stream.match(stringPrefixes)) {\n        state.tokenize = tokenStringFactory(stream.current());\n        return state.tokenize(stream, state);\n      }\n\n      // Handle operators and Delimiters\n      if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters))\n        return \"punctuation\";\n\n      if (stream.match(doubleOperators) || stream.match(singleOperators))\n        return \"operator\";\n\n      if (stream.match(singleDelimiters))\n        return \"punctuation\";\n\n      if (state.lastToken == \".\" && stream.match(identifiers))\n        return \"property\";\n\n      if (stream.match(keywords) || stream.match(wordOperators))\n        return \"keyword\";\n\n      if (stream.match(builtins))\n        return \"builtin\";\n\n      if (stream.match(/^(self|cls)\\b/))\n        return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\")\n          return \"def\";\n        return \"variable\";\n      }\n\n      // Handle non-detected items\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function tokenStringFactory(delimiter) {\n      while (\"rub\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenBase;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenBase;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushScope(stream, state, type) {\n      var offset = 0, align = null;\n      if (type == \"py\") {\n        while (top(state).type != \"py\")\n          state.scopes.pop();\n      }\n      offset = top(state).offset + (type == \"py\" ? conf.indentUnit : hangingIndent);\n      if (type != \"py\" && !stream.match(/^(\\s|#.*)*$/, false))\n        align = stream.column() + 1;\n      state.scopes.push({offset: offset, type: type, align: align});\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n      while (top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      // Handle decorators\n      if (current == \"@\"){\n        if(parserConf.version && parseInt(parserConf.version, 10) == 3){\n            return stream.match(identifiers, false) ? \"meta\" : \"operator\";\n        } else {\n            return stream.match(identifiers, false) ? \"meta\" : ERRORCLASS;\n        }\n      }\n\n      if ((style == \"variable\" || style == \"builtin\")\n          && state.lastToken == \"meta\")\n        style = \"meta\";\n\n      // Handle scope changes.\n      if (current == \"pass\" || current == \"return\")\n        state.dedent += 1;\n\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\")\n        pushScope(stream, state, \"py\");\n\n      var delimiter_index = current.length == 1 ? \"[({\".indexOf(current) : -1;\n      if (delimiter_index != -1)\n        pushScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\n      delimiter_index = \"])}\".indexOf(current);\n      if (delimiter_index != -1) {\n        if (top(state).type == current) state.scopes.pop();\n        else return ERRORCLASS;\n      }\n      if (state.dedent > 0 && stream.eol() && top(state).type == \"py\") {\n        if (state.scopes.length > 1) state.scopes.pop();\n        state.dedent -= 1;\n      }\n\n      return style;\n    }\n\n    var external = {\n      startState: function(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{offset: basecolumn || 0, type: \"py\", align: null}],\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n\n      token: function(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n\n        if (style && style != \"comment\")\n          state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n\n        if (stream.eol() && state.lambda)\n          state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n\n      indent: function(state, textAfter) {\n        if (state.tokenize != tokenBase)\n          return state.tokenize.isString ? CodeMirror.Pass : 0;\n\n        var scope = top(state);\n        var closing = textAfter && textAfter.charAt(0) == scope.type;\n        if (scope.align != null)\n          return scope.align - (closing ? 1 : 0);\n        else if (closing && state.scopes.length > 1)\n          return state.scopes[state.scopes.length - 2].offset;\n        else\n          return scope.offset;\n      },\n\n      closeBrackets: {triples: \"'\\\"\"},\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function(str) { return str.split(\" \"); };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except\"+\n                          \"extern gil include nogil property public\"+\n                          \"readonly struct union DEF IF ELIF ELSE\")\n  });\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/codemirror/mode/python/python.js\n ** module id = 456\n ** module chunks = 1\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../node_modules/gatsby/node_modules/css-loader/index.js!./../node_modules/stylus-loader/index.js!./playground.styl\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../node_modules/gatsby/node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/gatsby/node_modules/css-loader/index.js!./../node_modules/stylus-loader/index.js!./playground.styl\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/gatsby/node_modules/css-loader/index.js!./../node_modules/stylus-loader/index.js!./playground.styl\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../css/playground.styl\n ** module id = 457\n ** module chunks = 1\n **/","exports = module.exports = require(\"./../node_modules/gatsby/node_modules/css-loader/lib/css-base.js\")();\n// imports\nexports.i(require(\"-!./../node_modules/gatsby/node_modules/css-loader/index.js!./graphiql.css\"), \"\");\n\n// module\nexports.push([module.id, \".playground{top:106px;display:flex;flex-direction:row;min-width:960px}.playground,.playground .loading{position:absolute;left:0;right:0;bottom:0}.playground .loading{display:block;top:0;z-index:10000;background:hsla(0,0%,100%,.6)}.playground-schema{min-width:400px;width:36%;border-right:1px solid #e0e0e0;position:relative;z-index:100;display:flex;flex-direction:column}.playground-schema .cm-def:not(.CodeMirror-lint-mark-error),.playground-schema .cm-variable+.cm-keyword:not(.CodeMirror-lint-mark-error){transition:all .3s ease-in-out;background:transparent}.playground-schema .activeline .cm-def,.playground-schema .activeline .cm-variable+.cm-keyword{background:#d7d3f1;border-radius:1px;box-shadow:0 0 0 2px #d7d3f1}.playground-schema-editor{flex:1;position:relative}.playground-schema-editor .CodeMirror{font-size:13px;position:absolute;height:100%;width:100%;top:0;left:0;right:0;bottom:0;font-family:Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;color:#141823}.playground-schema-editor .CodeMirror-lines{padding:20px 0}.playground-schema-header{height:48px;box-sizing:border-box;font-family:Raleway,sans-serif;color:#999;font-weight:600;font-size:12px;text-transform:uppercase;line-height:52px;padding:0 12px;border-bottom:1px solid #d0d0d0;background:#f9f9f9}.playground-graphiql{flex:1;height:100%}.cm-s-graphene,.cm-s-graphene .cm-comment{color:#999}.cm-s-graphene .cm-punctuation{color:#555}.cm-s-graphene .cm-keyword{color:#a71d5d}.cm-s-graphene .cm-def{color:#1f61a0}.cm-s-graphene .cm-property{color:#333}.cm-s-graphene .cm-qualifier{color:#1c92a9}.cm-s-graphene .cm-attribute{color:#8b2bb9}.cm-s-graphene .cm-number{color:#2882f9}.cm-s-graphene .cm-string{color:#d64292}.cm-s-graphene .cm-builtin{color:#d47509}.cm-s-graphene .cm-string-2{color:#0b7fc7}.cm-s-graphene .cm-variable{color:#333}.cm-s-graphene .cm-meta{color:#b33086}.cm-s-graphene .cm-atom{color:#ca9800}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/gatsby/~/css-loader!../~/stylus-loader!../css/playground.styl\n ** module id = 458\n ** module chunks = 1\n **/","exports = module.exports = require(\"./../node_modules/gatsby/node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#graphiql-container{color:#141823;width:100%;display:-webkit-flex;display:flex;-webkit-flex-direction:row;flex-direction:row;height:100%;font-family:system,-apple-system,San Francisco,\\\\.SFNSDisplay-Regular,Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:14px}#graphiql-container .editorWrap{display:-webkit-flex;display:flex;-webkit-flex-direction:column;flex-direction:column;-webkit-flex:1;flex:1}#graphiql-container .title{display:none;font-size:18px}#graphiql-container .title em{font-family:georgia;font-size:19px}#graphiql-container .topBarWrap{flex-direction:row;background:#f9f9f9;height:48px}#graphiql-container .topBar,#graphiql-container .topBarWrap{display:-webkit-flex;display:flex;-webkit-flex-direction:row}#graphiql-container .topBar{border-bottom:1px solid #d0d0d0;cursor:default;-webkit-user-select:none;user-select:none;flex-direction:row;-webkit-flex:1;flex:1;-webkit-align-items:center;align-items:center}#graphiql-container .docExplorerShow{background:transparent;border:none;border-bottom:1px solid #d0d0d0;border-left:1px solid rgba(0,0,0,.2);color:#3b5998;cursor:pointer;font-size:14px;outline:0;padding:2px 20px 0 18px}#graphiql-container .docExplorerShow:before{border-left:2px solid #3b5998;border-top:2px solid #3b5998;content:'';display:inline-block;height:9px;margin:0 3px -1px 0;position:relative;width:9px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}#graphiql-container .editorBar{display:-webkit-flex;display:flex;-webkit-flex-direction:row;flex-direction:row;-webkit-flex:1;flex:1}#graphiql-container .queryWrap,#graphiql-container .resultWrap{display:-webkit-flex;display:flex;-webkit-flex-direction:column;flex-direction:column;-webkit-flex:1;flex:1}#graphiql-container .resultWrap{border-left:1px solid #e0e0e0}#graphiql-container .docExplorerWrap{box-shadow:0 0 8px rgba(0,0,0,.15);z-index:3;position:relative;background:#fff}#graphiql-container .docExplorerResizer{cursor:col-resize;height:100%;left:-5px;position:absolute;top:0;width:10px;z-index:10}#graphiql-container .docExplorerHide{cursor:pointer;font-size:18px;margin:-7px -8px -6px 0;padding:18px 16px 15px 12px}#graphiql-container .query-editor{-webkit-flex:1;flex:1;position:relative}#graphiql-container .variable-editor{height:30px;display:-webkit-flex;display:flex;-webkit-flex-direction:column;flex-direction:column;position:relative}#graphiql-container .variable-editor-title{background:#eee;border-bottom:1px solid #d6d6d6;border-top:1px solid #e0e0e0;color:#777;font-variant:small-caps;font-weight:700;letter-spacing:1px;line-height:14px;padding:6px 0 8px 43px;text-transform:lowercase;-webkit-user-select:none;user-select:none}#graphiql-container .codemirrorWrap,#graphiql-container .result-window{-webkit-flex:1;flex:1;position:relative}#graphiql-container .footer{background:#f6f7f8;border-left:1px solid #e0e0e0;border-top:1px solid #e0e0e0;margin-left:12px;position:relative}#graphiql-container .footer:before{background:#eee;bottom:0;content:\\\" \\\";left:-13px;position:absolute;top:-1px;width:12px}#graphiql-container .result-window .CodeMirror{background:#f6f7f8}#graphiql-container .result-window .CodeMirror-gutters{background-color:#eee;border-color:#e0e0e0;cursor:col-resize}#graphiql-container .result-window .CodeMirror-foldgutter,#graphiql-container .result-window .CodeMirror-foldgutter-folded:after,#graphiql-container .result-window .CodeMirror-foldgutter-open:after{padding-left:3px}#graphiql-container .execute-button{background:transparent;border:1px solid #777;border-radius:17px;cursor:pointer;fill:#444;height:34px;margin:0 14px;padding:0;width:34px}#graphiql-container .execute-button path{fill:#777}#graphiql-container .execute-button:hover{border-color:#333}#graphiql-container .execute-button:hover path{fill:#333}#graphiql-container .execute-button:active{background:#fff;border-color:#db594c}#graphiql-container .execute-button:active path{fill:#db594c}#graphiql-container .execute-button:focus{outline:0}#graphiql-container .CodeMirror-scroll{-webkit-overflow-scrolling:touch}#graphiql-container .CodeMirror{position:absolute;top:0;left:0;height:100%;width:100%;font-size:13px;font-family:Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;color:#141823}#graphiql-container .CodeMirror-lines{padding:20px 0}.CodeMirror-hint-information .content{-webkit-box-orient:vertical;color:#141823;display:-webkit-box;font-family:system,-apple-system,San Francisco,\\\\.SFNSDisplay-Regular,Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:13px;-webkit-line-clamp:3;line-height:16px;max-height:48px;overflow:hidden;text-overflow:-o-ellipsis-lastline}.CodeMirror-hint-information .content p:first-child{margin-top:0}.CodeMirror-hint-information .content p:last-child{margin-bottom:0}.CodeMirror-hint-information .infoType{color:#30a;margin-right:.5em;display:inline;cursor:pointer}.autoInsertedLeaf.cm-property{padding:2px 4px 1px;margin:-2px -4px -1px;border-radius:2px;border-bottom:2px solid hsla(0,0%,100%,0);-webkit-animation-duration:6s;animation-duration:6s;-webkit-animation-name:insertionFade;animation-name:insertionFade}@-webkit-keyframes insertionFade{0%,to{background:hsla(0,0%,100%,0);border-color:hsla(0,0%,100%,0)}15%,85%{background:#fbffc9;border-color:#f0f3c0}}@keyframes insertionFade{0%,to{background:hsla(0,0%,100%,0);border-color:hsla(0,0%,100%,0)}15%,85%{background:#fbffc9;border-color:#f0f3c0}}div.CodeMirror-lint-tooltip{background-color:#fff;color:#141823;border:0;border-radius:2px;box-shadow:0 1px 3px rgba(0,0,0,.45);font-family:system,-apple-system,San Francisco,\\\\.SFNSDisplay-Regular,Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:13px;line-height:16px;padding:6px 10px;opacity:0;transition:opacity .15s;-moz-transition:opacity .15s;-webkit-transition:opacity .15s;-o-transition:opacity .15s;-ms-transition:opacity .15s}div.CodeMirror-lint-message-error,div.CodeMirror-lint-message-warning{padding-left:23px}#graphiql-container .CodeMirror-foldmarker{border-radius:4px;background:#08f;background:-webkit-linear-gradient(#43a8ff,#0f83e8);background:linear-gradient(#43a8ff,#0f83e8);color:#fff;box-shadow:0 1px 1px rgba(0,0,0,.2),inset 0 0 0 1px rgba(0,0,0,.1);font-family:arial;line-height:0;padding:0 4px 1px;font-size:12px;margin:0 3px;text-shadow:0 -1px rgba(0,0,0,.1)}#graphiql-container div.CodeMirror span.CodeMirror-matchingbracket{color:#555;text-decoration:underline}#graphiql-container div.CodeMirror span.CodeMirror-nonmatchingbracket{color:red}#graphiql-container .cm-comment{color:#999}#graphiql-container .cm-punctuation{color:#555}#graphiql-container .cm-keyword{color:#b11a04}#graphiql-container .cm-def{color:#d2054e}#graphiql-container .cm-property{color:#1f61a0}#graphiql-container .cm-qualifier{color:#1c92a9}#graphiql-container .cm-attribute{color:#8b2bb9}#graphiql-container .cm-number{color:#2882f9}#graphiql-container .cm-string{color:#d64292}#graphiql-container .cm-builtin{color:#d47509}#graphiql-container .cm-string-2{color:#0b7fc7}#graphiql-container .cm-variable{color:#397d13}#graphiql-container .cm-meta{color:#b33086}#graphiql-container .cm-atom{color:#ca9800}.CodeMirror{font-family:monospace;height:300px;color:#000}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror div.CodeMirror-cursor{border-left:1px solid #000}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.CodeMirror.cm-fat-cursor div.CodeMirror-cursor{width:auto;border:0;background:#7e7}.CodeMirror.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite}@-webkit-keyframes blink{0%{background:#7e7}50%{background:none}to{background:#7e7}}@keyframes blink{0%{background:#7e7}50%{background:none}to{background:#7e7}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-ruler{border-left:1px solid #ccc;position:absolute}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;margin-bottom:-30px;*zoom:1;*display:inline}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;height:100%}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper{-webkit-user-select:none;-moz-user-select:none;user-select:none}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-code{outline:none}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-measure pre{position:static}.CodeMirror div.CodeMirror-cursor{position:absolute;border-right:none;width:0}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror ::selection{background:#d7d4f0}.CodeMirror ::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.CodeMirror span{*vertical-align:text-bottom}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:none}#graphiql-container .doc-explorer{background:#fff}#graphiql-container .doc-explorer-title-bar{cursor:default;display:-webkit-flex;display:flex;height:34px;line-height:14px;padding:8px 8px 5px;position:relative;-webkit-user-select:none;user-select:none}#graphiql-container .doc-explorer-title{padding:10px 0 10px 10px;font-weight:700;text-align:center;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;-webkit-flex:1;flex:1}#graphiql-container .doc-explorer-back{color:#3b5998;cursor:pointer;margin:-7px 0 -6px -8px;overflow-x:hidden;padding:17px 12px 16px 16px;text-overflow:ellipsis;white-space:nowrap}#graphiql-container .doc-explorer-back:before{border-left:2px solid #3b5998;border-top:2px solid #3b5998;content:'';display:inline-block;height:9px;margin:0 3px -1px 0;position:relative;width:9px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}#graphiql-container .doc-explorer-rhs{position:relative}#graphiql-container .doc-explorer-contents{background-color:#fff;border-top:1px solid #d6d6d6;bottom:0;left:0;min-width:300px;overflow-y:auto;padding:20px 15px;position:absolute;right:0;top:47px}#graphiql-container .doc-type-description blockquote:first-child,#graphiql-container .doc-type-description p:first-child{margin-top:0}#graphiql-container .doc-explorer-contents a{cursor:pointer;text-decoration:none}#graphiql-container .doc-explorer-contents a:hover{text-decoration:underline}#graphiql-container .doc-value-description{padding:4px 0 8px 12px}#graphiql-container .doc-category{margin:20px 0}#graphiql-container .doc-category-title{border-bottom:1px solid #e0e0e0;color:#777;cursor:default;font-size:14px;font-variant:small-caps;font-weight:700;letter-spacing:1px;margin:0 -15px 10px 0;padding:10px 0;-webkit-user-select:none;user-select:none}#graphiql-container .doc-category-item{margin:12px 0;color:#555}#graphiql-container .keyword{color:#b11a04}#graphiql-container .type-name{color:#ca9800}#graphiql-container .field-name{color:#1f61a0}#graphiql-container .value-name{color:#0b7fc7}#graphiql-container .arg-name{color:#8b2bb9}#graphiql-container .arg:after{content:', '}#graphiql-container .arg:last-child:after{content:''}.CodeMirror-foldmarker{color:blue;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-folded,.CodeMirror-foldgutter-open{cursor:pointer}.CodeMirror-foldgutter-open:after{content:\\\"\\\\25BE\\\"}.CodeMirror-foldgutter-folded:after{content:\\\"\\\\25B8\\\"}.CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:infobackground;border:1px solid #000;border-radius:4px 4px 4px 4px;color:infotext;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark-error,.CodeMirror-lint-mark-warning{background-position:left bottom;background-repeat:repeat-x}.CodeMirror-lint-mark-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\\\")}.CodeMirror-lint-mark-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-error,.CodeMirror-lint-marker-warning{background-position:center center;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message-error,.CodeMirror-lint-message-warning{padding-left:18px;background-position:top left;background-repeat:no-repeat}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-multiple{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\\\");background-repeat:no-repeat;background-position:right bottom;width:100%;height:100%}.CodeMirror-hints{font-family:Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;font-size:13px;list-style:none;margin:0;margin-left:-6px;max-height:14.5em;overflow-y:auto;overflow:hidden;padding:0}.CodeMirror-hints,.CodeMirror-hints-wrapper{background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.45);position:absolute;z-index:10}.CodeMirror-hints-wrapper{margin-left:-6px}.CodeMirror-hints-wrapper .CodeMirror-hints{box-shadow:none;position:relative;margin-left:0;z-index:0}.CodeMirror-hint{border-top:1px solid #f7f7f7;color:#141823;cursor:pointer;margin:0;max-width:300px;overflow:hidden;padding:2px 6px;white-space:pre}li.CodeMirror-hint-active{background-color:#08f;border-top-color:#fff;color:#fff}.CodeMirror-hint-information{border-top:1px solid silver;max-width:300px;padding:4px 6px;position:relative;z-index:1}.CodeMirror-hint-information:first-child{border-bottom:1px solid silver;border-top:none;margin-bottom:-1px}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/gatsby/~/css-loader!../css/graphiql.css\n ** module id = 459\n ** module chunks = 1\n **/"],"sourceRoot":""}